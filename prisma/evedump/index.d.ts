
/**
 * Client
**/

import * as runtime from './runtime/library';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model agtAgentTypes
 * 
 */
export type agtAgentTypes = $Result.DefaultSelection<Prisma.$agtAgentTypesPayload>
/**
 * Model agtAgents
 * 
 */
export type agtAgents = $Result.DefaultSelection<Prisma.$agtAgentsPayload>
/**
 * Model agtAgentsInSpace
 * 
 */
export type agtAgentsInSpace = $Result.DefaultSelection<Prisma.$agtAgentsInSpacePayload>
/**
 * Model agtResearchAgents
 * 
 */
export type agtResearchAgents = $Result.DefaultSelection<Prisma.$agtResearchAgentsPayload>
/**
 * Model certCerts
 * 
 */
export type certCerts = $Result.DefaultSelection<Prisma.$certCertsPayload>
/**
 * Model chrAncestries
 * 
 */
export type chrAncestries = $Result.DefaultSelection<Prisma.$chrAncestriesPayload>
/**
 * Model chrAttributes
 * 
 */
export type chrAttributes = $Result.DefaultSelection<Prisma.$chrAttributesPayload>
/**
 * Model chrBloodlines
 * 
 */
export type chrBloodlines = $Result.DefaultSelection<Prisma.$chrBloodlinesPayload>
/**
 * Model chrFactions
 * 
 */
export type chrFactions = $Result.DefaultSelection<Prisma.$chrFactionsPayload>
/**
 * Model chrRaces
 * 
 */
export type chrRaces = $Result.DefaultSelection<Prisma.$chrRacesPayload>
/**
 * Model crpActivities
 * 
 */
export type crpActivities = $Result.DefaultSelection<Prisma.$crpActivitiesPayload>
/**
 * Model crpNPCCorporationDivisions
 * 
 */
export type crpNPCCorporationDivisions = $Result.DefaultSelection<Prisma.$crpNPCCorporationDivisionsPayload>
/**
 * Model crpNPCCorporationResearchFields
 * 
 */
export type crpNPCCorporationResearchFields = $Result.DefaultSelection<Prisma.$crpNPCCorporationResearchFieldsPayload>
/**
 * Model crpNPCCorporationTrades
 * 
 */
export type crpNPCCorporationTrades = $Result.DefaultSelection<Prisma.$crpNPCCorporationTradesPayload>
/**
 * Model crpNPCCorporations
 * 
 */
export type crpNPCCorporations = $Result.DefaultSelection<Prisma.$crpNPCCorporationsPayload>
/**
 * Model crpNPCDivisions
 * 
 */
export type crpNPCDivisions = $Result.DefaultSelection<Prisma.$crpNPCDivisionsPayload>
/**
 * Model dgmAttributeCategories
 * 
 */
export type dgmAttributeCategories = $Result.DefaultSelection<Prisma.$dgmAttributeCategoriesPayload>
/**
 * Model dgmAttributeTypes
 * 
 */
export type dgmAttributeTypes = $Result.DefaultSelection<Prisma.$dgmAttributeTypesPayload>
/**
 * Model dgmEffects
 * 
 */
export type dgmEffects = $Result.DefaultSelection<Prisma.$dgmEffectsPayload>
/**
 * Model dgmExpressions
 * 
 */
export type dgmExpressions = $Result.DefaultSelection<Prisma.$dgmExpressionsPayload>
/**
 * Model dgmTypeAttributes
 * 
 */
export type dgmTypeAttributes = $Result.DefaultSelection<Prisma.$dgmTypeAttributesPayload>
/**
 * Model dgmTypeEffects
 * 
 */
export type dgmTypeEffects = $Result.DefaultSelection<Prisma.$dgmTypeEffectsPayload>
/**
 * Model eveGraphics
 * 
 */
export type eveGraphics = $Result.DefaultSelection<Prisma.$eveGraphicsPayload>
/**
 * Model eveIcons
 * 
 */
export type eveIcons = $Result.DefaultSelection<Prisma.$eveIconsPayload>
/**
 * Model eveUnits
 * 
 */
export type eveUnits = $Result.DefaultSelection<Prisma.$eveUnitsPayload>
/**
 * Model industryActivity
 * 
 */
export type industryActivity = $Result.DefaultSelection<Prisma.$industryActivityPayload>
/**
 * Model industryBlueprints
 * 
 */
export type industryBlueprints = $Result.DefaultSelection<Prisma.$industryBlueprintsPayload>
/**
 * Model invCategories
 * 
 */
export type invCategories = $Result.DefaultSelection<Prisma.$invCategoriesPayload>
/**
 * Model invContrabandTypes
 * 
 */
export type invContrabandTypes = $Result.DefaultSelection<Prisma.$invContrabandTypesPayload>
/**
 * Model invControlTowerResourcePurposes
 * 
 */
export type invControlTowerResourcePurposes = $Result.DefaultSelection<Prisma.$invControlTowerResourcePurposesPayload>
/**
 * Model invControlTowerResources
 * 
 */
export type invControlTowerResources = $Result.DefaultSelection<Prisma.$invControlTowerResourcesPayload>
/**
 * Model invFlags
 * 
 */
export type invFlags = $Result.DefaultSelection<Prisma.$invFlagsPayload>
/**
 * Model invGroups
 * 
 */
export type invGroups = $Result.DefaultSelection<Prisma.$invGroupsPayload>
/**
 * Model invItems
 * 
 */
export type invItems = $Result.DefaultSelection<Prisma.$invItemsPayload>
/**
 * Model invMarketGroups
 * 
 */
export type invMarketGroups = $Result.DefaultSelection<Prisma.$invMarketGroupsPayload>
/**
 * Model invMetaGroups
 * 
 */
export type invMetaGroups = $Result.DefaultSelection<Prisma.$invMetaGroupsPayload>
/**
 * Model invMetaTypes
 * 
 */
export type invMetaTypes = $Result.DefaultSelection<Prisma.$invMetaTypesPayload>
/**
 * Model invNames
 * 
 */
export type invNames = $Result.DefaultSelection<Prisma.$invNamesPayload>
/**
 * Model invPositions
 * 
 */
export type invPositions = $Result.DefaultSelection<Prisma.$invPositionsPayload>
/**
 * Model invTraits
 * 
 */
export type invTraits = $Result.DefaultSelection<Prisma.$invTraitsPayload>
/**
 * Model invTypeMaterials
 * 
 */
export type invTypeMaterials = $Result.DefaultSelection<Prisma.$invTypeMaterialsPayload>
/**
 * Model invTypeReactions
 * 
 */
export type invTypeReactions = $Result.DefaultSelection<Prisma.$invTypeReactionsPayload>
/**
 * Model invTypes
 * 
 */
export type invTypes = $Result.DefaultSelection<Prisma.$invTypesPayload>
/**
 * Model invUniqueNames
 * 
 */
export type invUniqueNames = $Result.DefaultSelection<Prisma.$invUniqueNamesPayload>
/**
 * Model invVolumes
 * 
 */
export type invVolumes = $Result.DefaultSelection<Prisma.$invVolumesPayload>
/**
 * Model mapCelestialGraphics
 * 
 */
export type mapCelestialGraphics = $Result.DefaultSelection<Prisma.$mapCelestialGraphicsPayload>
/**
 * Model mapCelestialStatistics
 * 
 */
export type mapCelestialStatistics = $Result.DefaultSelection<Prisma.$mapCelestialStatisticsPayload>
/**
 * Model mapConstellationJumps
 * 
 */
export type mapConstellationJumps = $Result.DefaultSelection<Prisma.$mapConstellationJumpsPayload>
/**
 * Model mapConstellations
 * 
 */
export type mapConstellations = $Result.DefaultSelection<Prisma.$mapConstellationsPayload>
/**
 * Model mapDenormalize
 * 
 */
export type mapDenormalize = $Result.DefaultSelection<Prisma.$mapDenormalizePayload>
/**
 * Model mapJumps
 * 
 */
export type mapJumps = $Result.DefaultSelection<Prisma.$mapJumpsPayload>
/**
 * Model mapLandmarks
 * 
 */
export type mapLandmarks = $Result.DefaultSelection<Prisma.$mapLandmarksPayload>
/**
 * Model mapLocationScenes
 * 
 */
export type mapLocationScenes = $Result.DefaultSelection<Prisma.$mapLocationScenesPayload>
/**
 * Model mapLocationWormholeClasses
 * 
 */
export type mapLocationWormholeClasses = $Result.DefaultSelection<Prisma.$mapLocationWormholeClassesPayload>
/**
 * Model mapRegionJumps
 * 
 */
export type mapRegionJumps = $Result.DefaultSelection<Prisma.$mapRegionJumpsPayload>
/**
 * Model mapRegions
 * 
 */
export type mapRegions = $Result.DefaultSelection<Prisma.$mapRegionsPayload>
/**
 * Model mapSolarSystemJumps
 * 
 */
export type mapSolarSystemJumps = $Result.DefaultSelection<Prisma.$mapSolarSystemJumpsPayload>
/**
 * Model mapSolarSystems
 * 
 */
export type mapSolarSystems = $Result.DefaultSelection<Prisma.$mapSolarSystemsPayload>
/**
 * Model mapUniverse
 * 
 */
export type mapUniverse = $Result.DefaultSelection<Prisma.$mapUniversePayload>
/**
 * Model planetSchematics
 * 
 */
export type planetSchematics = $Result.DefaultSelection<Prisma.$planetSchematicsPayload>
/**
 * Model planetSchematicsPinMap
 * 
 */
export type planetSchematicsPinMap = $Result.DefaultSelection<Prisma.$planetSchematicsPinMapPayload>
/**
 * Model planetSchematicsTypeMap
 * 
 */
export type planetSchematicsTypeMap = $Result.DefaultSelection<Prisma.$planetSchematicsTypeMapPayload>
/**
 * Model ramActivities
 * 
 */
export type ramActivities = $Result.DefaultSelection<Prisma.$ramActivitiesPayload>
/**
 * Model ramAssemblyLineStations
 * 
 */
export type ramAssemblyLineStations = $Result.DefaultSelection<Prisma.$ramAssemblyLineStationsPayload>
/**
 * Model ramAssemblyLineTypeDetailPerCategory
 * 
 */
export type ramAssemblyLineTypeDetailPerCategory = $Result.DefaultSelection<Prisma.$ramAssemblyLineTypeDetailPerCategoryPayload>
/**
 * Model ramAssemblyLineTypeDetailPerGroup
 * 
 */
export type ramAssemblyLineTypeDetailPerGroup = $Result.DefaultSelection<Prisma.$ramAssemblyLineTypeDetailPerGroupPayload>
/**
 * Model ramAssemblyLineTypes
 * 
 */
export type ramAssemblyLineTypes = $Result.DefaultSelection<Prisma.$ramAssemblyLineTypesPayload>
/**
 * Model ramInstallationTypeContents
 * 
 */
export type ramInstallationTypeContents = $Result.DefaultSelection<Prisma.$ramInstallationTypeContentsPayload>
/**
 * Model skinLicense
 * 
 */
export type skinLicense = $Result.DefaultSelection<Prisma.$skinLicensePayload>
/**
 * Model skinMaterials
 * 
 */
export type skinMaterials = $Result.DefaultSelection<Prisma.$skinMaterialsPayload>
/**
 * Model skins
 * 
 */
export type skins = $Result.DefaultSelection<Prisma.$skinsPayload>
/**
 * Model staOperationServices
 * 
 */
export type staOperationServices = $Result.DefaultSelection<Prisma.$staOperationServicesPayload>
/**
 * Model staOperations
 * 
 */
export type staOperations = $Result.DefaultSelection<Prisma.$staOperationsPayload>
/**
 * Model staServices
 * 
 */
export type staServices = $Result.DefaultSelection<Prisma.$staServicesPayload>
/**
 * Model staStationTypes
 * 
 */
export type staStationTypes = $Result.DefaultSelection<Prisma.$staStationTypesPayload>
/**
 * Model staStations
 * 
 */
export type staStations = $Result.DefaultSelection<Prisma.$staStationsPayload>
/**
 * Model translationTables
 * 
 */
export type translationTables = $Result.DefaultSelection<Prisma.$translationTablesPayload>
/**
 * Model trnTranslationColumns
 * 
 */
export type trnTranslationColumns = $Result.DefaultSelection<Prisma.$trnTranslationColumnsPayload>
/**
 * Model trnTranslationLanguages
 * 
 */
export type trnTranslationLanguages = $Result.DefaultSelection<Prisma.$trnTranslationLanguagesPayload>
/**
 * Model trnTranslations
 * 
 */
export type trnTranslations = $Result.DefaultSelection<Prisma.$trnTranslationsPayload>
/**
 * Model warCombatZoneSystems
 * 
 */
export type warCombatZoneSystems = $Result.DefaultSelection<Prisma.$warCombatZoneSystemsPayload>
/**
 * Model warCombatZones
 * 
 */
export type warCombatZones = $Result.DefaultSelection<Prisma.$warCombatZonesPayload>

/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more AgtAgentTypes
 * const agtAgentTypes = await prisma.agtAgentTypes.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  T extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof T ? T['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<T['log']> : never : never,
  ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more AgtAgentTypes
   * const agtAgentTypes = await prisma.agtAgentTypes.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<T, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<'extends', Prisma.TypeMapCb, ExtArgs>

      /**
   * `prisma.agtAgentTypes`: Exposes CRUD operations for the **agtAgentTypes** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AgtAgentTypes
    * const agtAgentTypes = await prisma.agtAgentTypes.findMany()
    * ```
    */
  get agtAgentTypes(): Prisma.agtAgentTypesDelegate<ExtArgs>;

  /**
   * `prisma.agtAgents`: Exposes CRUD operations for the **agtAgents** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AgtAgents
    * const agtAgents = await prisma.agtAgents.findMany()
    * ```
    */
  get agtAgents(): Prisma.agtAgentsDelegate<ExtArgs>;

  /**
   * `prisma.agtAgentsInSpace`: Exposes CRUD operations for the **agtAgentsInSpace** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AgtAgentsInSpaces
    * const agtAgentsInSpaces = await prisma.agtAgentsInSpace.findMany()
    * ```
    */
  get agtAgentsInSpace(): Prisma.agtAgentsInSpaceDelegate<ExtArgs>;

  /**
   * `prisma.agtResearchAgents`: Exposes CRUD operations for the **agtResearchAgents** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AgtResearchAgents
    * const agtResearchAgents = await prisma.agtResearchAgents.findMany()
    * ```
    */
  get agtResearchAgents(): Prisma.agtResearchAgentsDelegate<ExtArgs>;

  /**
   * `prisma.certCerts`: Exposes CRUD operations for the **certCerts** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CertCerts
    * const certCerts = await prisma.certCerts.findMany()
    * ```
    */
  get certCerts(): Prisma.certCertsDelegate<ExtArgs>;

  /**
   * `prisma.chrAncestries`: Exposes CRUD operations for the **chrAncestries** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ChrAncestries
    * const chrAncestries = await prisma.chrAncestries.findMany()
    * ```
    */
  get chrAncestries(): Prisma.chrAncestriesDelegate<ExtArgs>;

  /**
   * `prisma.chrAttributes`: Exposes CRUD operations for the **chrAttributes** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ChrAttributes
    * const chrAttributes = await prisma.chrAttributes.findMany()
    * ```
    */
  get chrAttributes(): Prisma.chrAttributesDelegate<ExtArgs>;

  /**
   * `prisma.chrBloodlines`: Exposes CRUD operations for the **chrBloodlines** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ChrBloodlines
    * const chrBloodlines = await prisma.chrBloodlines.findMany()
    * ```
    */
  get chrBloodlines(): Prisma.chrBloodlinesDelegate<ExtArgs>;

  /**
   * `prisma.chrFactions`: Exposes CRUD operations for the **chrFactions** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ChrFactions
    * const chrFactions = await prisma.chrFactions.findMany()
    * ```
    */
  get chrFactions(): Prisma.chrFactionsDelegate<ExtArgs>;

  /**
   * `prisma.chrRaces`: Exposes CRUD operations for the **chrRaces** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ChrRaces
    * const chrRaces = await prisma.chrRaces.findMany()
    * ```
    */
  get chrRaces(): Prisma.chrRacesDelegate<ExtArgs>;

  /**
   * `prisma.crpActivities`: Exposes CRUD operations for the **crpActivities** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CrpActivities
    * const crpActivities = await prisma.crpActivities.findMany()
    * ```
    */
  get crpActivities(): Prisma.crpActivitiesDelegate<ExtArgs>;

  /**
   * `prisma.crpNPCCorporationDivisions`: Exposes CRUD operations for the **crpNPCCorporationDivisions** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CrpNPCCorporationDivisions
    * const crpNPCCorporationDivisions = await prisma.crpNPCCorporationDivisions.findMany()
    * ```
    */
  get crpNPCCorporationDivisions(): Prisma.crpNPCCorporationDivisionsDelegate<ExtArgs>;

  /**
   * `prisma.crpNPCCorporationResearchFields`: Exposes CRUD operations for the **crpNPCCorporationResearchFields** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CrpNPCCorporationResearchFields
    * const crpNPCCorporationResearchFields = await prisma.crpNPCCorporationResearchFields.findMany()
    * ```
    */
  get crpNPCCorporationResearchFields(): Prisma.crpNPCCorporationResearchFieldsDelegate<ExtArgs>;

  /**
   * `prisma.crpNPCCorporationTrades`: Exposes CRUD operations for the **crpNPCCorporationTrades** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CrpNPCCorporationTrades
    * const crpNPCCorporationTrades = await prisma.crpNPCCorporationTrades.findMany()
    * ```
    */
  get crpNPCCorporationTrades(): Prisma.crpNPCCorporationTradesDelegate<ExtArgs>;

  /**
   * `prisma.crpNPCCorporations`: Exposes CRUD operations for the **crpNPCCorporations** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CrpNPCCorporations
    * const crpNPCCorporations = await prisma.crpNPCCorporations.findMany()
    * ```
    */
  get crpNPCCorporations(): Prisma.crpNPCCorporationsDelegate<ExtArgs>;

  /**
   * `prisma.crpNPCDivisions`: Exposes CRUD operations for the **crpNPCDivisions** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CrpNPCDivisions
    * const crpNPCDivisions = await prisma.crpNPCDivisions.findMany()
    * ```
    */
  get crpNPCDivisions(): Prisma.crpNPCDivisionsDelegate<ExtArgs>;

  /**
   * `prisma.dgmAttributeCategories`: Exposes CRUD operations for the **dgmAttributeCategories** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DgmAttributeCategories
    * const dgmAttributeCategories = await prisma.dgmAttributeCategories.findMany()
    * ```
    */
  get dgmAttributeCategories(): Prisma.dgmAttributeCategoriesDelegate<ExtArgs>;

  /**
   * `prisma.dgmAttributeTypes`: Exposes CRUD operations for the **dgmAttributeTypes** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DgmAttributeTypes
    * const dgmAttributeTypes = await prisma.dgmAttributeTypes.findMany()
    * ```
    */
  get dgmAttributeTypes(): Prisma.dgmAttributeTypesDelegate<ExtArgs>;

  /**
   * `prisma.dgmEffects`: Exposes CRUD operations for the **dgmEffects** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DgmEffects
    * const dgmEffects = await prisma.dgmEffects.findMany()
    * ```
    */
  get dgmEffects(): Prisma.dgmEffectsDelegate<ExtArgs>;

  /**
   * `prisma.dgmExpressions`: Exposes CRUD operations for the **dgmExpressions** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DgmExpressions
    * const dgmExpressions = await prisma.dgmExpressions.findMany()
    * ```
    */
  get dgmExpressions(): Prisma.dgmExpressionsDelegate<ExtArgs>;

  /**
   * `prisma.dgmTypeAttributes`: Exposes CRUD operations for the **dgmTypeAttributes** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DgmTypeAttributes
    * const dgmTypeAttributes = await prisma.dgmTypeAttributes.findMany()
    * ```
    */
  get dgmTypeAttributes(): Prisma.dgmTypeAttributesDelegate<ExtArgs>;

  /**
   * `prisma.dgmTypeEffects`: Exposes CRUD operations for the **dgmTypeEffects** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DgmTypeEffects
    * const dgmTypeEffects = await prisma.dgmTypeEffects.findMany()
    * ```
    */
  get dgmTypeEffects(): Prisma.dgmTypeEffectsDelegate<ExtArgs>;

  /**
   * `prisma.eveGraphics`: Exposes CRUD operations for the **eveGraphics** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more EveGraphics
    * const eveGraphics = await prisma.eveGraphics.findMany()
    * ```
    */
  get eveGraphics(): Prisma.eveGraphicsDelegate<ExtArgs>;

  /**
   * `prisma.eveIcons`: Exposes CRUD operations for the **eveIcons** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more EveIcons
    * const eveIcons = await prisma.eveIcons.findMany()
    * ```
    */
  get eveIcons(): Prisma.eveIconsDelegate<ExtArgs>;

  /**
   * `prisma.eveUnits`: Exposes CRUD operations for the **eveUnits** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more EveUnits
    * const eveUnits = await prisma.eveUnits.findMany()
    * ```
    */
  get eveUnits(): Prisma.eveUnitsDelegate<ExtArgs>;

  /**
   * `prisma.industryActivity`: Exposes CRUD operations for the **industryActivity** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more IndustryActivities
    * const industryActivities = await prisma.industryActivity.findMany()
    * ```
    */
  get industryActivity(): Prisma.industryActivityDelegate<ExtArgs>;

  /**
   * `prisma.industryBlueprints`: Exposes CRUD operations for the **industryBlueprints** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more IndustryBlueprints
    * const industryBlueprints = await prisma.industryBlueprints.findMany()
    * ```
    */
  get industryBlueprints(): Prisma.industryBlueprintsDelegate<ExtArgs>;

  /**
   * `prisma.invCategories`: Exposes CRUD operations for the **invCategories** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more InvCategories
    * const invCategories = await prisma.invCategories.findMany()
    * ```
    */
  get invCategories(): Prisma.invCategoriesDelegate<ExtArgs>;

  /**
   * `prisma.invContrabandTypes`: Exposes CRUD operations for the **invContrabandTypes** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more InvContrabandTypes
    * const invContrabandTypes = await prisma.invContrabandTypes.findMany()
    * ```
    */
  get invContrabandTypes(): Prisma.invContrabandTypesDelegate<ExtArgs>;

  /**
   * `prisma.invControlTowerResourcePurposes`: Exposes CRUD operations for the **invControlTowerResourcePurposes** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more InvControlTowerResourcePurposes
    * const invControlTowerResourcePurposes = await prisma.invControlTowerResourcePurposes.findMany()
    * ```
    */
  get invControlTowerResourcePurposes(): Prisma.invControlTowerResourcePurposesDelegate<ExtArgs>;

  /**
   * `prisma.invControlTowerResources`: Exposes CRUD operations for the **invControlTowerResources** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more InvControlTowerResources
    * const invControlTowerResources = await prisma.invControlTowerResources.findMany()
    * ```
    */
  get invControlTowerResources(): Prisma.invControlTowerResourcesDelegate<ExtArgs>;

  /**
   * `prisma.invFlags`: Exposes CRUD operations for the **invFlags** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more InvFlags
    * const invFlags = await prisma.invFlags.findMany()
    * ```
    */
  get invFlags(): Prisma.invFlagsDelegate<ExtArgs>;

  /**
   * `prisma.invGroups`: Exposes CRUD operations for the **invGroups** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more InvGroups
    * const invGroups = await prisma.invGroups.findMany()
    * ```
    */
  get invGroups(): Prisma.invGroupsDelegate<ExtArgs>;

  /**
   * `prisma.invItems`: Exposes CRUD operations for the **invItems** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more InvItems
    * const invItems = await prisma.invItems.findMany()
    * ```
    */
  get invItems(): Prisma.invItemsDelegate<ExtArgs>;

  /**
   * `prisma.invMarketGroups`: Exposes CRUD operations for the **invMarketGroups** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more InvMarketGroups
    * const invMarketGroups = await prisma.invMarketGroups.findMany()
    * ```
    */
  get invMarketGroups(): Prisma.invMarketGroupsDelegate<ExtArgs>;

  /**
   * `prisma.invMetaGroups`: Exposes CRUD operations for the **invMetaGroups** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more InvMetaGroups
    * const invMetaGroups = await prisma.invMetaGroups.findMany()
    * ```
    */
  get invMetaGroups(): Prisma.invMetaGroupsDelegate<ExtArgs>;

  /**
   * `prisma.invMetaTypes`: Exposes CRUD operations for the **invMetaTypes** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more InvMetaTypes
    * const invMetaTypes = await prisma.invMetaTypes.findMany()
    * ```
    */
  get invMetaTypes(): Prisma.invMetaTypesDelegate<ExtArgs>;

  /**
   * `prisma.invNames`: Exposes CRUD operations for the **invNames** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more InvNames
    * const invNames = await prisma.invNames.findMany()
    * ```
    */
  get invNames(): Prisma.invNamesDelegate<ExtArgs>;

  /**
   * `prisma.invPositions`: Exposes CRUD operations for the **invPositions** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more InvPositions
    * const invPositions = await prisma.invPositions.findMany()
    * ```
    */
  get invPositions(): Prisma.invPositionsDelegate<ExtArgs>;

  /**
   * `prisma.invTraits`: Exposes CRUD operations for the **invTraits** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more InvTraits
    * const invTraits = await prisma.invTraits.findMany()
    * ```
    */
  get invTraits(): Prisma.invTraitsDelegate<ExtArgs>;

  /**
   * `prisma.invTypeMaterials`: Exposes CRUD operations for the **invTypeMaterials** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more InvTypeMaterials
    * const invTypeMaterials = await prisma.invTypeMaterials.findMany()
    * ```
    */
  get invTypeMaterials(): Prisma.invTypeMaterialsDelegate<ExtArgs>;

  /**
   * `prisma.invTypeReactions`: Exposes CRUD operations for the **invTypeReactions** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more InvTypeReactions
    * const invTypeReactions = await prisma.invTypeReactions.findMany()
    * ```
    */
  get invTypeReactions(): Prisma.invTypeReactionsDelegate<ExtArgs>;

  /**
   * `prisma.invTypes`: Exposes CRUD operations for the **invTypes** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more InvTypes
    * const invTypes = await prisma.invTypes.findMany()
    * ```
    */
  get invTypes(): Prisma.invTypesDelegate<ExtArgs>;

  /**
   * `prisma.invUniqueNames`: Exposes CRUD operations for the **invUniqueNames** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more InvUniqueNames
    * const invUniqueNames = await prisma.invUniqueNames.findMany()
    * ```
    */
  get invUniqueNames(): Prisma.invUniqueNamesDelegate<ExtArgs>;

  /**
   * `prisma.invVolumes`: Exposes CRUD operations for the **invVolumes** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more InvVolumes
    * const invVolumes = await prisma.invVolumes.findMany()
    * ```
    */
  get invVolumes(): Prisma.invVolumesDelegate<ExtArgs>;

  /**
   * `prisma.mapCelestialGraphics`: Exposes CRUD operations for the **mapCelestialGraphics** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MapCelestialGraphics
    * const mapCelestialGraphics = await prisma.mapCelestialGraphics.findMany()
    * ```
    */
  get mapCelestialGraphics(): Prisma.mapCelestialGraphicsDelegate<ExtArgs>;

  /**
   * `prisma.mapCelestialStatistics`: Exposes CRUD operations for the **mapCelestialStatistics** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MapCelestialStatistics
    * const mapCelestialStatistics = await prisma.mapCelestialStatistics.findMany()
    * ```
    */
  get mapCelestialStatistics(): Prisma.mapCelestialStatisticsDelegate<ExtArgs>;

  /**
   * `prisma.mapConstellationJumps`: Exposes CRUD operations for the **mapConstellationJumps** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MapConstellationJumps
    * const mapConstellationJumps = await prisma.mapConstellationJumps.findMany()
    * ```
    */
  get mapConstellationJumps(): Prisma.mapConstellationJumpsDelegate<ExtArgs>;

  /**
   * `prisma.mapConstellations`: Exposes CRUD operations for the **mapConstellations** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MapConstellations
    * const mapConstellations = await prisma.mapConstellations.findMany()
    * ```
    */
  get mapConstellations(): Prisma.mapConstellationsDelegate<ExtArgs>;

  /**
   * `prisma.mapDenormalize`: Exposes CRUD operations for the **mapDenormalize** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MapDenormalizes
    * const mapDenormalizes = await prisma.mapDenormalize.findMany()
    * ```
    */
  get mapDenormalize(): Prisma.mapDenormalizeDelegate<ExtArgs>;

  /**
   * `prisma.mapJumps`: Exposes CRUD operations for the **mapJumps** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MapJumps
    * const mapJumps = await prisma.mapJumps.findMany()
    * ```
    */
  get mapJumps(): Prisma.mapJumpsDelegate<ExtArgs>;

  /**
   * `prisma.mapLandmarks`: Exposes CRUD operations for the **mapLandmarks** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MapLandmarks
    * const mapLandmarks = await prisma.mapLandmarks.findMany()
    * ```
    */
  get mapLandmarks(): Prisma.mapLandmarksDelegate<ExtArgs>;

  /**
   * `prisma.mapLocationScenes`: Exposes CRUD operations for the **mapLocationScenes** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MapLocationScenes
    * const mapLocationScenes = await prisma.mapLocationScenes.findMany()
    * ```
    */
  get mapLocationScenes(): Prisma.mapLocationScenesDelegate<ExtArgs>;

  /**
   * `prisma.mapLocationWormholeClasses`: Exposes CRUD operations for the **mapLocationWormholeClasses** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MapLocationWormholeClasses
    * const mapLocationWormholeClasses = await prisma.mapLocationWormholeClasses.findMany()
    * ```
    */
  get mapLocationWormholeClasses(): Prisma.mapLocationWormholeClassesDelegate<ExtArgs>;

  /**
   * `prisma.mapRegionJumps`: Exposes CRUD operations for the **mapRegionJumps** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MapRegionJumps
    * const mapRegionJumps = await prisma.mapRegionJumps.findMany()
    * ```
    */
  get mapRegionJumps(): Prisma.mapRegionJumpsDelegate<ExtArgs>;

  /**
   * `prisma.mapRegions`: Exposes CRUD operations for the **mapRegions** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MapRegions
    * const mapRegions = await prisma.mapRegions.findMany()
    * ```
    */
  get mapRegions(): Prisma.mapRegionsDelegate<ExtArgs>;

  /**
   * `prisma.mapSolarSystemJumps`: Exposes CRUD operations for the **mapSolarSystemJumps** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MapSolarSystemJumps
    * const mapSolarSystemJumps = await prisma.mapSolarSystemJumps.findMany()
    * ```
    */
  get mapSolarSystemJumps(): Prisma.mapSolarSystemJumpsDelegate<ExtArgs>;

  /**
   * `prisma.mapSolarSystems`: Exposes CRUD operations for the **mapSolarSystems** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MapSolarSystems
    * const mapSolarSystems = await prisma.mapSolarSystems.findMany()
    * ```
    */
  get mapSolarSystems(): Prisma.mapSolarSystemsDelegate<ExtArgs>;

  /**
   * `prisma.mapUniverse`: Exposes CRUD operations for the **mapUniverse** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MapUniverses
    * const mapUniverses = await prisma.mapUniverse.findMany()
    * ```
    */
  get mapUniverse(): Prisma.mapUniverseDelegate<ExtArgs>;

  /**
   * `prisma.planetSchematics`: Exposes CRUD operations for the **planetSchematics** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PlanetSchematics
    * const planetSchematics = await prisma.planetSchematics.findMany()
    * ```
    */
  get planetSchematics(): Prisma.planetSchematicsDelegate<ExtArgs>;

  /**
   * `prisma.planetSchematicsPinMap`: Exposes CRUD operations for the **planetSchematicsPinMap** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PlanetSchematicsPinMaps
    * const planetSchematicsPinMaps = await prisma.planetSchematicsPinMap.findMany()
    * ```
    */
  get planetSchematicsPinMap(): Prisma.planetSchematicsPinMapDelegate<ExtArgs>;

  /**
   * `prisma.planetSchematicsTypeMap`: Exposes CRUD operations for the **planetSchematicsTypeMap** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PlanetSchematicsTypeMaps
    * const planetSchematicsTypeMaps = await prisma.planetSchematicsTypeMap.findMany()
    * ```
    */
  get planetSchematicsTypeMap(): Prisma.planetSchematicsTypeMapDelegate<ExtArgs>;

  /**
   * `prisma.ramActivities`: Exposes CRUD operations for the **ramActivities** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RamActivities
    * const ramActivities = await prisma.ramActivities.findMany()
    * ```
    */
  get ramActivities(): Prisma.ramActivitiesDelegate<ExtArgs>;

  /**
   * `prisma.ramAssemblyLineStations`: Exposes CRUD operations for the **ramAssemblyLineStations** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RamAssemblyLineStations
    * const ramAssemblyLineStations = await prisma.ramAssemblyLineStations.findMany()
    * ```
    */
  get ramAssemblyLineStations(): Prisma.ramAssemblyLineStationsDelegate<ExtArgs>;

  /**
   * `prisma.ramAssemblyLineTypeDetailPerCategory`: Exposes CRUD operations for the **ramAssemblyLineTypeDetailPerCategory** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RamAssemblyLineTypeDetailPerCategories
    * const ramAssemblyLineTypeDetailPerCategories = await prisma.ramAssemblyLineTypeDetailPerCategory.findMany()
    * ```
    */
  get ramAssemblyLineTypeDetailPerCategory(): Prisma.ramAssemblyLineTypeDetailPerCategoryDelegate<ExtArgs>;

  /**
   * `prisma.ramAssemblyLineTypeDetailPerGroup`: Exposes CRUD operations for the **ramAssemblyLineTypeDetailPerGroup** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RamAssemblyLineTypeDetailPerGroups
    * const ramAssemblyLineTypeDetailPerGroups = await prisma.ramAssemblyLineTypeDetailPerGroup.findMany()
    * ```
    */
  get ramAssemblyLineTypeDetailPerGroup(): Prisma.ramAssemblyLineTypeDetailPerGroupDelegate<ExtArgs>;

  /**
   * `prisma.ramAssemblyLineTypes`: Exposes CRUD operations for the **ramAssemblyLineTypes** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RamAssemblyLineTypes
    * const ramAssemblyLineTypes = await prisma.ramAssemblyLineTypes.findMany()
    * ```
    */
  get ramAssemblyLineTypes(): Prisma.ramAssemblyLineTypesDelegate<ExtArgs>;

  /**
   * `prisma.ramInstallationTypeContents`: Exposes CRUD operations for the **ramInstallationTypeContents** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RamInstallationTypeContents
    * const ramInstallationTypeContents = await prisma.ramInstallationTypeContents.findMany()
    * ```
    */
  get ramInstallationTypeContents(): Prisma.ramInstallationTypeContentsDelegate<ExtArgs>;

  /**
   * `prisma.skinLicense`: Exposes CRUD operations for the **skinLicense** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SkinLicenses
    * const skinLicenses = await prisma.skinLicense.findMany()
    * ```
    */
  get skinLicense(): Prisma.skinLicenseDelegate<ExtArgs>;

  /**
   * `prisma.skinMaterials`: Exposes CRUD operations for the **skinMaterials** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SkinMaterials
    * const skinMaterials = await prisma.skinMaterials.findMany()
    * ```
    */
  get skinMaterials(): Prisma.skinMaterialsDelegate<ExtArgs>;

  /**
   * `prisma.skins`: Exposes CRUD operations for the **skins** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Skins
    * const skins = await prisma.skins.findMany()
    * ```
    */
  get skins(): Prisma.skinsDelegate<ExtArgs>;

  /**
   * `prisma.staOperationServices`: Exposes CRUD operations for the **staOperationServices** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more StaOperationServices
    * const staOperationServices = await prisma.staOperationServices.findMany()
    * ```
    */
  get staOperationServices(): Prisma.staOperationServicesDelegate<ExtArgs>;

  /**
   * `prisma.staOperations`: Exposes CRUD operations for the **staOperations** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more StaOperations
    * const staOperations = await prisma.staOperations.findMany()
    * ```
    */
  get staOperations(): Prisma.staOperationsDelegate<ExtArgs>;

  /**
   * `prisma.staServices`: Exposes CRUD operations for the **staServices** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more StaServices
    * const staServices = await prisma.staServices.findMany()
    * ```
    */
  get staServices(): Prisma.staServicesDelegate<ExtArgs>;

  /**
   * `prisma.staStationTypes`: Exposes CRUD operations for the **staStationTypes** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more StaStationTypes
    * const staStationTypes = await prisma.staStationTypes.findMany()
    * ```
    */
  get staStationTypes(): Prisma.staStationTypesDelegate<ExtArgs>;

  /**
   * `prisma.staStations`: Exposes CRUD operations for the **staStations** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more StaStations
    * const staStations = await prisma.staStations.findMany()
    * ```
    */
  get staStations(): Prisma.staStationsDelegate<ExtArgs>;

  /**
   * `prisma.translationTables`: Exposes CRUD operations for the **translationTables** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TranslationTables
    * const translationTables = await prisma.translationTables.findMany()
    * ```
    */
  get translationTables(): Prisma.translationTablesDelegate<ExtArgs>;

  /**
   * `prisma.trnTranslationColumns`: Exposes CRUD operations for the **trnTranslationColumns** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TrnTranslationColumns
    * const trnTranslationColumns = await prisma.trnTranslationColumns.findMany()
    * ```
    */
  get trnTranslationColumns(): Prisma.trnTranslationColumnsDelegate<ExtArgs>;

  /**
   * `prisma.trnTranslationLanguages`: Exposes CRUD operations for the **trnTranslationLanguages** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TrnTranslationLanguages
    * const trnTranslationLanguages = await prisma.trnTranslationLanguages.findMany()
    * ```
    */
  get trnTranslationLanguages(): Prisma.trnTranslationLanguagesDelegate<ExtArgs>;

  /**
   * `prisma.trnTranslations`: Exposes CRUD operations for the **trnTranslations** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TrnTranslations
    * const trnTranslations = await prisma.trnTranslations.findMany()
    * ```
    */
  get trnTranslations(): Prisma.trnTranslationsDelegate<ExtArgs>;

  /**
   * `prisma.warCombatZoneSystems`: Exposes CRUD operations for the **warCombatZoneSystems** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more WarCombatZoneSystems
    * const warCombatZoneSystems = await prisma.warCombatZoneSystems.findMany()
    * ```
    */
  get warCombatZoneSystems(): Prisma.warCombatZoneSystemsDelegate<ExtArgs>;

  /**
   * `prisma.warCombatZones`: Exposes CRUD operations for the **warCombatZones** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more WarCombatZones
    * const warCombatZones = await prisma.warCombatZones.findMany()
    * ```
    */
  get warCombatZones(): Prisma.warCombatZonesDelegate<ExtArgs>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError
  export import NotFoundError = runtime.NotFoundError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql

  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics 
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 5.1.1
   * Query Engine version: 6a3747c37ff169c90047725a05a6ef02e32ac97e
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON object.
   * This type can be useful to enforce some input to be JSON-compatible or as a super-type to be extended from. 
   */
  export type JsonObject = {[Key in string]?: JsonValue}

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON array.
   */
  export interface JsonArray extends Array<JsonValue> {}

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches any valid JSON value.
   */
  export type JsonValue = string | number | boolean | JsonObject | JsonArray | null

  /**
   * Matches a JSON object.
   * Unlike `JsonObject`, this type allows undefined and read-only properties.
   */
  export type InputJsonObject = {readonly [Key in string]?: InputJsonValue | null}

  /**
   * Matches a JSON array.
   * Unlike `JsonArray`, readonly arrays are assignable to this type.
   */
  export interface InputJsonArray extends ReadonlyArray<InputJsonValue | null> {}

  /**
   * Matches any valid value that can be used as an input for operations like
   * create and update as the value of a JSON field. Unlike `JsonValue`, this
   * type allows read-only arrays and read-only object properties and disallows
   * `null` at the top level.
   *
   * `null` cannot be used as the value of a JSON field because its meaning
   * would be ambiguous. Use `Prisma.JsonNull` to store the JSON null value or
   * `Prisma.DbNull` to clear the JSON value and set the field to the database
   * NULL value instead.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-by-null-values
   */
  export type InputJsonValue = string | number | boolean | InputJsonObject | InputJsonArray | { toJSON(): unknown }

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? K : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    agtAgentTypes: 'agtAgentTypes',
    agtAgents: 'agtAgents',
    agtAgentsInSpace: 'agtAgentsInSpace',
    agtResearchAgents: 'agtResearchAgents',
    certCerts: 'certCerts',
    chrAncestries: 'chrAncestries',
    chrAttributes: 'chrAttributes',
    chrBloodlines: 'chrBloodlines',
    chrFactions: 'chrFactions',
    chrRaces: 'chrRaces',
    crpActivities: 'crpActivities',
    crpNPCCorporationDivisions: 'crpNPCCorporationDivisions',
    crpNPCCorporationResearchFields: 'crpNPCCorporationResearchFields',
    crpNPCCorporationTrades: 'crpNPCCorporationTrades',
    crpNPCCorporations: 'crpNPCCorporations',
    crpNPCDivisions: 'crpNPCDivisions',
    dgmAttributeCategories: 'dgmAttributeCategories',
    dgmAttributeTypes: 'dgmAttributeTypes',
    dgmEffects: 'dgmEffects',
    dgmExpressions: 'dgmExpressions',
    dgmTypeAttributes: 'dgmTypeAttributes',
    dgmTypeEffects: 'dgmTypeEffects',
    eveGraphics: 'eveGraphics',
    eveIcons: 'eveIcons',
    eveUnits: 'eveUnits',
    industryActivity: 'industryActivity',
    industryBlueprints: 'industryBlueprints',
    invCategories: 'invCategories',
    invContrabandTypes: 'invContrabandTypes',
    invControlTowerResourcePurposes: 'invControlTowerResourcePurposes',
    invControlTowerResources: 'invControlTowerResources',
    invFlags: 'invFlags',
    invGroups: 'invGroups',
    invItems: 'invItems',
    invMarketGroups: 'invMarketGroups',
    invMetaGroups: 'invMetaGroups',
    invMetaTypes: 'invMetaTypes',
    invNames: 'invNames',
    invPositions: 'invPositions',
    invTraits: 'invTraits',
    invTypeMaterials: 'invTypeMaterials',
    invTypeReactions: 'invTypeReactions',
    invTypes: 'invTypes',
    invUniqueNames: 'invUniqueNames',
    invVolumes: 'invVolumes',
    mapCelestialGraphics: 'mapCelestialGraphics',
    mapCelestialStatistics: 'mapCelestialStatistics',
    mapConstellationJumps: 'mapConstellationJumps',
    mapConstellations: 'mapConstellations',
    mapDenormalize: 'mapDenormalize',
    mapJumps: 'mapJumps',
    mapLandmarks: 'mapLandmarks',
    mapLocationScenes: 'mapLocationScenes',
    mapLocationWormholeClasses: 'mapLocationWormholeClasses',
    mapRegionJumps: 'mapRegionJumps',
    mapRegions: 'mapRegions',
    mapSolarSystemJumps: 'mapSolarSystemJumps',
    mapSolarSystems: 'mapSolarSystems',
    mapUniverse: 'mapUniverse',
    planetSchematics: 'planetSchematics',
    planetSchematicsPinMap: 'planetSchematicsPinMap',
    planetSchematicsTypeMap: 'planetSchematicsTypeMap',
    ramActivities: 'ramActivities',
    ramAssemblyLineStations: 'ramAssemblyLineStations',
    ramAssemblyLineTypeDetailPerCategory: 'ramAssemblyLineTypeDetailPerCategory',
    ramAssemblyLineTypeDetailPerGroup: 'ramAssemblyLineTypeDetailPerGroup',
    ramAssemblyLineTypes: 'ramAssemblyLineTypes',
    ramInstallationTypeContents: 'ramInstallationTypeContents',
    skinLicense: 'skinLicense',
    skinMaterials: 'skinMaterials',
    skins: 'skins',
    staOperationServices: 'staOperationServices',
    staOperations: 'staOperations',
    staServices: 'staServices',
    staStationTypes: 'staStationTypes',
    staStations: 'staStations',
    translationTables: 'translationTables',
    trnTranslationColumns: 'trnTranslationColumns',
    trnTranslationLanguages: 'trnTranslationLanguages',
    trnTranslations: 'trnTranslations',
    warCombatZoneSystems: 'warCombatZoneSystems',
    warCombatZones: 'warCombatZones'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }


  interface TypeMapCb extends $Utils.Fn<{extArgs: $Extensions.Args}, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs']>
  }

  export type TypeMap<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    meta: {
      modelProps: 'agtAgentTypes' | 'agtAgents' | 'agtAgentsInSpace' | 'agtResearchAgents' | 'certCerts' | 'chrAncestries' | 'chrAttributes' | 'chrBloodlines' | 'chrFactions' | 'chrRaces' | 'crpActivities' | 'crpNPCCorporationDivisions' | 'crpNPCCorporationResearchFields' | 'crpNPCCorporationTrades' | 'crpNPCCorporations' | 'crpNPCDivisions' | 'dgmAttributeCategories' | 'dgmAttributeTypes' | 'dgmEffects' | 'dgmExpressions' | 'dgmTypeAttributes' | 'dgmTypeEffects' | 'eveGraphics' | 'eveIcons' | 'eveUnits' | 'industryActivity' | 'industryBlueprints' | 'invCategories' | 'invContrabandTypes' | 'invControlTowerResourcePurposes' | 'invControlTowerResources' | 'invFlags' | 'invGroups' | 'invItems' | 'invMarketGroups' | 'invMetaGroups' | 'invMetaTypes' | 'invNames' | 'invPositions' | 'invTraits' | 'invTypeMaterials' | 'invTypeReactions' | 'invTypes' | 'invUniqueNames' | 'invVolumes' | 'mapCelestialGraphics' | 'mapCelestialStatistics' | 'mapConstellationJumps' | 'mapConstellations' | 'mapDenormalize' | 'mapJumps' | 'mapLandmarks' | 'mapLocationScenes' | 'mapLocationWormholeClasses' | 'mapRegionJumps' | 'mapRegions' | 'mapSolarSystemJumps' | 'mapSolarSystems' | 'mapUniverse' | 'planetSchematics' | 'planetSchematicsPinMap' | 'planetSchematicsTypeMap' | 'ramActivities' | 'ramAssemblyLineStations' | 'ramAssemblyLineTypeDetailPerCategory' | 'ramAssemblyLineTypeDetailPerGroup' | 'ramAssemblyLineTypes' | 'ramInstallationTypeContents' | 'skinLicense' | 'skinMaterials' | 'skins' | 'staOperationServices' | 'staOperations' | 'staServices' | 'staStationTypes' | 'staStations' | 'translationTables' | 'trnTranslationColumns' | 'trnTranslationLanguages' | 'trnTranslations' | 'warCombatZoneSystems' | 'warCombatZones'
      txIsolationLevel: Prisma.TransactionIsolationLevel
    },
    model: {
      agtAgentTypes: {
        payload: Prisma.$agtAgentTypesPayload<ExtArgs>
        fields: Prisma.agtAgentTypesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.agtAgentTypesFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$agtAgentTypesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.agtAgentTypesFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$agtAgentTypesPayload>
          }
          findFirst: {
            args: Prisma.agtAgentTypesFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$agtAgentTypesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.agtAgentTypesFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$agtAgentTypesPayload>
          }
          findMany: {
            args: Prisma.agtAgentTypesFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$agtAgentTypesPayload>[]
          }
          create: {
            args: Prisma.agtAgentTypesCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$agtAgentTypesPayload>
          }
          createMany: {
            args: Prisma.agtAgentTypesCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.agtAgentTypesDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$agtAgentTypesPayload>
          }
          update: {
            args: Prisma.agtAgentTypesUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$agtAgentTypesPayload>
          }
          deleteMany: {
            args: Prisma.agtAgentTypesDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.agtAgentTypesUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.agtAgentTypesUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$agtAgentTypesPayload>
          }
          aggregate: {
            args: Prisma.AgtAgentTypesAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateAgtAgentTypes>
          }
          groupBy: {
            args: Prisma.agtAgentTypesGroupByArgs<ExtArgs>,
            result: $Utils.Optional<AgtAgentTypesGroupByOutputType>[]
          }
          count: {
            args: Prisma.agtAgentTypesCountArgs<ExtArgs>,
            result: $Utils.Optional<AgtAgentTypesCountAggregateOutputType> | number
          }
        }
      }
      agtAgents: {
        payload: Prisma.$agtAgentsPayload<ExtArgs>
        fields: Prisma.agtAgentsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.agtAgentsFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$agtAgentsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.agtAgentsFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$agtAgentsPayload>
          }
          findFirst: {
            args: Prisma.agtAgentsFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$agtAgentsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.agtAgentsFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$agtAgentsPayload>
          }
          findMany: {
            args: Prisma.agtAgentsFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$agtAgentsPayload>[]
          }
          create: {
            args: Prisma.agtAgentsCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$agtAgentsPayload>
          }
          createMany: {
            args: Prisma.agtAgentsCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.agtAgentsDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$agtAgentsPayload>
          }
          update: {
            args: Prisma.agtAgentsUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$agtAgentsPayload>
          }
          deleteMany: {
            args: Prisma.agtAgentsDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.agtAgentsUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.agtAgentsUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$agtAgentsPayload>
          }
          aggregate: {
            args: Prisma.AgtAgentsAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateAgtAgents>
          }
          groupBy: {
            args: Prisma.agtAgentsGroupByArgs<ExtArgs>,
            result: $Utils.Optional<AgtAgentsGroupByOutputType>[]
          }
          count: {
            args: Prisma.agtAgentsCountArgs<ExtArgs>,
            result: $Utils.Optional<AgtAgentsCountAggregateOutputType> | number
          }
        }
      }
      agtAgentsInSpace: {
        payload: Prisma.$agtAgentsInSpacePayload<ExtArgs>
        fields: Prisma.agtAgentsInSpaceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.agtAgentsInSpaceFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$agtAgentsInSpacePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.agtAgentsInSpaceFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$agtAgentsInSpacePayload>
          }
          findFirst: {
            args: Prisma.agtAgentsInSpaceFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$agtAgentsInSpacePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.agtAgentsInSpaceFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$agtAgentsInSpacePayload>
          }
          findMany: {
            args: Prisma.agtAgentsInSpaceFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$agtAgentsInSpacePayload>[]
          }
          create: {
            args: Prisma.agtAgentsInSpaceCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$agtAgentsInSpacePayload>
          }
          createMany: {
            args: Prisma.agtAgentsInSpaceCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.agtAgentsInSpaceDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$agtAgentsInSpacePayload>
          }
          update: {
            args: Prisma.agtAgentsInSpaceUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$agtAgentsInSpacePayload>
          }
          deleteMany: {
            args: Prisma.agtAgentsInSpaceDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.agtAgentsInSpaceUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.agtAgentsInSpaceUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$agtAgentsInSpacePayload>
          }
          aggregate: {
            args: Prisma.AgtAgentsInSpaceAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateAgtAgentsInSpace>
          }
          groupBy: {
            args: Prisma.agtAgentsInSpaceGroupByArgs<ExtArgs>,
            result: $Utils.Optional<AgtAgentsInSpaceGroupByOutputType>[]
          }
          count: {
            args: Prisma.agtAgentsInSpaceCountArgs<ExtArgs>,
            result: $Utils.Optional<AgtAgentsInSpaceCountAggregateOutputType> | number
          }
        }
      }
      agtResearchAgents: {
        payload: Prisma.$agtResearchAgentsPayload<ExtArgs>
        fields: Prisma.agtResearchAgentsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.agtResearchAgentsFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$agtResearchAgentsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.agtResearchAgentsFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$agtResearchAgentsPayload>
          }
          findFirst: {
            args: Prisma.agtResearchAgentsFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$agtResearchAgentsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.agtResearchAgentsFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$agtResearchAgentsPayload>
          }
          findMany: {
            args: Prisma.agtResearchAgentsFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$agtResearchAgentsPayload>[]
          }
          create: {
            args: Prisma.agtResearchAgentsCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$agtResearchAgentsPayload>
          }
          createMany: {
            args: Prisma.agtResearchAgentsCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.agtResearchAgentsDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$agtResearchAgentsPayload>
          }
          update: {
            args: Prisma.agtResearchAgentsUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$agtResearchAgentsPayload>
          }
          deleteMany: {
            args: Prisma.agtResearchAgentsDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.agtResearchAgentsUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.agtResearchAgentsUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$agtResearchAgentsPayload>
          }
          aggregate: {
            args: Prisma.AgtResearchAgentsAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateAgtResearchAgents>
          }
          groupBy: {
            args: Prisma.agtResearchAgentsGroupByArgs<ExtArgs>,
            result: $Utils.Optional<AgtResearchAgentsGroupByOutputType>[]
          }
          count: {
            args: Prisma.agtResearchAgentsCountArgs<ExtArgs>,
            result: $Utils.Optional<AgtResearchAgentsCountAggregateOutputType> | number
          }
        }
      }
      certCerts: {
        payload: Prisma.$certCertsPayload<ExtArgs>
        fields: Prisma.certCertsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.certCertsFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$certCertsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.certCertsFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$certCertsPayload>
          }
          findFirst: {
            args: Prisma.certCertsFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$certCertsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.certCertsFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$certCertsPayload>
          }
          findMany: {
            args: Prisma.certCertsFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$certCertsPayload>[]
          }
          create: {
            args: Prisma.certCertsCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$certCertsPayload>
          }
          createMany: {
            args: Prisma.certCertsCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.certCertsDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$certCertsPayload>
          }
          update: {
            args: Prisma.certCertsUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$certCertsPayload>
          }
          deleteMany: {
            args: Prisma.certCertsDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.certCertsUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.certCertsUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$certCertsPayload>
          }
          aggregate: {
            args: Prisma.CertCertsAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateCertCerts>
          }
          groupBy: {
            args: Prisma.certCertsGroupByArgs<ExtArgs>,
            result: $Utils.Optional<CertCertsGroupByOutputType>[]
          }
          count: {
            args: Prisma.certCertsCountArgs<ExtArgs>,
            result: $Utils.Optional<CertCertsCountAggregateOutputType> | number
          }
        }
      }
      chrAncestries: {
        payload: Prisma.$chrAncestriesPayload<ExtArgs>
        fields: Prisma.chrAncestriesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.chrAncestriesFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$chrAncestriesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.chrAncestriesFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$chrAncestriesPayload>
          }
          findFirst: {
            args: Prisma.chrAncestriesFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$chrAncestriesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.chrAncestriesFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$chrAncestriesPayload>
          }
          findMany: {
            args: Prisma.chrAncestriesFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$chrAncestriesPayload>[]
          }
          create: {
            args: Prisma.chrAncestriesCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$chrAncestriesPayload>
          }
          createMany: {
            args: Prisma.chrAncestriesCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.chrAncestriesDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$chrAncestriesPayload>
          }
          update: {
            args: Prisma.chrAncestriesUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$chrAncestriesPayload>
          }
          deleteMany: {
            args: Prisma.chrAncestriesDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.chrAncestriesUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.chrAncestriesUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$chrAncestriesPayload>
          }
          aggregate: {
            args: Prisma.ChrAncestriesAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateChrAncestries>
          }
          groupBy: {
            args: Prisma.chrAncestriesGroupByArgs<ExtArgs>,
            result: $Utils.Optional<ChrAncestriesGroupByOutputType>[]
          }
          count: {
            args: Prisma.chrAncestriesCountArgs<ExtArgs>,
            result: $Utils.Optional<ChrAncestriesCountAggregateOutputType> | number
          }
        }
      }
      chrAttributes: {
        payload: Prisma.$chrAttributesPayload<ExtArgs>
        fields: Prisma.chrAttributesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.chrAttributesFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$chrAttributesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.chrAttributesFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$chrAttributesPayload>
          }
          findFirst: {
            args: Prisma.chrAttributesFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$chrAttributesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.chrAttributesFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$chrAttributesPayload>
          }
          findMany: {
            args: Prisma.chrAttributesFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$chrAttributesPayload>[]
          }
          create: {
            args: Prisma.chrAttributesCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$chrAttributesPayload>
          }
          createMany: {
            args: Prisma.chrAttributesCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.chrAttributesDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$chrAttributesPayload>
          }
          update: {
            args: Prisma.chrAttributesUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$chrAttributesPayload>
          }
          deleteMany: {
            args: Prisma.chrAttributesDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.chrAttributesUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.chrAttributesUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$chrAttributesPayload>
          }
          aggregate: {
            args: Prisma.ChrAttributesAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateChrAttributes>
          }
          groupBy: {
            args: Prisma.chrAttributesGroupByArgs<ExtArgs>,
            result: $Utils.Optional<ChrAttributesGroupByOutputType>[]
          }
          count: {
            args: Prisma.chrAttributesCountArgs<ExtArgs>,
            result: $Utils.Optional<ChrAttributesCountAggregateOutputType> | number
          }
        }
      }
      chrBloodlines: {
        payload: Prisma.$chrBloodlinesPayload<ExtArgs>
        fields: Prisma.chrBloodlinesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.chrBloodlinesFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$chrBloodlinesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.chrBloodlinesFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$chrBloodlinesPayload>
          }
          findFirst: {
            args: Prisma.chrBloodlinesFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$chrBloodlinesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.chrBloodlinesFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$chrBloodlinesPayload>
          }
          findMany: {
            args: Prisma.chrBloodlinesFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$chrBloodlinesPayload>[]
          }
          create: {
            args: Prisma.chrBloodlinesCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$chrBloodlinesPayload>
          }
          createMany: {
            args: Prisma.chrBloodlinesCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.chrBloodlinesDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$chrBloodlinesPayload>
          }
          update: {
            args: Prisma.chrBloodlinesUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$chrBloodlinesPayload>
          }
          deleteMany: {
            args: Prisma.chrBloodlinesDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.chrBloodlinesUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.chrBloodlinesUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$chrBloodlinesPayload>
          }
          aggregate: {
            args: Prisma.ChrBloodlinesAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateChrBloodlines>
          }
          groupBy: {
            args: Prisma.chrBloodlinesGroupByArgs<ExtArgs>,
            result: $Utils.Optional<ChrBloodlinesGroupByOutputType>[]
          }
          count: {
            args: Prisma.chrBloodlinesCountArgs<ExtArgs>,
            result: $Utils.Optional<ChrBloodlinesCountAggregateOutputType> | number
          }
        }
      }
      chrFactions: {
        payload: Prisma.$chrFactionsPayload<ExtArgs>
        fields: Prisma.chrFactionsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.chrFactionsFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$chrFactionsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.chrFactionsFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$chrFactionsPayload>
          }
          findFirst: {
            args: Prisma.chrFactionsFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$chrFactionsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.chrFactionsFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$chrFactionsPayload>
          }
          findMany: {
            args: Prisma.chrFactionsFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$chrFactionsPayload>[]
          }
          create: {
            args: Prisma.chrFactionsCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$chrFactionsPayload>
          }
          createMany: {
            args: Prisma.chrFactionsCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.chrFactionsDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$chrFactionsPayload>
          }
          update: {
            args: Prisma.chrFactionsUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$chrFactionsPayload>
          }
          deleteMany: {
            args: Prisma.chrFactionsDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.chrFactionsUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.chrFactionsUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$chrFactionsPayload>
          }
          aggregate: {
            args: Prisma.ChrFactionsAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateChrFactions>
          }
          groupBy: {
            args: Prisma.chrFactionsGroupByArgs<ExtArgs>,
            result: $Utils.Optional<ChrFactionsGroupByOutputType>[]
          }
          count: {
            args: Prisma.chrFactionsCountArgs<ExtArgs>,
            result: $Utils.Optional<ChrFactionsCountAggregateOutputType> | number
          }
        }
      }
      chrRaces: {
        payload: Prisma.$chrRacesPayload<ExtArgs>
        fields: Prisma.chrRacesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.chrRacesFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$chrRacesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.chrRacesFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$chrRacesPayload>
          }
          findFirst: {
            args: Prisma.chrRacesFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$chrRacesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.chrRacesFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$chrRacesPayload>
          }
          findMany: {
            args: Prisma.chrRacesFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$chrRacesPayload>[]
          }
          create: {
            args: Prisma.chrRacesCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$chrRacesPayload>
          }
          createMany: {
            args: Prisma.chrRacesCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.chrRacesDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$chrRacesPayload>
          }
          update: {
            args: Prisma.chrRacesUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$chrRacesPayload>
          }
          deleteMany: {
            args: Prisma.chrRacesDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.chrRacesUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.chrRacesUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$chrRacesPayload>
          }
          aggregate: {
            args: Prisma.ChrRacesAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateChrRaces>
          }
          groupBy: {
            args: Prisma.chrRacesGroupByArgs<ExtArgs>,
            result: $Utils.Optional<ChrRacesGroupByOutputType>[]
          }
          count: {
            args: Prisma.chrRacesCountArgs<ExtArgs>,
            result: $Utils.Optional<ChrRacesCountAggregateOutputType> | number
          }
        }
      }
      crpActivities: {
        payload: Prisma.$crpActivitiesPayload<ExtArgs>
        fields: Prisma.crpActivitiesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.crpActivitiesFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$crpActivitiesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.crpActivitiesFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$crpActivitiesPayload>
          }
          findFirst: {
            args: Prisma.crpActivitiesFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$crpActivitiesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.crpActivitiesFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$crpActivitiesPayload>
          }
          findMany: {
            args: Prisma.crpActivitiesFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$crpActivitiesPayload>[]
          }
          create: {
            args: Prisma.crpActivitiesCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$crpActivitiesPayload>
          }
          createMany: {
            args: Prisma.crpActivitiesCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.crpActivitiesDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$crpActivitiesPayload>
          }
          update: {
            args: Prisma.crpActivitiesUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$crpActivitiesPayload>
          }
          deleteMany: {
            args: Prisma.crpActivitiesDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.crpActivitiesUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.crpActivitiesUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$crpActivitiesPayload>
          }
          aggregate: {
            args: Prisma.CrpActivitiesAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateCrpActivities>
          }
          groupBy: {
            args: Prisma.crpActivitiesGroupByArgs<ExtArgs>,
            result: $Utils.Optional<CrpActivitiesGroupByOutputType>[]
          }
          count: {
            args: Prisma.crpActivitiesCountArgs<ExtArgs>,
            result: $Utils.Optional<CrpActivitiesCountAggregateOutputType> | number
          }
        }
      }
      crpNPCCorporationDivisions: {
        payload: Prisma.$crpNPCCorporationDivisionsPayload<ExtArgs>
        fields: Prisma.crpNPCCorporationDivisionsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.crpNPCCorporationDivisionsFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$crpNPCCorporationDivisionsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.crpNPCCorporationDivisionsFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$crpNPCCorporationDivisionsPayload>
          }
          findFirst: {
            args: Prisma.crpNPCCorporationDivisionsFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$crpNPCCorporationDivisionsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.crpNPCCorporationDivisionsFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$crpNPCCorporationDivisionsPayload>
          }
          findMany: {
            args: Prisma.crpNPCCorporationDivisionsFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$crpNPCCorporationDivisionsPayload>[]
          }
          create: {
            args: Prisma.crpNPCCorporationDivisionsCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$crpNPCCorporationDivisionsPayload>
          }
          createMany: {
            args: Prisma.crpNPCCorporationDivisionsCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.crpNPCCorporationDivisionsDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$crpNPCCorporationDivisionsPayload>
          }
          update: {
            args: Prisma.crpNPCCorporationDivisionsUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$crpNPCCorporationDivisionsPayload>
          }
          deleteMany: {
            args: Prisma.crpNPCCorporationDivisionsDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.crpNPCCorporationDivisionsUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.crpNPCCorporationDivisionsUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$crpNPCCorporationDivisionsPayload>
          }
          aggregate: {
            args: Prisma.CrpNPCCorporationDivisionsAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateCrpNPCCorporationDivisions>
          }
          groupBy: {
            args: Prisma.crpNPCCorporationDivisionsGroupByArgs<ExtArgs>,
            result: $Utils.Optional<CrpNPCCorporationDivisionsGroupByOutputType>[]
          }
          count: {
            args: Prisma.crpNPCCorporationDivisionsCountArgs<ExtArgs>,
            result: $Utils.Optional<CrpNPCCorporationDivisionsCountAggregateOutputType> | number
          }
        }
      }
      crpNPCCorporationResearchFields: {
        payload: Prisma.$crpNPCCorporationResearchFieldsPayload<ExtArgs>
        fields: Prisma.crpNPCCorporationResearchFieldsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.crpNPCCorporationResearchFieldsFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$crpNPCCorporationResearchFieldsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.crpNPCCorporationResearchFieldsFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$crpNPCCorporationResearchFieldsPayload>
          }
          findFirst: {
            args: Prisma.crpNPCCorporationResearchFieldsFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$crpNPCCorporationResearchFieldsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.crpNPCCorporationResearchFieldsFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$crpNPCCorporationResearchFieldsPayload>
          }
          findMany: {
            args: Prisma.crpNPCCorporationResearchFieldsFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$crpNPCCorporationResearchFieldsPayload>[]
          }
          create: {
            args: Prisma.crpNPCCorporationResearchFieldsCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$crpNPCCorporationResearchFieldsPayload>
          }
          createMany: {
            args: Prisma.crpNPCCorporationResearchFieldsCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.crpNPCCorporationResearchFieldsDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$crpNPCCorporationResearchFieldsPayload>
          }
          update: {
            args: Prisma.crpNPCCorporationResearchFieldsUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$crpNPCCorporationResearchFieldsPayload>
          }
          deleteMany: {
            args: Prisma.crpNPCCorporationResearchFieldsDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.crpNPCCorporationResearchFieldsUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.crpNPCCorporationResearchFieldsUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$crpNPCCorporationResearchFieldsPayload>
          }
          aggregate: {
            args: Prisma.CrpNPCCorporationResearchFieldsAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateCrpNPCCorporationResearchFields>
          }
          groupBy: {
            args: Prisma.crpNPCCorporationResearchFieldsGroupByArgs<ExtArgs>,
            result: $Utils.Optional<CrpNPCCorporationResearchFieldsGroupByOutputType>[]
          }
          count: {
            args: Prisma.crpNPCCorporationResearchFieldsCountArgs<ExtArgs>,
            result: $Utils.Optional<CrpNPCCorporationResearchFieldsCountAggregateOutputType> | number
          }
        }
      }
      crpNPCCorporationTrades: {
        payload: Prisma.$crpNPCCorporationTradesPayload<ExtArgs>
        fields: Prisma.crpNPCCorporationTradesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.crpNPCCorporationTradesFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$crpNPCCorporationTradesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.crpNPCCorporationTradesFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$crpNPCCorporationTradesPayload>
          }
          findFirst: {
            args: Prisma.crpNPCCorporationTradesFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$crpNPCCorporationTradesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.crpNPCCorporationTradesFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$crpNPCCorporationTradesPayload>
          }
          findMany: {
            args: Prisma.crpNPCCorporationTradesFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$crpNPCCorporationTradesPayload>[]
          }
          create: {
            args: Prisma.crpNPCCorporationTradesCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$crpNPCCorporationTradesPayload>
          }
          createMany: {
            args: Prisma.crpNPCCorporationTradesCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.crpNPCCorporationTradesDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$crpNPCCorporationTradesPayload>
          }
          update: {
            args: Prisma.crpNPCCorporationTradesUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$crpNPCCorporationTradesPayload>
          }
          deleteMany: {
            args: Prisma.crpNPCCorporationTradesDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.crpNPCCorporationTradesUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.crpNPCCorporationTradesUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$crpNPCCorporationTradesPayload>
          }
          aggregate: {
            args: Prisma.CrpNPCCorporationTradesAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateCrpNPCCorporationTrades>
          }
          groupBy: {
            args: Prisma.crpNPCCorporationTradesGroupByArgs<ExtArgs>,
            result: $Utils.Optional<CrpNPCCorporationTradesGroupByOutputType>[]
          }
          count: {
            args: Prisma.crpNPCCorporationTradesCountArgs<ExtArgs>,
            result: $Utils.Optional<CrpNPCCorporationTradesCountAggregateOutputType> | number
          }
        }
      }
      crpNPCCorporations: {
        payload: Prisma.$crpNPCCorporationsPayload<ExtArgs>
        fields: Prisma.crpNPCCorporationsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.crpNPCCorporationsFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$crpNPCCorporationsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.crpNPCCorporationsFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$crpNPCCorporationsPayload>
          }
          findFirst: {
            args: Prisma.crpNPCCorporationsFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$crpNPCCorporationsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.crpNPCCorporationsFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$crpNPCCorporationsPayload>
          }
          findMany: {
            args: Prisma.crpNPCCorporationsFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$crpNPCCorporationsPayload>[]
          }
          create: {
            args: Prisma.crpNPCCorporationsCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$crpNPCCorporationsPayload>
          }
          createMany: {
            args: Prisma.crpNPCCorporationsCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.crpNPCCorporationsDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$crpNPCCorporationsPayload>
          }
          update: {
            args: Prisma.crpNPCCorporationsUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$crpNPCCorporationsPayload>
          }
          deleteMany: {
            args: Prisma.crpNPCCorporationsDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.crpNPCCorporationsUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.crpNPCCorporationsUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$crpNPCCorporationsPayload>
          }
          aggregate: {
            args: Prisma.CrpNPCCorporationsAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateCrpNPCCorporations>
          }
          groupBy: {
            args: Prisma.crpNPCCorporationsGroupByArgs<ExtArgs>,
            result: $Utils.Optional<CrpNPCCorporationsGroupByOutputType>[]
          }
          count: {
            args: Prisma.crpNPCCorporationsCountArgs<ExtArgs>,
            result: $Utils.Optional<CrpNPCCorporationsCountAggregateOutputType> | number
          }
        }
      }
      crpNPCDivisions: {
        payload: Prisma.$crpNPCDivisionsPayload<ExtArgs>
        fields: Prisma.crpNPCDivisionsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.crpNPCDivisionsFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$crpNPCDivisionsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.crpNPCDivisionsFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$crpNPCDivisionsPayload>
          }
          findFirst: {
            args: Prisma.crpNPCDivisionsFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$crpNPCDivisionsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.crpNPCDivisionsFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$crpNPCDivisionsPayload>
          }
          findMany: {
            args: Prisma.crpNPCDivisionsFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$crpNPCDivisionsPayload>[]
          }
          create: {
            args: Prisma.crpNPCDivisionsCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$crpNPCDivisionsPayload>
          }
          createMany: {
            args: Prisma.crpNPCDivisionsCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.crpNPCDivisionsDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$crpNPCDivisionsPayload>
          }
          update: {
            args: Prisma.crpNPCDivisionsUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$crpNPCDivisionsPayload>
          }
          deleteMany: {
            args: Prisma.crpNPCDivisionsDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.crpNPCDivisionsUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.crpNPCDivisionsUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$crpNPCDivisionsPayload>
          }
          aggregate: {
            args: Prisma.CrpNPCDivisionsAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateCrpNPCDivisions>
          }
          groupBy: {
            args: Prisma.crpNPCDivisionsGroupByArgs<ExtArgs>,
            result: $Utils.Optional<CrpNPCDivisionsGroupByOutputType>[]
          }
          count: {
            args: Prisma.crpNPCDivisionsCountArgs<ExtArgs>,
            result: $Utils.Optional<CrpNPCDivisionsCountAggregateOutputType> | number
          }
        }
      }
      dgmAttributeCategories: {
        payload: Prisma.$dgmAttributeCategoriesPayload<ExtArgs>
        fields: Prisma.dgmAttributeCategoriesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.dgmAttributeCategoriesFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$dgmAttributeCategoriesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.dgmAttributeCategoriesFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$dgmAttributeCategoriesPayload>
          }
          findFirst: {
            args: Prisma.dgmAttributeCategoriesFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$dgmAttributeCategoriesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.dgmAttributeCategoriesFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$dgmAttributeCategoriesPayload>
          }
          findMany: {
            args: Prisma.dgmAttributeCategoriesFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$dgmAttributeCategoriesPayload>[]
          }
          create: {
            args: Prisma.dgmAttributeCategoriesCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$dgmAttributeCategoriesPayload>
          }
          createMany: {
            args: Prisma.dgmAttributeCategoriesCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.dgmAttributeCategoriesDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$dgmAttributeCategoriesPayload>
          }
          update: {
            args: Prisma.dgmAttributeCategoriesUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$dgmAttributeCategoriesPayload>
          }
          deleteMany: {
            args: Prisma.dgmAttributeCategoriesDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.dgmAttributeCategoriesUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.dgmAttributeCategoriesUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$dgmAttributeCategoriesPayload>
          }
          aggregate: {
            args: Prisma.DgmAttributeCategoriesAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateDgmAttributeCategories>
          }
          groupBy: {
            args: Prisma.dgmAttributeCategoriesGroupByArgs<ExtArgs>,
            result: $Utils.Optional<DgmAttributeCategoriesGroupByOutputType>[]
          }
          count: {
            args: Prisma.dgmAttributeCategoriesCountArgs<ExtArgs>,
            result: $Utils.Optional<DgmAttributeCategoriesCountAggregateOutputType> | number
          }
        }
      }
      dgmAttributeTypes: {
        payload: Prisma.$dgmAttributeTypesPayload<ExtArgs>
        fields: Prisma.dgmAttributeTypesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.dgmAttributeTypesFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$dgmAttributeTypesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.dgmAttributeTypesFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$dgmAttributeTypesPayload>
          }
          findFirst: {
            args: Prisma.dgmAttributeTypesFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$dgmAttributeTypesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.dgmAttributeTypesFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$dgmAttributeTypesPayload>
          }
          findMany: {
            args: Prisma.dgmAttributeTypesFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$dgmAttributeTypesPayload>[]
          }
          create: {
            args: Prisma.dgmAttributeTypesCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$dgmAttributeTypesPayload>
          }
          createMany: {
            args: Prisma.dgmAttributeTypesCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.dgmAttributeTypesDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$dgmAttributeTypesPayload>
          }
          update: {
            args: Prisma.dgmAttributeTypesUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$dgmAttributeTypesPayload>
          }
          deleteMany: {
            args: Prisma.dgmAttributeTypesDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.dgmAttributeTypesUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.dgmAttributeTypesUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$dgmAttributeTypesPayload>
          }
          aggregate: {
            args: Prisma.DgmAttributeTypesAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateDgmAttributeTypes>
          }
          groupBy: {
            args: Prisma.dgmAttributeTypesGroupByArgs<ExtArgs>,
            result: $Utils.Optional<DgmAttributeTypesGroupByOutputType>[]
          }
          count: {
            args: Prisma.dgmAttributeTypesCountArgs<ExtArgs>,
            result: $Utils.Optional<DgmAttributeTypesCountAggregateOutputType> | number
          }
        }
      }
      dgmEffects: {
        payload: Prisma.$dgmEffectsPayload<ExtArgs>
        fields: Prisma.dgmEffectsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.dgmEffectsFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$dgmEffectsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.dgmEffectsFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$dgmEffectsPayload>
          }
          findFirst: {
            args: Prisma.dgmEffectsFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$dgmEffectsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.dgmEffectsFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$dgmEffectsPayload>
          }
          findMany: {
            args: Prisma.dgmEffectsFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$dgmEffectsPayload>[]
          }
          create: {
            args: Prisma.dgmEffectsCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$dgmEffectsPayload>
          }
          createMany: {
            args: Prisma.dgmEffectsCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.dgmEffectsDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$dgmEffectsPayload>
          }
          update: {
            args: Prisma.dgmEffectsUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$dgmEffectsPayload>
          }
          deleteMany: {
            args: Prisma.dgmEffectsDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.dgmEffectsUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.dgmEffectsUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$dgmEffectsPayload>
          }
          aggregate: {
            args: Prisma.DgmEffectsAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateDgmEffects>
          }
          groupBy: {
            args: Prisma.dgmEffectsGroupByArgs<ExtArgs>,
            result: $Utils.Optional<DgmEffectsGroupByOutputType>[]
          }
          count: {
            args: Prisma.dgmEffectsCountArgs<ExtArgs>,
            result: $Utils.Optional<DgmEffectsCountAggregateOutputType> | number
          }
        }
      }
      dgmExpressions: {
        payload: Prisma.$dgmExpressionsPayload<ExtArgs>
        fields: Prisma.dgmExpressionsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.dgmExpressionsFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$dgmExpressionsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.dgmExpressionsFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$dgmExpressionsPayload>
          }
          findFirst: {
            args: Prisma.dgmExpressionsFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$dgmExpressionsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.dgmExpressionsFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$dgmExpressionsPayload>
          }
          findMany: {
            args: Prisma.dgmExpressionsFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$dgmExpressionsPayload>[]
          }
          create: {
            args: Prisma.dgmExpressionsCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$dgmExpressionsPayload>
          }
          createMany: {
            args: Prisma.dgmExpressionsCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.dgmExpressionsDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$dgmExpressionsPayload>
          }
          update: {
            args: Prisma.dgmExpressionsUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$dgmExpressionsPayload>
          }
          deleteMany: {
            args: Prisma.dgmExpressionsDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.dgmExpressionsUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.dgmExpressionsUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$dgmExpressionsPayload>
          }
          aggregate: {
            args: Prisma.DgmExpressionsAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateDgmExpressions>
          }
          groupBy: {
            args: Prisma.dgmExpressionsGroupByArgs<ExtArgs>,
            result: $Utils.Optional<DgmExpressionsGroupByOutputType>[]
          }
          count: {
            args: Prisma.dgmExpressionsCountArgs<ExtArgs>,
            result: $Utils.Optional<DgmExpressionsCountAggregateOutputType> | number
          }
        }
      }
      dgmTypeAttributes: {
        payload: Prisma.$dgmTypeAttributesPayload<ExtArgs>
        fields: Prisma.dgmTypeAttributesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.dgmTypeAttributesFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$dgmTypeAttributesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.dgmTypeAttributesFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$dgmTypeAttributesPayload>
          }
          findFirst: {
            args: Prisma.dgmTypeAttributesFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$dgmTypeAttributesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.dgmTypeAttributesFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$dgmTypeAttributesPayload>
          }
          findMany: {
            args: Prisma.dgmTypeAttributesFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$dgmTypeAttributesPayload>[]
          }
          create: {
            args: Prisma.dgmTypeAttributesCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$dgmTypeAttributesPayload>
          }
          createMany: {
            args: Prisma.dgmTypeAttributesCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.dgmTypeAttributesDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$dgmTypeAttributesPayload>
          }
          update: {
            args: Prisma.dgmTypeAttributesUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$dgmTypeAttributesPayload>
          }
          deleteMany: {
            args: Prisma.dgmTypeAttributesDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.dgmTypeAttributesUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.dgmTypeAttributesUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$dgmTypeAttributesPayload>
          }
          aggregate: {
            args: Prisma.DgmTypeAttributesAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateDgmTypeAttributes>
          }
          groupBy: {
            args: Prisma.dgmTypeAttributesGroupByArgs<ExtArgs>,
            result: $Utils.Optional<DgmTypeAttributesGroupByOutputType>[]
          }
          count: {
            args: Prisma.dgmTypeAttributesCountArgs<ExtArgs>,
            result: $Utils.Optional<DgmTypeAttributesCountAggregateOutputType> | number
          }
        }
      }
      dgmTypeEffects: {
        payload: Prisma.$dgmTypeEffectsPayload<ExtArgs>
        fields: Prisma.dgmTypeEffectsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.dgmTypeEffectsFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$dgmTypeEffectsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.dgmTypeEffectsFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$dgmTypeEffectsPayload>
          }
          findFirst: {
            args: Prisma.dgmTypeEffectsFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$dgmTypeEffectsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.dgmTypeEffectsFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$dgmTypeEffectsPayload>
          }
          findMany: {
            args: Prisma.dgmTypeEffectsFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$dgmTypeEffectsPayload>[]
          }
          create: {
            args: Prisma.dgmTypeEffectsCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$dgmTypeEffectsPayload>
          }
          createMany: {
            args: Prisma.dgmTypeEffectsCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.dgmTypeEffectsDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$dgmTypeEffectsPayload>
          }
          update: {
            args: Prisma.dgmTypeEffectsUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$dgmTypeEffectsPayload>
          }
          deleteMany: {
            args: Prisma.dgmTypeEffectsDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.dgmTypeEffectsUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.dgmTypeEffectsUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$dgmTypeEffectsPayload>
          }
          aggregate: {
            args: Prisma.DgmTypeEffectsAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateDgmTypeEffects>
          }
          groupBy: {
            args: Prisma.dgmTypeEffectsGroupByArgs<ExtArgs>,
            result: $Utils.Optional<DgmTypeEffectsGroupByOutputType>[]
          }
          count: {
            args: Prisma.dgmTypeEffectsCountArgs<ExtArgs>,
            result: $Utils.Optional<DgmTypeEffectsCountAggregateOutputType> | number
          }
        }
      }
      eveGraphics: {
        payload: Prisma.$eveGraphicsPayload<ExtArgs>
        fields: Prisma.eveGraphicsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.eveGraphicsFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$eveGraphicsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.eveGraphicsFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$eveGraphicsPayload>
          }
          findFirst: {
            args: Prisma.eveGraphicsFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$eveGraphicsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.eveGraphicsFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$eveGraphicsPayload>
          }
          findMany: {
            args: Prisma.eveGraphicsFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$eveGraphicsPayload>[]
          }
          create: {
            args: Prisma.eveGraphicsCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$eveGraphicsPayload>
          }
          createMany: {
            args: Prisma.eveGraphicsCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.eveGraphicsDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$eveGraphicsPayload>
          }
          update: {
            args: Prisma.eveGraphicsUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$eveGraphicsPayload>
          }
          deleteMany: {
            args: Prisma.eveGraphicsDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.eveGraphicsUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.eveGraphicsUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$eveGraphicsPayload>
          }
          aggregate: {
            args: Prisma.EveGraphicsAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateEveGraphics>
          }
          groupBy: {
            args: Prisma.eveGraphicsGroupByArgs<ExtArgs>,
            result: $Utils.Optional<EveGraphicsGroupByOutputType>[]
          }
          count: {
            args: Prisma.eveGraphicsCountArgs<ExtArgs>,
            result: $Utils.Optional<EveGraphicsCountAggregateOutputType> | number
          }
        }
      }
      eveIcons: {
        payload: Prisma.$eveIconsPayload<ExtArgs>
        fields: Prisma.eveIconsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.eveIconsFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$eveIconsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.eveIconsFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$eveIconsPayload>
          }
          findFirst: {
            args: Prisma.eveIconsFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$eveIconsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.eveIconsFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$eveIconsPayload>
          }
          findMany: {
            args: Prisma.eveIconsFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$eveIconsPayload>[]
          }
          create: {
            args: Prisma.eveIconsCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$eveIconsPayload>
          }
          createMany: {
            args: Prisma.eveIconsCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.eveIconsDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$eveIconsPayload>
          }
          update: {
            args: Prisma.eveIconsUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$eveIconsPayload>
          }
          deleteMany: {
            args: Prisma.eveIconsDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.eveIconsUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.eveIconsUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$eveIconsPayload>
          }
          aggregate: {
            args: Prisma.EveIconsAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateEveIcons>
          }
          groupBy: {
            args: Prisma.eveIconsGroupByArgs<ExtArgs>,
            result: $Utils.Optional<EveIconsGroupByOutputType>[]
          }
          count: {
            args: Prisma.eveIconsCountArgs<ExtArgs>,
            result: $Utils.Optional<EveIconsCountAggregateOutputType> | number
          }
        }
      }
      eveUnits: {
        payload: Prisma.$eveUnitsPayload<ExtArgs>
        fields: Prisma.eveUnitsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.eveUnitsFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$eveUnitsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.eveUnitsFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$eveUnitsPayload>
          }
          findFirst: {
            args: Prisma.eveUnitsFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$eveUnitsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.eveUnitsFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$eveUnitsPayload>
          }
          findMany: {
            args: Prisma.eveUnitsFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$eveUnitsPayload>[]
          }
          create: {
            args: Prisma.eveUnitsCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$eveUnitsPayload>
          }
          createMany: {
            args: Prisma.eveUnitsCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.eveUnitsDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$eveUnitsPayload>
          }
          update: {
            args: Prisma.eveUnitsUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$eveUnitsPayload>
          }
          deleteMany: {
            args: Prisma.eveUnitsDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.eveUnitsUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.eveUnitsUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$eveUnitsPayload>
          }
          aggregate: {
            args: Prisma.EveUnitsAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateEveUnits>
          }
          groupBy: {
            args: Prisma.eveUnitsGroupByArgs<ExtArgs>,
            result: $Utils.Optional<EveUnitsGroupByOutputType>[]
          }
          count: {
            args: Prisma.eveUnitsCountArgs<ExtArgs>,
            result: $Utils.Optional<EveUnitsCountAggregateOutputType> | number
          }
        }
      }
      industryActivity: {
        payload: Prisma.$industryActivityPayload<ExtArgs>
        fields: Prisma.industryActivityFieldRefs
        operations: {
          findUnique: {
            args: Prisma.industryActivityFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$industryActivityPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.industryActivityFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$industryActivityPayload>
          }
          findFirst: {
            args: Prisma.industryActivityFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$industryActivityPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.industryActivityFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$industryActivityPayload>
          }
          findMany: {
            args: Prisma.industryActivityFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$industryActivityPayload>[]
          }
          create: {
            args: Prisma.industryActivityCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$industryActivityPayload>
          }
          createMany: {
            args: Prisma.industryActivityCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.industryActivityDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$industryActivityPayload>
          }
          update: {
            args: Prisma.industryActivityUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$industryActivityPayload>
          }
          deleteMany: {
            args: Prisma.industryActivityDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.industryActivityUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.industryActivityUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$industryActivityPayload>
          }
          aggregate: {
            args: Prisma.IndustryActivityAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateIndustryActivity>
          }
          groupBy: {
            args: Prisma.industryActivityGroupByArgs<ExtArgs>,
            result: $Utils.Optional<IndustryActivityGroupByOutputType>[]
          }
          count: {
            args: Prisma.industryActivityCountArgs<ExtArgs>,
            result: $Utils.Optional<IndustryActivityCountAggregateOutputType> | number
          }
        }
      }
      industryBlueprints: {
        payload: Prisma.$industryBlueprintsPayload<ExtArgs>
        fields: Prisma.industryBlueprintsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.industryBlueprintsFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$industryBlueprintsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.industryBlueprintsFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$industryBlueprintsPayload>
          }
          findFirst: {
            args: Prisma.industryBlueprintsFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$industryBlueprintsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.industryBlueprintsFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$industryBlueprintsPayload>
          }
          findMany: {
            args: Prisma.industryBlueprintsFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$industryBlueprintsPayload>[]
          }
          create: {
            args: Prisma.industryBlueprintsCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$industryBlueprintsPayload>
          }
          createMany: {
            args: Prisma.industryBlueprintsCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.industryBlueprintsDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$industryBlueprintsPayload>
          }
          update: {
            args: Prisma.industryBlueprintsUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$industryBlueprintsPayload>
          }
          deleteMany: {
            args: Prisma.industryBlueprintsDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.industryBlueprintsUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.industryBlueprintsUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$industryBlueprintsPayload>
          }
          aggregate: {
            args: Prisma.IndustryBlueprintsAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateIndustryBlueprints>
          }
          groupBy: {
            args: Prisma.industryBlueprintsGroupByArgs<ExtArgs>,
            result: $Utils.Optional<IndustryBlueprintsGroupByOutputType>[]
          }
          count: {
            args: Prisma.industryBlueprintsCountArgs<ExtArgs>,
            result: $Utils.Optional<IndustryBlueprintsCountAggregateOutputType> | number
          }
        }
      }
      invCategories: {
        payload: Prisma.$invCategoriesPayload<ExtArgs>
        fields: Prisma.invCategoriesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.invCategoriesFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$invCategoriesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.invCategoriesFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$invCategoriesPayload>
          }
          findFirst: {
            args: Prisma.invCategoriesFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$invCategoriesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.invCategoriesFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$invCategoriesPayload>
          }
          findMany: {
            args: Prisma.invCategoriesFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$invCategoriesPayload>[]
          }
          create: {
            args: Prisma.invCategoriesCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$invCategoriesPayload>
          }
          createMany: {
            args: Prisma.invCategoriesCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.invCategoriesDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$invCategoriesPayload>
          }
          update: {
            args: Prisma.invCategoriesUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$invCategoriesPayload>
          }
          deleteMany: {
            args: Prisma.invCategoriesDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.invCategoriesUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.invCategoriesUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$invCategoriesPayload>
          }
          aggregate: {
            args: Prisma.InvCategoriesAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateInvCategories>
          }
          groupBy: {
            args: Prisma.invCategoriesGroupByArgs<ExtArgs>,
            result: $Utils.Optional<InvCategoriesGroupByOutputType>[]
          }
          count: {
            args: Prisma.invCategoriesCountArgs<ExtArgs>,
            result: $Utils.Optional<InvCategoriesCountAggregateOutputType> | number
          }
        }
      }
      invContrabandTypes: {
        payload: Prisma.$invContrabandTypesPayload<ExtArgs>
        fields: Prisma.invContrabandTypesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.invContrabandTypesFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$invContrabandTypesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.invContrabandTypesFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$invContrabandTypesPayload>
          }
          findFirst: {
            args: Prisma.invContrabandTypesFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$invContrabandTypesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.invContrabandTypesFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$invContrabandTypesPayload>
          }
          findMany: {
            args: Prisma.invContrabandTypesFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$invContrabandTypesPayload>[]
          }
          create: {
            args: Prisma.invContrabandTypesCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$invContrabandTypesPayload>
          }
          createMany: {
            args: Prisma.invContrabandTypesCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.invContrabandTypesDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$invContrabandTypesPayload>
          }
          update: {
            args: Prisma.invContrabandTypesUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$invContrabandTypesPayload>
          }
          deleteMany: {
            args: Prisma.invContrabandTypesDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.invContrabandTypesUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.invContrabandTypesUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$invContrabandTypesPayload>
          }
          aggregate: {
            args: Prisma.InvContrabandTypesAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateInvContrabandTypes>
          }
          groupBy: {
            args: Prisma.invContrabandTypesGroupByArgs<ExtArgs>,
            result: $Utils.Optional<InvContrabandTypesGroupByOutputType>[]
          }
          count: {
            args: Prisma.invContrabandTypesCountArgs<ExtArgs>,
            result: $Utils.Optional<InvContrabandTypesCountAggregateOutputType> | number
          }
        }
      }
      invControlTowerResourcePurposes: {
        payload: Prisma.$invControlTowerResourcePurposesPayload<ExtArgs>
        fields: Prisma.invControlTowerResourcePurposesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.invControlTowerResourcePurposesFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$invControlTowerResourcePurposesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.invControlTowerResourcePurposesFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$invControlTowerResourcePurposesPayload>
          }
          findFirst: {
            args: Prisma.invControlTowerResourcePurposesFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$invControlTowerResourcePurposesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.invControlTowerResourcePurposesFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$invControlTowerResourcePurposesPayload>
          }
          findMany: {
            args: Prisma.invControlTowerResourcePurposesFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$invControlTowerResourcePurposesPayload>[]
          }
          create: {
            args: Prisma.invControlTowerResourcePurposesCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$invControlTowerResourcePurposesPayload>
          }
          createMany: {
            args: Prisma.invControlTowerResourcePurposesCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.invControlTowerResourcePurposesDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$invControlTowerResourcePurposesPayload>
          }
          update: {
            args: Prisma.invControlTowerResourcePurposesUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$invControlTowerResourcePurposesPayload>
          }
          deleteMany: {
            args: Prisma.invControlTowerResourcePurposesDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.invControlTowerResourcePurposesUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.invControlTowerResourcePurposesUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$invControlTowerResourcePurposesPayload>
          }
          aggregate: {
            args: Prisma.InvControlTowerResourcePurposesAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateInvControlTowerResourcePurposes>
          }
          groupBy: {
            args: Prisma.invControlTowerResourcePurposesGroupByArgs<ExtArgs>,
            result: $Utils.Optional<InvControlTowerResourcePurposesGroupByOutputType>[]
          }
          count: {
            args: Prisma.invControlTowerResourcePurposesCountArgs<ExtArgs>,
            result: $Utils.Optional<InvControlTowerResourcePurposesCountAggregateOutputType> | number
          }
        }
      }
      invControlTowerResources: {
        payload: Prisma.$invControlTowerResourcesPayload<ExtArgs>
        fields: Prisma.invControlTowerResourcesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.invControlTowerResourcesFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$invControlTowerResourcesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.invControlTowerResourcesFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$invControlTowerResourcesPayload>
          }
          findFirst: {
            args: Prisma.invControlTowerResourcesFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$invControlTowerResourcesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.invControlTowerResourcesFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$invControlTowerResourcesPayload>
          }
          findMany: {
            args: Prisma.invControlTowerResourcesFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$invControlTowerResourcesPayload>[]
          }
          create: {
            args: Prisma.invControlTowerResourcesCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$invControlTowerResourcesPayload>
          }
          createMany: {
            args: Prisma.invControlTowerResourcesCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.invControlTowerResourcesDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$invControlTowerResourcesPayload>
          }
          update: {
            args: Prisma.invControlTowerResourcesUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$invControlTowerResourcesPayload>
          }
          deleteMany: {
            args: Prisma.invControlTowerResourcesDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.invControlTowerResourcesUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.invControlTowerResourcesUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$invControlTowerResourcesPayload>
          }
          aggregate: {
            args: Prisma.InvControlTowerResourcesAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateInvControlTowerResources>
          }
          groupBy: {
            args: Prisma.invControlTowerResourcesGroupByArgs<ExtArgs>,
            result: $Utils.Optional<InvControlTowerResourcesGroupByOutputType>[]
          }
          count: {
            args: Prisma.invControlTowerResourcesCountArgs<ExtArgs>,
            result: $Utils.Optional<InvControlTowerResourcesCountAggregateOutputType> | number
          }
        }
      }
      invFlags: {
        payload: Prisma.$invFlagsPayload<ExtArgs>
        fields: Prisma.invFlagsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.invFlagsFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$invFlagsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.invFlagsFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$invFlagsPayload>
          }
          findFirst: {
            args: Prisma.invFlagsFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$invFlagsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.invFlagsFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$invFlagsPayload>
          }
          findMany: {
            args: Prisma.invFlagsFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$invFlagsPayload>[]
          }
          create: {
            args: Prisma.invFlagsCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$invFlagsPayload>
          }
          createMany: {
            args: Prisma.invFlagsCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.invFlagsDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$invFlagsPayload>
          }
          update: {
            args: Prisma.invFlagsUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$invFlagsPayload>
          }
          deleteMany: {
            args: Prisma.invFlagsDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.invFlagsUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.invFlagsUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$invFlagsPayload>
          }
          aggregate: {
            args: Prisma.InvFlagsAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateInvFlags>
          }
          groupBy: {
            args: Prisma.invFlagsGroupByArgs<ExtArgs>,
            result: $Utils.Optional<InvFlagsGroupByOutputType>[]
          }
          count: {
            args: Prisma.invFlagsCountArgs<ExtArgs>,
            result: $Utils.Optional<InvFlagsCountAggregateOutputType> | number
          }
        }
      }
      invGroups: {
        payload: Prisma.$invGroupsPayload<ExtArgs>
        fields: Prisma.invGroupsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.invGroupsFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$invGroupsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.invGroupsFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$invGroupsPayload>
          }
          findFirst: {
            args: Prisma.invGroupsFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$invGroupsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.invGroupsFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$invGroupsPayload>
          }
          findMany: {
            args: Prisma.invGroupsFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$invGroupsPayload>[]
          }
          create: {
            args: Prisma.invGroupsCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$invGroupsPayload>
          }
          createMany: {
            args: Prisma.invGroupsCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.invGroupsDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$invGroupsPayload>
          }
          update: {
            args: Prisma.invGroupsUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$invGroupsPayload>
          }
          deleteMany: {
            args: Prisma.invGroupsDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.invGroupsUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.invGroupsUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$invGroupsPayload>
          }
          aggregate: {
            args: Prisma.InvGroupsAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateInvGroups>
          }
          groupBy: {
            args: Prisma.invGroupsGroupByArgs<ExtArgs>,
            result: $Utils.Optional<InvGroupsGroupByOutputType>[]
          }
          count: {
            args: Prisma.invGroupsCountArgs<ExtArgs>,
            result: $Utils.Optional<InvGroupsCountAggregateOutputType> | number
          }
        }
      }
      invItems: {
        payload: Prisma.$invItemsPayload<ExtArgs>
        fields: Prisma.invItemsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.invItemsFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$invItemsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.invItemsFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$invItemsPayload>
          }
          findFirst: {
            args: Prisma.invItemsFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$invItemsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.invItemsFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$invItemsPayload>
          }
          findMany: {
            args: Prisma.invItemsFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$invItemsPayload>[]
          }
          create: {
            args: Prisma.invItemsCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$invItemsPayload>
          }
          createMany: {
            args: Prisma.invItemsCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.invItemsDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$invItemsPayload>
          }
          update: {
            args: Prisma.invItemsUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$invItemsPayload>
          }
          deleteMany: {
            args: Prisma.invItemsDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.invItemsUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.invItemsUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$invItemsPayload>
          }
          aggregate: {
            args: Prisma.InvItemsAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateInvItems>
          }
          groupBy: {
            args: Prisma.invItemsGroupByArgs<ExtArgs>,
            result: $Utils.Optional<InvItemsGroupByOutputType>[]
          }
          count: {
            args: Prisma.invItemsCountArgs<ExtArgs>,
            result: $Utils.Optional<InvItemsCountAggregateOutputType> | number
          }
        }
      }
      invMarketGroups: {
        payload: Prisma.$invMarketGroupsPayload<ExtArgs>
        fields: Prisma.invMarketGroupsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.invMarketGroupsFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$invMarketGroupsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.invMarketGroupsFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$invMarketGroupsPayload>
          }
          findFirst: {
            args: Prisma.invMarketGroupsFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$invMarketGroupsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.invMarketGroupsFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$invMarketGroupsPayload>
          }
          findMany: {
            args: Prisma.invMarketGroupsFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$invMarketGroupsPayload>[]
          }
          create: {
            args: Prisma.invMarketGroupsCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$invMarketGroupsPayload>
          }
          createMany: {
            args: Prisma.invMarketGroupsCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.invMarketGroupsDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$invMarketGroupsPayload>
          }
          update: {
            args: Prisma.invMarketGroupsUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$invMarketGroupsPayload>
          }
          deleteMany: {
            args: Prisma.invMarketGroupsDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.invMarketGroupsUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.invMarketGroupsUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$invMarketGroupsPayload>
          }
          aggregate: {
            args: Prisma.InvMarketGroupsAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateInvMarketGroups>
          }
          groupBy: {
            args: Prisma.invMarketGroupsGroupByArgs<ExtArgs>,
            result: $Utils.Optional<InvMarketGroupsGroupByOutputType>[]
          }
          count: {
            args: Prisma.invMarketGroupsCountArgs<ExtArgs>,
            result: $Utils.Optional<InvMarketGroupsCountAggregateOutputType> | number
          }
        }
      }
      invMetaGroups: {
        payload: Prisma.$invMetaGroupsPayload<ExtArgs>
        fields: Prisma.invMetaGroupsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.invMetaGroupsFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$invMetaGroupsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.invMetaGroupsFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$invMetaGroupsPayload>
          }
          findFirst: {
            args: Prisma.invMetaGroupsFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$invMetaGroupsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.invMetaGroupsFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$invMetaGroupsPayload>
          }
          findMany: {
            args: Prisma.invMetaGroupsFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$invMetaGroupsPayload>[]
          }
          create: {
            args: Prisma.invMetaGroupsCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$invMetaGroupsPayload>
          }
          createMany: {
            args: Prisma.invMetaGroupsCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.invMetaGroupsDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$invMetaGroupsPayload>
          }
          update: {
            args: Prisma.invMetaGroupsUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$invMetaGroupsPayload>
          }
          deleteMany: {
            args: Prisma.invMetaGroupsDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.invMetaGroupsUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.invMetaGroupsUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$invMetaGroupsPayload>
          }
          aggregate: {
            args: Prisma.InvMetaGroupsAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateInvMetaGroups>
          }
          groupBy: {
            args: Prisma.invMetaGroupsGroupByArgs<ExtArgs>,
            result: $Utils.Optional<InvMetaGroupsGroupByOutputType>[]
          }
          count: {
            args: Prisma.invMetaGroupsCountArgs<ExtArgs>,
            result: $Utils.Optional<InvMetaGroupsCountAggregateOutputType> | number
          }
        }
      }
      invMetaTypes: {
        payload: Prisma.$invMetaTypesPayload<ExtArgs>
        fields: Prisma.invMetaTypesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.invMetaTypesFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$invMetaTypesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.invMetaTypesFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$invMetaTypesPayload>
          }
          findFirst: {
            args: Prisma.invMetaTypesFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$invMetaTypesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.invMetaTypesFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$invMetaTypesPayload>
          }
          findMany: {
            args: Prisma.invMetaTypesFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$invMetaTypesPayload>[]
          }
          create: {
            args: Prisma.invMetaTypesCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$invMetaTypesPayload>
          }
          createMany: {
            args: Prisma.invMetaTypesCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.invMetaTypesDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$invMetaTypesPayload>
          }
          update: {
            args: Prisma.invMetaTypesUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$invMetaTypesPayload>
          }
          deleteMany: {
            args: Prisma.invMetaTypesDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.invMetaTypesUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.invMetaTypesUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$invMetaTypesPayload>
          }
          aggregate: {
            args: Prisma.InvMetaTypesAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateInvMetaTypes>
          }
          groupBy: {
            args: Prisma.invMetaTypesGroupByArgs<ExtArgs>,
            result: $Utils.Optional<InvMetaTypesGroupByOutputType>[]
          }
          count: {
            args: Prisma.invMetaTypesCountArgs<ExtArgs>,
            result: $Utils.Optional<InvMetaTypesCountAggregateOutputType> | number
          }
        }
      }
      invNames: {
        payload: Prisma.$invNamesPayload<ExtArgs>
        fields: Prisma.invNamesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.invNamesFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$invNamesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.invNamesFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$invNamesPayload>
          }
          findFirst: {
            args: Prisma.invNamesFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$invNamesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.invNamesFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$invNamesPayload>
          }
          findMany: {
            args: Prisma.invNamesFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$invNamesPayload>[]
          }
          create: {
            args: Prisma.invNamesCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$invNamesPayload>
          }
          createMany: {
            args: Prisma.invNamesCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.invNamesDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$invNamesPayload>
          }
          update: {
            args: Prisma.invNamesUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$invNamesPayload>
          }
          deleteMany: {
            args: Prisma.invNamesDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.invNamesUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.invNamesUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$invNamesPayload>
          }
          aggregate: {
            args: Prisma.InvNamesAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateInvNames>
          }
          groupBy: {
            args: Prisma.invNamesGroupByArgs<ExtArgs>,
            result: $Utils.Optional<InvNamesGroupByOutputType>[]
          }
          count: {
            args: Prisma.invNamesCountArgs<ExtArgs>,
            result: $Utils.Optional<InvNamesCountAggregateOutputType> | number
          }
        }
      }
      invPositions: {
        payload: Prisma.$invPositionsPayload<ExtArgs>
        fields: Prisma.invPositionsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.invPositionsFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$invPositionsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.invPositionsFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$invPositionsPayload>
          }
          findFirst: {
            args: Prisma.invPositionsFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$invPositionsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.invPositionsFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$invPositionsPayload>
          }
          findMany: {
            args: Prisma.invPositionsFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$invPositionsPayload>[]
          }
          create: {
            args: Prisma.invPositionsCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$invPositionsPayload>
          }
          createMany: {
            args: Prisma.invPositionsCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.invPositionsDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$invPositionsPayload>
          }
          update: {
            args: Prisma.invPositionsUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$invPositionsPayload>
          }
          deleteMany: {
            args: Prisma.invPositionsDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.invPositionsUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.invPositionsUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$invPositionsPayload>
          }
          aggregate: {
            args: Prisma.InvPositionsAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateInvPositions>
          }
          groupBy: {
            args: Prisma.invPositionsGroupByArgs<ExtArgs>,
            result: $Utils.Optional<InvPositionsGroupByOutputType>[]
          }
          count: {
            args: Prisma.invPositionsCountArgs<ExtArgs>,
            result: $Utils.Optional<InvPositionsCountAggregateOutputType> | number
          }
        }
      }
      invTraits: {
        payload: Prisma.$invTraitsPayload<ExtArgs>
        fields: Prisma.invTraitsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.invTraitsFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$invTraitsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.invTraitsFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$invTraitsPayload>
          }
          findFirst: {
            args: Prisma.invTraitsFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$invTraitsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.invTraitsFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$invTraitsPayload>
          }
          findMany: {
            args: Prisma.invTraitsFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$invTraitsPayload>[]
          }
          create: {
            args: Prisma.invTraitsCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$invTraitsPayload>
          }
          createMany: {
            args: Prisma.invTraitsCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.invTraitsDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$invTraitsPayload>
          }
          update: {
            args: Prisma.invTraitsUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$invTraitsPayload>
          }
          deleteMany: {
            args: Prisma.invTraitsDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.invTraitsUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.invTraitsUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$invTraitsPayload>
          }
          aggregate: {
            args: Prisma.InvTraitsAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateInvTraits>
          }
          groupBy: {
            args: Prisma.invTraitsGroupByArgs<ExtArgs>,
            result: $Utils.Optional<InvTraitsGroupByOutputType>[]
          }
          count: {
            args: Prisma.invTraitsCountArgs<ExtArgs>,
            result: $Utils.Optional<InvTraitsCountAggregateOutputType> | number
          }
        }
      }
      invTypeMaterials: {
        payload: Prisma.$invTypeMaterialsPayload<ExtArgs>
        fields: Prisma.invTypeMaterialsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.invTypeMaterialsFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$invTypeMaterialsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.invTypeMaterialsFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$invTypeMaterialsPayload>
          }
          findFirst: {
            args: Prisma.invTypeMaterialsFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$invTypeMaterialsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.invTypeMaterialsFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$invTypeMaterialsPayload>
          }
          findMany: {
            args: Prisma.invTypeMaterialsFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$invTypeMaterialsPayload>[]
          }
          create: {
            args: Prisma.invTypeMaterialsCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$invTypeMaterialsPayload>
          }
          createMany: {
            args: Prisma.invTypeMaterialsCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.invTypeMaterialsDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$invTypeMaterialsPayload>
          }
          update: {
            args: Prisma.invTypeMaterialsUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$invTypeMaterialsPayload>
          }
          deleteMany: {
            args: Prisma.invTypeMaterialsDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.invTypeMaterialsUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.invTypeMaterialsUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$invTypeMaterialsPayload>
          }
          aggregate: {
            args: Prisma.InvTypeMaterialsAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateInvTypeMaterials>
          }
          groupBy: {
            args: Prisma.invTypeMaterialsGroupByArgs<ExtArgs>,
            result: $Utils.Optional<InvTypeMaterialsGroupByOutputType>[]
          }
          count: {
            args: Prisma.invTypeMaterialsCountArgs<ExtArgs>,
            result: $Utils.Optional<InvTypeMaterialsCountAggregateOutputType> | number
          }
        }
      }
      invTypeReactions: {
        payload: Prisma.$invTypeReactionsPayload<ExtArgs>
        fields: Prisma.invTypeReactionsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.invTypeReactionsFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$invTypeReactionsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.invTypeReactionsFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$invTypeReactionsPayload>
          }
          findFirst: {
            args: Prisma.invTypeReactionsFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$invTypeReactionsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.invTypeReactionsFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$invTypeReactionsPayload>
          }
          findMany: {
            args: Prisma.invTypeReactionsFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$invTypeReactionsPayload>[]
          }
          create: {
            args: Prisma.invTypeReactionsCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$invTypeReactionsPayload>
          }
          createMany: {
            args: Prisma.invTypeReactionsCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.invTypeReactionsDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$invTypeReactionsPayload>
          }
          update: {
            args: Prisma.invTypeReactionsUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$invTypeReactionsPayload>
          }
          deleteMany: {
            args: Prisma.invTypeReactionsDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.invTypeReactionsUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.invTypeReactionsUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$invTypeReactionsPayload>
          }
          aggregate: {
            args: Prisma.InvTypeReactionsAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateInvTypeReactions>
          }
          groupBy: {
            args: Prisma.invTypeReactionsGroupByArgs<ExtArgs>,
            result: $Utils.Optional<InvTypeReactionsGroupByOutputType>[]
          }
          count: {
            args: Prisma.invTypeReactionsCountArgs<ExtArgs>,
            result: $Utils.Optional<InvTypeReactionsCountAggregateOutputType> | number
          }
        }
      }
      invTypes: {
        payload: Prisma.$invTypesPayload<ExtArgs>
        fields: Prisma.invTypesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.invTypesFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$invTypesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.invTypesFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$invTypesPayload>
          }
          findFirst: {
            args: Prisma.invTypesFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$invTypesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.invTypesFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$invTypesPayload>
          }
          findMany: {
            args: Prisma.invTypesFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$invTypesPayload>[]
          }
          create: {
            args: Prisma.invTypesCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$invTypesPayload>
          }
          createMany: {
            args: Prisma.invTypesCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.invTypesDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$invTypesPayload>
          }
          update: {
            args: Prisma.invTypesUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$invTypesPayload>
          }
          deleteMany: {
            args: Prisma.invTypesDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.invTypesUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.invTypesUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$invTypesPayload>
          }
          aggregate: {
            args: Prisma.InvTypesAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateInvTypes>
          }
          groupBy: {
            args: Prisma.invTypesGroupByArgs<ExtArgs>,
            result: $Utils.Optional<InvTypesGroupByOutputType>[]
          }
          count: {
            args: Prisma.invTypesCountArgs<ExtArgs>,
            result: $Utils.Optional<InvTypesCountAggregateOutputType> | number
          }
        }
      }
      invUniqueNames: {
        payload: Prisma.$invUniqueNamesPayload<ExtArgs>
        fields: Prisma.invUniqueNamesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.invUniqueNamesFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$invUniqueNamesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.invUniqueNamesFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$invUniqueNamesPayload>
          }
          findFirst: {
            args: Prisma.invUniqueNamesFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$invUniqueNamesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.invUniqueNamesFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$invUniqueNamesPayload>
          }
          findMany: {
            args: Prisma.invUniqueNamesFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$invUniqueNamesPayload>[]
          }
          create: {
            args: Prisma.invUniqueNamesCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$invUniqueNamesPayload>
          }
          createMany: {
            args: Prisma.invUniqueNamesCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.invUniqueNamesDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$invUniqueNamesPayload>
          }
          update: {
            args: Prisma.invUniqueNamesUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$invUniqueNamesPayload>
          }
          deleteMany: {
            args: Prisma.invUniqueNamesDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.invUniqueNamesUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.invUniqueNamesUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$invUniqueNamesPayload>
          }
          aggregate: {
            args: Prisma.InvUniqueNamesAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateInvUniqueNames>
          }
          groupBy: {
            args: Prisma.invUniqueNamesGroupByArgs<ExtArgs>,
            result: $Utils.Optional<InvUniqueNamesGroupByOutputType>[]
          }
          count: {
            args: Prisma.invUniqueNamesCountArgs<ExtArgs>,
            result: $Utils.Optional<InvUniqueNamesCountAggregateOutputType> | number
          }
        }
      }
      invVolumes: {
        payload: Prisma.$invVolumesPayload<ExtArgs>
        fields: Prisma.invVolumesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.invVolumesFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$invVolumesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.invVolumesFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$invVolumesPayload>
          }
          findFirst: {
            args: Prisma.invVolumesFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$invVolumesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.invVolumesFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$invVolumesPayload>
          }
          findMany: {
            args: Prisma.invVolumesFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$invVolumesPayload>[]
          }
          create: {
            args: Prisma.invVolumesCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$invVolumesPayload>
          }
          createMany: {
            args: Prisma.invVolumesCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.invVolumesDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$invVolumesPayload>
          }
          update: {
            args: Prisma.invVolumesUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$invVolumesPayload>
          }
          deleteMany: {
            args: Prisma.invVolumesDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.invVolumesUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.invVolumesUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$invVolumesPayload>
          }
          aggregate: {
            args: Prisma.InvVolumesAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateInvVolumes>
          }
          groupBy: {
            args: Prisma.invVolumesGroupByArgs<ExtArgs>,
            result: $Utils.Optional<InvVolumesGroupByOutputType>[]
          }
          count: {
            args: Prisma.invVolumesCountArgs<ExtArgs>,
            result: $Utils.Optional<InvVolumesCountAggregateOutputType> | number
          }
        }
      }
      mapCelestialGraphics: {
        payload: Prisma.$mapCelestialGraphicsPayload<ExtArgs>
        fields: Prisma.mapCelestialGraphicsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.mapCelestialGraphicsFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$mapCelestialGraphicsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.mapCelestialGraphicsFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$mapCelestialGraphicsPayload>
          }
          findFirst: {
            args: Prisma.mapCelestialGraphicsFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$mapCelestialGraphicsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.mapCelestialGraphicsFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$mapCelestialGraphicsPayload>
          }
          findMany: {
            args: Prisma.mapCelestialGraphicsFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$mapCelestialGraphicsPayload>[]
          }
          create: {
            args: Prisma.mapCelestialGraphicsCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$mapCelestialGraphicsPayload>
          }
          createMany: {
            args: Prisma.mapCelestialGraphicsCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.mapCelestialGraphicsDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$mapCelestialGraphicsPayload>
          }
          update: {
            args: Prisma.mapCelestialGraphicsUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$mapCelestialGraphicsPayload>
          }
          deleteMany: {
            args: Prisma.mapCelestialGraphicsDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.mapCelestialGraphicsUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.mapCelestialGraphicsUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$mapCelestialGraphicsPayload>
          }
          aggregate: {
            args: Prisma.MapCelestialGraphicsAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateMapCelestialGraphics>
          }
          groupBy: {
            args: Prisma.mapCelestialGraphicsGroupByArgs<ExtArgs>,
            result: $Utils.Optional<MapCelestialGraphicsGroupByOutputType>[]
          }
          count: {
            args: Prisma.mapCelestialGraphicsCountArgs<ExtArgs>,
            result: $Utils.Optional<MapCelestialGraphicsCountAggregateOutputType> | number
          }
        }
      }
      mapCelestialStatistics: {
        payload: Prisma.$mapCelestialStatisticsPayload<ExtArgs>
        fields: Prisma.mapCelestialStatisticsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.mapCelestialStatisticsFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$mapCelestialStatisticsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.mapCelestialStatisticsFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$mapCelestialStatisticsPayload>
          }
          findFirst: {
            args: Prisma.mapCelestialStatisticsFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$mapCelestialStatisticsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.mapCelestialStatisticsFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$mapCelestialStatisticsPayload>
          }
          findMany: {
            args: Prisma.mapCelestialStatisticsFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$mapCelestialStatisticsPayload>[]
          }
          create: {
            args: Prisma.mapCelestialStatisticsCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$mapCelestialStatisticsPayload>
          }
          createMany: {
            args: Prisma.mapCelestialStatisticsCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.mapCelestialStatisticsDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$mapCelestialStatisticsPayload>
          }
          update: {
            args: Prisma.mapCelestialStatisticsUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$mapCelestialStatisticsPayload>
          }
          deleteMany: {
            args: Prisma.mapCelestialStatisticsDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.mapCelestialStatisticsUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.mapCelestialStatisticsUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$mapCelestialStatisticsPayload>
          }
          aggregate: {
            args: Prisma.MapCelestialStatisticsAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateMapCelestialStatistics>
          }
          groupBy: {
            args: Prisma.mapCelestialStatisticsGroupByArgs<ExtArgs>,
            result: $Utils.Optional<MapCelestialStatisticsGroupByOutputType>[]
          }
          count: {
            args: Prisma.mapCelestialStatisticsCountArgs<ExtArgs>,
            result: $Utils.Optional<MapCelestialStatisticsCountAggregateOutputType> | number
          }
        }
      }
      mapConstellationJumps: {
        payload: Prisma.$mapConstellationJumpsPayload<ExtArgs>
        fields: Prisma.mapConstellationJumpsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.mapConstellationJumpsFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$mapConstellationJumpsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.mapConstellationJumpsFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$mapConstellationJumpsPayload>
          }
          findFirst: {
            args: Prisma.mapConstellationJumpsFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$mapConstellationJumpsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.mapConstellationJumpsFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$mapConstellationJumpsPayload>
          }
          findMany: {
            args: Prisma.mapConstellationJumpsFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$mapConstellationJumpsPayload>[]
          }
          create: {
            args: Prisma.mapConstellationJumpsCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$mapConstellationJumpsPayload>
          }
          createMany: {
            args: Prisma.mapConstellationJumpsCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.mapConstellationJumpsDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$mapConstellationJumpsPayload>
          }
          update: {
            args: Prisma.mapConstellationJumpsUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$mapConstellationJumpsPayload>
          }
          deleteMany: {
            args: Prisma.mapConstellationJumpsDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.mapConstellationJumpsUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.mapConstellationJumpsUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$mapConstellationJumpsPayload>
          }
          aggregate: {
            args: Prisma.MapConstellationJumpsAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateMapConstellationJumps>
          }
          groupBy: {
            args: Prisma.mapConstellationJumpsGroupByArgs<ExtArgs>,
            result: $Utils.Optional<MapConstellationJumpsGroupByOutputType>[]
          }
          count: {
            args: Prisma.mapConstellationJumpsCountArgs<ExtArgs>,
            result: $Utils.Optional<MapConstellationJumpsCountAggregateOutputType> | number
          }
        }
      }
      mapConstellations: {
        payload: Prisma.$mapConstellationsPayload<ExtArgs>
        fields: Prisma.mapConstellationsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.mapConstellationsFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$mapConstellationsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.mapConstellationsFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$mapConstellationsPayload>
          }
          findFirst: {
            args: Prisma.mapConstellationsFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$mapConstellationsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.mapConstellationsFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$mapConstellationsPayload>
          }
          findMany: {
            args: Prisma.mapConstellationsFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$mapConstellationsPayload>[]
          }
          create: {
            args: Prisma.mapConstellationsCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$mapConstellationsPayload>
          }
          createMany: {
            args: Prisma.mapConstellationsCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.mapConstellationsDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$mapConstellationsPayload>
          }
          update: {
            args: Prisma.mapConstellationsUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$mapConstellationsPayload>
          }
          deleteMany: {
            args: Prisma.mapConstellationsDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.mapConstellationsUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.mapConstellationsUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$mapConstellationsPayload>
          }
          aggregate: {
            args: Prisma.MapConstellationsAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateMapConstellations>
          }
          groupBy: {
            args: Prisma.mapConstellationsGroupByArgs<ExtArgs>,
            result: $Utils.Optional<MapConstellationsGroupByOutputType>[]
          }
          count: {
            args: Prisma.mapConstellationsCountArgs<ExtArgs>,
            result: $Utils.Optional<MapConstellationsCountAggregateOutputType> | number
          }
        }
      }
      mapDenormalize: {
        payload: Prisma.$mapDenormalizePayload<ExtArgs>
        fields: Prisma.mapDenormalizeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.mapDenormalizeFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$mapDenormalizePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.mapDenormalizeFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$mapDenormalizePayload>
          }
          findFirst: {
            args: Prisma.mapDenormalizeFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$mapDenormalizePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.mapDenormalizeFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$mapDenormalizePayload>
          }
          findMany: {
            args: Prisma.mapDenormalizeFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$mapDenormalizePayload>[]
          }
          create: {
            args: Prisma.mapDenormalizeCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$mapDenormalizePayload>
          }
          createMany: {
            args: Prisma.mapDenormalizeCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.mapDenormalizeDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$mapDenormalizePayload>
          }
          update: {
            args: Prisma.mapDenormalizeUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$mapDenormalizePayload>
          }
          deleteMany: {
            args: Prisma.mapDenormalizeDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.mapDenormalizeUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.mapDenormalizeUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$mapDenormalizePayload>
          }
          aggregate: {
            args: Prisma.MapDenormalizeAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateMapDenormalize>
          }
          groupBy: {
            args: Prisma.mapDenormalizeGroupByArgs<ExtArgs>,
            result: $Utils.Optional<MapDenormalizeGroupByOutputType>[]
          }
          count: {
            args: Prisma.mapDenormalizeCountArgs<ExtArgs>,
            result: $Utils.Optional<MapDenormalizeCountAggregateOutputType> | number
          }
        }
      }
      mapJumps: {
        payload: Prisma.$mapJumpsPayload<ExtArgs>
        fields: Prisma.mapJumpsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.mapJumpsFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$mapJumpsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.mapJumpsFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$mapJumpsPayload>
          }
          findFirst: {
            args: Prisma.mapJumpsFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$mapJumpsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.mapJumpsFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$mapJumpsPayload>
          }
          findMany: {
            args: Prisma.mapJumpsFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$mapJumpsPayload>[]
          }
          create: {
            args: Prisma.mapJumpsCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$mapJumpsPayload>
          }
          createMany: {
            args: Prisma.mapJumpsCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.mapJumpsDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$mapJumpsPayload>
          }
          update: {
            args: Prisma.mapJumpsUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$mapJumpsPayload>
          }
          deleteMany: {
            args: Prisma.mapJumpsDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.mapJumpsUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.mapJumpsUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$mapJumpsPayload>
          }
          aggregate: {
            args: Prisma.MapJumpsAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateMapJumps>
          }
          groupBy: {
            args: Prisma.mapJumpsGroupByArgs<ExtArgs>,
            result: $Utils.Optional<MapJumpsGroupByOutputType>[]
          }
          count: {
            args: Prisma.mapJumpsCountArgs<ExtArgs>,
            result: $Utils.Optional<MapJumpsCountAggregateOutputType> | number
          }
        }
      }
      mapLandmarks: {
        payload: Prisma.$mapLandmarksPayload<ExtArgs>
        fields: Prisma.mapLandmarksFieldRefs
        operations: {
          findUnique: {
            args: Prisma.mapLandmarksFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$mapLandmarksPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.mapLandmarksFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$mapLandmarksPayload>
          }
          findFirst: {
            args: Prisma.mapLandmarksFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$mapLandmarksPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.mapLandmarksFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$mapLandmarksPayload>
          }
          findMany: {
            args: Prisma.mapLandmarksFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$mapLandmarksPayload>[]
          }
          create: {
            args: Prisma.mapLandmarksCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$mapLandmarksPayload>
          }
          createMany: {
            args: Prisma.mapLandmarksCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.mapLandmarksDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$mapLandmarksPayload>
          }
          update: {
            args: Prisma.mapLandmarksUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$mapLandmarksPayload>
          }
          deleteMany: {
            args: Prisma.mapLandmarksDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.mapLandmarksUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.mapLandmarksUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$mapLandmarksPayload>
          }
          aggregate: {
            args: Prisma.MapLandmarksAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateMapLandmarks>
          }
          groupBy: {
            args: Prisma.mapLandmarksGroupByArgs<ExtArgs>,
            result: $Utils.Optional<MapLandmarksGroupByOutputType>[]
          }
          count: {
            args: Prisma.mapLandmarksCountArgs<ExtArgs>,
            result: $Utils.Optional<MapLandmarksCountAggregateOutputType> | number
          }
        }
      }
      mapLocationScenes: {
        payload: Prisma.$mapLocationScenesPayload<ExtArgs>
        fields: Prisma.mapLocationScenesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.mapLocationScenesFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$mapLocationScenesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.mapLocationScenesFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$mapLocationScenesPayload>
          }
          findFirst: {
            args: Prisma.mapLocationScenesFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$mapLocationScenesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.mapLocationScenesFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$mapLocationScenesPayload>
          }
          findMany: {
            args: Prisma.mapLocationScenesFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$mapLocationScenesPayload>[]
          }
          create: {
            args: Prisma.mapLocationScenesCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$mapLocationScenesPayload>
          }
          createMany: {
            args: Prisma.mapLocationScenesCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.mapLocationScenesDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$mapLocationScenesPayload>
          }
          update: {
            args: Prisma.mapLocationScenesUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$mapLocationScenesPayload>
          }
          deleteMany: {
            args: Prisma.mapLocationScenesDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.mapLocationScenesUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.mapLocationScenesUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$mapLocationScenesPayload>
          }
          aggregate: {
            args: Prisma.MapLocationScenesAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateMapLocationScenes>
          }
          groupBy: {
            args: Prisma.mapLocationScenesGroupByArgs<ExtArgs>,
            result: $Utils.Optional<MapLocationScenesGroupByOutputType>[]
          }
          count: {
            args: Prisma.mapLocationScenesCountArgs<ExtArgs>,
            result: $Utils.Optional<MapLocationScenesCountAggregateOutputType> | number
          }
        }
      }
      mapLocationWormholeClasses: {
        payload: Prisma.$mapLocationWormholeClassesPayload<ExtArgs>
        fields: Prisma.mapLocationWormholeClassesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.mapLocationWormholeClassesFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$mapLocationWormholeClassesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.mapLocationWormholeClassesFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$mapLocationWormholeClassesPayload>
          }
          findFirst: {
            args: Prisma.mapLocationWormholeClassesFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$mapLocationWormholeClassesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.mapLocationWormholeClassesFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$mapLocationWormholeClassesPayload>
          }
          findMany: {
            args: Prisma.mapLocationWormholeClassesFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$mapLocationWormholeClassesPayload>[]
          }
          create: {
            args: Prisma.mapLocationWormholeClassesCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$mapLocationWormholeClassesPayload>
          }
          createMany: {
            args: Prisma.mapLocationWormholeClassesCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.mapLocationWormholeClassesDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$mapLocationWormholeClassesPayload>
          }
          update: {
            args: Prisma.mapLocationWormholeClassesUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$mapLocationWormholeClassesPayload>
          }
          deleteMany: {
            args: Prisma.mapLocationWormholeClassesDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.mapLocationWormholeClassesUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.mapLocationWormholeClassesUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$mapLocationWormholeClassesPayload>
          }
          aggregate: {
            args: Prisma.MapLocationWormholeClassesAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateMapLocationWormholeClasses>
          }
          groupBy: {
            args: Prisma.mapLocationWormholeClassesGroupByArgs<ExtArgs>,
            result: $Utils.Optional<MapLocationWormholeClassesGroupByOutputType>[]
          }
          count: {
            args: Prisma.mapLocationWormholeClassesCountArgs<ExtArgs>,
            result: $Utils.Optional<MapLocationWormholeClassesCountAggregateOutputType> | number
          }
        }
      }
      mapRegionJumps: {
        payload: Prisma.$mapRegionJumpsPayload<ExtArgs>
        fields: Prisma.mapRegionJumpsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.mapRegionJumpsFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$mapRegionJumpsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.mapRegionJumpsFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$mapRegionJumpsPayload>
          }
          findFirst: {
            args: Prisma.mapRegionJumpsFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$mapRegionJumpsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.mapRegionJumpsFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$mapRegionJumpsPayload>
          }
          findMany: {
            args: Prisma.mapRegionJumpsFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$mapRegionJumpsPayload>[]
          }
          create: {
            args: Prisma.mapRegionJumpsCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$mapRegionJumpsPayload>
          }
          createMany: {
            args: Prisma.mapRegionJumpsCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.mapRegionJumpsDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$mapRegionJumpsPayload>
          }
          update: {
            args: Prisma.mapRegionJumpsUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$mapRegionJumpsPayload>
          }
          deleteMany: {
            args: Prisma.mapRegionJumpsDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.mapRegionJumpsUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.mapRegionJumpsUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$mapRegionJumpsPayload>
          }
          aggregate: {
            args: Prisma.MapRegionJumpsAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateMapRegionJumps>
          }
          groupBy: {
            args: Prisma.mapRegionJumpsGroupByArgs<ExtArgs>,
            result: $Utils.Optional<MapRegionJumpsGroupByOutputType>[]
          }
          count: {
            args: Prisma.mapRegionJumpsCountArgs<ExtArgs>,
            result: $Utils.Optional<MapRegionJumpsCountAggregateOutputType> | number
          }
        }
      }
      mapRegions: {
        payload: Prisma.$mapRegionsPayload<ExtArgs>
        fields: Prisma.mapRegionsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.mapRegionsFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$mapRegionsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.mapRegionsFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$mapRegionsPayload>
          }
          findFirst: {
            args: Prisma.mapRegionsFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$mapRegionsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.mapRegionsFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$mapRegionsPayload>
          }
          findMany: {
            args: Prisma.mapRegionsFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$mapRegionsPayload>[]
          }
          create: {
            args: Prisma.mapRegionsCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$mapRegionsPayload>
          }
          createMany: {
            args: Prisma.mapRegionsCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.mapRegionsDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$mapRegionsPayload>
          }
          update: {
            args: Prisma.mapRegionsUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$mapRegionsPayload>
          }
          deleteMany: {
            args: Prisma.mapRegionsDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.mapRegionsUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.mapRegionsUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$mapRegionsPayload>
          }
          aggregate: {
            args: Prisma.MapRegionsAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateMapRegions>
          }
          groupBy: {
            args: Prisma.mapRegionsGroupByArgs<ExtArgs>,
            result: $Utils.Optional<MapRegionsGroupByOutputType>[]
          }
          count: {
            args: Prisma.mapRegionsCountArgs<ExtArgs>,
            result: $Utils.Optional<MapRegionsCountAggregateOutputType> | number
          }
        }
      }
      mapSolarSystemJumps: {
        payload: Prisma.$mapSolarSystemJumpsPayload<ExtArgs>
        fields: Prisma.mapSolarSystemJumpsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.mapSolarSystemJumpsFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$mapSolarSystemJumpsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.mapSolarSystemJumpsFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$mapSolarSystemJumpsPayload>
          }
          findFirst: {
            args: Prisma.mapSolarSystemJumpsFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$mapSolarSystemJumpsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.mapSolarSystemJumpsFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$mapSolarSystemJumpsPayload>
          }
          findMany: {
            args: Prisma.mapSolarSystemJumpsFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$mapSolarSystemJumpsPayload>[]
          }
          create: {
            args: Prisma.mapSolarSystemJumpsCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$mapSolarSystemJumpsPayload>
          }
          createMany: {
            args: Prisma.mapSolarSystemJumpsCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.mapSolarSystemJumpsDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$mapSolarSystemJumpsPayload>
          }
          update: {
            args: Prisma.mapSolarSystemJumpsUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$mapSolarSystemJumpsPayload>
          }
          deleteMany: {
            args: Prisma.mapSolarSystemJumpsDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.mapSolarSystemJumpsUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.mapSolarSystemJumpsUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$mapSolarSystemJumpsPayload>
          }
          aggregate: {
            args: Prisma.MapSolarSystemJumpsAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateMapSolarSystemJumps>
          }
          groupBy: {
            args: Prisma.mapSolarSystemJumpsGroupByArgs<ExtArgs>,
            result: $Utils.Optional<MapSolarSystemJumpsGroupByOutputType>[]
          }
          count: {
            args: Prisma.mapSolarSystemJumpsCountArgs<ExtArgs>,
            result: $Utils.Optional<MapSolarSystemJumpsCountAggregateOutputType> | number
          }
        }
      }
      mapSolarSystems: {
        payload: Prisma.$mapSolarSystemsPayload<ExtArgs>
        fields: Prisma.mapSolarSystemsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.mapSolarSystemsFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$mapSolarSystemsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.mapSolarSystemsFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$mapSolarSystemsPayload>
          }
          findFirst: {
            args: Prisma.mapSolarSystemsFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$mapSolarSystemsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.mapSolarSystemsFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$mapSolarSystemsPayload>
          }
          findMany: {
            args: Prisma.mapSolarSystemsFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$mapSolarSystemsPayload>[]
          }
          create: {
            args: Prisma.mapSolarSystemsCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$mapSolarSystemsPayload>
          }
          createMany: {
            args: Prisma.mapSolarSystemsCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.mapSolarSystemsDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$mapSolarSystemsPayload>
          }
          update: {
            args: Prisma.mapSolarSystemsUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$mapSolarSystemsPayload>
          }
          deleteMany: {
            args: Prisma.mapSolarSystemsDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.mapSolarSystemsUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.mapSolarSystemsUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$mapSolarSystemsPayload>
          }
          aggregate: {
            args: Prisma.MapSolarSystemsAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateMapSolarSystems>
          }
          groupBy: {
            args: Prisma.mapSolarSystemsGroupByArgs<ExtArgs>,
            result: $Utils.Optional<MapSolarSystemsGroupByOutputType>[]
          }
          count: {
            args: Prisma.mapSolarSystemsCountArgs<ExtArgs>,
            result: $Utils.Optional<MapSolarSystemsCountAggregateOutputType> | number
          }
        }
      }
      mapUniverse: {
        payload: Prisma.$mapUniversePayload<ExtArgs>
        fields: Prisma.mapUniverseFieldRefs
        operations: {
          findUnique: {
            args: Prisma.mapUniverseFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$mapUniversePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.mapUniverseFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$mapUniversePayload>
          }
          findFirst: {
            args: Prisma.mapUniverseFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$mapUniversePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.mapUniverseFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$mapUniversePayload>
          }
          findMany: {
            args: Prisma.mapUniverseFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$mapUniversePayload>[]
          }
          create: {
            args: Prisma.mapUniverseCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$mapUniversePayload>
          }
          createMany: {
            args: Prisma.mapUniverseCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.mapUniverseDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$mapUniversePayload>
          }
          update: {
            args: Prisma.mapUniverseUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$mapUniversePayload>
          }
          deleteMany: {
            args: Prisma.mapUniverseDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.mapUniverseUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.mapUniverseUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$mapUniversePayload>
          }
          aggregate: {
            args: Prisma.MapUniverseAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateMapUniverse>
          }
          groupBy: {
            args: Prisma.mapUniverseGroupByArgs<ExtArgs>,
            result: $Utils.Optional<MapUniverseGroupByOutputType>[]
          }
          count: {
            args: Prisma.mapUniverseCountArgs<ExtArgs>,
            result: $Utils.Optional<MapUniverseCountAggregateOutputType> | number
          }
        }
      }
      planetSchematics: {
        payload: Prisma.$planetSchematicsPayload<ExtArgs>
        fields: Prisma.planetSchematicsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.planetSchematicsFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$planetSchematicsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.planetSchematicsFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$planetSchematicsPayload>
          }
          findFirst: {
            args: Prisma.planetSchematicsFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$planetSchematicsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.planetSchematicsFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$planetSchematicsPayload>
          }
          findMany: {
            args: Prisma.planetSchematicsFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$planetSchematicsPayload>[]
          }
          create: {
            args: Prisma.planetSchematicsCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$planetSchematicsPayload>
          }
          createMany: {
            args: Prisma.planetSchematicsCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.planetSchematicsDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$planetSchematicsPayload>
          }
          update: {
            args: Prisma.planetSchematicsUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$planetSchematicsPayload>
          }
          deleteMany: {
            args: Prisma.planetSchematicsDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.planetSchematicsUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.planetSchematicsUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$planetSchematicsPayload>
          }
          aggregate: {
            args: Prisma.PlanetSchematicsAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregatePlanetSchematics>
          }
          groupBy: {
            args: Prisma.planetSchematicsGroupByArgs<ExtArgs>,
            result: $Utils.Optional<PlanetSchematicsGroupByOutputType>[]
          }
          count: {
            args: Prisma.planetSchematicsCountArgs<ExtArgs>,
            result: $Utils.Optional<PlanetSchematicsCountAggregateOutputType> | number
          }
        }
      }
      planetSchematicsPinMap: {
        payload: Prisma.$planetSchematicsPinMapPayload<ExtArgs>
        fields: Prisma.planetSchematicsPinMapFieldRefs
        operations: {
          findUnique: {
            args: Prisma.planetSchematicsPinMapFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$planetSchematicsPinMapPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.planetSchematicsPinMapFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$planetSchematicsPinMapPayload>
          }
          findFirst: {
            args: Prisma.planetSchematicsPinMapFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$planetSchematicsPinMapPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.planetSchematicsPinMapFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$planetSchematicsPinMapPayload>
          }
          findMany: {
            args: Prisma.planetSchematicsPinMapFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$planetSchematicsPinMapPayload>[]
          }
          create: {
            args: Prisma.planetSchematicsPinMapCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$planetSchematicsPinMapPayload>
          }
          createMany: {
            args: Prisma.planetSchematicsPinMapCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.planetSchematicsPinMapDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$planetSchematicsPinMapPayload>
          }
          update: {
            args: Prisma.planetSchematicsPinMapUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$planetSchematicsPinMapPayload>
          }
          deleteMany: {
            args: Prisma.planetSchematicsPinMapDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.planetSchematicsPinMapUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.planetSchematicsPinMapUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$planetSchematicsPinMapPayload>
          }
          aggregate: {
            args: Prisma.PlanetSchematicsPinMapAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregatePlanetSchematicsPinMap>
          }
          groupBy: {
            args: Prisma.planetSchematicsPinMapGroupByArgs<ExtArgs>,
            result: $Utils.Optional<PlanetSchematicsPinMapGroupByOutputType>[]
          }
          count: {
            args: Prisma.planetSchematicsPinMapCountArgs<ExtArgs>,
            result: $Utils.Optional<PlanetSchematicsPinMapCountAggregateOutputType> | number
          }
        }
      }
      planetSchematicsTypeMap: {
        payload: Prisma.$planetSchematicsTypeMapPayload<ExtArgs>
        fields: Prisma.planetSchematicsTypeMapFieldRefs
        operations: {
          findUnique: {
            args: Prisma.planetSchematicsTypeMapFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$planetSchematicsTypeMapPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.planetSchematicsTypeMapFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$planetSchematicsTypeMapPayload>
          }
          findFirst: {
            args: Prisma.planetSchematicsTypeMapFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$planetSchematicsTypeMapPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.planetSchematicsTypeMapFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$planetSchematicsTypeMapPayload>
          }
          findMany: {
            args: Prisma.planetSchematicsTypeMapFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$planetSchematicsTypeMapPayload>[]
          }
          create: {
            args: Prisma.planetSchematicsTypeMapCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$planetSchematicsTypeMapPayload>
          }
          createMany: {
            args: Prisma.planetSchematicsTypeMapCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.planetSchematicsTypeMapDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$planetSchematicsTypeMapPayload>
          }
          update: {
            args: Prisma.planetSchematicsTypeMapUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$planetSchematicsTypeMapPayload>
          }
          deleteMany: {
            args: Prisma.planetSchematicsTypeMapDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.planetSchematicsTypeMapUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.planetSchematicsTypeMapUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$planetSchematicsTypeMapPayload>
          }
          aggregate: {
            args: Prisma.PlanetSchematicsTypeMapAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregatePlanetSchematicsTypeMap>
          }
          groupBy: {
            args: Prisma.planetSchematicsTypeMapGroupByArgs<ExtArgs>,
            result: $Utils.Optional<PlanetSchematicsTypeMapGroupByOutputType>[]
          }
          count: {
            args: Prisma.planetSchematicsTypeMapCountArgs<ExtArgs>,
            result: $Utils.Optional<PlanetSchematicsTypeMapCountAggregateOutputType> | number
          }
        }
      }
      ramActivities: {
        payload: Prisma.$ramActivitiesPayload<ExtArgs>
        fields: Prisma.ramActivitiesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ramActivitiesFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ramActivitiesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ramActivitiesFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ramActivitiesPayload>
          }
          findFirst: {
            args: Prisma.ramActivitiesFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ramActivitiesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ramActivitiesFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ramActivitiesPayload>
          }
          findMany: {
            args: Prisma.ramActivitiesFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ramActivitiesPayload>[]
          }
          create: {
            args: Prisma.ramActivitiesCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ramActivitiesPayload>
          }
          createMany: {
            args: Prisma.ramActivitiesCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.ramActivitiesDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ramActivitiesPayload>
          }
          update: {
            args: Prisma.ramActivitiesUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ramActivitiesPayload>
          }
          deleteMany: {
            args: Prisma.ramActivitiesDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.ramActivitiesUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.ramActivitiesUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ramActivitiesPayload>
          }
          aggregate: {
            args: Prisma.RamActivitiesAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateRamActivities>
          }
          groupBy: {
            args: Prisma.ramActivitiesGroupByArgs<ExtArgs>,
            result: $Utils.Optional<RamActivitiesGroupByOutputType>[]
          }
          count: {
            args: Prisma.ramActivitiesCountArgs<ExtArgs>,
            result: $Utils.Optional<RamActivitiesCountAggregateOutputType> | number
          }
        }
      }
      ramAssemblyLineStations: {
        payload: Prisma.$ramAssemblyLineStationsPayload<ExtArgs>
        fields: Prisma.ramAssemblyLineStationsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ramAssemblyLineStationsFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ramAssemblyLineStationsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ramAssemblyLineStationsFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ramAssemblyLineStationsPayload>
          }
          findFirst: {
            args: Prisma.ramAssemblyLineStationsFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ramAssemblyLineStationsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ramAssemblyLineStationsFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ramAssemblyLineStationsPayload>
          }
          findMany: {
            args: Prisma.ramAssemblyLineStationsFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ramAssemblyLineStationsPayload>[]
          }
          create: {
            args: Prisma.ramAssemblyLineStationsCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ramAssemblyLineStationsPayload>
          }
          createMany: {
            args: Prisma.ramAssemblyLineStationsCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.ramAssemblyLineStationsDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ramAssemblyLineStationsPayload>
          }
          update: {
            args: Prisma.ramAssemblyLineStationsUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ramAssemblyLineStationsPayload>
          }
          deleteMany: {
            args: Prisma.ramAssemblyLineStationsDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.ramAssemblyLineStationsUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.ramAssemblyLineStationsUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ramAssemblyLineStationsPayload>
          }
          aggregate: {
            args: Prisma.RamAssemblyLineStationsAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateRamAssemblyLineStations>
          }
          groupBy: {
            args: Prisma.ramAssemblyLineStationsGroupByArgs<ExtArgs>,
            result: $Utils.Optional<RamAssemblyLineStationsGroupByOutputType>[]
          }
          count: {
            args: Prisma.ramAssemblyLineStationsCountArgs<ExtArgs>,
            result: $Utils.Optional<RamAssemblyLineStationsCountAggregateOutputType> | number
          }
        }
      }
      ramAssemblyLineTypeDetailPerCategory: {
        payload: Prisma.$ramAssemblyLineTypeDetailPerCategoryPayload<ExtArgs>
        fields: Prisma.ramAssemblyLineTypeDetailPerCategoryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ramAssemblyLineTypeDetailPerCategoryFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ramAssemblyLineTypeDetailPerCategoryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ramAssemblyLineTypeDetailPerCategoryFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ramAssemblyLineTypeDetailPerCategoryPayload>
          }
          findFirst: {
            args: Prisma.ramAssemblyLineTypeDetailPerCategoryFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ramAssemblyLineTypeDetailPerCategoryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ramAssemblyLineTypeDetailPerCategoryFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ramAssemblyLineTypeDetailPerCategoryPayload>
          }
          findMany: {
            args: Prisma.ramAssemblyLineTypeDetailPerCategoryFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ramAssemblyLineTypeDetailPerCategoryPayload>[]
          }
          create: {
            args: Prisma.ramAssemblyLineTypeDetailPerCategoryCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ramAssemblyLineTypeDetailPerCategoryPayload>
          }
          createMany: {
            args: Prisma.ramAssemblyLineTypeDetailPerCategoryCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.ramAssemblyLineTypeDetailPerCategoryDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ramAssemblyLineTypeDetailPerCategoryPayload>
          }
          update: {
            args: Prisma.ramAssemblyLineTypeDetailPerCategoryUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ramAssemblyLineTypeDetailPerCategoryPayload>
          }
          deleteMany: {
            args: Prisma.ramAssemblyLineTypeDetailPerCategoryDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.ramAssemblyLineTypeDetailPerCategoryUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.ramAssemblyLineTypeDetailPerCategoryUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ramAssemblyLineTypeDetailPerCategoryPayload>
          }
          aggregate: {
            args: Prisma.RamAssemblyLineTypeDetailPerCategoryAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateRamAssemblyLineTypeDetailPerCategory>
          }
          groupBy: {
            args: Prisma.ramAssemblyLineTypeDetailPerCategoryGroupByArgs<ExtArgs>,
            result: $Utils.Optional<RamAssemblyLineTypeDetailPerCategoryGroupByOutputType>[]
          }
          count: {
            args: Prisma.ramAssemblyLineTypeDetailPerCategoryCountArgs<ExtArgs>,
            result: $Utils.Optional<RamAssemblyLineTypeDetailPerCategoryCountAggregateOutputType> | number
          }
        }
      }
      ramAssemblyLineTypeDetailPerGroup: {
        payload: Prisma.$ramAssemblyLineTypeDetailPerGroupPayload<ExtArgs>
        fields: Prisma.ramAssemblyLineTypeDetailPerGroupFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ramAssemblyLineTypeDetailPerGroupFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ramAssemblyLineTypeDetailPerGroupPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ramAssemblyLineTypeDetailPerGroupFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ramAssemblyLineTypeDetailPerGroupPayload>
          }
          findFirst: {
            args: Prisma.ramAssemblyLineTypeDetailPerGroupFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ramAssemblyLineTypeDetailPerGroupPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ramAssemblyLineTypeDetailPerGroupFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ramAssemblyLineTypeDetailPerGroupPayload>
          }
          findMany: {
            args: Prisma.ramAssemblyLineTypeDetailPerGroupFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ramAssemblyLineTypeDetailPerGroupPayload>[]
          }
          create: {
            args: Prisma.ramAssemblyLineTypeDetailPerGroupCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ramAssemblyLineTypeDetailPerGroupPayload>
          }
          createMany: {
            args: Prisma.ramAssemblyLineTypeDetailPerGroupCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.ramAssemblyLineTypeDetailPerGroupDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ramAssemblyLineTypeDetailPerGroupPayload>
          }
          update: {
            args: Prisma.ramAssemblyLineTypeDetailPerGroupUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ramAssemblyLineTypeDetailPerGroupPayload>
          }
          deleteMany: {
            args: Prisma.ramAssemblyLineTypeDetailPerGroupDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.ramAssemblyLineTypeDetailPerGroupUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.ramAssemblyLineTypeDetailPerGroupUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ramAssemblyLineTypeDetailPerGroupPayload>
          }
          aggregate: {
            args: Prisma.RamAssemblyLineTypeDetailPerGroupAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateRamAssemblyLineTypeDetailPerGroup>
          }
          groupBy: {
            args: Prisma.ramAssemblyLineTypeDetailPerGroupGroupByArgs<ExtArgs>,
            result: $Utils.Optional<RamAssemblyLineTypeDetailPerGroupGroupByOutputType>[]
          }
          count: {
            args: Prisma.ramAssemblyLineTypeDetailPerGroupCountArgs<ExtArgs>,
            result: $Utils.Optional<RamAssemblyLineTypeDetailPerGroupCountAggregateOutputType> | number
          }
        }
      }
      ramAssemblyLineTypes: {
        payload: Prisma.$ramAssemblyLineTypesPayload<ExtArgs>
        fields: Prisma.ramAssemblyLineTypesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ramAssemblyLineTypesFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ramAssemblyLineTypesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ramAssemblyLineTypesFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ramAssemblyLineTypesPayload>
          }
          findFirst: {
            args: Prisma.ramAssemblyLineTypesFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ramAssemblyLineTypesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ramAssemblyLineTypesFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ramAssemblyLineTypesPayload>
          }
          findMany: {
            args: Prisma.ramAssemblyLineTypesFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ramAssemblyLineTypesPayload>[]
          }
          create: {
            args: Prisma.ramAssemblyLineTypesCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ramAssemblyLineTypesPayload>
          }
          createMany: {
            args: Prisma.ramAssemblyLineTypesCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.ramAssemblyLineTypesDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ramAssemblyLineTypesPayload>
          }
          update: {
            args: Prisma.ramAssemblyLineTypesUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ramAssemblyLineTypesPayload>
          }
          deleteMany: {
            args: Prisma.ramAssemblyLineTypesDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.ramAssemblyLineTypesUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.ramAssemblyLineTypesUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ramAssemblyLineTypesPayload>
          }
          aggregate: {
            args: Prisma.RamAssemblyLineTypesAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateRamAssemblyLineTypes>
          }
          groupBy: {
            args: Prisma.ramAssemblyLineTypesGroupByArgs<ExtArgs>,
            result: $Utils.Optional<RamAssemblyLineTypesGroupByOutputType>[]
          }
          count: {
            args: Prisma.ramAssemblyLineTypesCountArgs<ExtArgs>,
            result: $Utils.Optional<RamAssemblyLineTypesCountAggregateOutputType> | number
          }
        }
      }
      ramInstallationTypeContents: {
        payload: Prisma.$ramInstallationTypeContentsPayload<ExtArgs>
        fields: Prisma.ramInstallationTypeContentsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ramInstallationTypeContentsFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ramInstallationTypeContentsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ramInstallationTypeContentsFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ramInstallationTypeContentsPayload>
          }
          findFirst: {
            args: Prisma.ramInstallationTypeContentsFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ramInstallationTypeContentsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ramInstallationTypeContentsFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ramInstallationTypeContentsPayload>
          }
          findMany: {
            args: Prisma.ramInstallationTypeContentsFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ramInstallationTypeContentsPayload>[]
          }
          create: {
            args: Prisma.ramInstallationTypeContentsCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ramInstallationTypeContentsPayload>
          }
          createMany: {
            args: Prisma.ramInstallationTypeContentsCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.ramInstallationTypeContentsDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ramInstallationTypeContentsPayload>
          }
          update: {
            args: Prisma.ramInstallationTypeContentsUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ramInstallationTypeContentsPayload>
          }
          deleteMany: {
            args: Prisma.ramInstallationTypeContentsDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.ramInstallationTypeContentsUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.ramInstallationTypeContentsUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ramInstallationTypeContentsPayload>
          }
          aggregate: {
            args: Prisma.RamInstallationTypeContentsAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateRamInstallationTypeContents>
          }
          groupBy: {
            args: Prisma.ramInstallationTypeContentsGroupByArgs<ExtArgs>,
            result: $Utils.Optional<RamInstallationTypeContentsGroupByOutputType>[]
          }
          count: {
            args: Prisma.ramInstallationTypeContentsCountArgs<ExtArgs>,
            result: $Utils.Optional<RamInstallationTypeContentsCountAggregateOutputType> | number
          }
        }
      }
      skinLicense: {
        payload: Prisma.$skinLicensePayload<ExtArgs>
        fields: Prisma.skinLicenseFieldRefs
        operations: {
          findUnique: {
            args: Prisma.skinLicenseFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$skinLicensePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.skinLicenseFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$skinLicensePayload>
          }
          findFirst: {
            args: Prisma.skinLicenseFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$skinLicensePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.skinLicenseFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$skinLicensePayload>
          }
          findMany: {
            args: Prisma.skinLicenseFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$skinLicensePayload>[]
          }
          create: {
            args: Prisma.skinLicenseCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$skinLicensePayload>
          }
          createMany: {
            args: Prisma.skinLicenseCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.skinLicenseDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$skinLicensePayload>
          }
          update: {
            args: Prisma.skinLicenseUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$skinLicensePayload>
          }
          deleteMany: {
            args: Prisma.skinLicenseDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.skinLicenseUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.skinLicenseUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$skinLicensePayload>
          }
          aggregate: {
            args: Prisma.SkinLicenseAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateSkinLicense>
          }
          groupBy: {
            args: Prisma.skinLicenseGroupByArgs<ExtArgs>,
            result: $Utils.Optional<SkinLicenseGroupByOutputType>[]
          }
          count: {
            args: Prisma.skinLicenseCountArgs<ExtArgs>,
            result: $Utils.Optional<SkinLicenseCountAggregateOutputType> | number
          }
        }
      }
      skinMaterials: {
        payload: Prisma.$skinMaterialsPayload<ExtArgs>
        fields: Prisma.skinMaterialsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.skinMaterialsFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$skinMaterialsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.skinMaterialsFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$skinMaterialsPayload>
          }
          findFirst: {
            args: Prisma.skinMaterialsFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$skinMaterialsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.skinMaterialsFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$skinMaterialsPayload>
          }
          findMany: {
            args: Prisma.skinMaterialsFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$skinMaterialsPayload>[]
          }
          create: {
            args: Prisma.skinMaterialsCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$skinMaterialsPayload>
          }
          createMany: {
            args: Prisma.skinMaterialsCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.skinMaterialsDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$skinMaterialsPayload>
          }
          update: {
            args: Prisma.skinMaterialsUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$skinMaterialsPayload>
          }
          deleteMany: {
            args: Prisma.skinMaterialsDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.skinMaterialsUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.skinMaterialsUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$skinMaterialsPayload>
          }
          aggregate: {
            args: Prisma.SkinMaterialsAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateSkinMaterials>
          }
          groupBy: {
            args: Prisma.skinMaterialsGroupByArgs<ExtArgs>,
            result: $Utils.Optional<SkinMaterialsGroupByOutputType>[]
          }
          count: {
            args: Prisma.skinMaterialsCountArgs<ExtArgs>,
            result: $Utils.Optional<SkinMaterialsCountAggregateOutputType> | number
          }
        }
      }
      skins: {
        payload: Prisma.$skinsPayload<ExtArgs>
        fields: Prisma.skinsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.skinsFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$skinsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.skinsFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$skinsPayload>
          }
          findFirst: {
            args: Prisma.skinsFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$skinsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.skinsFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$skinsPayload>
          }
          findMany: {
            args: Prisma.skinsFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$skinsPayload>[]
          }
          create: {
            args: Prisma.skinsCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$skinsPayload>
          }
          createMany: {
            args: Prisma.skinsCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.skinsDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$skinsPayload>
          }
          update: {
            args: Prisma.skinsUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$skinsPayload>
          }
          deleteMany: {
            args: Prisma.skinsDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.skinsUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.skinsUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$skinsPayload>
          }
          aggregate: {
            args: Prisma.SkinsAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateSkins>
          }
          groupBy: {
            args: Prisma.skinsGroupByArgs<ExtArgs>,
            result: $Utils.Optional<SkinsGroupByOutputType>[]
          }
          count: {
            args: Prisma.skinsCountArgs<ExtArgs>,
            result: $Utils.Optional<SkinsCountAggregateOutputType> | number
          }
        }
      }
      staOperationServices: {
        payload: Prisma.$staOperationServicesPayload<ExtArgs>
        fields: Prisma.staOperationServicesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.staOperationServicesFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$staOperationServicesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.staOperationServicesFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$staOperationServicesPayload>
          }
          findFirst: {
            args: Prisma.staOperationServicesFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$staOperationServicesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.staOperationServicesFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$staOperationServicesPayload>
          }
          findMany: {
            args: Prisma.staOperationServicesFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$staOperationServicesPayload>[]
          }
          create: {
            args: Prisma.staOperationServicesCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$staOperationServicesPayload>
          }
          createMany: {
            args: Prisma.staOperationServicesCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.staOperationServicesDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$staOperationServicesPayload>
          }
          update: {
            args: Prisma.staOperationServicesUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$staOperationServicesPayload>
          }
          deleteMany: {
            args: Prisma.staOperationServicesDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.staOperationServicesUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.staOperationServicesUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$staOperationServicesPayload>
          }
          aggregate: {
            args: Prisma.StaOperationServicesAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateStaOperationServices>
          }
          groupBy: {
            args: Prisma.staOperationServicesGroupByArgs<ExtArgs>,
            result: $Utils.Optional<StaOperationServicesGroupByOutputType>[]
          }
          count: {
            args: Prisma.staOperationServicesCountArgs<ExtArgs>,
            result: $Utils.Optional<StaOperationServicesCountAggregateOutputType> | number
          }
        }
      }
      staOperations: {
        payload: Prisma.$staOperationsPayload<ExtArgs>
        fields: Prisma.staOperationsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.staOperationsFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$staOperationsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.staOperationsFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$staOperationsPayload>
          }
          findFirst: {
            args: Prisma.staOperationsFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$staOperationsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.staOperationsFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$staOperationsPayload>
          }
          findMany: {
            args: Prisma.staOperationsFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$staOperationsPayload>[]
          }
          create: {
            args: Prisma.staOperationsCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$staOperationsPayload>
          }
          createMany: {
            args: Prisma.staOperationsCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.staOperationsDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$staOperationsPayload>
          }
          update: {
            args: Prisma.staOperationsUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$staOperationsPayload>
          }
          deleteMany: {
            args: Prisma.staOperationsDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.staOperationsUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.staOperationsUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$staOperationsPayload>
          }
          aggregate: {
            args: Prisma.StaOperationsAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateStaOperations>
          }
          groupBy: {
            args: Prisma.staOperationsGroupByArgs<ExtArgs>,
            result: $Utils.Optional<StaOperationsGroupByOutputType>[]
          }
          count: {
            args: Prisma.staOperationsCountArgs<ExtArgs>,
            result: $Utils.Optional<StaOperationsCountAggregateOutputType> | number
          }
        }
      }
      staServices: {
        payload: Prisma.$staServicesPayload<ExtArgs>
        fields: Prisma.staServicesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.staServicesFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$staServicesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.staServicesFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$staServicesPayload>
          }
          findFirst: {
            args: Prisma.staServicesFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$staServicesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.staServicesFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$staServicesPayload>
          }
          findMany: {
            args: Prisma.staServicesFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$staServicesPayload>[]
          }
          create: {
            args: Prisma.staServicesCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$staServicesPayload>
          }
          createMany: {
            args: Prisma.staServicesCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.staServicesDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$staServicesPayload>
          }
          update: {
            args: Prisma.staServicesUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$staServicesPayload>
          }
          deleteMany: {
            args: Prisma.staServicesDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.staServicesUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.staServicesUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$staServicesPayload>
          }
          aggregate: {
            args: Prisma.StaServicesAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateStaServices>
          }
          groupBy: {
            args: Prisma.staServicesGroupByArgs<ExtArgs>,
            result: $Utils.Optional<StaServicesGroupByOutputType>[]
          }
          count: {
            args: Prisma.staServicesCountArgs<ExtArgs>,
            result: $Utils.Optional<StaServicesCountAggregateOutputType> | number
          }
        }
      }
      staStationTypes: {
        payload: Prisma.$staStationTypesPayload<ExtArgs>
        fields: Prisma.staStationTypesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.staStationTypesFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$staStationTypesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.staStationTypesFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$staStationTypesPayload>
          }
          findFirst: {
            args: Prisma.staStationTypesFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$staStationTypesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.staStationTypesFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$staStationTypesPayload>
          }
          findMany: {
            args: Prisma.staStationTypesFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$staStationTypesPayload>[]
          }
          create: {
            args: Prisma.staStationTypesCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$staStationTypesPayload>
          }
          createMany: {
            args: Prisma.staStationTypesCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.staStationTypesDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$staStationTypesPayload>
          }
          update: {
            args: Prisma.staStationTypesUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$staStationTypesPayload>
          }
          deleteMany: {
            args: Prisma.staStationTypesDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.staStationTypesUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.staStationTypesUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$staStationTypesPayload>
          }
          aggregate: {
            args: Prisma.StaStationTypesAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateStaStationTypes>
          }
          groupBy: {
            args: Prisma.staStationTypesGroupByArgs<ExtArgs>,
            result: $Utils.Optional<StaStationTypesGroupByOutputType>[]
          }
          count: {
            args: Prisma.staStationTypesCountArgs<ExtArgs>,
            result: $Utils.Optional<StaStationTypesCountAggregateOutputType> | number
          }
        }
      }
      staStations: {
        payload: Prisma.$staStationsPayload<ExtArgs>
        fields: Prisma.staStationsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.staStationsFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$staStationsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.staStationsFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$staStationsPayload>
          }
          findFirst: {
            args: Prisma.staStationsFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$staStationsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.staStationsFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$staStationsPayload>
          }
          findMany: {
            args: Prisma.staStationsFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$staStationsPayload>[]
          }
          create: {
            args: Prisma.staStationsCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$staStationsPayload>
          }
          createMany: {
            args: Prisma.staStationsCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.staStationsDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$staStationsPayload>
          }
          update: {
            args: Prisma.staStationsUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$staStationsPayload>
          }
          deleteMany: {
            args: Prisma.staStationsDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.staStationsUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.staStationsUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$staStationsPayload>
          }
          aggregate: {
            args: Prisma.StaStationsAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateStaStations>
          }
          groupBy: {
            args: Prisma.staStationsGroupByArgs<ExtArgs>,
            result: $Utils.Optional<StaStationsGroupByOutputType>[]
          }
          count: {
            args: Prisma.staStationsCountArgs<ExtArgs>,
            result: $Utils.Optional<StaStationsCountAggregateOutputType> | number
          }
        }
      }
      translationTables: {
        payload: Prisma.$translationTablesPayload<ExtArgs>
        fields: Prisma.translationTablesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.translationTablesFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$translationTablesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.translationTablesFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$translationTablesPayload>
          }
          findFirst: {
            args: Prisma.translationTablesFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$translationTablesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.translationTablesFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$translationTablesPayload>
          }
          findMany: {
            args: Prisma.translationTablesFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$translationTablesPayload>[]
          }
          create: {
            args: Prisma.translationTablesCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$translationTablesPayload>
          }
          createMany: {
            args: Prisma.translationTablesCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.translationTablesDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$translationTablesPayload>
          }
          update: {
            args: Prisma.translationTablesUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$translationTablesPayload>
          }
          deleteMany: {
            args: Prisma.translationTablesDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.translationTablesUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.translationTablesUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$translationTablesPayload>
          }
          aggregate: {
            args: Prisma.TranslationTablesAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateTranslationTables>
          }
          groupBy: {
            args: Prisma.translationTablesGroupByArgs<ExtArgs>,
            result: $Utils.Optional<TranslationTablesGroupByOutputType>[]
          }
          count: {
            args: Prisma.translationTablesCountArgs<ExtArgs>,
            result: $Utils.Optional<TranslationTablesCountAggregateOutputType> | number
          }
        }
      }
      trnTranslationColumns: {
        payload: Prisma.$trnTranslationColumnsPayload<ExtArgs>
        fields: Prisma.trnTranslationColumnsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.trnTranslationColumnsFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$trnTranslationColumnsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.trnTranslationColumnsFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$trnTranslationColumnsPayload>
          }
          findFirst: {
            args: Prisma.trnTranslationColumnsFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$trnTranslationColumnsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.trnTranslationColumnsFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$trnTranslationColumnsPayload>
          }
          findMany: {
            args: Prisma.trnTranslationColumnsFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$trnTranslationColumnsPayload>[]
          }
          create: {
            args: Prisma.trnTranslationColumnsCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$trnTranslationColumnsPayload>
          }
          createMany: {
            args: Prisma.trnTranslationColumnsCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.trnTranslationColumnsDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$trnTranslationColumnsPayload>
          }
          update: {
            args: Prisma.trnTranslationColumnsUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$trnTranslationColumnsPayload>
          }
          deleteMany: {
            args: Prisma.trnTranslationColumnsDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.trnTranslationColumnsUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.trnTranslationColumnsUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$trnTranslationColumnsPayload>
          }
          aggregate: {
            args: Prisma.TrnTranslationColumnsAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateTrnTranslationColumns>
          }
          groupBy: {
            args: Prisma.trnTranslationColumnsGroupByArgs<ExtArgs>,
            result: $Utils.Optional<TrnTranslationColumnsGroupByOutputType>[]
          }
          count: {
            args: Prisma.trnTranslationColumnsCountArgs<ExtArgs>,
            result: $Utils.Optional<TrnTranslationColumnsCountAggregateOutputType> | number
          }
        }
      }
      trnTranslationLanguages: {
        payload: Prisma.$trnTranslationLanguagesPayload<ExtArgs>
        fields: Prisma.trnTranslationLanguagesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.trnTranslationLanguagesFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$trnTranslationLanguagesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.trnTranslationLanguagesFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$trnTranslationLanguagesPayload>
          }
          findFirst: {
            args: Prisma.trnTranslationLanguagesFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$trnTranslationLanguagesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.trnTranslationLanguagesFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$trnTranslationLanguagesPayload>
          }
          findMany: {
            args: Prisma.trnTranslationLanguagesFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$trnTranslationLanguagesPayload>[]
          }
          create: {
            args: Prisma.trnTranslationLanguagesCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$trnTranslationLanguagesPayload>
          }
          createMany: {
            args: Prisma.trnTranslationLanguagesCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.trnTranslationLanguagesDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$trnTranslationLanguagesPayload>
          }
          update: {
            args: Prisma.trnTranslationLanguagesUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$trnTranslationLanguagesPayload>
          }
          deleteMany: {
            args: Prisma.trnTranslationLanguagesDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.trnTranslationLanguagesUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.trnTranslationLanguagesUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$trnTranslationLanguagesPayload>
          }
          aggregate: {
            args: Prisma.TrnTranslationLanguagesAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateTrnTranslationLanguages>
          }
          groupBy: {
            args: Prisma.trnTranslationLanguagesGroupByArgs<ExtArgs>,
            result: $Utils.Optional<TrnTranslationLanguagesGroupByOutputType>[]
          }
          count: {
            args: Prisma.trnTranslationLanguagesCountArgs<ExtArgs>,
            result: $Utils.Optional<TrnTranslationLanguagesCountAggregateOutputType> | number
          }
        }
      }
      trnTranslations: {
        payload: Prisma.$trnTranslationsPayload<ExtArgs>
        fields: Prisma.trnTranslationsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.trnTranslationsFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$trnTranslationsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.trnTranslationsFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$trnTranslationsPayload>
          }
          findFirst: {
            args: Prisma.trnTranslationsFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$trnTranslationsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.trnTranslationsFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$trnTranslationsPayload>
          }
          findMany: {
            args: Prisma.trnTranslationsFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$trnTranslationsPayload>[]
          }
          create: {
            args: Prisma.trnTranslationsCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$trnTranslationsPayload>
          }
          createMany: {
            args: Prisma.trnTranslationsCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.trnTranslationsDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$trnTranslationsPayload>
          }
          update: {
            args: Prisma.trnTranslationsUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$trnTranslationsPayload>
          }
          deleteMany: {
            args: Prisma.trnTranslationsDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.trnTranslationsUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.trnTranslationsUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$trnTranslationsPayload>
          }
          aggregate: {
            args: Prisma.TrnTranslationsAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateTrnTranslations>
          }
          groupBy: {
            args: Prisma.trnTranslationsGroupByArgs<ExtArgs>,
            result: $Utils.Optional<TrnTranslationsGroupByOutputType>[]
          }
          count: {
            args: Prisma.trnTranslationsCountArgs<ExtArgs>,
            result: $Utils.Optional<TrnTranslationsCountAggregateOutputType> | number
          }
        }
      }
      warCombatZoneSystems: {
        payload: Prisma.$warCombatZoneSystemsPayload<ExtArgs>
        fields: Prisma.warCombatZoneSystemsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.warCombatZoneSystemsFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$warCombatZoneSystemsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.warCombatZoneSystemsFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$warCombatZoneSystemsPayload>
          }
          findFirst: {
            args: Prisma.warCombatZoneSystemsFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$warCombatZoneSystemsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.warCombatZoneSystemsFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$warCombatZoneSystemsPayload>
          }
          findMany: {
            args: Prisma.warCombatZoneSystemsFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$warCombatZoneSystemsPayload>[]
          }
          create: {
            args: Prisma.warCombatZoneSystemsCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$warCombatZoneSystemsPayload>
          }
          createMany: {
            args: Prisma.warCombatZoneSystemsCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.warCombatZoneSystemsDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$warCombatZoneSystemsPayload>
          }
          update: {
            args: Prisma.warCombatZoneSystemsUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$warCombatZoneSystemsPayload>
          }
          deleteMany: {
            args: Prisma.warCombatZoneSystemsDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.warCombatZoneSystemsUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.warCombatZoneSystemsUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$warCombatZoneSystemsPayload>
          }
          aggregate: {
            args: Prisma.WarCombatZoneSystemsAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateWarCombatZoneSystems>
          }
          groupBy: {
            args: Prisma.warCombatZoneSystemsGroupByArgs<ExtArgs>,
            result: $Utils.Optional<WarCombatZoneSystemsGroupByOutputType>[]
          }
          count: {
            args: Prisma.warCombatZoneSystemsCountArgs<ExtArgs>,
            result: $Utils.Optional<WarCombatZoneSystemsCountAggregateOutputType> | number
          }
        }
      }
      warCombatZones: {
        payload: Prisma.$warCombatZonesPayload<ExtArgs>
        fields: Prisma.warCombatZonesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.warCombatZonesFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$warCombatZonesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.warCombatZonesFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$warCombatZonesPayload>
          }
          findFirst: {
            args: Prisma.warCombatZonesFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$warCombatZonesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.warCombatZonesFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$warCombatZonesPayload>
          }
          findMany: {
            args: Prisma.warCombatZonesFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$warCombatZonesPayload>[]
          }
          create: {
            args: Prisma.warCombatZonesCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$warCombatZonesPayload>
          }
          createMany: {
            args: Prisma.warCombatZonesCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.warCombatZonesDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$warCombatZonesPayload>
          }
          update: {
            args: Prisma.warCombatZonesUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$warCombatZonesPayload>
          }
          deleteMany: {
            args: Prisma.warCombatZonesDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.warCombatZonesUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.warCombatZonesUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$warCombatZonesPayload>
          }
          aggregate: {
            args: Prisma.WarCombatZonesAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateWarCombatZones>
          }
          groupBy: {
            args: Prisma.warCombatZonesGroupByArgs<ExtArgs>,
            result: $Utils.Optional<WarCombatZonesGroupByOutputType>[]
          }
          count: {
            args: Prisma.warCombatZonesCountArgs<ExtArgs>,
            result: $Utils.Optional<WarCombatZonesCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<'define', Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'

  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources

    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat

    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *  { emit: 'stdout', level: 'query' },
     *  { emit: 'stdout', level: 'info' },
     *  { emit: 'stdout', level: 'warn' }
     *  { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: Array<LogLevel | LogDefinition>
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */



  /**
   * Models
   */

  /**
   * Model agtAgentTypes
   */

  export type AggregateAgtAgentTypes = {
    _count: AgtAgentTypesCountAggregateOutputType | null
    _avg: AgtAgentTypesAvgAggregateOutputType | null
    _sum: AgtAgentTypesSumAggregateOutputType | null
    _min: AgtAgentTypesMinAggregateOutputType | null
    _max: AgtAgentTypesMaxAggregateOutputType | null
  }

  export type AgtAgentTypesAvgAggregateOutputType = {
    agentTypeID: number | null
  }

  export type AgtAgentTypesSumAggregateOutputType = {
    agentTypeID: number | null
  }

  export type AgtAgentTypesMinAggregateOutputType = {
    agentTypeID: number | null
    agentType: string | null
  }

  export type AgtAgentTypesMaxAggregateOutputType = {
    agentTypeID: number | null
    agentType: string | null
  }

  export type AgtAgentTypesCountAggregateOutputType = {
    agentTypeID: number
    agentType: number
    _all: number
  }


  export type AgtAgentTypesAvgAggregateInputType = {
    agentTypeID?: true
  }

  export type AgtAgentTypesSumAggregateInputType = {
    agentTypeID?: true
  }

  export type AgtAgentTypesMinAggregateInputType = {
    agentTypeID?: true
    agentType?: true
  }

  export type AgtAgentTypesMaxAggregateInputType = {
    agentTypeID?: true
    agentType?: true
  }

  export type AgtAgentTypesCountAggregateInputType = {
    agentTypeID?: true
    agentType?: true
    _all?: true
  }

  export type AgtAgentTypesAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which agtAgentTypes to aggregate.
     */
    where?: agtAgentTypesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of agtAgentTypes to fetch.
     */
    orderBy?: agtAgentTypesOrderByWithRelationInput | agtAgentTypesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: agtAgentTypesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` agtAgentTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` agtAgentTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned agtAgentTypes
    **/
    _count?: true | AgtAgentTypesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AgtAgentTypesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AgtAgentTypesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AgtAgentTypesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AgtAgentTypesMaxAggregateInputType
  }

  export type GetAgtAgentTypesAggregateType<T extends AgtAgentTypesAggregateArgs> = {
        [P in keyof T & keyof AggregateAgtAgentTypes]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAgtAgentTypes[P]>
      : GetScalarType<T[P], AggregateAgtAgentTypes[P]>
  }




  export type agtAgentTypesGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: agtAgentTypesWhereInput
    orderBy?: agtAgentTypesOrderByWithAggregationInput | agtAgentTypesOrderByWithAggregationInput[]
    by: AgtAgentTypesScalarFieldEnum[] | AgtAgentTypesScalarFieldEnum
    having?: agtAgentTypesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AgtAgentTypesCountAggregateInputType | true
    _avg?: AgtAgentTypesAvgAggregateInputType
    _sum?: AgtAgentTypesSumAggregateInputType
    _min?: AgtAgentTypesMinAggregateInputType
    _max?: AgtAgentTypesMaxAggregateInputType
  }

  export type AgtAgentTypesGroupByOutputType = {
    agentTypeID: number
    agentType: string | null
    _count: AgtAgentTypesCountAggregateOutputType | null
    _avg: AgtAgentTypesAvgAggregateOutputType | null
    _sum: AgtAgentTypesSumAggregateOutputType | null
    _min: AgtAgentTypesMinAggregateOutputType | null
    _max: AgtAgentTypesMaxAggregateOutputType | null
  }

  type GetAgtAgentTypesGroupByPayload<T extends agtAgentTypesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AgtAgentTypesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AgtAgentTypesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AgtAgentTypesGroupByOutputType[P]>
            : GetScalarType<T[P], AgtAgentTypesGroupByOutputType[P]>
        }
      >
    >


  export type agtAgentTypesSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    agentTypeID?: boolean
    agentType?: boolean
  }, ExtArgs["result"]["agtAgentTypes"]>

  export type agtAgentTypesSelectScalar = {
    agentTypeID?: boolean
    agentType?: boolean
  }


  export type $agtAgentTypesPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    name: "agtAgentTypes"
    objects: {}
    scalars: $Extensions.GetResult<{
      agentTypeID: number
      agentType: string | null
    }, ExtArgs["result"]["agtAgentTypes"]>
    composites: {}
  }


  type agtAgentTypesGetPayload<S extends boolean | null | undefined | agtAgentTypesDefaultArgs> = $Result.GetResult<Prisma.$agtAgentTypesPayload, S>

  type agtAgentTypesCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<agtAgentTypesFindManyArgs, 'select' | 'include'> & {
      select?: AgtAgentTypesCountAggregateInputType | true
    }

  export interface agtAgentTypesDelegate<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['agtAgentTypes'], meta: { name: 'agtAgentTypes' } }
    /**
     * Find zero or one AgtAgentTypes that matches the filter.
     * @param {agtAgentTypesFindUniqueArgs} args - Arguments to find a AgtAgentTypes
     * @example
     * // Get one AgtAgentTypes
     * const agtAgentTypes = await prisma.agtAgentTypes.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends agtAgentTypesFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, agtAgentTypesFindUniqueArgs<ExtArgs>>
    ): Prisma__agtAgentTypesClient<$Result.GetResult<Prisma.$agtAgentTypesPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one AgtAgentTypes that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {agtAgentTypesFindUniqueOrThrowArgs} args - Arguments to find a AgtAgentTypes
     * @example
     * // Get one AgtAgentTypes
     * const agtAgentTypes = await prisma.agtAgentTypes.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends agtAgentTypesFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, agtAgentTypesFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__agtAgentTypesClient<$Result.GetResult<Prisma.$agtAgentTypesPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first AgtAgentTypes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {agtAgentTypesFindFirstArgs} args - Arguments to find a AgtAgentTypes
     * @example
     * // Get one AgtAgentTypes
     * const agtAgentTypes = await prisma.agtAgentTypes.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends agtAgentTypesFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, agtAgentTypesFindFirstArgs<ExtArgs>>
    ): Prisma__agtAgentTypesClient<$Result.GetResult<Prisma.$agtAgentTypesPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first AgtAgentTypes that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {agtAgentTypesFindFirstOrThrowArgs} args - Arguments to find a AgtAgentTypes
     * @example
     * // Get one AgtAgentTypes
     * const agtAgentTypes = await prisma.agtAgentTypes.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends agtAgentTypesFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, agtAgentTypesFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__agtAgentTypesClient<$Result.GetResult<Prisma.$agtAgentTypesPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more AgtAgentTypes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {agtAgentTypesFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AgtAgentTypes
     * const agtAgentTypes = await prisma.agtAgentTypes.findMany()
     * 
     * // Get first 10 AgtAgentTypes
     * const agtAgentTypes = await prisma.agtAgentTypes.findMany({ take: 10 })
     * 
     * // Only select the `agentTypeID`
     * const agtAgentTypesWithAgentTypeIDOnly = await prisma.agtAgentTypes.findMany({ select: { agentTypeID: true } })
     * 
    **/
    findMany<T extends agtAgentTypesFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, agtAgentTypesFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$agtAgentTypesPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a AgtAgentTypes.
     * @param {agtAgentTypesCreateArgs} args - Arguments to create a AgtAgentTypes.
     * @example
     * // Create one AgtAgentTypes
     * const AgtAgentTypes = await prisma.agtAgentTypes.create({
     *   data: {
     *     // ... data to create a AgtAgentTypes
     *   }
     * })
     * 
    **/
    create<T extends agtAgentTypesCreateArgs<ExtArgs>>(
      args: SelectSubset<T, agtAgentTypesCreateArgs<ExtArgs>>
    ): Prisma__agtAgentTypesClient<$Result.GetResult<Prisma.$agtAgentTypesPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many AgtAgentTypes.
     *     @param {agtAgentTypesCreateManyArgs} args - Arguments to create many AgtAgentTypes.
     *     @example
     *     // Create many AgtAgentTypes
     *     const agtAgentTypes = await prisma.agtAgentTypes.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends agtAgentTypesCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, agtAgentTypesCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a AgtAgentTypes.
     * @param {agtAgentTypesDeleteArgs} args - Arguments to delete one AgtAgentTypes.
     * @example
     * // Delete one AgtAgentTypes
     * const AgtAgentTypes = await prisma.agtAgentTypes.delete({
     *   where: {
     *     // ... filter to delete one AgtAgentTypes
     *   }
     * })
     * 
    **/
    delete<T extends agtAgentTypesDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, agtAgentTypesDeleteArgs<ExtArgs>>
    ): Prisma__agtAgentTypesClient<$Result.GetResult<Prisma.$agtAgentTypesPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one AgtAgentTypes.
     * @param {agtAgentTypesUpdateArgs} args - Arguments to update one AgtAgentTypes.
     * @example
     * // Update one AgtAgentTypes
     * const agtAgentTypes = await prisma.agtAgentTypes.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends agtAgentTypesUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, agtAgentTypesUpdateArgs<ExtArgs>>
    ): Prisma__agtAgentTypesClient<$Result.GetResult<Prisma.$agtAgentTypesPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more AgtAgentTypes.
     * @param {agtAgentTypesDeleteManyArgs} args - Arguments to filter AgtAgentTypes to delete.
     * @example
     * // Delete a few AgtAgentTypes
     * const { count } = await prisma.agtAgentTypes.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends agtAgentTypesDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, agtAgentTypesDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AgtAgentTypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {agtAgentTypesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AgtAgentTypes
     * const agtAgentTypes = await prisma.agtAgentTypes.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends agtAgentTypesUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, agtAgentTypesUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one AgtAgentTypes.
     * @param {agtAgentTypesUpsertArgs} args - Arguments to update or create a AgtAgentTypes.
     * @example
     * // Update or create a AgtAgentTypes
     * const agtAgentTypes = await prisma.agtAgentTypes.upsert({
     *   create: {
     *     // ... data to create a AgtAgentTypes
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AgtAgentTypes we want to update
     *   }
     * })
    **/
    upsert<T extends agtAgentTypesUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, agtAgentTypesUpsertArgs<ExtArgs>>
    ): Prisma__agtAgentTypesClient<$Result.GetResult<Prisma.$agtAgentTypesPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of AgtAgentTypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {agtAgentTypesCountArgs} args - Arguments to filter AgtAgentTypes to count.
     * @example
     * // Count the number of AgtAgentTypes
     * const count = await prisma.agtAgentTypes.count({
     *   where: {
     *     // ... the filter for the AgtAgentTypes we want to count
     *   }
     * })
    **/
    count<T extends agtAgentTypesCountArgs>(
      args?: Subset<T, agtAgentTypesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AgtAgentTypesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AgtAgentTypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgtAgentTypesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AgtAgentTypesAggregateArgs>(args: Subset<T, AgtAgentTypesAggregateArgs>): Prisma.PrismaPromise<GetAgtAgentTypesAggregateType<T>>

    /**
     * Group by AgtAgentTypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {agtAgentTypesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends agtAgentTypesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: agtAgentTypesGroupByArgs['orderBy'] }
        : { orderBy?: agtAgentTypesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, agtAgentTypesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAgtAgentTypesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the agtAgentTypes model
   */
  readonly fields: agtAgentTypesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for agtAgentTypes.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__agtAgentTypesClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';


    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the agtAgentTypes model
   */ 
  interface agtAgentTypesFieldRefs {
    readonly agentTypeID: FieldRef<"agtAgentTypes", 'Int'>
    readonly agentType: FieldRef<"agtAgentTypes", 'String'>
  }
    

  // Custom InputTypes

  /**
   * agtAgentTypes findUnique
   */
  export type agtAgentTypesFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the agtAgentTypes
     */
    select?: agtAgentTypesSelect<ExtArgs> | null
    /**
     * Filter, which agtAgentTypes to fetch.
     */
    where: agtAgentTypesWhereUniqueInput
  }


  /**
   * agtAgentTypes findUniqueOrThrow
   */
  export type agtAgentTypesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the agtAgentTypes
     */
    select?: agtAgentTypesSelect<ExtArgs> | null
    /**
     * Filter, which agtAgentTypes to fetch.
     */
    where: agtAgentTypesWhereUniqueInput
  }


  /**
   * agtAgentTypes findFirst
   */
  export type agtAgentTypesFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the agtAgentTypes
     */
    select?: agtAgentTypesSelect<ExtArgs> | null
    /**
     * Filter, which agtAgentTypes to fetch.
     */
    where?: agtAgentTypesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of agtAgentTypes to fetch.
     */
    orderBy?: agtAgentTypesOrderByWithRelationInput | agtAgentTypesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for agtAgentTypes.
     */
    cursor?: agtAgentTypesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` agtAgentTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` agtAgentTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of agtAgentTypes.
     */
    distinct?: AgtAgentTypesScalarFieldEnum | AgtAgentTypesScalarFieldEnum[]
  }


  /**
   * agtAgentTypes findFirstOrThrow
   */
  export type agtAgentTypesFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the agtAgentTypes
     */
    select?: agtAgentTypesSelect<ExtArgs> | null
    /**
     * Filter, which agtAgentTypes to fetch.
     */
    where?: agtAgentTypesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of agtAgentTypes to fetch.
     */
    orderBy?: agtAgentTypesOrderByWithRelationInput | agtAgentTypesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for agtAgentTypes.
     */
    cursor?: agtAgentTypesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` agtAgentTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` agtAgentTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of agtAgentTypes.
     */
    distinct?: AgtAgentTypesScalarFieldEnum | AgtAgentTypesScalarFieldEnum[]
  }


  /**
   * agtAgentTypes findMany
   */
  export type agtAgentTypesFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the agtAgentTypes
     */
    select?: agtAgentTypesSelect<ExtArgs> | null
    /**
     * Filter, which agtAgentTypes to fetch.
     */
    where?: agtAgentTypesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of agtAgentTypes to fetch.
     */
    orderBy?: agtAgentTypesOrderByWithRelationInput | agtAgentTypesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing agtAgentTypes.
     */
    cursor?: agtAgentTypesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` agtAgentTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` agtAgentTypes.
     */
    skip?: number
    distinct?: AgtAgentTypesScalarFieldEnum | AgtAgentTypesScalarFieldEnum[]
  }


  /**
   * agtAgentTypes create
   */
  export type agtAgentTypesCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the agtAgentTypes
     */
    select?: agtAgentTypesSelect<ExtArgs> | null
    /**
     * The data needed to create a agtAgentTypes.
     */
    data: XOR<agtAgentTypesCreateInput, agtAgentTypesUncheckedCreateInput>
  }


  /**
   * agtAgentTypes createMany
   */
  export type agtAgentTypesCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many agtAgentTypes.
     */
    data: agtAgentTypesCreateManyInput | agtAgentTypesCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * agtAgentTypes update
   */
  export type agtAgentTypesUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the agtAgentTypes
     */
    select?: agtAgentTypesSelect<ExtArgs> | null
    /**
     * The data needed to update a agtAgentTypes.
     */
    data: XOR<agtAgentTypesUpdateInput, agtAgentTypesUncheckedUpdateInput>
    /**
     * Choose, which agtAgentTypes to update.
     */
    where: agtAgentTypesWhereUniqueInput
  }


  /**
   * agtAgentTypes updateMany
   */
  export type agtAgentTypesUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update agtAgentTypes.
     */
    data: XOR<agtAgentTypesUpdateManyMutationInput, agtAgentTypesUncheckedUpdateManyInput>
    /**
     * Filter which agtAgentTypes to update
     */
    where?: agtAgentTypesWhereInput
  }


  /**
   * agtAgentTypes upsert
   */
  export type agtAgentTypesUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the agtAgentTypes
     */
    select?: agtAgentTypesSelect<ExtArgs> | null
    /**
     * The filter to search for the agtAgentTypes to update in case it exists.
     */
    where: agtAgentTypesWhereUniqueInput
    /**
     * In case the agtAgentTypes found by the `where` argument doesn't exist, create a new agtAgentTypes with this data.
     */
    create: XOR<agtAgentTypesCreateInput, agtAgentTypesUncheckedCreateInput>
    /**
     * In case the agtAgentTypes was found with the provided `where` argument, update it with this data.
     */
    update: XOR<agtAgentTypesUpdateInput, agtAgentTypesUncheckedUpdateInput>
  }


  /**
   * agtAgentTypes delete
   */
  export type agtAgentTypesDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the agtAgentTypes
     */
    select?: agtAgentTypesSelect<ExtArgs> | null
    /**
     * Filter which agtAgentTypes to delete.
     */
    where: agtAgentTypesWhereUniqueInput
  }


  /**
   * agtAgentTypes deleteMany
   */
  export type agtAgentTypesDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which agtAgentTypes to delete
     */
    where?: agtAgentTypesWhereInput
  }


  /**
   * agtAgentTypes without action
   */
  export type agtAgentTypesDefaultArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the agtAgentTypes
     */
    select?: agtAgentTypesSelect<ExtArgs> | null
  }



  /**
   * Model agtAgents
   */

  export type AggregateAgtAgents = {
    _count: AgtAgentsCountAggregateOutputType | null
    _avg: AgtAgentsAvgAggregateOutputType | null
    _sum: AgtAgentsSumAggregateOutputType | null
    _min: AgtAgentsMinAggregateOutputType | null
    _max: AgtAgentsMaxAggregateOutputType | null
  }

  export type AgtAgentsAvgAggregateOutputType = {
    agentID: number | null
    divisionID: number | null
    corporationID: number | null
    locationID: number | null
    level: number | null
    quality: number | null
    agentTypeID: number | null
  }

  export type AgtAgentsSumAggregateOutputType = {
    agentID: number | null
    divisionID: number | null
    corporationID: number | null
    locationID: number | null
    level: number | null
    quality: number | null
    agentTypeID: number | null
  }

  export type AgtAgentsMinAggregateOutputType = {
    agentID: number | null
    divisionID: number | null
    corporationID: number | null
    locationID: number | null
    level: number | null
    quality: number | null
    agentTypeID: number | null
    isLocator: boolean | null
  }

  export type AgtAgentsMaxAggregateOutputType = {
    agentID: number | null
    divisionID: number | null
    corporationID: number | null
    locationID: number | null
    level: number | null
    quality: number | null
    agentTypeID: number | null
    isLocator: boolean | null
  }

  export type AgtAgentsCountAggregateOutputType = {
    agentID: number
    divisionID: number
    corporationID: number
    locationID: number
    level: number
    quality: number
    agentTypeID: number
    isLocator: number
    _all: number
  }


  export type AgtAgentsAvgAggregateInputType = {
    agentID?: true
    divisionID?: true
    corporationID?: true
    locationID?: true
    level?: true
    quality?: true
    agentTypeID?: true
  }

  export type AgtAgentsSumAggregateInputType = {
    agentID?: true
    divisionID?: true
    corporationID?: true
    locationID?: true
    level?: true
    quality?: true
    agentTypeID?: true
  }

  export type AgtAgentsMinAggregateInputType = {
    agentID?: true
    divisionID?: true
    corporationID?: true
    locationID?: true
    level?: true
    quality?: true
    agentTypeID?: true
    isLocator?: true
  }

  export type AgtAgentsMaxAggregateInputType = {
    agentID?: true
    divisionID?: true
    corporationID?: true
    locationID?: true
    level?: true
    quality?: true
    agentTypeID?: true
    isLocator?: true
  }

  export type AgtAgentsCountAggregateInputType = {
    agentID?: true
    divisionID?: true
    corporationID?: true
    locationID?: true
    level?: true
    quality?: true
    agentTypeID?: true
    isLocator?: true
    _all?: true
  }

  export type AgtAgentsAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which agtAgents to aggregate.
     */
    where?: agtAgentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of agtAgents to fetch.
     */
    orderBy?: agtAgentsOrderByWithRelationInput | agtAgentsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: agtAgentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` agtAgents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` agtAgents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned agtAgents
    **/
    _count?: true | AgtAgentsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AgtAgentsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AgtAgentsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AgtAgentsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AgtAgentsMaxAggregateInputType
  }

  export type GetAgtAgentsAggregateType<T extends AgtAgentsAggregateArgs> = {
        [P in keyof T & keyof AggregateAgtAgents]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAgtAgents[P]>
      : GetScalarType<T[P], AggregateAgtAgents[P]>
  }




  export type agtAgentsGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: agtAgentsWhereInput
    orderBy?: agtAgentsOrderByWithAggregationInput | agtAgentsOrderByWithAggregationInput[]
    by: AgtAgentsScalarFieldEnum[] | AgtAgentsScalarFieldEnum
    having?: agtAgentsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AgtAgentsCountAggregateInputType | true
    _avg?: AgtAgentsAvgAggregateInputType
    _sum?: AgtAgentsSumAggregateInputType
    _min?: AgtAgentsMinAggregateInputType
    _max?: AgtAgentsMaxAggregateInputType
  }

  export type AgtAgentsGroupByOutputType = {
    agentID: number
    divisionID: number | null
    corporationID: number | null
    locationID: number | null
    level: number | null
    quality: number | null
    agentTypeID: number | null
    isLocator: boolean | null
    _count: AgtAgentsCountAggregateOutputType | null
    _avg: AgtAgentsAvgAggregateOutputType | null
    _sum: AgtAgentsSumAggregateOutputType | null
    _min: AgtAgentsMinAggregateOutputType | null
    _max: AgtAgentsMaxAggregateOutputType | null
  }

  type GetAgtAgentsGroupByPayload<T extends agtAgentsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AgtAgentsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AgtAgentsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AgtAgentsGroupByOutputType[P]>
            : GetScalarType<T[P], AgtAgentsGroupByOutputType[P]>
        }
      >
    >


  export type agtAgentsSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    agentID?: boolean
    divisionID?: boolean
    corporationID?: boolean
    locationID?: boolean
    level?: boolean
    quality?: boolean
    agentTypeID?: boolean
    isLocator?: boolean
  }, ExtArgs["result"]["agtAgents"]>

  export type agtAgentsSelectScalar = {
    agentID?: boolean
    divisionID?: boolean
    corporationID?: boolean
    locationID?: boolean
    level?: boolean
    quality?: boolean
    agentTypeID?: boolean
    isLocator?: boolean
  }


  export type $agtAgentsPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    name: "agtAgents"
    objects: {}
    scalars: $Extensions.GetResult<{
      agentID: number
      divisionID: number | null
      corporationID: number | null
      locationID: number | null
      level: number | null
      quality: number | null
      agentTypeID: number | null
      isLocator: boolean | null
    }, ExtArgs["result"]["agtAgents"]>
    composites: {}
  }


  type agtAgentsGetPayload<S extends boolean | null | undefined | agtAgentsDefaultArgs> = $Result.GetResult<Prisma.$agtAgentsPayload, S>

  type agtAgentsCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<agtAgentsFindManyArgs, 'select' | 'include'> & {
      select?: AgtAgentsCountAggregateInputType | true
    }

  export interface agtAgentsDelegate<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['agtAgents'], meta: { name: 'agtAgents' } }
    /**
     * Find zero or one AgtAgents that matches the filter.
     * @param {agtAgentsFindUniqueArgs} args - Arguments to find a AgtAgents
     * @example
     * // Get one AgtAgents
     * const agtAgents = await prisma.agtAgents.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends agtAgentsFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, agtAgentsFindUniqueArgs<ExtArgs>>
    ): Prisma__agtAgentsClient<$Result.GetResult<Prisma.$agtAgentsPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one AgtAgents that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {agtAgentsFindUniqueOrThrowArgs} args - Arguments to find a AgtAgents
     * @example
     * // Get one AgtAgents
     * const agtAgents = await prisma.agtAgents.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends agtAgentsFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, agtAgentsFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__agtAgentsClient<$Result.GetResult<Prisma.$agtAgentsPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first AgtAgents that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {agtAgentsFindFirstArgs} args - Arguments to find a AgtAgents
     * @example
     * // Get one AgtAgents
     * const agtAgents = await prisma.agtAgents.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends agtAgentsFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, agtAgentsFindFirstArgs<ExtArgs>>
    ): Prisma__agtAgentsClient<$Result.GetResult<Prisma.$agtAgentsPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first AgtAgents that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {agtAgentsFindFirstOrThrowArgs} args - Arguments to find a AgtAgents
     * @example
     * // Get one AgtAgents
     * const agtAgents = await prisma.agtAgents.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends agtAgentsFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, agtAgentsFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__agtAgentsClient<$Result.GetResult<Prisma.$agtAgentsPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more AgtAgents that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {agtAgentsFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AgtAgents
     * const agtAgents = await prisma.agtAgents.findMany()
     * 
     * // Get first 10 AgtAgents
     * const agtAgents = await prisma.agtAgents.findMany({ take: 10 })
     * 
     * // Only select the `agentID`
     * const agtAgentsWithAgentIDOnly = await prisma.agtAgents.findMany({ select: { agentID: true } })
     * 
    **/
    findMany<T extends agtAgentsFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, agtAgentsFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$agtAgentsPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a AgtAgents.
     * @param {agtAgentsCreateArgs} args - Arguments to create a AgtAgents.
     * @example
     * // Create one AgtAgents
     * const AgtAgents = await prisma.agtAgents.create({
     *   data: {
     *     // ... data to create a AgtAgents
     *   }
     * })
     * 
    **/
    create<T extends agtAgentsCreateArgs<ExtArgs>>(
      args: SelectSubset<T, agtAgentsCreateArgs<ExtArgs>>
    ): Prisma__agtAgentsClient<$Result.GetResult<Prisma.$agtAgentsPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many AgtAgents.
     *     @param {agtAgentsCreateManyArgs} args - Arguments to create many AgtAgents.
     *     @example
     *     // Create many AgtAgents
     *     const agtAgents = await prisma.agtAgents.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends agtAgentsCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, agtAgentsCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a AgtAgents.
     * @param {agtAgentsDeleteArgs} args - Arguments to delete one AgtAgents.
     * @example
     * // Delete one AgtAgents
     * const AgtAgents = await prisma.agtAgents.delete({
     *   where: {
     *     // ... filter to delete one AgtAgents
     *   }
     * })
     * 
    **/
    delete<T extends agtAgentsDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, agtAgentsDeleteArgs<ExtArgs>>
    ): Prisma__agtAgentsClient<$Result.GetResult<Prisma.$agtAgentsPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one AgtAgents.
     * @param {agtAgentsUpdateArgs} args - Arguments to update one AgtAgents.
     * @example
     * // Update one AgtAgents
     * const agtAgents = await prisma.agtAgents.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends agtAgentsUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, agtAgentsUpdateArgs<ExtArgs>>
    ): Prisma__agtAgentsClient<$Result.GetResult<Prisma.$agtAgentsPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more AgtAgents.
     * @param {agtAgentsDeleteManyArgs} args - Arguments to filter AgtAgents to delete.
     * @example
     * // Delete a few AgtAgents
     * const { count } = await prisma.agtAgents.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends agtAgentsDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, agtAgentsDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AgtAgents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {agtAgentsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AgtAgents
     * const agtAgents = await prisma.agtAgents.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends agtAgentsUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, agtAgentsUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one AgtAgents.
     * @param {agtAgentsUpsertArgs} args - Arguments to update or create a AgtAgents.
     * @example
     * // Update or create a AgtAgents
     * const agtAgents = await prisma.agtAgents.upsert({
     *   create: {
     *     // ... data to create a AgtAgents
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AgtAgents we want to update
     *   }
     * })
    **/
    upsert<T extends agtAgentsUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, agtAgentsUpsertArgs<ExtArgs>>
    ): Prisma__agtAgentsClient<$Result.GetResult<Prisma.$agtAgentsPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of AgtAgents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {agtAgentsCountArgs} args - Arguments to filter AgtAgents to count.
     * @example
     * // Count the number of AgtAgents
     * const count = await prisma.agtAgents.count({
     *   where: {
     *     // ... the filter for the AgtAgents we want to count
     *   }
     * })
    **/
    count<T extends agtAgentsCountArgs>(
      args?: Subset<T, agtAgentsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AgtAgentsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AgtAgents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgtAgentsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AgtAgentsAggregateArgs>(args: Subset<T, AgtAgentsAggregateArgs>): Prisma.PrismaPromise<GetAgtAgentsAggregateType<T>>

    /**
     * Group by AgtAgents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {agtAgentsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends agtAgentsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: agtAgentsGroupByArgs['orderBy'] }
        : { orderBy?: agtAgentsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, agtAgentsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAgtAgentsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the agtAgents model
   */
  readonly fields: agtAgentsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for agtAgents.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__agtAgentsClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';


    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the agtAgents model
   */ 
  interface agtAgentsFieldRefs {
    readonly agentID: FieldRef<"agtAgents", 'Int'>
    readonly divisionID: FieldRef<"agtAgents", 'Int'>
    readonly corporationID: FieldRef<"agtAgents", 'Int'>
    readonly locationID: FieldRef<"agtAgents", 'Int'>
    readonly level: FieldRef<"agtAgents", 'Int'>
    readonly quality: FieldRef<"agtAgents", 'Int'>
    readonly agentTypeID: FieldRef<"agtAgents", 'Int'>
    readonly isLocator: FieldRef<"agtAgents", 'Boolean'>
  }
    

  // Custom InputTypes

  /**
   * agtAgents findUnique
   */
  export type agtAgentsFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the agtAgents
     */
    select?: agtAgentsSelect<ExtArgs> | null
    /**
     * Filter, which agtAgents to fetch.
     */
    where: agtAgentsWhereUniqueInput
  }


  /**
   * agtAgents findUniqueOrThrow
   */
  export type agtAgentsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the agtAgents
     */
    select?: agtAgentsSelect<ExtArgs> | null
    /**
     * Filter, which agtAgents to fetch.
     */
    where: agtAgentsWhereUniqueInput
  }


  /**
   * agtAgents findFirst
   */
  export type agtAgentsFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the agtAgents
     */
    select?: agtAgentsSelect<ExtArgs> | null
    /**
     * Filter, which agtAgents to fetch.
     */
    where?: agtAgentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of agtAgents to fetch.
     */
    orderBy?: agtAgentsOrderByWithRelationInput | agtAgentsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for agtAgents.
     */
    cursor?: agtAgentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` agtAgents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` agtAgents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of agtAgents.
     */
    distinct?: AgtAgentsScalarFieldEnum | AgtAgentsScalarFieldEnum[]
  }


  /**
   * agtAgents findFirstOrThrow
   */
  export type agtAgentsFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the agtAgents
     */
    select?: agtAgentsSelect<ExtArgs> | null
    /**
     * Filter, which agtAgents to fetch.
     */
    where?: agtAgentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of agtAgents to fetch.
     */
    orderBy?: agtAgentsOrderByWithRelationInput | agtAgentsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for agtAgents.
     */
    cursor?: agtAgentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` agtAgents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` agtAgents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of agtAgents.
     */
    distinct?: AgtAgentsScalarFieldEnum | AgtAgentsScalarFieldEnum[]
  }


  /**
   * agtAgents findMany
   */
  export type agtAgentsFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the agtAgents
     */
    select?: agtAgentsSelect<ExtArgs> | null
    /**
     * Filter, which agtAgents to fetch.
     */
    where?: agtAgentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of agtAgents to fetch.
     */
    orderBy?: agtAgentsOrderByWithRelationInput | agtAgentsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing agtAgents.
     */
    cursor?: agtAgentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` agtAgents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` agtAgents.
     */
    skip?: number
    distinct?: AgtAgentsScalarFieldEnum | AgtAgentsScalarFieldEnum[]
  }


  /**
   * agtAgents create
   */
  export type agtAgentsCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the agtAgents
     */
    select?: agtAgentsSelect<ExtArgs> | null
    /**
     * The data needed to create a agtAgents.
     */
    data: XOR<agtAgentsCreateInput, agtAgentsUncheckedCreateInput>
  }


  /**
   * agtAgents createMany
   */
  export type agtAgentsCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many agtAgents.
     */
    data: agtAgentsCreateManyInput | agtAgentsCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * agtAgents update
   */
  export type agtAgentsUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the agtAgents
     */
    select?: agtAgentsSelect<ExtArgs> | null
    /**
     * The data needed to update a agtAgents.
     */
    data: XOR<agtAgentsUpdateInput, agtAgentsUncheckedUpdateInput>
    /**
     * Choose, which agtAgents to update.
     */
    where: agtAgentsWhereUniqueInput
  }


  /**
   * agtAgents updateMany
   */
  export type agtAgentsUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update agtAgents.
     */
    data: XOR<agtAgentsUpdateManyMutationInput, agtAgentsUncheckedUpdateManyInput>
    /**
     * Filter which agtAgents to update
     */
    where?: agtAgentsWhereInput
  }


  /**
   * agtAgents upsert
   */
  export type agtAgentsUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the agtAgents
     */
    select?: agtAgentsSelect<ExtArgs> | null
    /**
     * The filter to search for the agtAgents to update in case it exists.
     */
    where: agtAgentsWhereUniqueInput
    /**
     * In case the agtAgents found by the `where` argument doesn't exist, create a new agtAgents with this data.
     */
    create: XOR<agtAgentsCreateInput, agtAgentsUncheckedCreateInput>
    /**
     * In case the agtAgents was found with the provided `where` argument, update it with this data.
     */
    update: XOR<agtAgentsUpdateInput, agtAgentsUncheckedUpdateInput>
  }


  /**
   * agtAgents delete
   */
  export type agtAgentsDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the agtAgents
     */
    select?: agtAgentsSelect<ExtArgs> | null
    /**
     * Filter which agtAgents to delete.
     */
    where: agtAgentsWhereUniqueInput
  }


  /**
   * agtAgents deleteMany
   */
  export type agtAgentsDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which agtAgents to delete
     */
    where?: agtAgentsWhereInput
  }


  /**
   * agtAgents without action
   */
  export type agtAgentsDefaultArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the agtAgents
     */
    select?: agtAgentsSelect<ExtArgs> | null
  }



  /**
   * Model agtAgentsInSpace
   */

  export type AggregateAgtAgentsInSpace = {
    _count: AgtAgentsInSpaceCountAggregateOutputType | null
    _avg: AgtAgentsInSpaceAvgAggregateOutputType | null
    _sum: AgtAgentsInSpaceSumAggregateOutputType | null
    _min: AgtAgentsInSpaceMinAggregateOutputType | null
    _max: AgtAgentsInSpaceMaxAggregateOutputType | null
  }

  export type AgtAgentsInSpaceAvgAggregateOutputType = {
    agentID: number | null
    dungeonID: number | null
    solarSystemID: number | null
    spawnPointID: number | null
    typeID: number | null
  }

  export type AgtAgentsInSpaceSumAggregateOutputType = {
    agentID: number | null
    dungeonID: number | null
    solarSystemID: number | null
    spawnPointID: number | null
    typeID: number | null
  }

  export type AgtAgentsInSpaceMinAggregateOutputType = {
    agentID: number | null
    dungeonID: number | null
    solarSystemID: number | null
    spawnPointID: number | null
    typeID: number | null
  }

  export type AgtAgentsInSpaceMaxAggregateOutputType = {
    agentID: number | null
    dungeonID: number | null
    solarSystemID: number | null
    spawnPointID: number | null
    typeID: number | null
  }

  export type AgtAgentsInSpaceCountAggregateOutputType = {
    agentID: number
    dungeonID: number
    solarSystemID: number
    spawnPointID: number
    typeID: number
    _all: number
  }


  export type AgtAgentsInSpaceAvgAggregateInputType = {
    agentID?: true
    dungeonID?: true
    solarSystemID?: true
    spawnPointID?: true
    typeID?: true
  }

  export type AgtAgentsInSpaceSumAggregateInputType = {
    agentID?: true
    dungeonID?: true
    solarSystemID?: true
    spawnPointID?: true
    typeID?: true
  }

  export type AgtAgentsInSpaceMinAggregateInputType = {
    agentID?: true
    dungeonID?: true
    solarSystemID?: true
    spawnPointID?: true
    typeID?: true
  }

  export type AgtAgentsInSpaceMaxAggregateInputType = {
    agentID?: true
    dungeonID?: true
    solarSystemID?: true
    spawnPointID?: true
    typeID?: true
  }

  export type AgtAgentsInSpaceCountAggregateInputType = {
    agentID?: true
    dungeonID?: true
    solarSystemID?: true
    spawnPointID?: true
    typeID?: true
    _all?: true
  }

  export type AgtAgentsInSpaceAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which agtAgentsInSpace to aggregate.
     */
    where?: agtAgentsInSpaceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of agtAgentsInSpaces to fetch.
     */
    orderBy?: agtAgentsInSpaceOrderByWithRelationInput | agtAgentsInSpaceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: agtAgentsInSpaceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` agtAgentsInSpaces from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` agtAgentsInSpaces.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned agtAgentsInSpaces
    **/
    _count?: true | AgtAgentsInSpaceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AgtAgentsInSpaceAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AgtAgentsInSpaceSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AgtAgentsInSpaceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AgtAgentsInSpaceMaxAggregateInputType
  }

  export type GetAgtAgentsInSpaceAggregateType<T extends AgtAgentsInSpaceAggregateArgs> = {
        [P in keyof T & keyof AggregateAgtAgentsInSpace]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAgtAgentsInSpace[P]>
      : GetScalarType<T[P], AggregateAgtAgentsInSpace[P]>
  }




  export type agtAgentsInSpaceGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: agtAgentsInSpaceWhereInput
    orderBy?: agtAgentsInSpaceOrderByWithAggregationInput | agtAgentsInSpaceOrderByWithAggregationInput[]
    by: AgtAgentsInSpaceScalarFieldEnum[] | AgtAgentsInSpaceScalarFieldEnum
    having?: agtAgentsInSpaceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AgtAgentsInSpaceCountAggregateInputType | true
    _avg?: AgtAgentsInSpaceAvgAggregateInputType
    _sum?: AgtAgentsInSpaceSumAggregateInputType
    _min?: AgtAgentsInSpaceMinAggregateInputType
    _max?: AgtAgentsInSpaceMaxAggregateInputType
  }

  export type AgtAgentsInSpaceGroupByOutputType = {
    agentID: number
    dungeonID: number | null
    solarSystemID: number | null
    spawnPointID: number | null
    typeID: number | null
    _count: AgtAgentsInSpaceCountAggregateOutputType | null
    _avg: AgtAgentsInSpaceAvgAggregateOutputType | null
    _sum: AgtAgentsInSpaceSumAggregateOutputType | null
    _min: AgtAgentsInSpaceMinAggregateOutputType | null
    _max: AgtAgentsInSpaceMaxAggregateOutputType | null
  }

  type GetAgtAgentsInSpaceGroupByPayload<T extends agtAgentsInSpaceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AgtAgentsInSpaceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AgtAgentsInSpaceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AgtAgentsInSpaceGroupByOutputType[P]>
            : GetScalarType<T[P], AgtAgentsInSpaceGroupByOutputType[P]>
        }
      >
    >


  export type agtAgentsInSpaceSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    agentID?: boolean
    dungeonID?: boolean
    solarSystemID?: boolean
    spawnPointID?: boolean
    typeID?: boolean
  }, ExtArgs["result"]["agtAgentsInSpace"]>

  export type agtAgentsInSpaceSelectScalar = {
    agentID?: boolean
    dungeonID?: boolean
    solarSystemID?: boolean
    spawnPointID?: boolean
    typeID?: boolean
  }


  export type $agtAgentsInSpacePayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    name: "agtAgentsInSpace"
    objects: {}
    scalars: $Extensions.GetResult<{
      agentID: number
      dungeonID: number | null
      solarSystemID: number | null
      spawnPointID: number | null
      typeID: number | null
    }, ExtArgs["result"]["agtAgentsInSpace"]>
    composites: {}
  }


  type agtAgentsInSpaceGetPayload<S extends boolean | null | undefined | agtAgentsInSpaceDefaultArgs> = $Result.GetResult<Prisma.$agtAgentsInSpacePayload, S>

  type agtAgentsInSpaceCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<agtAgentsInSpaceFindManyArgs, 'select' | 'include'> & {
      select?: AgtAgentsInSpaceCountAggregateInputType | true
    }

  export interface agtAgentsInSpaceDelegate<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['agtAgentsInSpace'], meta: { name: 'agtAgentsInSpace' } }
    /**
     * Find zero or one AgtAgentsInSpace that matches the filter.
     * @param {agtAgentsInSpaceFindUniqueArgs} args - Arguments to find a AgtAgentsInSpace
     * @example
     * // Get one AgtAgentsInSpace
     * const agtAgentsInSpace = await prisma.agtAgentsInSpace.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends agtAgentsInSpaceFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, agtAgentsInSpaceFindUniqueArgs<ExtArgs>>
    ): Prisma__agtAgentsInSpaceClient<$Result.GetResult<Prisma.$agtAgentsInSpacePayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one AgtAgentsInSpace that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {agtAgentsInSpaceFindUniqueOrThrowArgs} args - Arguments to find a AgtAgentsInSpace
     * @example
     * // Get one AgtAgentsInSpace
     * const agtAgentsInSpace = await prisma.agtAgentsInSpace.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends agtAgentsInSpaceFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, agtAgentsInSpaceFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__agtAgentsInSpaceClient<$Result.GetResult<Prisma.$agtAgentsInSpacePayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first AgtAgentsInSpace that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {agtAgentsInSpaceFindFirstArgs} args - Arguments to find a AgtAgentsInSpace
     * @example
     * // Get one AgtAgentsInSpace
     * const agtAgentsInSpace = await prisma.agtAgentsInSpace.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends agtAgentsInSpaceFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, agtAgentsInSpaceFindFirstArgs<ExtArgs>>
    ): Prisma__agtAgentsInSpaceClient<$Result.GetResult<Prisma.$agtAgentsInSpacePayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first AgtAgentsInSpace that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {agtAgentsInSpaceFindFirstOrThrowArgs} args - Arguments to find a AgtAgentsInSpace
     * @example
     * // Get one AgtAgentsInSpace
     * const agtAgentsInSpace = await prisma.agtAgentsInSpace.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends agtAgentsInSpaceFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, agtAgentsInSpaceFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__agtAgentsInSpaceClient<$Result.GetResult<Prisma.$agtAgentsInSpacePayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more AgtAgentsInSpaces that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {agtAgentsInSpaceFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AgtAgentsInSpaces
     * const agtAgentsInSpaces = await prisma.agtAgentsInSpace.findMany()
     * 
     * // Get first 10 AgtAgentsInSpaces
     * const agtAgentsInSpaces = await prisma.agtAgentsInSpace.findMany({ take: 10 })
     * 
     * // Only select the `agentID`
     * const agtAgentsInSpaceWithAgentIDOnly = await prisma.agtAgentsInSpace.findMany({ select: { agentID: true } })
     * 
    **/
    findMany<T extends agtAgentsInSpaceFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, agtAgentsInSpaceFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$agtAgentsInSpacePayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a AgtAgentsInSpace.
     * @param {agtAgentsInSpaceCreateArgs} args - Arguments to create a AgtAgentsInSpace.
     * @example
     * // Create one AgtAgentsInSpace
     * const AgtAgentsInSpace = await prisma.agtAgentsInSpace.create({
     *   data: {
     *     // ... data to create a AgtAgentsInSpace
     *   }
     * })
     * 
    **/
    create<T extends agtAgentsInSpaceCreateArgs<ExtArgs>>(
      args: SelectSubset<T, agtAgentsInSpaceCreateArgs<ExtArgs>>
    ): Prisma__agtAgentsInSpaceClient<$Result.GetResult<Prisma.$agtAgentsInSpacePayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many AgtAgentsInSpaces.
     *     @param {agtAgentsInSpaceCreateManyArgs} args - Arguments to create many AgtAgentsInSpaces.
     *     @example
     *     // Create many AgtAgentsInSpaces
     *     const agtAgentsInSpace = await prisma.agtAgentsInSpace.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends agtAgentsInSpaceCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, agtAgentsInSpaceCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a AgtAgentsInSpace.
     * @param {agtAgentsInSpaceDeleteArgs} args - Arguments to delete one AgtAgentsInSpace.
     * @example
     * // Delete one AgtAgentsInSpace
     * const AgtAgentsInSpace = await prisma.agtAgentsInSpace.delete({
     *   where: {
     *     // ... filter to delete one AgtAgentsInSpace
     *   }
     * })
     * 
    **/
    delete<T extends agtAgentsInSpaceDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, agtAgentsInSpaceDeleteArgs<ExtArgs>>
    ): Prisma__agtAgentsInSpaceClient<$Result.GetResult<Prisma.$agtAgentsInSpacePayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one AgtAgentsInSpace.
     * @param {agtAgentsInSpaceUpdateArgs} args - Arguments to update one AgtAgentsInSpace.
     * @example
     * // Update one AgtAgentsInSpace
     * const agtAgentsInSpace = await prisma.agtAgentsInSpace.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends agtAgentsInSpaceUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, agtAgentsInSpaceUpdateArgs<ExtArgs>>
    ): Prisma__agtAgentsInSpaceClient<$Result.GetResult<Prisma.$agtAgentsInSpacePayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more AgtAgentsInSpaces.
     * @param {agtAgentsInSpaceDeleteManyArgs} args - Arguments to filter AgtAgentsInSpaces to delete.
     * @example
     * // Delete a few AgtAgentsInSpaces
     * const { count } = await prisma.agtAgentsInSpace.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends agtAgentsInSpaceDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, agtAgentsInSpaceDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AgtAgentsInSpaces.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {agtAgentsInSpaceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AgtAgentsInSpaces
     * const agtAgentsInSpace = await prisma.agtAgentsInSpace.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends agtAgentsInSpaceUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, agtAgentsInSpaceUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one AgtAgentsInSpace.
     * @param {agtAgentsInSpaceUpsertArgs} args - Arguments to update or create a AgtAgentsInSpace.
     * @example
     * // Update or create a AgtAgentsInSpace
     * const agtAgentsInSpace = await prisma.agtAgentsInSpace.upsert({
     *   create: {
     *     // ... data to create a AgtAgentsInSpace
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AgtAgentsInSpace we want to update
     *   }
     * })
    **/
    upsert<T extends agtAgentsInSpaceUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, agtAgentsInSpaceUpsertArgs<ExtArgs>>
    ): Prisma__agtAgentsInSpaceClient<$Result.GetResult<Prisma.$agtAgentsInSpacePayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of AgtAgentsInSpaces.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {agtAgentsInSpaceCountArgs} args - Arguments to filter AgtAgentsInSpaces to count.
     * @example
     * // Count the number of AgtAgentsInSpaces
     * const count = await prisma.agtAgentsInSpace.count({
     *   where: {
     *     // ... the filter for the AgtAgentsInSpaces we want to count
     *   }
     * })
    **/
    count<T extends agtAgentsInSpaceCountArgs>(
      args?: Subset<T, agtAgentsInSpaceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AgtAgentsInSpaceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AgtAgentsInSpace.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgtAgentsInSpaceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AgtAgentsInSpaceAggregateArgs>(args: Subset<T, AgtAgentsInSpaceAggregateArgs>): Prisma.PrismaPromise<GetAgtAgentsInSpaceAggregateType<T>>

    /**
     * Group by AgtAgentsInSpace.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {agtAgentsInSpaceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends agtAgentsInSpaceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: agtAgentsInSpaceGroupByArgs['orderBy'] }
        : { orderBy?: agtAgentsInSpaceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, agtAgentsInSpaceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAgtAgentsInSpaceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the agtAgentsInSpace model
   */
  readonly fields: agtAgentsInSpaceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for agtAgentsInSpace.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__agtAgentsInSpaceClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';


    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the agtAgentsInSpace model
   */ 
  interface agtAgentsInSpaceFieldRefs {
    readonly agentID: FieldRef<"agtAgentsInSpace", 'Int'>
    readonly dungeonID: FieldRef<"agtAgentsInSpace", 'Int'>
    readonly solarSystemID: FieldRef<"agtAgentsInSpace", 'Int'>
    readonly spawnPointID: FieldRef<"agtAgentsInSpace", 'Int'>
    readonly typeID: FieldRef<"agtAgentsInSpace", 'Int'>
  }
    

  // Custom InputTypes

  /**
   * agtAgentsInSpace findUnique
   */
  export type agtAgentsInSpaceFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the agtAgentsInSpace
     */
    select?: agtAgentsInSpaceSelect<ExtArgs> | null
    /**
     * Filter, which agtAgentsInSpace to fetch.
     */
    where: agtAgentsInSpaceWhereUniqueInput
  }


  /**
   * agtAgentsInSpace findUniqueOrThrow
   */
  export type agtAgentsInSpaceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the agtAgentsInSpace
     */
    select?: agtAgentsInSpaceSelect<ExtArgs> | null
    /**
     * Filter, which agtAgentsInSpace to fetch.
     */
    where: agtAgentsInSpaceWhereUniqueInput
  }


  /**
   * agtAgentsInSpace findFirst
   */
  export type agtAgentsInSpaceFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the agtAgentsInSpace
     */
    select?: agtAgentsInSpaceSelect<ExtArgs> | null
    /**
     * Filter, which agtAgentsInSpace to fetch.
     */
    where?: agtAgentsInSpaceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of agtAgentsInSpaces to fetch.
     */
    orderBy?: agtAgentsInSpaceOrderByWithRelationInput | agtAgentsInSpaceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for agtAgentsInSpaces.
     */
    cursor?: agtAgentsInSpaceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` agtAgentsInSpaces from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` agtAgentsInSpaces.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of agtAgentsInSpaces.
     */
    distinct?: AgtAgentsInSpaceScalarFieldEnum | AgtAgentsInSpaceScalarFieldEnum[]
  }


  /**
   * agtAgentsInSpace findFirstOrThrow
   */
  export type agtAgentsInSpaceFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the agtAgentsInSpace
     */
    select?: agtAgentsInSpaceSelect<ExtArgs> | null
    /**
     * Filter, which agtAgentsInSpace to fetch.
     */
    where?: agtAgentsInSpaceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of agtAgentsInSpaces to fetch.
     */
    orderBy?: agtAgentsInSpaceOrderByWithRelationInput | agtAgentsInSpaceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for agtAgentsInSpaces.
     */
    cursor?: agtAgentsInSpaceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` agtAgentsInSpaces from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` agtAgentsInSpaces.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of agtAgentsInSpaces.
     */
    distinct?: AgtAgentsInSpaceScalarFieldEnum | AgtAgentsInSpaceScalarFieldEnum[]
  }


  /**
   * agtAgentsInSpace findMany
   */
  export type agtAgentsInSpaceFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the agtAgentsInSpace
     */
    select?: agtAgentsInSpaceSelect<ExtArgs> | null
    /**
     * Filter, which agtAgentsInSpaces to fetch.
     */
    where?: agtAgentsInSpaceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of agtAgentsInSpaces to fetch.
     */
    orderBy?: agtAgentsInSpaceOrderByWithRelationInput | agtAgentsInSpaceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing agtAgentsInSpaces.
     */
    cursor?: agtAgentsInSpaceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` agtAgentsInSpaces from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` agtAgentsInSpaces.
     */
    skip?: number
    distinct?: AgtAgentsInSpaceScalarFieldEnum | AgtAgentsInSpaceScalarFieldEnum[]
  }


  /**
   * agtAgentsInSpace create
   */
  export type agtAgentsInSpaceCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the agtAgentsInSpace
     */
    select?: agtAgentsInSpaceSelect<ExtArgs> | null
    /**
     * The data needed to create a agtAgentsInSpace.
     */
    data: XOR<agtAgentsInSpaceCreateInput, agtAgentsInSpaceUncheckedCreateInput>
  }


  /**
   * agtAgentsInSpace createMany
   */
  export type agtAgentsInSpaceCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many agtAgentsInSpaces.
     */
    data: agtAgentsInSpaceCreateManyInput | agtAgentsInSpaceCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * agtAgentsInSpace update
   */
  export type agtAgentsInSpaceUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the agtAgentsInSpace
     */
    select?: agtAgentsInSpaceSelect<ExtArgs> | null
    /**
     * The data needed to update a agtAgentsInSpace.
     */
    data: XOR<agtAgentsInSpaceUpdateInput, agtAgentsInSpaceUncheckedUpdateInput>
    /**
     * Choose, which agtAgentsInSpace to update.
     */
    where: agtAgentsInSpaceWhereUniqueInput
  }


  /**
   * agtAgentsInSpace updateMany
   */
  export type agtAgentsInSpaceUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update agtAgentsInSpaces.
     */
    data: XOR<agtAgentsInSpaceUpdateManyMutationInput, agtAgentsInSpaceUncheckedUpdateManyInput>
    /**
     * Filter which agtAgentsInSpaces to update
     */
    where?: agtAgentsInSpaceWhereInput
  }


  /**
   * agtAgentsInSpace upsert
   */
  export type agtAgentsInSpaceUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the agtAgentsInSpace
     */
    select?: agtAgentsInSpaceSelect<ExtArgs> | null
    /**
     * The filter to search for the agtAgentsInSpace to update in case it exists.
     */
    where: agtAgentsInSpaceWhereUniqueInput
    /**
     * In case the agtAgentsInSpace found by the `where` argument doesn't exist, create a new agtAgentsInSpace with this data.
     */
    create: XOR<agtAgentsInSpaceCreateInput, agtAgentsInSpaceUncheckedCreateInput>
    /**
     * In case the agtAgentsInSpace was found with the provided `where` argument, update it with this data.
     */
    update: XOR<agtAgentsInSpaceUpdateInput, agtAgentsInSpaceUncheckedUpdateInput>
  }


  /**
   * agtAgentsInSpace delete
   */
  export type agtAgentsInSpaceDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the agtAgentsInSpace
     */
    select?: agtAgentsInSpaceSelect<ExtArgs> | null
    /**
     * Filter which agtAgentsInSpace to delete.
     */
    where: agtAgentsInSpaceWhereUniqueInput
  }


  /**
   * agtAgentsInSpace deleteMany
   */
  export type agtAgentsInSpaceDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which agtAgentsInSpaces to delete
     */
    where?: agtAgentsInSpaceWhereInput
  }


  /**
   * agtAgentsInSpace without action
   */
  export type agtAgentsInSpaceDefaultArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the agtAgentsInSpace
     */
    select?: agtAgentsInSpaceSelect<ExtArgs> | null
  }



  /**
   * Model agtResearchAgents
   */

  export type AggregateAgtResearchAgents = {
    _count: AgtResearchAgentsCountAggregateOutputType | null
    _avg: AgtResearchAgentsAvgAggregateOutputType | null
    _sum: AgtResearchAgentsSumAggregateOutputType | null
    _min: AgtResearchAgentsMinAggregateOutputType | null
    _max: AgtResearchAgentsMaxAggregateOutputType | null
  }

  export type AgtResearchAgentsAvgAggregateOutputType = {
    agentID: number | null
    typeID: number | null
  }

  export type AgtResearchAgentsSumAggregateOutputType = {
    agentID: number | null
    typeID: number | null
  }

  export type AgtResearchAgentsMinAggregateOutputType = {
    agentID: number | null
    typeID: number | null
  }

  export type AgtResearchAgentsMaxAggregateOutputType = {
    agentID: number | null
    typeID: number | null
  }

  export type AgtResearchAgentsCountAggregateOutputType = {
    agentID: number
    typeID: number
    _all: number
  }


  export type AgtResearchAgentsAvgAggregateInputType = {
    agentID?: true
    typeID?: true
  }

  export type AgtResearchAgentsSumAggregateInputType = {
    agentID?: true
    typeID?: true
  }

  export type AgtResearchAgentsMinAggregateInputType = {
    agentID?: true
    typeID?: true
  }

  export type AgtResearchAgentsMaxAggregateInputType = {
    agentID?: true
    typeID?: true
  }

  export type AgtResearchAgentsCountAggregateInputType = {
    agentID?: true
    typeID?: true
    _all?: true
  }

  export type AgtResearchAgentsAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which agtResearchAgents to aggregate.
     */
    where?: agtResearchAgentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of agtResearchAgents to fetch.
     */
    orderBy?: agtResearchAgentsOrderByWithRelationInput | agtResearchAgentsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: agtResearchAgentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` agtResearchAgents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` agtResearchAgents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned agtResearchAgents
    **/
    _count?: true | AgtResearchAgentsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AgtResearchAgentsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AgtResearchAgentsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AgtResearchAgentsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AgtResearchAgentsMaxAggregateInputType
  }

  export type GetAgtResearchAgentsAggregateType<T extends AgtResearchAgentsAggregateArgs> = {
        [P in keyof T & keyof AggregateAgtResearchAgents]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAgtResearchAgents[P]>
      : GetScalarType<T[P], AggregateAgtResearchAgents[P]>
  }




  export type agtResearchAgentsGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: agtResearchAgentsWhereInput
    orderBy?: agtResearchAgentsOrderByWithAggregationInput | agtResearchAgentsOrderByWithAggregationInput[]
    by: AgtResearchAgentsScalarFieldEnum[] | AgtResearchAgentsScalarFieldEnum
    having?: agtResearchAgentsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AgtResearchAgentsCountAggregateInputType | true
    _avg?: AgtResearchAgentsAvgAggregateInputType
    _sum?: AgtResearchAgentsSumAggregateInputType
    _min?: AgtResearchAgentsMinAggregateInputType
    _max?: AgtResearchAgentsMaxAggregateInputType
  }

  export type AgtResearchAgentsGroupByOutputType = {
    agentID: number
    typeID: number
    _count: AgtResearchAgentsCountAggregateOutputType | null
    _avg: AgtResearchAgentsAvgAggregateOutputType | null
    _sum: AgtResearchAgentsSumAggregateOutputType | null
    _min: AgtResearchAgentsMinAggregateOutputType | null
    _max: AgtResearchAgentsMaxAggregateOutputType | null
  }

  type GetAgtResearchAgentsGroupByPayload<T extends agtResearchAgentsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AgtResearchAgentsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AgtResearchAgentsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AgtResearchAgentsGroupByOutputType[P]>
            : GetScalarType<T[P], AgtResearchAgentsGroupByOutputType[P]>
        }
      >
    >


  export type agtResearchAgentsSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    agentID?: boolean
    typeID?: boolean
  }, ExtArgs["result"]["agtResearchAgents"]>

  export type agtResearchAgentsSelectScalar = {
    agentID?: boolean
    typeID?: boolean
  }


  export type $agtResearchAgentsPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    name: "agtResearchAgents"
    objects: {}
    scalars: $Extensions.GetResult<{
      agentID: number
      typeID: number
    }, ExtArgs["result"]["agtResearchAgents"]>
    composites: {}
  }


  type agtResearchAgentsGetPayload<S extends boolean | null | undefined | agtResearchAgentsDefaultArgs> = $Result.GetResult<Prisma.$agtResearchAgentsPayload, S>

  type agtResearchAgentsCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<agtResearchAgentsFindManyArgs, 'select' | 'include'> & {
      select?: AgtResearchAgentsCountAggregateInputType | true
    }

  export interface agtResearchAgentsDelegate<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['agtResearchAgents'], meta: { name: 'agtResearchAgents' } }
    /**
     * Find zero or one AgtResearchAgents that matches the filter.
     * @param {agtResearchAgentsFindUniqueArgs} args - Arguments to find a AgtResearchAgents
     * @example
     * // Get one AgtResearchAgents
     * const agtResearchAgents = await prisma.agtResearchAgents.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends agtResearchAgentsFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, agtResearchAgentsFindUniqueArgs<ExtArgs>>
    ): Prisma__agtResearchAgentsClient<$Result.GetResult<Prisma.$agtResearchAgentsPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one AgtResearchAgents that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {agtResearchAgentsFindUniqueOrThrowArgs} args - Arguments to find a AgtResearchAgents
     * @example
     * // Get one AgtResearchAgents
     * const agtResearchAgents = await prisma.agtResearchAgents.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends agtResearchAgentsFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, agtResearchAgentsFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__agtResearchAgentsClient<$Result.GetResult<Prisma.$agtResearchAgentsPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first AgtResearchAgents that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {agtResearchAgentsFindFirstArgs} args - Arguments to find a AgtResearchAgents
     * @example
     * // Get one AgtResearchAgents
     * const agtResearchAgents = await prisma.agtResearchAgents.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends agtResearchAgentsFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, agtResearchAgentsFindFirstArgs<ExtArgs>>
    ): Prisma__agtResearchAgentsClient<$Result.GetResult<Prisma.$agtResearchAgentsPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first AgtResearchAgents that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {agtResearchAgentsFindFirstOrThrowArgs} args - Arguments to find a AgtResearchAgents
     * @example
     * // Get one AgtResearchAgents
     * const agtResearchAgents = await prisma.agtResearchAgents.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends agtResearchAgentsFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, agtResearchAgentsFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__agtResearchAgentsClient<$Result.GetResult<Prisma.$agtResearchAgentsPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more AgtResearchAgents that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {agtResearchAgentsFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AgtResearchAgents
     * const agtResearchAgents = await prisma.agtResearchAgents.findMany()
     * 
     * // Get first 10 AgtResearchAgents
     * const agtResearchAgents = await prisma.agtResearchAgents.findMany({ take: 10 })
     * 
     * // Only select the `agentID`
     * const agtResearchAgentsWithAgentIDOnly = await prisma.agtResearchAgents.findMany({ select: { agentID: true } })
     * 
    **/
    findMany<T extends agtResearchAgentsFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, agtResearchAgentsFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$agtResearchAgentsPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a AgtResearchAgents.
     * @param {agtResearchAgentsCreateArgs} args - Arguments to create a AgtResearchAgents.
     * @example
     * // Create one AgtResearchAgents
     * const AgtResearchAgents = await prisma.agtResearchAgents.create({
     *   data: {
     *     // ... data to create a AgtResearchAgents
     *   }
     * })
     * 
    **/
    create<T extends agtResearchAgentsCreateArgs<ExtArgs>>(
      args: SelectSubset<T, agtResearchAgentsCreateArgs<ExtArgs>>
    ): Prisma__agtResearchAgentsClient<$Result.GetResult<Prisma.$agtResearchAgentsPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many AgtResearchAgents.
     *     @param {agtResearchAgentsCreateManyArgs} args - Arguments to create many AgtResearchAgents.
     *     @example
     *     // Create many AgtResearchAgents
     *     const agtResearchAgents = await prisma.agtResearchAgents.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends agtResearchAgentsCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, agtResearchAgentsCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a AgtResearchAgents.
     * @param {agtResearchAgentsDeleteArgs} args - Arguments to delete one AgtResearchAgents.
     * @example
     * // Delete one AgtResearchAgents
     * const AgtResearchAgents = await prisma.agtResearchAgents.delete({
     *   where: {
     *     // ... filter to delete one AgtResearchAgents
     *   }
     * })
     * 
    **/
    delete<T extends agtResearchAgentsDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, agtResearchAgentsDeleteArgs<ExtArgs>>
    ): Prisma__agtResearchAgentsClient<$Result.GetResult<Prisma.$agtResearchAgentsPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one AgtResearchAgents.
     * @param {agtResearchAgentsUpdateArgs} args - Arguments to update one AgtResearchAgents.
     * @example
     * // Update one AgtResearchAgents
     * const agtResearchAgents = await prisma.agtResearchAgents.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends agtResearchAgentsUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, agtResearchAgentsUpdateArgs<ExtArgs>>
    ): Prisma__agtResearchAgentsClient<$Result.GetResult<Prisma.$agtResearchAgentsPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more AgtResearchAgents.
     * @param {agtResearchAgentsDeleteManyArgs} args - Arguments to filter AgtResearchAgents to delete.
     * @example
     * // Delete a few AgtResearchAgents
     * const { count } = await prisma.agtResearchAgents.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends agtResearchAgentsDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, agtResearchAgentsDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AgtResearchAgents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {agtResearchAgentsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AgtResearchAgents
     * const agtResearchAgents = await prisma.agtResearchAgents.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends agtResearchAgentsUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, agtResearchAgentsUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one AgtResearchAgents.
     * @param {agtResearchAgentsUpsertArgs} args - Arguments to update or create a AgtResearchAgents.
     * @example
     * // Update or create a AgtResearchAgents
     * const agtResearchAgents = await prisma.agtResearchAgents.upsert({
     *   create: {
     *     // ... data to create a AgtResearchAgents
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AgtResearchAgents we want to update
     *   }
     * })
    **/
    upsert<T extends agtResearchAgentsUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, agtResearchAgentsUpsertArgs<ExtArgs>>
    ): Prisma__agtResearchAgentsClient<$Result.GetResult<Prisma.$agtResearchAgentsPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of AgtResearchAgents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {agtResearchAgentsCountArgs} args - Arguments to filter AgtResearchAgents to count.
     * @example
     * // Count the number of AgtResearchAgents
     * const count = await prisma.agtResearchAgents.count({
     *   where: {
     *     // ... the filter for the AgtResearchAgents we want to count
     *   }
     * })
    **/
    count<T extends agtResearchAgentsCountArgs>(
      args?: Subset<T, agtResearchAgentsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AgtResearchAgentsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AgtResearchAgents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgtResearchAgentsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AgtResearchAgentsAggregateArgs>(args: Subset<T, AgtResearchAgentsAggregateArgs>): Prisma.PrismaPromise<GetAgtResearchAgentsAggregateType<T>>

    /**
     * Group by AgtResearchAgents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {agtResearchAgentsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends agtResearchAgentsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: agtResearchAgentsGroupByArgs['orderBy'] }
        : { orderBy?: agtResearchAgentsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, agtResearchAgentsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAgtResearchAgentsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the agtResearchAgents model
   */
  readonly fields: agtResearchAgentsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for agtResearchAgents.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__agtResearchAgentsClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';


    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the agtResearchAgents model
   */ 
  interface agtResearchAgentsFieldRefs {
    readonly agentID: FieldRef<"agtResearchAgents", 'Int'>
    readonly typeID: FieldRef<"agtResearchAgents", 'Int'>
  }
    

  // Custom InputTypes

  /**
   * agtResearchAgents findUnique
   */
  export type agtResearchAgentsFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the agtResearchAgents
     */
    select?: agtResearchAgentsSelect<ExtArgs> | null
    /**
     * Filter, which agtResearchAgents to fetch.
     */
    where: agtResearchAgentsWhereUniqueInput
  }


  /**
   * agtResearchAgents findUniqueOrThrow
   */
  export type agtResearchAgentsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the agtResearchAgents
     */
    select?: agtResearchAgentsSelect<ExtArgs> | null
    /**
     * Filter, which agtResearchAgents to fetch.
     */
    where: agtResearchAgentsWhereUniqueInput
  }


  /**
   * agtResearchAgents findFirst
   */
  export type agtResearchAgentsFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the agtResearchAgents
     */
    select?: agtResearchAgentsSelect<ExtArgs> | null
    /**
     * Filter, which agtResearchAgents to fetch.
     */
    where?: agtResearchAgentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of agtResearchAgents to fetch.
     */
    orderBy?: agtResearchAgentsOrderByWithRelationInput | agtResearchAgentsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for agtResearchAgents.
     */
    cursor?: agtResearchAgentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` agtResearchAgents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` agtResearchAgents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of agtResearchAgents.
     */
    distinct?: AgtResearchAgentsScalarFieldEnum | AgtResearchAgentsScalarFieldEnum[]
  }


  /**
   * agtResearchAgents findFirstOrThrow
   */
  export type agtResearchAgentsFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the agtResearchAgents
     */
    select?: agtResearchAgentsSelect<ExtArgs> | null
    /**
     * Filter, which agtResearchAgents to fetch.
     */
    where?: agtResearchAgentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of agtResearchAgents to fetch.
     */
    orderBy?: agtResearchAgentsOrderByWithRelationInput | agtResearchAgentsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for agtResearchAgents.
     */
    cursor?: agtResearchAgentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` agtResearchAgents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` agtResearchAgents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of agtResearchAgents.
     */
    distinct?: AgtResearchAgentsScalarFieldEnum | AgtResearchAgentsScalarFieldEnum[]
  }


  /**
   * agtResearchAgents findMany
   */
  export type agtResearchAgentsFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the agtResearchAgents
     */
    select?: agtResearchAgentsSelect<ExtArgs> | null
    /**
     * Filter, which agtResearchAgents to fetch.
     */
    where?: agtResearchAgentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of agtResearchAgents to fetch.
     */
    orderBy?: agtResearchAgentsOrderByWithRelationInput | agtResearchAgentsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing agtResearchAgents.
     */
    cursor?: agtResearchAgentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` agtResearchAgents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` agtResearchAgents.
     */
    skip?: number
    distinct?: AgtResearchAgentsScalarFieldEnum | AgtResearchAgentsScalarFieldEnum[]
  }


  /**
   * agtResearchAgents create
   */
  export type agtResearchAgentsCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the agtResearchAgents
     */
    select?: agtResearchAgentsSelect<ExtArgs> | null
    /**
     * The data needed to create a agtResearchAgents.
     */
    data: XOR<agtResearchAgentsCreateInput, agtResearchAgentsUncheckedCreateInput>
  }


  /**
   * agtResearchAgents createMany
   */
  export type agtResearchAgentsCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many agtResearchAgents.
     */
    data: agtResearchAgentsCreateManyInput | agtResearchAgentsCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * agtResearchAgents update
   */
  export type agtResearchAgentsUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the agtResearchAgents
     */
    select?: agtResearchAgentsSelect<ExtArgs> | null
    /**
     * The data needed to update a agtResearchAgents.
     */
    data: XOR<agtResearchAgentsUpdateInput, agtResearchAgentsUncheckedUpdateInput>
    /**
     * Choose, which agtResearchAgents to update.
     */
    where: agtResearchAgentsWhereUniqueInput
  }


  /**
   * agtResearchAgents updateMany
   */
  export type agtResearchAgentsUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update agtResearchAgents.
     */
    data: XOR<agtResearchAgentsUpdateManyMutationInput, agtResearchAgentsUncheckedUpdateManyInput>
    /**
     * Filter which agtResearchAgents to update
     */
    where?: agtResearchAgentsWhereInput
  }


  /**
   * agtResearchAgents upsert
   */
  export type agtResearchAgentsUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the agtResearchAgents
     */
    select?: agtResearchAgentsSelect<ExtArgs> | null
    /**
     * The filter to search for the agtResearchAgents to update in case it exists.
     */
    where: agtResearchAgentsWhereUniqueInput
    /**
     * In case the agtResearchAgents found by the `where` argument doesn't exist, create a new agtResearchAgents with this data.
     */
    create: XOR<agtResearchAgentsCreateInput, agtResearchAgentsUncheckedCreateInput>
    /**
     * In case the agtResearchAgents was found with the provided `where` argument, update it with this data.
     */
    update: XOR<agtResearchAgentsUpdateInput, agtResearchAgentsUncheckedUpdateInput>
  }


  /**
   * agtResearchAgents delete
   */
  export type agtResearchAgentsDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the agtResearchAgents
     */
    select?: agtResearchAgentsSelect<ExtArgs> | null
    /**
     * Filter which agtResearchAgents to delete.
     */
    where: agtResearchAgentsWhereUniqueInput
  }


  /**
   * agtResearchAgents deleteMany
   */
  export type agtResearchAgentsDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which agtResearchAgents to delete
     */
    where?: agtResearchAgentsWhereInput
  }


  /**
   * agtResearchAgents without action
   */
  export type agtResearchAgentsDefaultArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the agtResearchAgents
     */
    select?: agtResearchAgentsSelect<ExtArgs> | null
  }



  /**
   * Model certCerts
   */

  export type AggregateCertCerts = {
    _count: CertCertsCountAggregateOutputType | null
    _avg: CertCertsAvgAggregateOutputType | null
    _sum: CertCertsSumAggregateOutputType | null
    _min: CertCertsMinAggregateOutputType | null
    _max: CertCertsMaxAggregateOutputType | null
  }

  export type CertCertsAvgAggregateOutputType = {
    certID: number | null
    groupID: number | null
  }

  export type CertCertsSumAggregateOutputType = {
    certID: number | null
    groupID: number | null
  }

  export type CertCertsMinAggregateOutputType = {
    certID: number | null
    description: string | null
    groupID: number | null
    name: string | null
  }

  export type CertCertsMaxAggregateOutputType = {
    certID: number | null
    description: string | null
    groupID: number | null
    name: string | null
  }

  export type CertCertsCountAggregateOutputType = {
    certID: number
    description: number
    groupID: number
    name: number
    _all: number
  }


  export type CertCertsAvgAggregateInputType = {
    certID?: true
    groupID?: true
  }

  export type CertCertsSumAggregateInputType = {
    certID?: true
    groupID?: true
  }

  export type CertCertsMinAggregateInputType = {
    certID?: true
    description?: true
    groupID?: true
    name?: true
  }

  export type CertCertsMaxAggregateInputType = {
    certID?: true
    description?: true
    groupID?: true
    name?: true
  }

  export type CertCertsCountAggregateInputType = {
    certID?: true
    description?: true
    groupID?: true
    name?: true
    _all?: true
  }

  export type CertCertsAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which certCerts to aggregate.
     */
    where?: certCertsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of certCerts to fetch.
     */
    orderBy?: certCertsOrderByWithRelationInput | certCertsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: certCertsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` certCerts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` certCerts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned certCerts
    **/
    _count?: true | CertCertsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CertCertsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CertCertsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CertCertsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CertCertsMaxAggregateInputType
  }

  export type GetCertCertsAggregateType<T extends CertCertsAggregateArgs> = {
        [P in keyof T & keyof AggregateCertCerts]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCertCerts[P]>
      : GetScalarType<T[P], AggregateCertCerts[P]>
  }




  export type certCertsGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: certCertsWhereInput
    orderBy?: certCertsOrderByWithAggregationInput | certCertsOrderByWithAggregationInput[]
    by: CertCertsScalarFieldEnum[] | CertCertsScalarFieldEnum
    having?: certCertsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CertCertsCountAggregateInputType | true
    _avg?: CertCertsAvgAggregateInputType
    _sum?: CertCertsSumAggregateInputType
    _min?: CertCertsMinAggregateInputType
    _max?: CertCertsMaxAggregateInputType
  }

  export type CertCertsGroupByOutputType = {
    certID: number
    description: string | null
    groupID: number | null
    name: string | null
    _count: CertCertsCountAggregateOutputType | null
    _avg: CertCertsAvgAggregateOutputType | null
    _sum: CertCertsSumAggregateOutputType | null
    _min: CertCertsMinAggregateOutputType | null
    _max: CertCertsMaxAggregateOutputType | null
  }

  type GetCertCertsGroupByPayload<T extends certCertsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CertCertsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CertCertsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CertCertsGroupByOutputType[P]>
            : GetScalarType<T[P], CertCertsGroupByOutputType[P]>
        }
      >
    >


  export type certCertsSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    certID?: boolean
    description?: boolean
    groupID?: boolean
    name?: boolean
  }, ExtArgs["result"]["certCerts"]>

  export type certCertsSelectScalar = {
    certID?: boolean
    description?: boolean
    groupID?: boolean
    name?: boolean
  }


  export type $certCertsPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    name: "certCerts"
    objects: {}
    scalars: $Extensions.GetResult<{
      certID: number
      description: string | null
      groupID: number | null
      name: string | null
    }, ExtArgs["result"]["certCerts"]>
    composites: {}
  }


  type certCertsGetPayload<S extends boolean | null | undefined | certCertsDefaultArgs> = $Result.GetResult<Prisma.$certCertsPayload, S>

  type certCertsCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<certCertsFindManyArgs, 'select' | 'include'> & {
      select?: CertCertsCountAggregateInputType | true
    }

  export interface certCertsDelegate<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['certCerts'], meta: { name: 'certCerts' } }
    /**
     * Find zero or one CertCerts that matches the filter.
     * @param {certCertsFindUniqueArgs} args - Arguments to find a CertCerts
     * @example
     * // Get one CertCerts
     * const certCerts = await prisma.certCerts.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends certCertsFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, certCertsFindUniqueArgs<ExtArgs>>
    ): Prisma__certCertsClient<$Result.GetResult<Prisma.$certCertsPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one CertCerts that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {certCertsFindUniqueOrThrowArgs} args - Arguments to find a CertCerts
     * @example
     * // Get one CertCerts
     * const certCerts = await prisma.certCerts.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends certCertsFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, certCertsFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__certCertsClient<$Result.GetResult<Prisma.$certCertsPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first CertCerts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {certCertsFindFirstArgs} args - Arguments to find a CertCerts
     * @example
     * // Get one CertCerts
     * const certCerts = await prisma.certCerts.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends certCertsFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, certCertsFindFirstArgs<ExtArgs>>
    ): Prisma__certCertsClient<$Result.GetResult<Prisma.$certCertsPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first CertCerts that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {certCertsFindFirstOrThrowArgs} args - Arguments to find a CertCerts
     * @example
     * // Get one CertCerts
     * const certCerts = await prisma.certCerts.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends certCertsFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, certCertsFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__certCertsClient<$Result.GetResult<Prisma.$certCertsPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more CertCerts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {certCertsFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CertCerts
     * const certCerts = await prisma.certCerts.findMany()
     * 
     * // Get first 10 CertCerts
     * const certCerts = await prisma.certCerts.findMany({ take: 10 })
     * 
     * // Only select the `certID`
     * const certCertsWithCertIDOnly = await prisma.certCerts.findMany({ select: { certID: true } })
     * 
    **/
    findMany<T extends certCertsFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, certCertsFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$certCertsPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a CertCerts.
     * @param {certCertsCreateArgs} args - Arguments to create a CertCerts.
     * @example
     * // Create one CertCerts
     * const CertCerts = await prisma.certCerts.create({
     *   data: {
     *     // ... data to create a CertCerts
     *   }
     * })
     * 
    **/
    create<T extends certCertsCreateArgs<ExtArgs>>(
      args: SelectSubset<T, certCertsCreateArgs<ExtArgs>>
    ): Prisma__certCertsClient<$Result.GetResult<Prisma.$certCertsPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many CertCerts.
     *     @param {certCertsCreateManyArgs} args - Arguments to create many CertCerts.
     *     @example
     *     // Create many CertCerts
     *     const certCerts = await prisma.certCerts.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends certCertsCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, certCertsCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a CertCerts.
     * @param {certCertsDeleteArgs} args - Arguments to delete one CertCerts.
     * @example
     * // Delete one CertCerts
     * const CertCerts = await prisma.certCerts.delete({
     *   where: {
     *     // ... filter to delete one CertCerts
     *   }
     * })
     * 
    **/
    delete<T extends certCertsDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, certCertsDeleteArgs<ExtArgs>>
    ): Prisma__certCertsClient<$Result.GetResult<Prisma.$certCertsPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one CertCerts.
     * @param {certCertsUpdateArgs} args - Arguments to update one CertCerts.
     * @example
     * // Update one CertCerts
     * const certCerts = await prisma.certCerts.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends certCertsUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, certCertsUpdateArgs<ExtArgs>>
    ): Prisma__certCertsClient<$Result.GetResult<Prisma.$certCertsPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more CertCerts.
     * @param {certCertsDeleteManyArgs} args - Arguments to filter CertCerts to delete.
     * @example
     * // Delete a few CertCerts
     * const { count } = await prisma.certCerts.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends certCertsDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, certCertsDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CertCerts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {certCertsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CertCerts
     * const certCerts = await prisma.certCerts.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends certCertsUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, certCertsUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one CertCerts.
     * @param {certCertsUpsertArgs} args - Arguments to update or create a CertCerts.
     * @example
     * // Update or create a CertCerts
     * const certCerts = await prisma.certCerts.upsert({
     *   create: {
     *     // ... data to create a CertCerts
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CertCerts we want to update
     *   }
     * })
    **/
    upsert<T extends certCertsUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, certCertsUpsertArgs<ExtArgs>>
    ): Prisma__certCertsClient<$Result.GetResult<Prisma.$certCertsPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of CertCerts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {certCertsCountArgs} args - Arguments to filter CertCerts to count.
     * @example
     * // Count the number of CertCerts
     * const count = await prisma.certCerts.count({
     *   where: {
     *     // ... the filter for the CertCerts we want to count
     *   }
     * })
    **/
    count<T extends certCertsCountArgs>(
      args?: Subset<T, certCertsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CertCertsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CertCerts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CertCertsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CertCertsAggregateArgs>(args: Subset<T, CertCertsAggregateArgs>): Prisma.PrismaPromise<GetCertCertsAggregateType<T>>

    /**
     * Group by CertCerts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {certCertsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends certCertsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: certCertsGroupByArgs['orderBy'] }
        : { orderBy?: certCertsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, certCertsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCertCertsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the certCerts model
   */
  readonly fields: certCertsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for certCerts.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__certCertsClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';


    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the certCerts model
   */ 
  interface certCertsFieldRefs {
    readonly certID: FieldRef<"certCerts", 'Int'>
    readonly description: FieldRef<"certCerts", 'String'>
    readonly groupID: FieldRef<"certCerts", 'Int'>
    readonly name: FieldRef<"certCerts", 'String'>
  }
    

  // Custom InputTypes

  /**
   * certCerts findUnique
   */
  export type certCertsFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the certCerts
     */
    select?: certCertsSelect<ExtArgs> | null
    /**
     * Filter, which certCerts to fetch.
     */
    where: certCertsWhereUniqueInput
  }


  /**
   * certCerts findUniqueOrThrow
   */
  export type certCertsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the certCerts
     */
    select?: certCertsSelect<ExtArgs> | null
    /**
     * Filter, which certCerts to fetch.
     */
    where: certCertsWhereUniqueInput
  }


  /**
   * certCerts findFirst
   */
  export type certCertsFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the certCerts
     */
    select?: certCertsSelect<ExtArgs> | null
    /**
     * Filter, which certCerts to fetch.
     */
    where?: certCertsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of certCerts to fetch.
     */
    orderBy?: certCertsOrderByWithRelationInput | certCertsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for certCerts.
     */
    cursor?: certCertsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` certCerts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` certCerts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of certCerts.
     */
    distinct?: CertCertsScalarFieldEnum | CertCertsScalarFieldEnum[]
  }


  /**
   * certCerts findFirstOrThrow
   */
  export type certCertsFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the certCerts
     */
    select?: certCertsSelect<ExtArgs> | null
    /**
     * Filter, which certCerts to fetch.
     */
    where?: certCertsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of certCerts to fetch.
     */
    orderBy?: certCertsOrderByWithRelationInput | certCertsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for certCerts.
     */
    cursor?: certCertsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` certCerts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` certCerts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of certCerts.
     */
    distinct?: CertCertsScalarFieldEnum | CertCertsScalarFieldEnum[]
  }


  /**
   * certCerts findMany
   */
  export type certCertsFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the certCerts
     */
    select?: certCertsSelect<ExtArgs> | null
    /**
     * Filter, which certCerts to fetch.
     */
    where?: certCertsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of certCerts to fetch.
     */
    orderBy?: certCertsOrderByWithRelationInput | certCertsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing certCerts.
     */
    cursor?: certCertsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` certCerts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` certCerts.
     */
    skip?: number
    distinct?: CertCertsScalarFieldEnum | CertCertsScalarFieldEnum[]
  }


  /**
   * certCerts create
   */
  export type certCertsCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the certCerts
     */
    select?: certCertsSelect<ExtArgs> | null
    /**
     * The data needed to create a certCerts.
     */
    data: XOR<certCertsCreateInput, certCertsUncheckedCreateInput>
  }


  /**
   * certCerts createMany
   */
  export type certCertsCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many certCerts.
     */
    data: certCertsCreateManyInput | certCertsCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * certCerts update
   */
  export type certCertsUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the certCerts
     */
    select?: certCertsSelect<ExtArgs> | null
    /**
     * The data needed to update a certCerts.
     */
    data: XOR<certCertsUpdateInput, certCertsUncheckedUpdateInput>
    /**
     * Choose, which certCerts to update.
     */
    where: certCertsWhereUniqueInput
  }


  /**
   * certCerts updateMany
   */
  export type certCertsUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update certCerts.
     */
    data: XOR<certCertsUpdateManyMutationInput, certCertsUncheckedUpdateManyInput>
    /**
     * Filter which certCerts to update
     */
    where?: certCertsWhereInput
  }


  /**
   * certCerts upsert
   */
  export type certCertsUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the certCerts
     */
    select?: certCertsSelect<ExtArgs> | null
    /**
     * The filter to search for the certCerts to update in case it exists.
     */
    where: certCertsWhereUniqueInput
    /**
     * In case the certCerts found by the `where` argument doesn't exist, create a new certCerts with this data.
     */
    create: XOR<certCertsCreateInput, certCertsUncheckedCreateInput>
    /**
     * In case the certCerts was found with the provided `where` argument, update it with this data.
     */
    update: XOR<certCertsUpdateInput, certCertsUncheckedUpdateInput>
  }


  /**
   * certCerts delete
   */
  export type certCertsDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the certCerts
     */
    select?: certCertsSelect<ExtArgs> | null
    /**
     * Filter which certCerts to delete.
     */
    where: certCertsWhereUniqueInput
  }


  /**
   * certCerts deleteMany
   */
  export type certCertsDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which certCerts to delete
     */
    where?: certCertsWhereInput
  }


  /**
   * certCerts without action
   */
  export type certCertsDefaultArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the certCerts
     */
    select?: certCertsSelect<ExtArgs> | null
  }



  /**
   * Model chrAncestries
   */

  export type AggregateChrAncestries = {
    _count: ChrAncestriesCountAggregateOutputType | null
    _avg: ChrAncestriesAvgAggregateOutputType | null
    _sum: ChrAncestriesSumAggregateOutputType | null
    _min: ChrAncestriesMinAggregateOutputType | null
    _max: ChrAncestriesMaxAggregateOutputType | null
  }

  export type ChrAncestriesAvgAggregateOutputType = {
    ancestryID: number | null
    bloodlineID: number | null
    perception: number | null
    willpower: number | null
    charisma: number | null
    memory: number | null
    intelligence: number | null
    iconID: number | null
  }

  export type ChrAncestriesSumAggregateOutputType = {
    ancestryID: number | null
    bloodlineID: number | null
    perception: number | null
    willpower: number | null
    charisma: number | null
    memory: number | null
    intelligence: number | null
    iconID: number | null
  }

  export type ChrAncestriesMinAggregateOutputType = {
    ancestryID: number | null
    ancestryName: string | null
    bloodlineID: number | null
    description: string | null
    perception: number | null
    willpower: number | null
    charisma: number | null
    memory: number | null
    intelligence: number | null
    iconID: number | null
    shortDescription: string | null
  }

  export type ChrAncestriesMaxAggregateOutputType = {
    ancestryID: number | null
    ancestryName: string | null
    bloodlineID: number | null
    description: string | null
    perception: number | null
    willpower: number | null
    charisma: number | null
    memory: number | null
    intelligence: number | null
    iconID: number | null
    shortDescription: string | null
  }

  export type ChrAncestriesCountAggregateOutputType = {
    ancestryID: number
    ancestryName: number
    bloodlineID: number
    description: number
    perception: number
    willpower: number
    charisma: number
    memory: number
    intelligence: number
    iconID: number
    shortDescription: number
    _all: number
  }


  export type ChrAncestriesAvgAggregateInputType = {
    ancestryID?: true
    bloodlineID?: true
    perception?: true
    willpower?: true
    charisma?: true
    memory?: true
    intelligence?: true
    iconID?: true
  }

  export type ChrAncestriesSumAggregateInputType = {
    ancestryID?: true
    bloodlineID?: true
    perception?: true
    willpower?: true
    charisma?: true
    memory?: true
    intelligence?: true
    iconID?: true
  }

  export type ChrAncestriesMinAggregateInputType = {
    ancestryID?: true
    ancestryName?: true
    bloodlineID?: true
    description?: true
    perception?: true
    willpower?: true
    charisma?: true
    memory?: true
    intelligence?: true
    iconID?: true
    shortDescription?: true
  }

  export type ChrAncestriesMaxAggregateInputType = {
    ancestryID?: true
    ancestryName?: true
    bloodlineID?: true
    description?: true
    perception?: true
    willpower?: true
    charisma?: true
    memory?: true
    intelligence?: true
    iconID?: true
    shortDescription?: true
  }

  export type ChrAncestriesCountAggregateInputType = {
    ancestryID?: true
    ancestryName?: true
    bloodlineID?: true
    description?: true
    perception?: true
    willpower?: true
    charisma?: true
    memory?: true
    intelligence?: true
    iconID?: true
    shortDescription?: true
    _all?: true
  }

  export type ChrAncestriesAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which chrAncestries to aggregate.
     */
    where?: chrAncestriesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of chrAncestries to fetch.
     */
    orderBy?: chrAncestriesOrderByWithRelationInput | chrAncestriesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: chrAncestriesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` chrAncestries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` chrAncestries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned chrAncestries
    **/
    _count?: true | ChrAncestriesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ChrAncestriesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ChrAncestriesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ChrAncestriesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ChrAncestriesMaxAggregateInputType
  }

  export type GetChrAncestriesAggregateType<T extends ChrAncestriesAggregateArgs> = {
        [P in keyof T & keyof AggregateChrAncestries]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateChrAncestries[P]>
      : GetScalarType<T[P], AggregateChrAncestries[P]>
  }




  export type chrAncestriesGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: chrAncestriesWhereInput
    orderBy?: chrAncestriesOrderByWithAggregationInput | chrAncestriesOrderByWithAggregationInput[]
    by: ChrAncestriesScalarFieldEnum[] | ChrAncestriesScalarFieldEnum
    having?: chrAncestriesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ChrAncestriesCountAggregateInputType | true
    _avg?: ChrAncestriesAvgAggregateInputType
    _sum?: ChrAncestriesSumAggregateInputType
    _min?: ChrAncestriesMinAggregateInputType
    _max?: ChrAncestriesMaxAggregateInputType
  }

  export type ChrAncestriesGroupByOutputType = {
    ancestryID: number
    ancestryName: string | null
    bloodlineID: number | null
    description: string | null
    perception: number | null
    willpower: number | null
    charisma: number | null
    memory: number | null
    intelligence: number | null
    iconID: number | null
    shortDescription: string | null
    _count: ChrAncestriesCountAggregateOutputType | null
    _avg: ChrAncestriesAvgAggregateOutputType | null
    _sum: ChrAncestriesSumAggregateOutputType | null
    _min: ChrAncestriesMinAggregateOutputType | null
    _max: ChrAncestriesMaxAggregateOutputType | null
  }

  type GetChrAncestriesGroupByPayload<T extends chrAncestriesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ChrAncestriesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ChrAncestriesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ChrAncestriesGroupByOutputType[P]>
            : GetScalarType<T[P], ChrAncestriesGroupByOutputType[P]>
        }
      >
    >


  export type chrAncestriesSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    ancestryID?: boolean
    ancestryName?: boolean
    bloodlineID?: boolean
    description?: boolean
    perception?: boolean
    willpower?: boolean
    charisma?: boolean
    memory?: boolean
    intelligence?: boolean
    iconID?: boolean
    shortDescription?: boolean
  }, ExtArgs["result"]["chrAncestries"]>

  export type chrAncestriesSelectScalar = {
    ancestryID?: boolean
    ancestryName?: boolean
    bloodlineID?: boolean
    description?: boolean
    perception?: boolean
    willpower?: boolean
    charisma?: boolean
    memory?: boolean
    intelligence?: boolean
    iconID?: boolean
    shortDescription?: boolean
  }


  export type $chrAncestriesPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    name: "chrAncestries"
    objects: {}
    scalars: $Extensions.GetResult<{
      ancestryID: number
      ancestryName: string | null
      bloodlineID: number | null
      description: string | null
      perception: number | null
      willpower: number | null
      charisma: number | null
      memory: number | null
      intelligence: number | null
      iconID: number | null
      shortDescription: string | null
    }, ExtArgs["result"]["chrAncestries"]>
    composites: {}
  }


  type chrAncestriesGetPayload<S extends boolean | null | undefined | chrAncestriesDefaultArgs> = $Result.GetResult<Prisma.$chrAncestriesPayload, S>

  type chrAncestriesCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<chrAncestriesFindManyArgs, 'select' | 'include'> & {
      select?: ChrAncestriesCountAggregateInputType | true
    }

  export interface chrAncestriesDelegate<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['chrAncestries'], meta: { name: 'chrAncestries' } }
    /**
     * Find zero or one ChrAncestries that matches the filter.
     * @param {chrAncestriesFindUniqueArgs} args - Arguments to find a ChrAncestries
     * @example
     * // Get one ChrAncestries
     * const chrAncestries = await prisma.chrAncestries.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends chrAncestriesFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, chrAncestriesFindUniqueArgs<ExtArgs>>
    ): Prisma__chrAncestriesClient<$Result.GetResult<Prisma.$chrAncestriesPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one ChrAncestries that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {chrAncestriesFindUniqueOrThrowArgs} args - Arguments to find a ChrAncestries
     * @example
     * // Get one ChrAncestries
     * const chrAncestries = await prisma.chrAncestries.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends chrAncestriesFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, chrAncestriesFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__chrAncestriesClient<$Result.GetResult<Prisma.$chrAncestriesPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first ChrAncestries that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {chrAncestriesFindFirstArgs} args - Arguments to find a ChrAncestries
     * @example
     * // Get one ChrAncestries
     * const chrAncestries = await prisma.chrAncestries.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends chrAncestriesFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, chrAncestriesFindFirstArgs<ExtArgs>>
    ): Prisma__chrAncestriesClient<$Result.GetResult<Prisma.$chrAncestriesPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first ChrAncestries that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {chrAncestriesFindFirstOrThrowArgs} args - Arguments to find a ChrAncestries
     * @example
     * // Get one ChrAncestries
     * const chrAncestries = await prisma.chrAncestries.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends chrAncestriesFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, chrAncestriesFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__chrAncestriesClient<$Result.GetResult<Prisma.$chrAncestriesPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more ChrAncestries that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {chrAncestriesFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ChrAncestries
     * const chrAncestries = await prisma.chrAncestries.findMany()
     * 
     * // Get first 10 ChrAncestries
     * const chrAncestries = await prisma.chrAncestries.findMany({ take: 10 })
     * 
     * // Only select the `ancestryID`
     * const chrAncestriesWithAncestryIDOnly = await prisma.chrAncestries.findMany({ select: { ancestryID: true } })
     * 
    **/
    findMany<T extends chrAncestriesFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, chrAncestriesFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$chrAncestriesPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a ChrAncestries.
     * @param {chrAncestriesCreateArgs} args - Arguments to create a ChrAncestries.
     * @example
     * // Create one ChrAncestries
     * const ChrAncestries = await prisma.chrAncestries.create({
     *   data: {
     *     // ... data to create a ChrAncestries
     *   }
     * })
     * 
    **/
    create<T extends chrAncestriesCreateArgs<ExtArgs>>(
      args: SelectSubset<T, chrAncestriesCreateArgs<ExtArgs>>
    ): Prisma__chrAncestriesClient<$Result.GetResult<Prisma.$chrAncestriesPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many ChrAncestries.
     *     @param {chrAncestriesCreateManyArgs} args - Arguments to create many ChrAncestries.
     *     @example
     *     // Create many ChrAncestries
     *     const chrAncestries = await prisma.chrAncestries.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends chrAncestriesCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, chrAncestriesCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a ChrAncestries.
     * @param {chrAncestriesDeleteArgs} args - Arguments to delete one ChrAncestries.
     * @example
     * // Delete one ChrAncestries
     * const ChrAncestries = await prisma.chrAncestries.delete({
     *   where: {
     *     // ... filter to delete one ChrAncestries
     *   }
     * })
     * 
    **/
    delete<T extends chrAncestriesDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, chrAncestriesDeleteArgs<ExtArgs>>
    ): Prisma__chrAncestriesClient<$Result.GetResult<Prisma.$chrAncestriesPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one ChrAncestries.
     * @param {chrAncestriesUpdateArgs} args - Arguments to update one ChrAncestries.
     * @example
     * // Update one ChrAncestries
     * const chrAncestries = await prisma.chrAncestries.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends chrAncestriesUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, chrAncestriesUpdateArgs<ExtArgs>>
    ): Prisma__chrAncestriesClient<$Result.GetResult<Prisma.$chrAncestriesPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more ChrAncestries.
     * @param {chrAncestriesDeleteManyArgs} args - Arguments to filter ChrAncestries to delete.
     * @example
     * // Delete a few ChrAncestries
     * const { count } = await prisma.chrAncestries.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends chrAncestriesDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, chrAncestriesDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ChrAncestries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {chrAncestriesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ChrAncestries
     * const chrAncestries = await prisma.chrAncestries.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends chrAncestriesUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, chrAncestriesUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ChrAncestries.
     * @param {chrAncestriesUpsertArgs} args - Arguments to update or create a ChrAncestries.
     * @example
     * // Update or create a ChrAncestries
     * const chrAncestries = await prisma.chrAncestries.upsert({
     *   create: {
     *     // ... data to create a ChrAncestries
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ChrAncestries we want to update
     *   }
     * })
    **/
    upsert<T extends chrAncestriesUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, chrAncestriesUpsertArgs<ExtArgs>>
    ): Prisma__chrAncestriesClient<$Result.GetResult<Prisma.$chrAncestriesPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of ChrAncestries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {chrAncestriesCountArgs} args - Arguments to filter ChrAncestries to count.
     * @example
     * // Count the number of ChrAncestries
     * const count = await prisma.chrAncestries.count({
     *   where: {
     *     // ... the filter for the ChrAncestries we want to count
     *   }
     * })
    **/
    count<T extends chrAncestriesCountArgs>(
      args?: Subset<T, chrAncestriesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ChrAncestriesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ChrAncestries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChrAncestriesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ChrAncestriesAggregateArgs>(args: Subset<T, ChrAncestriesAggregateArgs>): Prisma.PrismaPromise<GetChrAncestriesAggregateType<T>>

    /**
     * Group by ChrAncestries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {chrAncestriesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends chrAncestriesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: chrAncestriesGroupByArgs['orderBy'] }
        : { orderBy?: chrAncestriesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, chrAncestriesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetChrAncestriesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the chrAncestries model
   */
  readonly fields: chrAncestriesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for chrAncestries.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__chrAncestriesClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';


    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the chrAncestries model
   */ 
  interface chrAncestriesFieldRefs {
    readonly ancestryID: FieldRef<"chrAncestries", 'Int'>
    readonly ancestryName: FieldRef<"chrAncestries", 'String'>
    readonly bloodlineID: FieldRef<"chrAncestries", 'Int'>
    readonly description: FieldRef<"chrAncestries", 'String'>
    readonly perception: FieldRef<"chrAncestries", 'Int'>
    readonly willpower: FieldRef<"chrAncestries", 'Int'>
    readonly charisma: FieldRef<"chrAncestries", 'Int'>
    readonly memory: FieldRef<"chrAncestries", 'Int'>
    readonly intelligence: FieldRef<"chrAncestries", 'Int'>
    readonly iconID: FieldRef<"chrAncestries", 'Int'>
    readonly shortDescription: FieldRef<"chrAncestries", 'String'>
  }
    

  // Custom InputTypes

  /**
   * chrAncestries findUnique
   */
  export type chrAncestriesFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the chrAncestries
     */
    select?: chrAncestriesSelect<ExtArgs> | null
    /**
     * Filter, which chrAncestries to fetch.
     */
    where: chrAncestriesWhereUniqueInput
  }


  /**
   * chrAncestries findUniqueOrThrow
   */
  export type chrAncestriesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the chrAncestries
     */
    select?: chrAncestriesSelect<ExtArgs> | null
    /**
     * Filter, which chrAncestries to fetch.
     */
    where: chrAncestriesWhereUniqueInput
  }


  /**
   * chrAncestries findFirst
   */
  export type chrAncestriesFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the chrAncestries
     */
    select?: chrAncestriesSelect<ExtArgs> | null
    /**
     * Filter, which chrAncestries to fetch.
     */
    where?: chrAncestriesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of chrAncestries to fetch.
     */
    orderBy?: chrAncestriesOrderByWithRelationInput | chrAncestriesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for chrAncestries.
     */
    cursor?: chrAncestriesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` chrAncestries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` chrAncestries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of chrAncestries.
     */
    distinct?: ChrAncestriesScalarFieldEnum | ChrAncestriesScalarFieldEnum[]
  }


  /**
   * chrAncestries findFirstOrThrow
   */
  export type chrAncestriesFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the chrAncestries
     */
    select?: chrAncestriesSelect<ExtArgs> | null
    /**
     * Filter, which chrAncestries to fetch.
     */
    where?: chrAncestriesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of chrAncestries to fetch.
     */
    orderBy?: chrAncestriesOrderByWithRelationInput | chrAncestriesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for chrAncestries.
     */
    cursor?: chrAncestriesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` chrAncestries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` chrAncestries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of chrAncestries.
     */
    distinct?: ChrAncestriesScalarFieldEnum | ChrAncestriesScalarFieldEnum[]
  }


  /**
   * chrAncestries findMany
   */
  export type chrAncestriesFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the chrAncestries
     */
    select?: chrAncestriesSelect<ExtArgs> | null
    /**
     * Filter, which chrAncestries to fetch.
     */
    where?: chrAncestriesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of chrAncestries to fetch.
     */
    orderBy?: chrAncestriesOrderByWithRelationInput | chrAncestriesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing chrAncestries.
     */
    cursor?: chrAncestriesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` chrAncestries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` chrAncestries.
     */
    skip?: number
    distinct?: ChrAncestriesScalarFieldEnum | ChrAncestriesScalarFieldEnum[]
  }


  /**
   * chrAncestries create
   */
  export type chrAncestriesCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the chrAncestries
     */
    select?: chrAncestriesSelect<ExtArgs> | null
    /**
     * The data needed to create a chrAncestries.
     */
    data: XOR<chrAncestriesCreateInput, chrAncestriesUncheckedCreateInput>
  }


  /**
   * chrAncestries createMany
   */
  export type chrAncestriesCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many chrAncestries.
     */
    data: chrAncestriesCreateManyInput | chrAncestriesCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * chrAncestries update
   */
  export type chrAncestriesUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the chrAncestries
     */
    select?: chrAncestriesSelect<ExtArgs> | null
    /**
     * The data needed to update a chrAncestries.
     */
    data: XOR<chrAncestriesUpdateInput, chrAncestriesUncheckedUpdateInput>
    /**
     * Choose, which chrAncestries to update.
     */
    where: chrAncestriesWhereUniqueInput
  }


  /**
   * chrAncestries updateMany
   */
  export type chrAncestriesUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update chrAncestries.
     */
    data: XOR<chrAncestriesUpdateManyMutationInput, chrAncestriesUncheckedUpdateManyInput>
    /**
     * Filter which chrAncestries to update
     */
    where?: chrAncestriesWhereInput
  }


  /**
   * chrAncestries upsert
   */
  export type chrAncestriesUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the chrAncestries
     */
    select?: chrAncestriesSelect<ExtArgs> | null
    /**
     * The filter to search for the chrAncestries to update in case it exists.
     */
    where: chrAncestriesWhereUniqueInput
    /**
     * In case the chrAncestries found by the `where` argument doesn't exist, create a new chrAncestries with this data.
     */
    create: XOR<chrAncestriesCreateInput, chrAncestriesUncheckedCreateInput>
    /**
     * In case the chrAncestries was found with the provided `where` argument, update it with this data.
     */
    update: XOR<chrAncestriesUpdateInput, chrAncestriesUncheckedUpdateInput>
  }


  /**
   * chrAncestries delete
   */
  export type chrAncestriesDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the chrAncestries
     */
    select?: chrAncestriesSelect<ExtArgs> | null
    /**
     * Filter which chrAncestries to delete.
     */
    where: chrAncestriesWhereUniqueInput
  }


  /**
   * chrAncestries deleteMany
   */
  export type chrAncestriesDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which chrAncestries to delete
     */
    where?: chrAncestriesWhereInput
  }


  /**
   * chrAncestries without action
   */
  export type chrAncestriesDefaultArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the chrAncestries
     */
    select?: chrAncestriesSelect<ExtArgs> | null
  }



  /**
   * Model chrAttributes
   */

  export type AggregateChrAttributes = {
    _count: ChrAttributesCountAggregateOutputType | null
    _avg: ChrAttributesAvgAggregateOutputType | null
    _sum: ChrAttributesSumAggregateOutputType | null
    _min: ChrAttributesMinAggregateOutputType | null
    _max: ChrAttributesMaxAggregateOutputType | null
  }

  export type ChrAttributesAvgAggregateOutputType = {
    attributeID: number | null
    iconID: number | null
  }

  export type ChrAttributesSumAggregateOutputType = {
    attributeID: number | null
    iconID: number | null
  }

  export type ChrAttributesMinAggregateOutputType = {
    attributeID: number | null
    attributeName: string | null
    description: string | null
    iconID: number | null
    shortDescription: string | null
    notes: string | null
  }

  export type ChrAttributesMaxAggregateOutputType = {
    attributeID: number | null
    attributeName: string | null
    description: string | null
    iconID: number | null
    shortDescription: string | null
    notes: string | null
  }

  export type ChrAttributesCountAggregateOutputType = {
    attributeID: number
    attributeName: number
    description: number
    iconID: number
    shortDescription: number
    notes: number
    _all: number
  }


  export type ChrAttributesAvgAggregateInputType = {
    attributeID?: true
    iconID?: true
  }

  export type ChrAttributesSumAggregateInputType = {
    attributeID?: true
    iconID?: true
  }

  export type ChrAttributesMinAggregateInputType = {
    attributeID?: true
    attributeName?: true
    description?: true
    iconID?: true
    shortDescription?: true
    notes?: true
  }

  export type ChrAttributesMaxAggregateInputType = {
    attributeID?: true
    attributeName?: true
    description?: true
    iconID?: true
    shortDescription?: true
    notes?: true
  }

  export type ChrAttributesCountAggregateInputType = {
    attributeID?: true
    attributeName?: true
    description?: true
    iconID?: true
    shortDescription?: true
    notes?: true
    _all?: true
  }

  export type ChrAttributesAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which chrAttributes to aggregate.
     */
    where?: chrAttributesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of chrAttributes to fetch.
     */
    orderBy?: chrAttributesOrderByWithRelationInput | chrAttributesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: chrAttributesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` chrAttributes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` chrAttributes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned chrAttributes
    **/
    _count?: true | ChrAttributesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ChrAttributesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ChrAttributesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ChrAttributesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ChrAttributesMaxAggregateInputType
  }

  export type GetChrAttributesAggregateType<T extends ChrAttributesAggregateArgs> = {
        [P in keyof T & keyof AggregateChrAttributes]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateChrAttributes[P]>
      : GetScalarType<T[P], AggregateChrAttributes[P]>
  }




  export type chrAttributesGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: chrAttributesWhereInput
    orderBy?: chrAttributesOrderByWithAggregationInput | chrAttributesOrderByWithAggregationInput[]
    by: ChrAttributesScalarFieldEnum[] | ChrAttributesScalarFieldEnum
    having?: chrAttributesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ChrAttributesCountAggregateInputType | true
    _avg?: ChrAttributesAvgAggregateInputType
    _sum?: ChrAttributesSumAggregateInputType
    _min?: ChrAttributesMinAggregateInputType
    _max?: ChrAttributesMaxAggregateInputType
  }

  export type ChrAttributesGroupByOutputType = {
    attributeID: number
    attributeName: string | null
    description: string | null
    iconID: number | null
    shortDescription: string | null
    notes: string | null
    _count: ChrAttributesCountAggregateOutputType | null
    _avg: ChrAttributesAvgAggregateOutputType | null
    _sum: ChrAttributesSumAggregateOutputType | null
    _min: ChrAttributesMinAggregateOutputType | null
    _max: ChrAttributesMaxAggregateOutputType | null
  }

  type GetChrAttributesGroupByPayload<T extends chrAttributesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ChrAttributesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ChrAttributesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ChrAttributesGroupByOutputType[P]>
            : GetScalarType<T[P], ChrAttributesGroupByOutputType[P]>
        }
      >
    >


  export type chrAttributesSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    attributeID?: boolean
    attributeName?: boolean
    description?: boolean
    iconID?: boolean
    shortDescription?: boolean
    notes?: boolean
  }, ExtArgs["result"]["chrAttributes"]>

  export type chrAttributesSelectScalar = {
    attributeID?: boolean
    attributeName?: boolean
    description?: boolean
    iconID?: boolean
    shortDescription?: boolean
    notes?: boolean
  }


  export type $chrAttributesPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    name: "chrAttributes"
    objects: {}
    scalars: $Extensions.GetResult<{
      attributeID: number
      attributeName: string | null
      description: string | null
      iconID: number | null
      shortDescription: string | null
      notes: string | null
    }, ExtArgs["result"]["chrAttributes"]>
    composites: {}
  }


  type chrAttributesGetPayload<S extends boolean | null | undefined | chrAttributesDefaultArgs> = $Result.GetResult<Prisma.$chrAttributesPayload, S>

  type chrAttributesCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<chrAttributesFindManyArgs, 'select' | 'include'> & {
      select?: ChrAttributesCountAggregateInputType | true
    }

  export interface chrAttributesDelegate<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['chrAttributes'], meta: { name: 'chrAttributes' } }
    /**
     * Find zero or one ChrAttributes that matches the filter.
     * @param {chrAttributesFindUniqueArgs} args - Arguments to find a ChrAttributes
     * @example
     * // Get one ChrAttributes
     * const chrAttributes = await prisma.chrAttributes.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends chrAttributesFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, chrAttributesFindUniqueArgs<ExtArgs>>
    ): Prisma__chrAttributesClient<$Result.GetResult<Prisma.$chrAttributesPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one ChrAttributes that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {chrAttributesFindUniqueOrThrowArgs} args - Arguments to find a ChrAttributes
     * @example
     * // Get one ChrAttributes
     * const chrAttributes = await prisma.chrAttributes.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends chrAttributesFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, chrAttributesFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__chrAttributesClient<$Result.GetResult<Prisma.$chrAttributesPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first ChrAttributes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {chrAttributesFindFirstArgs} args - Arguments to find a ChrAttributes
     * @example
     * // Get one ChrAttributes
     * const chrAttributes = await prisma.chrAttributes.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends chrAttributesFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, chrAttributesFindFirstArgs<ExtArgs>>
    ): Prisma__chrAttributesClient<$Result.GetResult<Prisma.$chrAttributesPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first ChrAttributes that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {chrAttributesFindFirstOrThrowArgs} args - Arguments to find a ChrAttributes
     * @example
     * // Get one ChrAttributes
     * const chrAttributes = await prisma.chrAttributes.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends chrAttributesFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, chrAttributesFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__chrAttributesClient<$Result.GetResult<Prisma.$chrAttributesPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more ChrAttributes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {chrAttributesFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ChrAttributes
     * const chrAttributes = await prisma.chrAttributes.findMany()
     * 
     * // Get first 10 ChrAttributes
     * const chrAttributes = await prisma.chrAttributes.findMany({ take: 10 })
     * 
     * // Only select the `attributeID`
     * const chrAttributesWithAttributeIDOnly = await prisma.chrAttributes.findMany({ select: { attributeID: true } })
     * 
    **/
    findMany<T extends chrAttributesFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, chrAttributesFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$chrAttributesPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a ChrAttributes.
     * @param {chrAttributesCreateArgs} args - Arguments to create a ChrAttributes.
     * @example
     * // Create one ChrAttributes
     * const ChrAttributes = await prisma.chrAttributes.create({
     *   data: {
     *     // ... data to create a ChrAttributes
     *   }
     * })
     * 
    **/
    create<T extends chrAttributesCreateArgs<ExtArgs>>(
      args: SelectSubset<T, chrAttributesCreateArgs<ExtArgs>>
    ): Prisma__chrAttributesClient<$Result.GetResult<Prisma.$chrAttributesPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many ChrAttributes.
     *     @param {chrAttributesCreateManyArgs} args - Arguments to create many ChrAttributes.
     *     @example
     *     // Create many ChrAttributes
     *     const chrAttributes = await prisma.chrAttributes.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends chrAttributesCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, chrAttributesCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a ChrAttributes.
     * @param {chrAttributesDeleteArgs} args - Arguments to delete one ChrAttributes.
     * @example
     * // Delete one ChrAttributes
     * const ChrAttributes = await prisma.chrAttributes.delete({
     *   where: {
     *     // ... filter to delete one ChrAttributes
     *   }
     * })
     * 
    **/
    delete<T extends chrAttributesDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, chrAttributesDeleteArgs<ExtArgs>>
    ): Prisma__chrAttributesClient<$Result.GetResult<Prisma.$chrAttributesPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one ChrAttributes.
     * @param {chrAttributesUpdateArgs} args - Arguments to update one ChrAttributes.
     * @example
     * // Update one ChrAttributes
     * const chrAttributes = await prisma.chrAttributes.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends chrAttributesUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, chrAttributesUpdateArgs<ExtArgs>>
    ): Prisma__chrAttributesClient<$Result.GetResult<Prisma.$chrAttributesPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more ChrAttributes.
     * @param {chrAttributesDeleteManyArgs} args - Arguments to filter ChrAttributes to delete.
     * @example
     * // Delete a few ChrAttributes
     * const { count } = await prisma.chrAttributes.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends chrAttributesDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, chrAttributesDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ChrAttributes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {chrAttributesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ChrAttributes
     * const chrAttributes = await prisma.chrAttributes.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends chrAttributesUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, chrAttributesUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ChrAttributes.
     * @param {chrAttributesUpsertArgs} args - Arguments to update or create a ChrAttributes.
     * @example
     * // Update or create a ChrAttributes
     * const chrAttributes = await prisma.chrAttributes.upsert({
     *   create: {
     *     // ... data to create a ChrAttributes
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ChrAttributes we want to update
     *   }
     * })
    **/
    upsert<T extends chrAttributesUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, chrAttributesUpsertArgs<ExtArgs>>
    ): Prisma__chrAttributesClient<$Result.GetResult<Prisma.$chrAttributesPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of ChrAttributes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {chrAttributesCountArgs} args - Arguments to filter ChrAttributes to count.
     * @example
     * // Count the number of ChrAttributes
     * const count = await prisma.chrAttributes.count({
     *   where: {
     *     // ... the filter for the ChrAttributes we want to count
     *   }
     * })
    **/
    count<T extends chrAttributesCountArgs>(
      args?: Subset<T, chrAttributesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ChrAttributesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ChrAttributes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChrAttributesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ChrAttributesAggregateArgs>(args: Subset<T, ChrAttributesAggregateArgs>): Prisma.PrismaPromise<GetChrAttributesAggregateType<T>>

    /**
     * Group by ChrAttributes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {chrAttributesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends chrAttributesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: chrAttributesGroupByArgs['orderBy'] }
        : { orderBy?: chrAttributesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, chrAttributesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetChrAttributesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the chrAttributes model
   */
  readonly fields: chrAttributesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for chrAttributes.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__chrAttributesClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';


    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the chrAttributes model
   */ 
  interface chrAttributesFieldRefs {
    readonly attributeID: FieldRef<"chrAttributes", 'Int'>
    readonly attributeName: FieldRef<"chrAttributes", 'String'>
    readonly description: FieldRef<"chrAttributes", 'String'>
    readonly iconID: FieldRef<"chrAttributes", 'Int'>
    readonly shortDescription: FieldRef<"chrAttributes", 'String'>
    readonly notes: FieldRef<"chrAttributes", 'String'>
  }
    

  // Custom InputTypes

  /**
   * chrAttributes findUnique
   */
  export type chrAttributesFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the chrAttributes
     */
    select?: chrAttributesSelect<ExtArgs> | null
    /**
     * Filter, which chrAttributes to fetch.
     */
    where: chrAttributesWhereUniqueInput
  }


  /**
   * chrAttributes findUniqueOrThrow
   */
  export type chrAttributesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the chrAttributes
     */
    select?: chrAttributesSelect<ExtArgs> | null
    /**
     * Filter, which chrAttributes to fetch.
     */
    where: chrAttributesWhereUniqueInput
  }


  /**
   * chrAttributes findFirst
   */
  export type chrAttributesFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the chrAttributes
     */
    select?: chrAttributesSelect<ExtArgs> | null
    /**
     * Filter, which chrAttributes to fetch.
     */
    where?: chrAttributesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of chrAttributes to fetch.
     */
    orderBy?: chrAttributesOrderByWithRelationInput | chrAttributesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for chrAttributes.
     */
    cursor?: chrAttributesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` chrAttributes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` chrAttributes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of chrAttributes.
     */
    distinct?: ChrAttributesScalarFieldEnum | ChrAttributesScalarFieldEnum[]
  }


  /**
   * chrAttributes findFirstOrThrow
   */
  export type chrAttributesFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the chrAttributes
     */
    select?: chrAttributesSelect<ExtArgs> | null
    /**
     * Filter, which chrAttributes to fetch.
     */
    where?: chrAttributesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of chrAttributes to fetch.
     */
    orderBy?: chrAttributesOrderByWithRelationInput | chrAttributesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for chrAttributes.
     */
    cursor?: chrAttributesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` chrAttributes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` chrAttributes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of chrAttributes.
     */
    distinct?: ChrAttributesScalarFieldEnum | ChrAttributesScalarFieldEnum[]
  }


  /**
   * chrAttributes findMany
   */
  export type chrAttributesFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the chrAttributes
     */
    select?: chrAttributesSelect<ExtArgs> | null
    /**
     * Filter, which chrAttributes to fetch.
     */
    where?: chrAttributesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of chrAttributes to fetch.
     */
    orderBy?: chrAttributesOrderByWithRelationInput | chrAttributesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing chrAttributes.
     */
    cursor?: chrAttributesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` chrAttributes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` chrAttributes.
     */
    skip?: number
    distinct?: ChrAttributesScalarFieldEnum | ChrAttributesScalarFieldEnum[]
  }


  /**
   * chrAttributes create
   */
  export type chrAttributesCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the chrAttributes
     */
    select?: chrAttributesSelect<ExtArgs> | null
    /**
     * The data needed to create a chrAttributes.
     */
    data: XOR<chrAttributesCreateInput, chrAttributesUncheckedCreateInput>
  }


  /**
   * chrAttributes createMany
   */
  export type chrAttributesCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many chrAttributes.
     */
    data: chrAttributesCreateManyInput | chrAttributesCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * chrAttributes update
   */
  export type chrAttributesUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the chrAttributes
     */
    select?: chrAttributesSelect<ExtArgs> | null
    /**
     * The data needed to update a chrAttributes.
     */
    data: XOR<chrAttributesUpdateInput, chrAttributesUncheckedUpdateInput>
    /**
     * Choose, which chrAttributes to update.
     */
    where: chrAttributesWhereUniqueInput
  }


  /**
   * chrAttributes updateMany
   */
  export type chrAttributesUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update chrAttributes.
     */
    data: XOR<chrAttributesUpdateManyMutationInput, chrAttributesUncheckedUpdateManyInput>
    /**
     * Filter which chrAttributes to update
     */
    where?: chrAttributesWhereInput
  }


  /**
   * chrAttributes upsert
   */
  export type chrAttributesUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the chrAttributes
     */
    select?: chrAttributesSelect<ExtArgs> | null
    /**
     * The filter to search for the chrAttributes to update in case it exists.
     */
    where: chrAttributesWhereUniqueInput
    /**
     * In case the chrAttributes found by the `where` argument doesn't exist, create a new chrAttributes with this data.
     */
    create: XOR<chrAttributesCreateInput, chrAttributesUncheckedCreateInput>
    /**
     * In case the chrAttributes was found with the provided `where` argument, update it with this data.
     */
    update: XOR<chrAttributesUpdateInput, chrAttributesUncheckedUpdateInput>
  }


  /**
   * chrAttributes delete
   */
  export type chrAttributesDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the chrAttributes
     */
    select?: chrAttributesSelect<ExtArgs> | null
    /**
     * Filter which chrAttributes to delete.
     */
    where: chrAttributesWhereUniqueInput
  }


  /**
   * chrAttributes deleteMany
   */
  export type chrAttributesDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which chrAttributes to delete
     */
    where?: chrAttributesWhereInput
  }


  /**
   * chrAttributes without action
   */
  export type chrAttributesDefaultArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the chrAttributes
     */
    select?: chrAttributesSelect<ExtArgs> | null
  }



  /**
   * Model chrBloodlines
   */

  export type AggregateChrBloodlines = {
    _count: ChrBloodlinesCountAggregateOutputType | null
    _avg: ChrBloodlinesAvgAggregateOutputType | null
    _sum: ChrBloodlinesSumAggregateOutputType | null
    _min: ChrBloodlinesMinAggregateOutputType | null
    _max: ChrBloodlinesMaxAggregateOutputType | null
  }

  export type ChrBloodlinesAvgAggregateOutputType = {
    bloodlineID: number | null
    raceID: number | null
    shipTypeID: number | null
    corporationID: number | null
    perception: number | null
    willpower: number | null
    charisma: number | null
    memory: number | null
    intelligence: number | null
    iconID: number | null
  }

  export type ChrBloodlinesSumAggregateOutputType = {
    bloodlineID: number | null
    raceID: number | null
    shipTypeID: number | null
    corporationID: number | null
    perception: number | null
    willpower: number | null
    charisma: number | null
    memory: number | null
    intelligence: number | null
    iconID: number | null
  }

  export type ChrBloodlinesMinAggregateOutputType = {
    bloodlineID: number | null
    bloodlineName: string | null
    raceID: number | null
    description: string | null
    maleDescription: string | null
    femaleDescription: string | null
    shipTypeID: number | null
    corporationID: number | null
    perception: number | null
    willpower: number | null
    charisma: number | null
    memory: number | null
    intelligence: number | null
    iconID: number | null
    shortDescription: string | null
    shortMaleDescription: string | null
    shortFemaleDescription: string | null
  }

  export type ChrBloodlinesMaxAggregateOutputType = {
    bloodlineID: number | null
    bloodlineName: string | null
    raceID: number | null
    description: string | null
    maleDescription: string | null
    femaleDescription: string | null
    shipTypeID: number | null
    corporationID: number | null
    perception: number | null
    willpower: number | null
    charisma: number | null
    memory: number | null
    intelligence: number | null
    iconID: number | null
    shortDescription: string | null
    shortMaleDescription: string | null
    shortFemaleDescription: string | null
  }

  export type ChrBloodlinesCountAggregateOutputType = {
    bloodlineID: number
    bloodlineName: number
    raceID: number
    description: number
    maleDescription: number
    femaleDescription: number
    shipTypeID: number
    corporationID: number
    perception: number
    willpower: number
    charisma: number
    memory: number
    intelligence: number
    iconID: number
    shortDescription: number
    shortMaleDescription: number
    shortFemaleDescription: number
    _all: number
  }


  export type ChrBloodlinesAvgAggregateInputType = {
    bloodlineID?: true
    raceID?: true
    shipTypeID?: true
    corporationID?: true
    perception?: true
    willpower?: true
    charisma?: true
    memory?: true
    intelligence?: true
    iconID?: true
  }

  export type ChrBloodlinesSumAggregateInputType = {
    bloodlineID?: true
    raceID?: true
    shipTypeID?: true
    corporationID?: true
    perception?: true
    willpower?: true
    charisma?: true
    memory?: true
    intelligence?: true
    iconID?: true
  }

  export type ChrBloodlinesMinAggregateInputType = {
    bloodlineID?: true
    bloodlineName?: true
    raceID?: true
    description?: true
    maleDescription?: true
    femaleDescription?: true
    shipTypeID?: true
    corporationID?: true
    perception?: true
    willpower?: true
    charisma?: true
    memory?: true
    intelligence?: true
    iconID?: true
    shortDescription?: true
    shortMaleDescription?: true
    shortFemaleDescription?: true
  }

  export type ChrBloodlinesMaxAggregateInputType = {
    bloodlineID?: true
    bloodlineName?: true
    raceID?: true
    description?: true
    maleDescription?: true
    femaleDescription?: true
    shipTypeID?: true
    corporationID?: true
    perception?: true
    willpower?: true
    charisma?: true
    memory?: true
    intelligence?: true
    iconID?: true
    shortDescription?: true
    shortMaleDescription?: true
    shortFemaleDescription?: true
  }

  export type ChrBloodlinesCountAggregateInputType = {
    bloodlineID?: true
    bloodlineName?: true
    raceID?: true
    description?: true
    maleDescription?: true
    femaleDescription?: true
    shipTypeID?: true
    corporationID?: true
    perception?: true
    willpower?: true
    charisma?: true
    memory?: true
    intelligence?: true
    iconID?: true
    shortDescription?: true
    shortMaleDescription?: true
    shortFemaleDescription?: true
    _all?: true
  }

  export type ChrBloodlinesAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which chrBloodlines to aggregate.
     */
    where?: chrBloodlinesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of chrBloodlines to fetch.
     */
    orderBy?: chrBloodlinesOrderByWithRelationInput | chrBloodlinesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: chrBloodlinesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` chrBloodlines from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` chrBloodlines.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned chrBloodlines
    **/
    _count?: true | ChrBloodlinesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ChrBloodlinesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ChrBloodlinesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ChrBloodlinesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ChrBloodlinesMaxAggregateInputType
  }

  export type GetChrBloodlinesAggregateType<T extends ChrBloodlinesAggregateArgs> = {
        [P in keyof T & keyof AggregateChrBloodlines]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateChrBloodlines[P]>
      : GetScalarType<T[P], AggregateChrBloodlines[P]>
  }




  export type chrBloodlinesGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: chrBloodlinesWhereInput
    orderBy?: chrBloodlinesOrderByWithAggregationInput | chrBloodlinesOrderByWithAggregationInput[]
    by: ChrBloodlinesScalarFieldEnum[] | ChrBloodlinesScalarFieldEnum
    having?: chrBloodlinesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ChrBloodlinesCountAggregateInputType | true
    _avg?: ChrBloodlinesAvgAggregateInputType
    _sum?: ChrBloodlinesSumAggregateInputType
    _min?: ChrBloodlinesMinAggregateInputType
    _max?: ChrBloodlinesMaxAggregateInputType
  }

  export type ChrBloodlinesGroupByOutputType = {
    bloodlineID: number
    bloodlineName: string | null
    raceID: number | null
    description: string | null
    maleDescription: string | null
    femaleDescription: string | null
    shipTypeID: number | null
    corporationID: number | null
    perception: number | null
    willpower: number | null
    charisma: number | null
    memory: number | null
    intelligence: number | null
    iconID: number | null
    shortDescription: string | null
    shortMaleDescription: string | null
    shortFemaleDescription: string | null
    _count: ChrBloodlinesCountAggregateOutputType | null
    _avg: ChrBloodlinesAvgAggregateOutputType | null
    _sum: ChrBloodlinesSumAggregateOutputType | null
    _min: ChrBloodlinesMinAggregateOutputType | null
    _max: ChrBloodlinesMaxAggregateOutputType | null
  }

  type GetChrBloodlinesGroupByPayload<T extends chrBloodlinesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ChrBloodlinesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ChrBloodlinesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ChrBloodlinesGroupByOutputType[P]>
            : GetScalarType<T[P], ChrBloodlinesGroupByOutputType[P]>
        }
      >
    >


  export type chrBloodlinesSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    bloodlineID?: boolean
    bloodlineName?: boolean
    raceID?: boolean
    description?: boolean
    maleDescription?: boolean
    femaleDescription?: boolean
    shipTypeID?: boolean
    corporationID?: boolean
    perception?: boolean
    willpower?: boolean
    charisma?: boolean
    memory?: boolean
    intelligence?: boolean
    iconID?: boolean
    shortDescription?: boolean
    shortMaleDescription?: boolean
    shortFemaleDescription?: boolean
  }, ExtArgs["result"]["chrBloodlines"]>

  export type chrBloodlinesSelectScalar = {
    bloodlineID?: boolean
    bloodlineName?: boolean
    raceID?: boolean
    description?: boolean
    maleDescription?: boolean
    femaleDescription?: boolean
    shipTypeID?: boolean
    corporationID?: boolean
    perception?: boolean
    willpower?: boolean
    charisma?: boolean
    memory?: boolean
    intelligence?: boolean
    iconID?: boolean
    shortDescription?: boolean
    shortMaleDescription?: boolean
    shortFemaleDescription?: boolean
  }


  export type $chrBloodlinesPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    name: "chrBloodlines"
    objects: {}
    scalars: $Extensions.GetResult<{
      bloodlineID: number
      bloodlineName: string | null
      raceID: number | null
      description: string | null
      maleDescription: string | null
      femaleDescription: string | null
      shipTypeID: number | null
      corporationID: number | null
      perception: number | null
      willpower: number | null
      charisma: number | null
      memory: number | null
      intelligence: number | null
      iconID: number | null
      shortDescription: string | null
      shortMaleDescription: string | null
      shortFemaleDescription: string | null
    }, ExtArgs["result"]["chrBloodlines"]>
    composites: {}
  }


  type chrBloodlinesGetPayload<S extends boolean | null | undefined | chrBloodlinesDefaultArgs> = $Result.GetResult<Prisma.$chrBloodlinesPayload, S>

  type chrBloodlinesCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<chrBloodlinesFindManyArgs, 'select' | 'include'> & {
      select?: ChrBloodlinesCountAggregateInputType | true
    }

  export interface chrBloodlinesDelegate<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['chrBloodlines'], meta: { name: 'chrBloodlines' } }
    /**
     * Find zero or one ChrBloodlines that matches the filter.
     * @param {chrBloodlinesFindUniqueArgs} args - Arguments to find a ChrBloodlines
     * @example
     * // Get one ChrBloodlines
     * const chrBloodlines = await prisma.chrBloodlines.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends chrBloodlinesFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, chrBloodlinesFindUniqueArgs<ExtArgs>>
    ): Prisma__chrBloodlinesClient<$Result.GetResult<Prisma.$chrBloodlinesPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one ChrBloodlines that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {chrBloodlinesFindUniqueOrThrowArgs} args - Arguments to find a ChrBloodlines
     * @example
     * // Get one ChrBloodlines
     * const chrBloodlines = await prisma.chrBloodlines.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends chrBloodlinesFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, chrBloodlinesFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__chrBloodlinesClient<$Result.GetResult<Prisma.$chrBloodlinesPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first ChrBloodlines that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {chrBloodlinesFindFirstArgs} args - Arguments to find a ChrBloodlines
     * @example
     * // Get one ChrBloodlines
     * const chrBloodlines = await prisma.chrBloodlines.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends chrBloodlinesFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, chrBloodlinesFindFirstArgs<ExtArgs>>
    ): Prisma__chrBloodlinesClient<$Result.GetResult<Prisma.$chrBloodlinesPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first ChrBloodlines that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {chrBloodlinesFindFirstOrThrowArgs} args - Arguments to find a ChrBloodlines
     * @example
     * // Get one ChrBloodlines
     * const chrBloodlines = await prisma.chrBloodlines.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends chrBloodlinesFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, chrBloodlinesFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__chrBloodlinesClient<$Result.GetResult<Prisma.$chrBloodlinesPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more ChrBloodlines that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {chrBloodlinesFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ChrBloodlines
     * const chrBloodlines = await prisma.chrBloodlines.findMany()
     * 
     * // Get first 10 ChrBloodlines
     * const chrBloodlines = await prisma.chrBloodlines.findMany({ take: 10 })
     * 
     * // Only select the `bloodlineID`
     * const chrBloodlinesWithBloodlineIDOnly = await prisma.chrBloodlines.findMany({ select: { bloodlineID: true } })
     * 
    **/
    findMany<T extends chrBloodlinesFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, chrBloodlinesFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$chrBloodlinesPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a ChrBloodlines.
     * @param {chrBloodlinesCreateArgs} args - Arguments to create a ChrBloodlines.
     * @example
     * // Create one ChrBloodlines
     * const ChrBloodlines = await prisma.chrBloodlines.create({
     *   data: {
     *     // ... data to create a ChrBloodlines
     *   }
     * })
     * 
    **/
    create<T extends chrBloodlinesCreateArgs<ExtArgs>>(
      args: SelectSubset<T, chrBloodlinesCreateArgs<ExtArgs>>
    ): Prisma__chrBloodlinesClient<$Result.GetResult<Prisma.$chrBloodlinesPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many ChrBloodlines.
     *     @param {chrBloodlinesCreateManyArgs} args - Arguments to create many ChrBloodlines.
     *     @example
     *     // Create many ChrBloodlines
     *     const chrBloodlines = await prisma.chrBloodlines.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends chrBloodlinesCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, chrBloodlinesCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a ChrBloodlines.
     * @param {chrBloodlinesDeleteArgs} args - Arguments to delete one ChrBloodlines.
     * @example
     * // Delete one ChrBloodlines
     * const ChrBloodlines = await prisma.chrBloodlines.delete({
     *   where: {
     *     // ... filter to delete one ChrBloodlines
     *   }
     * })
     * 
    **/
    delete<T extends chrBloodlinesDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, chrBloodlinesDeleteArgs<ExtArgs>>
    ): Prisma__chrBloodlinesClient<$Result.GetResult<Prisma.$chrBloodlinesPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one ChrBloodlines.
     * @param {chrBloodlinesUpdateArgs} args - Arguments to update one ChrBloodlines.
     * @example
     * // Update one ChrBloodlines
     * const chrBloodlines = await prisma.chrBloodlines.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends chrBloodlinesUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, chrBloodlinesUpdateArgs<ExtArgs>>
    ): Prisma__chrBloodlinesClient<$Result.GetResult<Prisma.$chrBloodlinesPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more ChrBloodlines.
     * @param {chrBloodlinesDeleteManyArgs} args - Arguments to filter ChrBloodlines to delete.
     * @example
     * // Delete a few ChrBloodlines
     * const { count } = await prisma.chrBloodlines.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends chrBloodlinesDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, chrBloodlinesDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ChrBloodlines.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {chrBloodlinesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ChrBloodlines
     * const chrBloodlines = await prisma.chrBloodlines.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends chrBloodlinesUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, chrBloodlinesUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ChrBloodlines.
     * @param {chrBloodlinesUpsertArgs} args - Arguments to update or create a ChrBloodlines.
     * @example
     * // Update or create a ChrBloodlines
     * const chrBloodlines = await prisma.chrBloodlines.upsert({
     *   create: {
     *     // ... data to create a ChrBloodlines
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ChrBloodlines we want to update
     *   }
     * })
    **/
    upsert<T extends chrBloodlinesUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, chrBloodlinesUpsertArgs<ExtArgs>>
    ): Prisma__chrBloodlinesClient<$Result.GetResult<Prisma.$chrBloodlinesPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of ChrBloodlines.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {chrBloodlinesCountArgs} args - Arguments to filter ChrBloodlines to count.
     * @example
     * // Count the number of ChrBloodlines
     * const count = await prisma.chrBloodlines.count({
     *   where: {
     *     // ... the filter for the ChrBloodlines we want to count
     *   }
     * })
    **/
    count<T extends chrBloodlinesCountArgs>(
      args?: Subset<T, chrBloodlinesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ChrBloodlinesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ChrBloodlines.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChrBloodlinesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ChrBloodlinesAggregateArgs>(args: Subset<T, ChrBloodlinesAggregateArgs>): Prisma.PrismaPromise<GetChrBloodlinesAggregateType<T>>

    /**
     * Group by ChrBloodlines.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {chrBloodlinesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends chrBloodlinesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: chrBloodlinesGroupByArgs['orderBy'] }
        : { orderBy?: chrBloodlinesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, chrBloodlinesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetChrBloodlinesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the chrBloodlines model
   */
  readonly fields: chrBloodlinesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for chrBloodlines.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__chrBloodlinesClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';


    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the chrBloodlines model
   */ 
  interface chrBloodlinesFieldRefs {
    readonly bloodlineID: FieldRef<"chrBloodlines", 'Int'>
    readonly bloodlineName: FieldRef<"chrBloodlines", 'String'>
    readonly raceID: FieldRef<"chrBloodlines", 'Int'>
    readonly description: FieldRef<"chrBloodlines", 'String'>
    readonly maleDescription: FieldRef<"chrBloodlines", 'String'>
    readonly femaleDescription: FieldRef<"chrBloodlines", 'String'>
    readonly shipTypeID: FieldRef<"chrBloodlines", 'Int'>
    readonly corporationID: FieldRef<"chrBloodlines", 'Int'>
    readonly perception: FieldRef<"chrBloodlines", 'Int'>
    readonly willpower: FieldRef<"chrBloodlines", 'Int'>
    readonly charisma: FieldRef<"chrBloodlines", 'Int'>
    readonly memory: FieldRef<"chrBloodlines", 'Int'>
    readonly intelligence: FieldRef<"chrBloodlines", 'Int'>
    readonly iconID: FieldRef<"chrBloodlines", 'Int'>
    readonly shortDescription: FieldRef<"chrBloodlines", 'String'>
    readonly shortMaleDescription: FieldRef<"chrBloodlines", 'String'>
    readonly shortFemaleDescription: FieldRef<"chrBloodlines", 'String'>
  }
    

  // Custom InputTypes

  /**
   * chrBloodlines findUnique
   */
  export type chrBloodlinesFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the chrBloodlines
     */
    select?: chrBloodlinesSelect<ExtArgs> | null
    /**
     * Filter, which chrBloodlines to fetch.
     */
    where: chrBloodlinesWhereUniqueInput
  }


  /**
   * chrBloodlines findUniqueOrThrow
   */
  export type chrBloodlinesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the chrBloodlines
     */
    select?: chrBloodlinesSelect<ExtArgs> | null
    /**
     * Filter, which chrBloodlines to fetch.
     */
    where: chrBloodlinesWhereUniqueInput
  }


  /**
   * chrBloodlines findFirst
   */
  export type chrBloodlinesFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the chrBloodlines
     */
    select?: chrBloodlinesSelect<ExtArgs> | null
    /**
     * Filter, which chrBloodlines to fetch.
     */
    where?: chrBloodlinesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of chrBloodlines to fetch.
     */
    orderBy?: chrBloodlinesOrderByWithRelationInput | chrBloodlinesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for chrBloodlines.
     */
    cursor?: chrBloodlinesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` chrBloodlines from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` chrBloodlines.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of chrBloodlines.
     */
    distinct?: ChrBloodlinesScalarFieldEnum | ChrBloodlinesScalarFieldEnum[]
  }


  /**
   * chrBloodlines findFirstOrThrow
   */
  export type chrBloodlinesFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the chrBloodlines
     */
    select?: chrBloodlinesSelect<ExtArgs> | null
    /**
     * Filter, which chrBloodlines to fetch.
     */
    where?: chrBloodlinesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of chrBloodlines to fetch.
     */
    orderBy?: chrBloodlinesOrderByWithRelationInput | chrBloodlinesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for chrBloodlines.
     */
    cursor?: chrBloodlinesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` chrBloodlines from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` chrBloodlines.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of chrBloodlines.
     */
    distinct?: ChrBloodlinesScalarFieldEnum | ChrBloodlinesScalarFieldEnum[]
  }


  /**
   * chrBloodlines findMany
   */
  export type chrBloodlinesFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the chrBloodlines
     */
    select?: chrBloodlinesSelect<ExtArgs> | null
    /**
     * Filter, which chrBloodlines to fetch.
     */
    where?: chrBloodlinesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of chrBloodlines to fetch.
     */
    orderBy?: chrBloodlinesOrderByWithRelationInput | chrBloodlinesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing chrBloodlines.
     */
    cursor?: chrBloodlinesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` chrBloodlines from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` chrBloodlines.
     */
    skip?: number
    distinct?: ChrBloodlinesScalarFieldEnum | ChrBloodlinesScalarFieldEnum[]
  }


  /**
   * chrBloodlines create
   */
  export type chrBloodlinesCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the chrBloodlines
     */
    select?: chrBloodlinesSelect<ExtArgs> | null
    /**
     * The data needed to create a chrBloodlines.
     */
    data: XOR<chrBloodlinesCreateInput, chrBloodlinesUncheckedCreateInput>
  }


  /**
   * chrBloodlines createMany
   */
  export type chrBloodlinesCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many chrBloodlines.
     */
    data: chrBloodlinesCreateManyInput | chrBloodlinesCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * chrBloodlines update
   */
  export type chrBloodlinesUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the chrBloodlines
     */
    select?: chrBloodlinesSelect<ExtArgs> | null
    /**
     * The data needed to update a chrBloodlines.
     */
    data: XOR<chrBloodlinesUpdateInput, chrBloodlinesUncheckedUpdateInput>
    /**
     * Choose, which chrBloodlines to update.
     */
    where: chrBloodlinesWhereUniqueInput
  }


  /**
   * chrBloodlines updateMany
   */
  export type chrBloodlinesUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update chrBloodlines.
     */
    data: XOR<chrBloodlinesUpdateManyMutationInput, chrBloodlinesUncheckedUpdateManyInput>
    /**
     * Filter which chrBloodlines to update
     */
    where?: chrBloodlinesWhereInput
  }


  /**
   * chrBloodlines upsert
   */
  export type chrBloodlinesUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the chrBloodlines
     */
    select?: chrBloodlinesSelect<ExtArgs> | null
    /**
     * The filter to search for the chrBloodlines to update in case it exists.
     */
    where: chrBloodlinesWhereUniqueInput
    /**
     * In case the chrBloodlines found by the `where` argument doesn't exist, create a new chrBloodlines with this data.
     */
    create: XOR<chrBloodlinesCreateInput, chrBloodlinesUncheckedCreateInput>
    /**
     * In case the chrBloodlines was found with the provided `where` argument, update it with this data.
     */
    update: XOR<chrBloodlinesUpdateInput, chrBloodlinesUncheckedUpdateInput>
  }


  /**
   * chrBloodlines delete
   */
  export type chrBloodlinesDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the chrBloodlines
     */
    select?: chrBloodlinesSelect<ExtArgs> | null
    /**
     * Filter which chrBloodlines to delete.
     */
    where: chrBloodlinesWhereUniqueInput
  }


  /**
   * chrBloodlines deleteMany
   */
  export type chrBloodlinesDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which chrBloodlines to delete
     */
    where?: chrBloodlinesWhereInput
  }


  /**
   * chrBloodlines without action
   */
  export type chrBloodlinesDefaultArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the chrBloodlines
     */
    select?: chrBloodlinesSelect<ExtArgs> | null
  }



  /**
   * Model chrFactions
   */

  export type AggregateChrFactions = {
    _count: ChrFactionsCountAggregateOutputType | null
    _avg: ChrFactionsAvgAggregateOutputType | null
    _sum: ChrFactionsSumAggregateOutputType | null
    _min: ChrFactionsMinAggregateOutputType | null
    _max: ChrFactionsMaxAggregateOutputType | null
  }

  export type ChrFactionsAvgAggregateOutputType = {
    factionID: number | null
    raceIDs: number | null
    solarSystemID: number | null
    corporationID: number | null
    sizeFactor: number | null
    stationCount: number | null
    stationSystemCount: number | null
    militiaCorporationID: number | null
    iconID: number | null
  }

  export type ChrFactionsSumAggregateOutputType = {
    factionID: number | null
    raceIDs: number | null
    solarSystemID: number | null
    corporationID: number | null
    sizeFactor: number | null
    stationCount: number | null
    stationSystemCount: number | null
    militiaCorporationID: number | null
    iconID: number | null
  }

  export type ChrFactionsMinAggregateOutputType = {
    factionID: number | null
    factionName: string | null
    description: string | null
    raceIDs: number | null
    solarSystemID: number | null
    corporationID: number | null
    sizeFactor: number | null
    stationCount: number | null
    stationSystemCount: number | null
    militiaCorporationID: number | null
    iconID: number | null
  }

  export type ChrFactionsMaxAggregateOutputType = {
    factionID: number | null
    factionName: string | null
    description: string | null
    raceIDs: number | null
    solarSystemID: number | null
    corporationID: number | null
    sizeFactor: number | null
    stationCount: number | null
    stationSystemCount: number | null
    militiaCorporationID: number | null
    iconID: number | null
  }

  export type ChrFactionsCountAggregateOutputType = {
    factionID: number
    factionName: number
    description: number
    raceIDs: number
    solarSystemID: number
    corporationID: number
    sizeFactor: number
    stationCount: number
    stationSystemCount: number
    militiaCorporationID: number
    iconID: number
    _all: number
  }


  export type ChrFactionsAvgAggregateInputType = {
    factionID?: true
    raceIDs?: true
    solarSystemID?: true
    corporationID?: true
    sizeFactor?: true
    stationCount?: true
    stationSystemCount?: true
    militiaCorporationID?: true
    iconID?: true
  }

  export type ChrFactionsSumAggregateInputType = {
    factionID?: true
    raceIDs?: true
    solarSystemID?: true
    corporationID?: true
    sizeFactor?: true
    stationCount?: true
    stationSystemCount?: true
    militiaCorporationID?: true
    iconID?: true
  }

  export type ChrFactionsMinAggregateInputType = {
    factionID?: true
    factionName?: true
    description?: true
    raceIDs?: true
    solarSystemID?: true
    corporationID?: true
    sizeFactor?: true
    stationCount?: true
    stationSystemCount?: true
    militiaCorporationID?: true
    iconID?: true
  }

  export type ChrFactionsMaxAggregateInputType = {
    factionID?: true
    factionName?: true
    description?: true
    raceIDs?: true
    solarSystemID?: true
    corporationID?: true
    sizeFactor?: true
    stationCount?: true
    stationSystemCount?: true
    militiaCorporationID?: true
    iconID?: true
  }

  export type ChrFactionsCountAggregateInputType = {
    factionID?: true
    factionName?: true
    description?: true
    raceIDs?: true
    solarSystemID?: true
    corporationID?: true
    sizeFactor?: true
    stationCount?: true
    stationSystemCount?: true
    militiaCorporationID?: true
    iconID?: true
    _all?: true
  }

  export type ChrFactionsAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which chrFactions to aggregate.
     */
    where?: chrFactionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of chrFactions to fetch.
     */
    orderBy?: chrFactionsOrderByWithRelationInput | chrFactionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: chrFactionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` chrFactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` chrFactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned chrFactions
    **/
    _count?: true | ChrFactionsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ChrFactionsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ChrFactionsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ChrFactionsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ChrFactionsMaxAggregateInputType
  }

  export type GetChrFactionsAggregateType<T extends ChrFactionsAggregateArgs> = {
        [P in keyof T & keyof AggregateChrFactions]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateChrFactions[P]>
      : GetScalarType<T[P], AggregateChrFactions[P]>
  }




  export type chrFactionsGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: chrFactionsWhereInput
    orderBy?: chrFactionsOrderByWithAggregationInput | chrFactionsOrderByWithAggregationInput[]
    by: ChrFactionsScalarFieldEnum[] | ChrFactionsScalarFieldEnum
    having?: chrFactionsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ChrFactionsCountAggregateInputType | true
    _avg?: ChrFactionsAvgAggregateInputType
    _sum?: ChrFactionsSumAggregateInputType
    _min?: ChrFactionsMinAggregateInputType
    _max?: ChrFactionsMaxAggregateInputType
  }

  export type ChrFactionsGroupByOutputType = {
    factionID: number
    factionName: string | null
    description: string | null
    raceIDs: number | null
    solarSystemID: number | null
    corporationID: number | null
    sizeFactor: number | null
    stationCount: number | null
    stationSystemCount: number | null
    militiaCorporationID: number | null
    iconID: number | null
    _count: ChrFactionsCountAggregateOutputType | null
    _avg: ChrFactionsAvgAggregateOutputType | null
    _sum: ChrFactionsSumAggregateOutputType | null
    _min: ChrFactionsMinAggregateOutputType | null
    _max: ChrFactionsMaxAggregateOutputType | null
  }

  type GetChrFactionsGroupByPayload<T extends chrFactionsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ChrFactionsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ChrFactionsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ChrFactionsGroupByOutputType[P]>
            : GetScalarType<T[P], ChrFactionsGroupByOutputType[P]>
        }
      >
    >


  export type chrFactionsSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    factionID?: boolean
    factionName?: boolean
    description?: boolean
    raceIDs?: boolean
    solarSystemID?: boolean
    corporationID?: boolean
    sizeFactor?: boolean
    stationCount?: boolean
    stationSystemCount?: boolean
    militiaCorporationID?: boolean
    iconID?: boolean
  }, ExtArgs["result"]["chrFactions"]>

  export type chrFactionsSelectScalar = {
    factionID?: boolean
    factionName?: boolean
    description?: boolean
    raceIDs?: boolean
    solarSystemID?: boolean
    corporationID?: boolean
    sizeFactor?: boolean
    stationCount?: boolean
    stationSystemCount?: boolean
    militiaCorporationID?: boolean
    iconID?: boolean
  }


  export type $chrFactionsPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    name: "chrFactions"
    objects: {}
    scalars: $Extensions.GetResult<{
      factionID: number
      factionName: string | null
      description: string | null
      raceIDs: number | null
      solarSystemID: number | null
      corporationID: number | null
      sizeFactor: number | null
      stationCount: number | null
      stationSystemCount: number | null
      militiaCorporationID: number | null
      iconID: number | null
    }, ExtArgs["result"]["chrFactions"]>
    composites: {}
  }


  type chrFactionsGetPayload<S extends boolean | null | undefined | chrFactionsDefaultArgs> = $Result.GetResult<Prisma.$chrFactionsPayload, S>

  type chrFactionsCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<chrFactionsFindManyArgs, 'select' | 'include'> & {
      select?: ChrFactionsCountAggregateInputType | true
    }

  export interface chrFactionsDelegate<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['chrFactions'], meta: { name: 'chrFactions' } }
    /**
     * Find zero or one ChrFactions that matches the filter.
     * @param {chrFactionsFindUniqueArgs} args - Arguments to find a ChrFactions
     * @example
     * // Get one ChrFactions
     * const chrFactions = await prisma.chrFactions.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends chrFactionsFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, chrFactionsFindUniqueArgs<ExtArgs>>
    ): Prisma__chrFactionsClient<$Result.GetResult<Prisma.$chrFactionsPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one ChrFactions that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {chrFactionsFindUniqueOrThrowArgs} args - Arguments to find a ChrFactions
     * @example
     * // Get one ChrFactions
     * const chrFactions = await prisma.chrFactions.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends chrFactionsFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, chrFactionsFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__chrFactionsClient<$Result.GetResult<Prisma.$chrFactionsPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first ChrFactions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {chrFactionsFindFirstArgs} args - Arguments to find a ChrFactions
     * @example
     * // Get one ChrFactions
     * const chrFactions = await prisma.chrFactions.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends chrFactionsFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, chrFactionsFindFirstArgs<ExtArgs>>
    ): Prisma__chrFactionsClient<$Result.GetResult<Prisma.$chrFactionsPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first ChrFactions that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {chrFactionsFindFirstOrThrowArgs} args - Arguments to find a ChrFactions
     * @example
     * // Get one ChrFactions
     * const chrFactions = await prisma.chrFactions.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends chrFactionsFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, chrFactionsFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__chrFactionsClient<$Result.GetResult<Prisma.$chrFactionsPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more ChrFactions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {chrFactionsFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ChrFactions
     * const chrFactions = await prisma.chrFactions.findMany()
     * 
     * // Get first 10 ChrFactions
     * const chrFactions = await prisma.chrFactions.findMany({ take: 10 })
     * 
     * // Only select the `factionID`
     * const chrFactionsWithFactionIDOnly = await prisma.chrFactions.findMany({ select: { factionID: true } })
     * 
    **/
    findMany<T extends chrFactionsFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, chrFactionsFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$chrFactionsPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a ChrFactions.
     * @param {chrFactionsCreateArgs} args - Arguments to create a ChrFactions.
     * @example
     * // Create one ChrFactions
     * const ChrFactions = await prisma.chrFactions.create({
     *   data: {
     *     // ... data to create a ChrFactions
     *   }
     * })
     * 
    **/
    create<T extends chrFactionsCreateArgs<ExtArgs>>(
      args: SelectSubset<T, chrFactionsCreateArgs<ExtArgs>>
    ): Prisma__chrFactionsClient<$Result.GetResult<Prisma.$chrFactionsPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many ChrFactions.
     *     @param {chrFactionsCreateManyArgs} args - Arguments to create many ChrFactions.
     *     @example
     *     // Create many ChrFactions
     *     const chrFactions = await prisma.chrFactions.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends chrFactionsCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, chrFactionsCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a ChrFactions.
     * @param {chrFactionsDeleteArgs} args - Arguments to delete one ChrFactions.
     * @example
     * // Delete one ChrFactions
     * const ChrFactions = await prisma.chrFactions.delete({
     *   where: {
     *     // ... filter to delete one ChrFactions
     *   }
     * })
     * 
    **/
    delete<T extends chrFactionsDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, chrFactionsDeleteArgs<ExtArgs>>
    ): Prisma__chrFactionsClient<$Result.GetResult<Prisma.$chrFactionsPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one ChrFactions.
     * @param {chrFactionsUpdateArgs} args - Arguments to update one ChrFactions.
     * @example
     * // Update one ChrFactions
     * const chrFactions = await prisma.chrFactions.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends chrFactionsUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, chrFactionsUpdateArgs<ExtArgs>>
    ): Prisma__chrFactionsClient<$Result.GetResult<Prisma.$chrFactionsPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more ChrFactions.
     * @param {chrFactionsDeleteManyArgs} args - Arguments to filter ChrFactions to delete.
     * @example
     * // Delete a few ChrFactions
     * const { count } = await prisma.chrFactions.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends chrFactionsDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, chrFactionsDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ChrFactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {chrFactionsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ChrFactions
     * const chrFactions = await prisma.chrFactions.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends chrFactionsUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, chrFactionsUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ChrFactions.
     * @param {chrFactionsUpsertArgs} args - Arguments to update or create a ChrFactions.
     * @example
     * // Update or create a ChrFactions
     * const chrFactions = await prisma.chrFactions.upsert({
     *   create: {
     *     // ... data to create a ChrFactions
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ChrFactions we want to update
     *   }
     * })
    **/
    upsert<T extends chrFactionsUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, chrFactionsUpsertArgs<ExtArgs>>
    ): Prisma__chrFactionsClient<$Result.GetResult<Prisma.$chrFactionsPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of ChrFactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {chrFactionsCountArgs} args - Arguments to filter ChrFactions to count.
     * @example
     * // Count the number of ChrFactions
     * const count = await prisma.chrFactions.count({
     *   where: {
     *     // ... the filter for the ChrFactions we want to count
     *   }
     * })
    **/
    count<T extends chrFactionsCountArgs>(
      args?: Subset<T, chrFactionsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ChrFactionsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ChrFactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChrFactionsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ChrFactionsAggregateArgs>(args: Subset<T, ChrFactionsAggregateArgs>): Prisma.PrismaPromise<GetChrFactionsAggregateType<T>>

    /**
     * Group by ChrFactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {chrFactionsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends chrFactionsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: chrFactionsGroupByArgs['orderBy'] }
        : { orderBy?: chrFactionsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, chrFactionsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetChrFactionsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the chrFactions model
   */
  readonly fields: chrFactionsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for chrFactions.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__chrFactionsClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';


    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the chrFactions model
   */ 
  interface chrFactionsFieldRefs {
    readonly factionID: FieldRef<"chrFactions", 'Int'>
    readonly factionName: FieldRef<"chrFactions", 'String'>
    readonly description: FieldRef<"chrFactions", 'String'>
    readonly raceIDs: FieldRef<"chrFactions", 'Int'>
    readonly solarSystemID: FieldRef<"chrFactions", 'Int'>
    readonly corporationID: FieldRef<"chrFactions", 'Int'>
    readonly sizeFactor: FieldRef<"chrFactions", 'Float'>
    readonly stationCount: FieldRef<"chrFactions", 'Int'>
    readonly stationSystemCount: FieldRef<"chrFactions", 'Int'>
    readonly militiaCorporationID: FieldRef<"chrFactions", 'Int'>
    readonly iconID: FieldRef<"chrFactions", 'Int'>
  }
    

  // Custom InputTypes

  /**
   * chrFactions findUnique
   */
  export type chrFactionsFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the chrFactions
     */
    select?: chrFactionsSelect<ExtArgs> | null
    /**
     * Filter, which chrFactions to fetch.
     */
    where: chrFactionsWhereUniqueInput
  }


  /**
   * chrFactions findUniqueOrThrow
   */
  export type chrFactionsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the chrFactions
     */
    select?: chrFactionsSelect<ExtArgs> | null
    /**
     * Filter, which chrFactions to fetch.
     */
    where: chrFactionsWhereUniqueInput
  }


  /**
   * chrFactions findFirst
   */
  export type chrFactionsFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the chrFactions
     */
    select?: chrFactionsSelect<ExtArgs> | null
    /**
     * Filter, which chrFactions to fetch.
     */
    where?: chrFactionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of chrFactions to fetch.
     */
    orderBy?: chrFactionsOrderByWithRelationInput | chrFactionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for chrFactions.
     */
    cursor?: chrFactionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` chrFactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` chrFactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of chrFactions.
     */
    distinct?: ChrFactionsScalarFieldEnum | ChrFactionsScalarFieldEnum[]
  }


  /**
   * chrFactions findFirstOrThrow
   */
  export type chrFactionsFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the chrFactions
     */
    select?: chrFactionsSelect<ExtArgs> | null
    /**
     * Filter, which chrFactions to fetch.
     */
    where?: chrFactionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of chrFactions to fetch.
     */
    orderBy?: chrFactionsOrderByWithRelationInput | chrFactionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for chrFactions.
     */
    cursor?: chrFactionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` chrFactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` chrFactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of chrFactions.
     */
    distinct?: ChrFactionsScalarFieldEnum | ChrFactionsScalarFieldEnum[]
  }


  /**
   * chrFactions findMany
   */
  export type chrFactionsFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the chrFactions
     */
    select?: chrFactionsSelect<ExtArgs> | null
    /**
     * Filter, which chrFactions to fetch.
     */
    where?: chrFactionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of chrFactions to fetch.
     */
    orderBy?: chrFactionsOrderByWithRelationInput | chrFactionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing chrFactions.
     */
    cursor?: chrFactionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` chrFactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` chrFactions.
     */
    skip?: number
    distinct?: ChrFactionsScalarFieldEnum | ChrFactionsScalarFieldEnum[]
  }


  /**
   * chrFactions create
   */
  export type chrFactionsCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the chrFactions
     */
    select?: chrFactionsSelect<ExtArgs> | null
    /**
     * The data needed to create a chrFactions.
     */
    data: XOR<chrFactionsCreateInput, chrFactionsUncheckedCreateInput>
  }


  /**
   * chrFactions createMany
   */
  export type chrFactionsCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many chrFactions.
     */
    data: chrFactionsCreateManyInput | chrFactionsCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * chrFactions update
   */
  export type chrFactionsUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the chrFactions
     */
    select?: chrFactionsSelect<ExtArgs> | null
    /**
     * The data needed to update a chrFactions.
     */
    data: XOR<chrFactionsUpdateInput, chrFactionsUncheckedUpdateInput>
    /**
     * Choose, which chrFactions to update.
     */
    where: chrFactionsWhereUniqueInput
  }


  /**
   * chrFactions updateMany
   */
  export type chrFactionsUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update chrFactions.
     */
    data: XOR<chrFactionsUpdateManyMutationInput, chrFactionsUncheckedUpdateManyInput>
    /**
     * Filter which chrFactions to update
     */
    where?: chrFactionsWhereInput
  }


  /**
   * chrFactions upsert
   */
  export type chrFactionsUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the chrFactions
     */
    select?: chrFactionsSelect<ExtArgs> | null
    /**
     * The filter to search for the chrFactions to update in case it exists.
     */
    where: chrFactionsWhereUniqueInput
    /**
     * In case the chrFactions found by the `where` argument doesn't exist, create a new chrFactions with this data.
     */
    create: XOR<chrFactionsCreateInput, chrFactionsUncheckedCreateInput>
    /**
     * In case the chrFactions was found with the provided `where` argument, update it with this data.
     */
    update: XOR<chrFactionsUpdateInput, chrFactionsUncheckedUpdateInput>
  }


  /**
   * chrFactions delete
   */
  export type chrFactionsDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the chrFactions
     */
    select?: chrFactionsSelect<ExtArgs> | null
    /**
     * Filter which chrFactions to delete.
     */
    where: chrFactionsWhereUniqueInput
  }


  /**
   * chrFactions deleteMany
   */
  export type chrFactionsDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which chrFactions to delete
     */
    where?: chrFactionsWhereInput
  }


  /**
   * chrFactions without action
   */
  export type chrFactionsDefaultArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the chrFactions
     */
    select?: chrFactionsSelect<ExtArgs> | null
  }



  /**
   * Model chrRaces
   */

  export type AggregateChrRaces = {
    _count: ChrRacesCountAggregateOutputType | null
    _avg: ChrRacesAvgAggregateOutputType | null
    _sum: ChrRacesSumAggregateOutputType | null
    _min: ChrRacesMinAggregateOutputType | null
    _max: ChrRacesMaxAggregateOutputType | null
  }

  export type ChrRacesAvgAggregateOutputType = {
    raceID: number | null
    iconID: number | null
  }

  export type ChrRacesSumAggregateOutputType = {
    raceID: number | null
    iconID: number | null
  }

  export type ChrRacesMinAggregateOutputType = {
    raceID: number | null
    raceName: string | null
    description: string | null
    iconID: number | null
    shortDescription: string | null
  }

  export type ChrRacesMaxAggregateOutputType = {
    raceID: number | null
    raceName: string | null
    description: string | null
    iconID: number | null
    shortDescription: string | null
  }

  export type ChrRacesCountAggregateOutputType = {
    raceID: number
    raceName: number
    description: number
    iconID: number
    shortDescription: number
    _all: number
  }


  export type ChrRacesAvgAggregateInputType = {
    raceID?: true
    iconID?: true
  }

  export type ChrRacesSumAggregateInputType = {
    raceID?: true
    iconID?: true
  }

  export type ChrRacesMinAggregateInputType = {
    raceID?: true
    raceName?: true
    description?: true
    iconID?: true
    shortDescription?: true
  }

  export type ChrRacesMaxAggregateInputType = {
    raceID?: true
    raceName?: true
    description?: true
    iconID?: true
    shortDescription?: true
  }

  export type ChrRacesCountAggregateInputType = {
    raceID?: true
    raceName?: true
    description?: true
    iconID?: true
    shortDescription?: true
    _all?: true
  }

  export type ChrRacesAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which chrRaces to aggregate.
     */
    where?: chrRacesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of chrRaces to fetch.
     */
    orderBy?: chrRacesOrderByWithRelationInput | chrRacesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: chrRacesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` chrRaces from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` chrRaces.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned chrRaces
    **/
    _count?: true | ChrRacesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ChrRacesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ChrRacesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ChrRacesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ChrRacesMaxAggregateInputType
  }

  export type GetChrRacesAggregateType<T extends ChrRacesAggregateArgs> = {
        [P in keyof T & keyof AggregateChrRaces]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateChrRaces[P]>
      : GetScalarType<T[P], AggregateChrRaces[P]>
  }




  export type chrRacesGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: chrRacesWhereInput
    orderBy?: chrRacesOrderByWithAggregationInput | chrRacesOrderByWithAggregationInput[]
    by: ChrRacesScalarFieldEnum[] | ChrRacesScalarFieldEnum
    having?: chrRacesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ChrRacesCountAggregateInputType | true
    _avg?: ChrRacesAvgAggregateInputType
    _sum?: ChrRacesSumAggregateInputType
    _min?: ChrRacesMinAggregateInputType
    _max?: ChrRacesMaxAggregateInputType
  }

  export type ChrRacesGroupByOutputType = {
    raceID: number
    raceName: string | null
    description: string | null
    iconID: number | null
    shortDescription: string | null
    _count: ChrRacesCountAggregateOutputType | null
    _avg: ChrRacesAvgAggregateOutputType | null
    _sum: ChrRacesSumAggregateOutputType | null
    _min: ChrRacesMinAggregateOutputType | null
    _max: ChrRacesMaxAggregateOutputType | null
  }

  type GetChrRacesGroupByPayload<T extends chrRacesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ChrRacesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ChrRacesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ChrRacesGroupByOutputType[P]>
            : GetScalarType<T[P], ChrRacesGroupByOutputType[P]>
        }
      >
    >


  export type chrRacesSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    raceID?: boolean
    raceName?: boolean
    description?: boolean
    iconID?: boolean
    shortDescription?: boolean
  }, ExtArgs["result"]["chrRaces"]>

  export type chrRacesSelectScalar = {
    raceID?: boolean
    raceName?: boolean
    description?: boolean
    iconID?: boolean
    shortDescription?: boolean
  }


  export type $chrRacesPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    name: "chrRaces"
    objects: {}
    scalars: $Extensions.GetResult<{
      raceID: number
      raceName: string | null
      description: string | null
      iconID: number | null
      shortDescription: string | null
    }, ExtArgs["result"]["chrRaces"]>
    composites: {}
  }


  type chrRacesGetPayload<S extends boolean | null | undefined | chrRacesDefaultArgs> = $Result.GetResult<Prisma.$chrRacesPayload, S>

  type chrRacesCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<chrRacesFindManyArgs, 'select' | 'include'> & {
      select?: ChrRacesCountAggregateInputType | true
    }

  export interface chrRacesDelegate<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['chrRaces'], meta: { name: 'chrRaces' } }
    /**
     * Find zero or one ChrRaces that matches the filter.
     * @param {chrRacesFindUniqueArgs} args - Arguments to find a ChrRaces
     * @example
     * // Get one ChrRaces
     * const chrRaces = await prisma.chrRaces.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends chrRacesFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, chrRacesFindUniqueArgs<ExtArgs>>
    ): Prisma__chrRacesClient<$Result.GetResult<Prisma.$chrRacesPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one ChrRaces that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {chrRacesFindUniqueOrThrowArgs} args - Arguments to find a ChrRaces
     * @example
     * // Get one ChrRaces
     * const chrRaces = await prisma.chrRaces.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends chrRacesFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, chrRacesFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__chrRacesClient<$Result.GetResult<Prisma.$chrRacesPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first ChrRaces that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {chrRacesFindFirstArgs} args - Arguments to find a ChrRaces
     * @example
     * // Get one ChrRaces
     * const chrRaces = await prisma.chrRaces.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends chrRacesFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, chrRacesFindFirstArgs<ExtArgs>>
    ): Prisma__chrRacesClient<$Result.GetResult<Prisma.$chrRacesPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first ChrRaces that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {chrRacesFindFirstOrThrowArgs} args - Arguments to find a ChrRaces
     * @example
     * // Get one ChrRaces
     * const chrRaces = await prisma.chrRaces.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends chrRacesFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, chrRacesFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__chrRacesClient<$Result.GetResult<Prisma.$chrRacesPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more ChrRaces that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {chrRacesFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ChrRaces
     * const chrRaces = await prisma.chrRaces.findMany()
     * 
     * // Get first 10 ChrRaces
     * const chrRaces = await prisma.chrRaces.findMany({ take: 10 })
     * 
     * // Only select the `raceID`
     * const chrRacesWithRaceIDOnly = await prisma.chrRaces.findMany({ select: { raceID: true } })
     * 
    **/
    findMany<T extends chrRacesFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, chrRacesFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$chrRacesPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a ChrRaces.
     * @param {chrRacesCreateArgs} args - Arguments to create a ChrRaces.
     * @example
     * // Create one ChrRaces
     * const ChrRaces = await prisma.chrRaces.create({
     *   data: {
     *     // ... data to create a ChrRaces
     *   }
     * })
     * 
    **/
    create<T extends chrRacesCreateArgs<ExtArgs>>(
      args: SelectSubset<T, chrRacesCreateArgs<ExtArgs>>
    ): Prisma__chrRacesClient<$Result.GetResult<Prisma.$chrRacesPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many ChrRaces.
     *     @param {chrRacesCreateManyArgs} args - Arguments to create many ChrRaces.
     *     @example
     *     // Create many ChrRaces
     *     const chrRaces = await prisma.chrRaces.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends chrRacesCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, chrRacesCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a ChrRaces.
     * @param {chrRacesDeleteArgs} args - Arguments to delete one ChrRaces.
     * @example
     * // Delete one ChrRaces
     * const ChrRaces = await prisma.chrRaces.delete({
     *   where: {
     *     // ... filter to delete one ChrRaces
     *   }
     * })
     * 
    **/
    delete<T extends chrRacesDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, chrRacesDeleteArgs<ExtArgs>>
    ): Prisma__chrRacesClient<$Result.GetResult<Prisma.$chrRacesPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one ChrRaces.
     * @param {chrRacesUpdateArgs} args - Arguments to update one ChrRaces.
     * @example
     * // Update one ChrRaces
     * const chrRaces = await prisma.chrRaces.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends chrRacesUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, chrRacesUpdateArgs<ExtArgs>>
    ): Prisma__chrRacesClient<$Result.GetResult<Prisma.$chrRacesPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more ChrRaces.
     * @param {chrRacesDeleteManyArgs} args - Arguments to filter ChrRaces to delete.
     * @example
     * // Delete a few ChrRaces
     * const { count } = await prisma.chrRaces.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends chrRacesDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, chrRacesDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ChrRaces.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {chrRacesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ChrRaces
     * const chrRaces = await prisma.chrRaces.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends chrRacesUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, chrRacesUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ChrRaces.
     * @param {chrRacesUpsertArgs} args - Arguments to update or create a ChrRaces.
     * @example
     * // Update or create a ChrRaces
     * const chrRaces = await prisma.chrRaces.upsert({
     *   create: {
     *     // ... data to create a ChrRaces
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ChrRaces we want to update
     *   }
     * })
    **/
    upsert<T extends chrRacesUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, chrRacesUpsertArgs<ExtArgs>>
    ): Prisma__chrRacesClient<$Result.GetResult<Prisma.$chrRacesPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of ChrRaces.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {chrRacesCountArgs} args - Arguments to filter ChrRaces to count.
     * @example
     * // Count the number of ChrRaces
     * const count = await prisma.chrRaces.count({
     *   where: {
     *     // ... the filter for the ChrRaces we want to count
     *   }
     * })
    **/
    count<T extends chrRacesCountArgs>(
      args?: Subset<T, chrRacesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ChrRacesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ChrRaces.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChrRacesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ChrRacesAggregateArgs>(args: Subset<T, ChrRacesAggregateArgs>): Prisma.PrismaPromise<GetChrRacesAggregateType<T>>

    /**
     * Group by ChrRaces.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {chrRacesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends chrRacesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: chrRacesGroupByArgs['orderBy'] }
        : { orderBy?: chrRacesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, chrRacesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetChrRacesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the chrRaces model
   */
  readonly fields: chrRacesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for chrRaces.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__chrRacesClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';


    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the chrRaces model
   */ 
  interface chrRacesFieldRefs {
    readonly raceID: FieldRef<"chrRaces", 'Int'>
    readonly raceName: FieldRef<"chrRaces", 'String'>
    readonly description: FieldRef<"chrRaces", 'String'>
    readonly iconID: FieldRef<"chrRaces", 'Int'>
    readonly shortDescription: FieldRef<"chrRaces", 'String'>
  }
    

  // Custom InputTypes

  /**
   * chrRaces findUnique
   */
  export type chrRacesFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the chrRaces
     */
    select?: chrRacesSelect<ExtArgs> | null
    /**
     * Filter, which chrRaces to fetch.
     */
    where: chrRacesWhereUniqueInput
  }


  /**
   * chrRaces findUniqueOrThrow
   */
  export type chrRacesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the chrRaces
     */
    select?: chrRacesSelect<ExtArgs> | null
    /**
     * Filter, which chrRaces to fetch.
     */
    where: chrRacesWhereUniqueInput
  }


  /**
   * chrRaces findFirst
   */
  export type chrRacesFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the chrRaces
     */
    select?: chrRacesSelect<ExtArgs> | null
    /**
     * Filter, which chrRaces to fetch.
     */
    where?: chrRacesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of chrRaces to fetch.
     */
    orderBy?: chrRacesOrderByWithRelationInput | chrRacesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for chrRaces.
     */
    cursor?: chrRacesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` chrRaces from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` chrRaces.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of chrRaces.
     */
    distinct?: ChrRacesScalarFieldEnum | ChrRacesScalarFieldEnum[]
  }


  /**
   * chrRaces findFirstOrThrow
   */
  export type chrRacesFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the chrRaces
     */
    select?: chrRacesSelect<ExtArgs> | null
    /**
     * Filter, which chrRaces to fetch.
     */
    where?: chrRacesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of chrRaces to fetch.
     */
    orderBy?: chrRacesOrderByWithRelationInput | chrRacesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for chrRaces.
     */
    cursor?: chrRacesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` chrRaces from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` chrRaces.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of chrRaces.
     */
    distinct?: ChrRacesScalarFieldEnum | ChrRacesScalarFieldEnum[]
  }


  /**
   * chrRaces findMany
   */
  export type chrRacesFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the chrRaces
     */
    select?: chrRacesSelect<ExtArgs> | null
    /**
     * Filter, which chrRaces to fetch.
     */
    where?: chrRacesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of chrRaces to fetch.
     */
    orderBy?: chrRacesOrderByWithRelationInput | chrRacesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing chrRaces.
     */
    cursor?: chrRacesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` chrRaces from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` chrRaces.
     */
    skip?: number
    distinct?: ChrRacesScalarFieldEnum | ChrRacesScalarFieldEnum[]
  }


  /**
   * chrRaces create
   */
  export type chrRacesCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the chrRaces
     */
    select?: chrRacesSelect<ExtArgs> | null
    /**
     * The data needed to create a chrRaces.
     */
    data: XOR<chrRacesCreateInput, chrRacesUncheckedCreateInput>
  }


  /**
   * chrRaces createMany
   */
  export type chrRacesCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many chrRaces.
     */
    data: chrRacesCreateManyInput | chrRacesCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * chrRaces update
   */
  export type chrRacesUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the chrRaces
     */
    select?: chrRacesSelect<ExtArgs> | null
    /**
     * The data needed to update a chrRaces.
     */
    data: XOR<chrRacesUpdateInput, chrRacesUncheckedUpdateInput>
    /**
     * Choose, which chrRaces to update.
     */
    where: chrRacesWhereUniqueInput
  }


  /**
   * chrRaces updateMany
   */
  export type chrRacesUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update chrRaces.
     */
    data: XOR<chrRacesUpdateManyMutationInput, chrRacesUncheckedUpdateManyInput>
    /**
     * Filter which chrRaces to update
     */
    where?: chrRacesWhereInput
  }


  /**
   * chrRaces upsert
   */
  export type chrRacesUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the chrRaces
     */
    select?: chrRacesSelect<ExtArgs> | null
    /**
     * The filter to search for the chrRaces to update in case it exists.
     */
    where: chrRacesWhereUniqueInput
    /**
     * In case the chrRaces found by the `where` argument doesn't exist, create a new chrRaces with this data.
     */
    create: XOR<chrRacesCreateInput, chrRacesUncheckedCreateInput>
    /**
     * In case the chrRaces was found with the provided `where` argument, update it with this data.
     */
    update: XOR<chrRacesUpdateInput, chrRacesUncheckedUpdateInput>
  }


  /**
   * chrRaces delete
   */
  export type chrRacesDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the chrRaces
     */
    select?: chrRacesSelect<ExtArgs> | null
    /**
     * Filter which chrRaces to delete.
     */
    where: chrRacesWhereUniqueInput
  }


  /**
   * chrRaces deleteMany
   */
  export type chrRacesDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which chrRaces to delete
     */
    where?: chrRacesWhereInput
  }


  /**
   * chrRaces without action
   */
  export type chrRacesDefaultArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the chrRaces
     */
    select?: chrRacesSelect<ExtArgs> | null
  }



  /**
   * Model crpActivities
   */

  export type AggregateCrpActivities = {
    _count: CrpActivitiesCountAggregateOutputType | null
    _avg: CrpActivitiesAvgAggregateOutputType | null
    _sum: CrpActivitiesSumAggregateOutputType | null
    _min: CrpActivitiesMinAggregateOutputType | null
    _max: CrpActivitiesMaxAggregateOutputType | null
  }

  export type CrpActivitiesAvgAggregateOutputType = {
    activityID: number | null
  }

  export type CrpActivitiesSumAggregateOutputType = {
    activityID: number | null
  }

  export type CrpActivitiesMinAggregateOutputType = {
    activityID: number | null
    activityName: string | null
    description: string | null
  }

  export type CrpActivitiesMaxAggregateOutputType = {
    activityID: number | null
    activityName: string | null
    description: string | null
  }

  export type CrpActivitiesCountAggregateOutputType = {
    activityID: number
    activityName: number
    description: number
    _all: number
  }


  export type CrpActivitiesAvgAggregateInputType = {
    activityID?: true
  }

  export type CrpActivitiesSumAggregateInputType = {
    activityID?: true
  }

  export type CrpActivitiesMinAggregateInputType = {
    activityID?: true
    activityName?: true
    description?: true
  }

  export type CrpActivitiesMaxAggregateInputType = {
    activityID?: true
    activityName?: true
    description?: true
  }

  export type CrpActivitiesCountAggregateInputType = {
    activityID?: true
    activityName?: true
    description?: true
    _all?: true
  }

  export type CrpActivitiesAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which crpActivities to aggregate.
     */
    where?: crpActivitiesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of crpActivities to fetch.
     */
    orderBy?: crpActivitiesOrderByWithRelationInput | crpActivitiesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: crpActivitiesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` crpActivities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` crpActivities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned crpActivities
    **/
    _count?: true | CrpActivitiesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CrpActivitiesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CrpActivitiesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CrpActivitiesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CrpActivitiesMaxAggregateInputType
  }

  export type GetCrpActivitiesAggregateType<T extends CrpActivitiesAggregateArgs> = {
        [P in keyof T & keyof AggregateCrpActivities]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCrpActivities[P]>
      : GetScalarType<T[P], AggregateCrpActivities[P]>
  }




  export type crpActivitiesGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: crpActivitiesWhereInput
    orderBy?: crpActivitiesOrderByWithAggregationInput | crpActivitiesOrderByWithAggregationInput[]
    by: CrpActivitiesScalarFieldEnum[] | CrpActivitiesScalarFieldEnum
    having?: crpActivitiesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CrpActivitiesCountAggregateInputType | true
    _avg?: CrpActivitiesAvgAggregateInputType
    _sum?: CrpActivitiesSumAggregateInputType
    _min?: CrpActivitiesMinAggregateInputType
    _max?: CrpActivitiesMaxAggregateInputType
  }

  export type CrpActivitiesGroupByOutputType = {
    activityID: number
    activityName: string | null
    description: string | null
    _count: CrpActivitiesCountAggregateOutputType | null
    _avg: CrpActivitiesAvgAggregateOutputType | null
    _sum: CrpActivitiesSumAggregateOutputType | null
    _min: CrpActivitiesMinAggregateOutputType | null
    _max: CrpActivitiesMaxAggregateOutputType | null
  }

  type GetCrpActivitiesGroupByPayload<T extends crpActivitiesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CrpActivitiesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CrpActivitiesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CrpActivitiesGroupByOutputType[P]>
            : GetScalarType<T[P], CrpActivitiesGroupByOutputType[P]>
        }
      >
    >


  export type crpActivitiesSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    activityID?: boolean
    activityName?: boolean
    description?: boolean
  }, ExtArgs["result"]["crpActivities"]>

  export type crpActivitiesSelectScalar = {
    activityID?: boolean
    activityName?: boolean
    description?: boolean
  }


  export type $crpActivitiesPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    name: "crpActivities"
    objects: {}
    scalars: $Extensions.GetResult<{
      activityID: number
      activityName: string | null
      description: string | null
    }, ExtArgs["result"]["crpActivities"]>
    composites: {}
  }


  type crpActivitiesGetPayload<S extends boolean | null | undefined | crpActivitiesDefaultArgs> = $Result.GetResult<Prisma.$crpActivitiesPayload, S>

  type crpActivitiesCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<crpActivitiesFindManyArgs, 'select' | 'include'> & {
      select?: CrpActivitiesCountAggregateInputType | true
    }

  export interface crpActivitiesDelegate<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['crpActivities'], meta: { name: 'crpActivities' } }
    /**
     * Find zero or one CrpActivities that matches the filter.
     * @param {crpActivitiesFindUniqueArgs} args - Arguments to find a CrpActivities
     * @example
     * // Get one CrpActivities
     * const crpActivities = await prisma.crpActivities.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends crpActivitiesFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, crpActivitiesFindUniqueArgs<ExtArgs>>
    ): Prisma__crpActivitiesClient<$Result.GetResult<Prisma.$crpActivitiesPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one CrpActivities that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {crpActivitiesFindUniqueOrThrowArgs} args - Arguments to find a CrpActivities
     * @example
     * // Get one CrpActivities
     * const crpActivities = await prisma.crpActivities.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends crpActivitiesFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, crpActivitiesFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__crpActivitiesClient<$Result.GetResult<Prisma.$crpActivitiesPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first CrpActivities that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {crpActivitiesFindFirstArgs} args - Arguments to find a CrpActivities
     * @example
     * // Get one CrpActivities
     * const crpActivities = await prisma.crpActivities.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends crpActivitiesFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, crpActivitiesFindFirstArgs<ExtArgs>>
    ): Prisma__crpActivitiesClient<$Result.GetResult<Prisma.$crpActivitiesPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first CrpActivities that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {crpActivitiesFindFirstOrThrowArgs} args - Arguments to find a CrpActivities
     * @example
     * // Get one CrpActivities
     * const crpActivities = await prisma.crpActivities.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends crpActivitiesFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, crpActivitiesFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__crpActivitiesClient<$Result.GetResult<Prisma.$crpActivitiesPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more CrpActivities that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {crpActivitiesFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CrpActivities
     * const crpActivities = await prisma.crpActivities.findMany()
     * 
     * // Get first 10 CrpActivities
     * const crpActivities = await prisma.crpActivities.findMany({ take: 10 })
     * 
     * // Only select the `activityID`
     * const crpActivitiesWithActivityIDOnly = await prisma.crpActivities.findMany({ select: { activityID: true } })
     * 
    **/
    findMany<T extends crpActivitiesFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, crpActivitiesFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$crpActivitiesPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a CrpActivities.
     * @param {crpActivitiesCreateArgs} args - Arguments to create a CrpActivities.
     * @example
     * // Create one CrpActivities
     * const CrpActivities = await prisma.crpActivities.create({
     *   data: {
     *     // ... data to create a CrpActivities
     *   }
     * })
     * 
    **/
    create<T extends crpActivitiesCreateArgs<ExtArgs>>(
      args: SelectSubset<T, crpActivitiesCreateArgs<ExtArgs>>
    ): Prisma__crpActivitiesClient<$Result.GetResult<Prisma.$crpActivitiesPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many CrpActivities.
     *     @param {crpActivitiesCreateManyArgs} args - Arguments to create many CrpActivities.
     *     @example
     *     // Create many CrpActivities
     *     const crpActivities = await prisma.crpActivities.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends crpActivitiesCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, crpActivitiesCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a CrpActivities.
     * @param {crpActivitiesDeleteArgs} args - Arguments to delete one CrpActivities.
     * @example
     * // Delete one CrpActivities
     * const CrpActivities = await prisma.crpActivities.delete({
     *   where: {
     *     // ... filter to delete one CrpActivities
     *   }
     * })
     * 
    **/
    delete<T extends crpActivitiesDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, crpActivitiesDeleteArgs<ExtArgs>>
    ): Prisma__crpActivitiesClient<$Result.GetResult<Prisma.$crpActivitiesPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one CrpActivities.
     * @param {crpActivitiesUpdateArgs} args - Arguments to update one CrpActivities.
     * @example
     * // Update one CrpActivities
     * const crpActivities = await prisma.crpActivities.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends crpActivitiesUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, crpActivitiesUpdateArgs<ExtArgs>>
    ): Prisma__crpActivitiesClient<$Result.GetResult<Prisma.$crpActivitiesPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more CrpActivities.
     * @param {crpActivitiesDeleteManyArgs} args - Arguments to filter CrpActivities to delete.
     * @example
     * // Delete a few CrpActivities
     * const { count } = await prisma.crpActivities.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends crpActivitiesDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, crpActivitiesDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CrpActivities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {crpActivitiesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CrpActivities
     * const crpActivities = await prisma.crpActivities.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends crpActivitiesUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, crpActivitiesUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one CrpActivities.
     * @param {crpActivitiesUpsertArgs} args - Arguments to update or create a CrpActivities.
     * @example
     * // Update or create a CrpActivities
     * const crpActivities = await prisma.crpActivities.upsert({
     *   create: {
     *     // ... data to create a CrpActivities
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CrpActivities we want to update
     *   }
     * })
    **/
    upsert<T extends crpActivitiesUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, crpActivitiesUpsertArgs<ExtArgs>>
    ): Prisma__crpActivitiesClient<$Result.GetResult<Prisma.$crpActivitiesPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of CrpActivities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {crpActivitiesCountArgs} args - Arguments to filter CrpActivities to count.
     * @example
     * // Count the number of CrpActivities
     * const count = await prisma.crpActivities.count({
     *   where: {
     *     // ... the filter for the CrpActivities we want to count
     *   }
     * })
    **/
    count<T extends crpActivitiesCountArgs>(
      args?: Subset<T, crpActivitiesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CrpActivitiesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CrpActivities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CrpActivitiesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CrpActivitiesAggregateArgs>(args: Subset<T, CrpActivitiesAggregateArgs>): Prisma.PrismaPromise<GetCrpActivitiesAggregateType<T>>

    /**
     * Group by CrpActivities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {crpActivitiesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends crpActivitiesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: crpActivitiesGroupByArgs['orderBy'] }
        : { orderBy?: crpActivitiesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, crpActivitiesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCrpActivitiesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the crpActivities model
   */
  readonly fields: crpActivitiesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for crpActivities.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__crpActivitiesClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';


    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the crpActivities model
   */ 
  interface crpActivitiesFieldRefs {
    readonly activityID: FieldRef<"crpActivities", 'Int'>
    readonly activityName: FieldRef<"crpActivities", 'String'>
    readonly description: FieldRef<"crpActivities", 'String'>
  }
    

  // Custom InputTypes

  /**
   * crpActivities findUnique
   */
  export type crpActivitiesFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the crpActivities
     */
    select?: crpActivitiesSelect<ExtArgs> | null
    /**
     * Filter, which crpActivities to fetch.
     */
    where: crpActivitiesWhereUniqueInput
  }


  /**
   * crpActivities findUniqueOrThrow
   */
  export type crpActivitiesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the crpActivities
     */
    select?: crpActivitiesSelect<ExtArgs> | null
    /**
     * Filter, which crpActivities to fetch.
     */
    where: crpActivitiesWhereUniqueInput
  }


  /**
   * crpActivities findFirst
   */
  export type crpActivitiesFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the crpActivities
     */
    select?: crpActivitiesSelect<ExtArgs> | null
    /**
     * Filter, which crpActivities to fetch.
     */
    where?: crpActivitiesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of crpActivities to fetch.
     */
    orderBy?: crpActivitiesOrderByWithRelationInput | crpActivitiesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for crpActivities.
     */
    cursor?: crpActivitiesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` crpActivities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` crpActivities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of crpActivities.
     */
    distinct?: CrpActivitiesScalarFieldEnum | CrpActivitiesScalarFieldEnum[]
  }


  /**
   * crpActivities findFirstOrThrow
   */
  export type crpActivitiesFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the crpActivities
     */
    select?: crpActivitiesSelect<ExtArgs> | null
    /**
     * Filter, which crpActivities to fetch.
     */
    where?: crpActivitiesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of crpActivities to fetch.
     */
    orderBy?: crpActivitiesOrderByWithRelationInput | crpActivitiesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for crpActivities.
     */
    cursor?: crpActivitiesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` crpActivities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` crpActivities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of crpActivities.
     */
    distinct?: CrpActivitiesScalarFieldEnum | CrpActivitiesScalarFieldEnum[]
  }


  /**
   * crpActivities findMany
   */
  export type crpActivitiesFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the crpActivities
     */
    select?: crpActivitiesSelect<ExtArgs> | null
    /**
     * Filter, which crpActivities to fetch.
     */
    where?: crpActivitiesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of crpActivities to fetch.
     */
    orderBy?: crpActivitiesOrderByWithRelationInput | crpActivitiesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing crpActivities.
     */
    cursor?: crpActivitiesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` crpActivities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` crpActivities.
     */
    skip?: number
    distinct?: CrpActivitiesScalarFieldEnum | CrpActivitiesScalarFieldEnum[]
  }


  /**
   * crpActivities create
   */
  export type crpActivitiesCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the crpActivities
     */
    select?: crpActivitiesSelect<ExtArgs> | null
    /**
     * The data needed to create a crpActivities.
     */
    data: XOR<crpActivitiesCreateInput, crpActivitiesUncheckedCreateInput>
  }


  /**
   * crpActivities createMany
   */
  export type crpActivitiesCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many crpActivities.
     */
    data: crpActivitiesCreateManyInput | crpActivitiesCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * crpActivities update
   */
  export type crpActivitiesUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the crpActivities
     */
    select?: crpActivitiesSelect<ExtArgs> | null
    /**
     * The data needed to update a crpActivities.
     */
    data: XOR<crpActivitiesUpdateInput, crpActivitiesUncheckedUpdateInput>
    /**
     * Choose, which crpActivities to update.
     */
    where: crpActivitiesWhereUniqueInput
  }


  /**
   * crpActivities updateMany
   */
  export type crpActivitiesUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update crpActivities.
     */
    data: XOR<crpActivitiesUpdateManyMutationInput, crpActivitiesUncheckedUpdateManyInput>
    /**
     * Filter which crpActivities to update
     */
    where?: crpActivitiesWhereInput
  }


  /**
   * crpActivities upsert
   */
  export type crpActivitiesUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the crpActivities
     */
    select?: crpActivitiesSelect<ExtArgs> | null
    /**
     * The filter to search for the crpActivities to update in case it exists.
     */
    where: crpActivitiesWhereUniqueInput
    /**
     * In case the crpActivities found by the `where` argument doesn't exist, create a new crpActivities with this data.
     */
    create: XOR<crpActivitiesCreateInput, crpActivitiesUncheckedCreateInput>
    /**
     * In case the crpActivities was found with the provided `where` argument, update it with this data.
     */
    update: XOR<crpActivitiesUpdateInput, crpActivitiesUncheckedUpdateInput>
  }


  /**
   * crpActivities delete
   */
  export type crpActivitiesDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the crpActivities
     */
    select?: crpActivitiesSelect<ExtArgs> | null
    /**
     * Filter which crpActivities to delete.
     */
    where: crpActivitiesWhereUniqueInput
  }


  /**
   * crpActivities deleteMany
   */
  export type crpActivitiesDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which crpActivities to delete
     */
    where?: crpActivitiesWhereInput
  }


  /**
   * crpActivities without action
   */
  export type crpActivitiesDefaultArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the crpActivities
     */
    select?: crpActivitiesSelect<ExtArgs> | null
  }



  /**
   * Model crpNPCCorporationDivisions
   */

  export type AggregateCrpNPCCorporationDivisions = {
    _count: CrpNPCCorporationDivisionsCountAggregateOutputType | null
    _avg: CrpNPCCorporationDivisionsAvgAggregateOutputType | null
    _sum: CrpNPCCorporationDivisionsSumAggregateOutputType | null
    _min: CrpNPCCorporationDivisionsMinAggregateOutputType | null
    _max: CrpNPCCorporationDivisionsMaxAggregateOutputType | null
  }

  export type CrpNPCCorporationDivisionsAvgAggregateOutputType = {
    corporationID: number | null
    divisionID: number | null
    size: number | null
  }

  export type CrpNPCCorporationDivisionsSumAggregateOutputType = {
    corporationID: number | null
    divisionID: number | null
    size: number | null
  }

  export type CrpNPCCorporationDivisionsMinAggregateOutputType = {
    corporationID: number | null
    divisionID: number | null
    size: number | null
  }

  export type CrpNPCCorporationDivisionsMaxAggregateOutputType = {
    corporationID: number | null
    divisionID: number | null
    size: number | null
  }

  export type CrpNPCCorporationDivisionsCountAggregateOutputType = {
    corporationID: number
    divisionID: number
    size: number
    _all: number
  }


  export type CrpNPCCorporationDivisionsAvgAggregateInputType = {
    corporationID?: true
    divisionID?: true
    size?: true
  }

  export type CrpNPCCorporationDivisionsSumAggregateInputType = {
    corporationID?: true
    divisionID?: true
    size?: true
  }

  export type CrpNPCCorporationDivisionsMinAggregateInputType = {
    corporationID?: true
    divisionID?: true
    size?: true
  }

  export type CrpNPCCorporationDivisionsMaxAggregateInputType = {
    corporationID?: true
    divisionID?: true
    size?: true
  }

  export type CrpNPCCorporationDivisionsCountAggregateInputType = {
    corporationID?: true
    divisionID?: true
    size?: true
    _all?: true
  }

  export type CrpNPCCorporationDivisionsAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which crpNPCCorporationDivisions to aggregate.
     */
    where?: crpNPCCorporationDivisionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of crpNPCCorporationDivisions to fetch.
     */
    orderBy?: crpNPCCorporationDivisionsOrderByWithRelationInput | crpNPCCorporationDivisionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: crpNPCCorporationDivisionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` crpNPCCorporationDivisions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` crpNPCCorporationDivisions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned crpNPCCorporationDivisions
    **/
    _count?: true | CrpNPCCorporationDivisionsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CrpNPCCorporationDivisionsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CrpNPCCorporationDivisionsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CrpNPCCorporationDivisionsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CrpNPCCorporationDivisionsMaxAggregateInputType
  }

  export type GetCrpNPCCorporationDivisionsAggregateType<T extends CrpNPCCorporationDivisionsAggregateArgs> = {
        [P in keyof T & keyof AggregateCrpNPCCorporationDivisions]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCrpNPCCorporationDivisions[P]>
      : GetScalarType<T[P], AggregateCrpNPCCorporationDivisions[P]>
  }




  export type crpNPCCorporationDivisionsGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: crpNPCCorporationDivisionsWhereInput
    orderBy?: crpNPCCorporationDivisionsOrderByWithAggregationInput | crpNPCCorporationDivisionsOrderByWithAggregationInput[]
    by: CrpNPCCorporationDivisionsScalarFieldEnum[] | CrpNPCCorporationDivisionsScalarFieldEnum
    having?: crpNPCCorporationDivisionsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CrpNPCCorporationDivisionsCountAggregateInputType | true
    _avg?: CrpNPCCorporationDivisionsAvgAggregateInputType
    _sum?: CrpNPCCorporationDivisionsSumAggregateInputType
    _min?: CrpNPCCorporationDivisionsMinAggregateInputType
    _max?: CrpNPCCorporationDivisionsMaxAggregateInputType
  }

  export type CrpNPCCorporationDivisionsGroupByOutputType = {
    corporationID: number
    divisionID: number
    size: number | null
    _count: CrpNPCCorporationDivisionsCountAggregateOutputType | null
    _avg: CrpNPCCorporationDivisionsAvgAggregateOutputType | null
    _sum: CrpNPCCorporationDivisionsSumAggregateOutputType | null
    _min: CrpNPCCorporationDivisionsMinAggregateOutputType | null
    _max: CrpNPCCorporationDivisionsMaxAggregateOutputType | null
  }

  type GetCrpNPCCorporationDivisionsGroupByPayload<T extends crpNPCCorporationDivisionsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CrpNPCCorporationDivisionsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CrpNPCCorporationDivisionsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CrpNPCCorporationDivisionsGroupByOutputType[P]>
            : GetScalarType<T[P], CrpNPCCorporationDivisionsGroupByOutputType[P]>
        }
      >
    >


  export type crpNPCCorporationDivisionsSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    corporationID?: boolean
    divisionID?: boolean
    size?: boolean
  }, ExtArgs["result"]["crpNPCCorporationDivisions"]>

  export type crpNPCCorporationDivisionsSelectScalar = {
    corporationID?: boolean
    divisionID?: boolean
    size?: boolean
  }


  export type $crpNPCCorporationDivisionsPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    name: "crpNPCCorporationDivisions"
    objects: {}
    scalars: $Extensions.GetResult<{
      corporationID: number
      divisionID: number
      size: number | null
    }, ExtArgs["result"]["crpNPCCorporationDivisions"]>
    composites: {}
  }


  type crpNPCCorporationDivisionsGetPayload<S extends boolean | null | undefined | crpNPCCorporationDivisionsDefaultArgs> = $Result.GetResult<Prisma.$crpNPCCorporationDivisionsPayload, S>

  type crpNPCCorporationDivisionsCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<crpNPCCorporationDivisionsFindManyArgs, 'select' | 'include'> & {
      select?: CrpNPCCorporationDivisionsCountAggregateInputType | true
    }

  export interface crpNPCCorporationDivisionsDelegate<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['crpNPCCorporationDivisions'], meta: { name: 'crpNPCCorporationDivisions' } }
    /**
     * Find zero or one CrpNPCCorporationDivisions that matches the filter.
     * @param {crpNPCCorporationDivisionsFindUniqueArgs} args - Arguments to find a CrpNPCCorporationDivisions
     * @example
     * // Get one CrpNPCCorporationDivisions
     * const crpNPCCorporationDivisions = await prisma.crpNPCCorporationDivisions.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends crpNPCCorporationDivisionsFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, crpNPCCorporationDivisionsFindUniqueArgs<ExtArgs>>
    ): Prisma__crpNPCCorporationDivisionsClient<$Result.GetResult<Prisma.$crpNPCCorporationDivisionsPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one CrpNPCCorporationDivisions that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {crpNPCCorporationDivisionsFindUniqueOrThrowArgs} args - Arguments to find a CrpNPCCorporationDivisions
     * @example
     * // Get one CrpNPCCorporationDivisions
     * const crpNPCCorporationDivisions = await prisma.crpNPCCorporationDivisions.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends crpNPCCorporationDivisionsFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, crpNPCCorporationDivisionsFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__crpNPCCorporationDivisionsClient<$Result.GetResult<Prisma.$crpNPCCorporationDivisionsPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first CrpNPCCorporationDivisions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {crpNPCCorporationDivisionsFindFirstArgs} args - Arguments to find a CrpNPCCorporationDivisions
     * @example
     * // Get one CrpNPCCorporationDivisions
     * const crpNPCCorporationDivisions = await prisma.crpNPCCorporationDivisions.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends crpNPCCorporationDivisionsFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, crpNPCCorporationDivisionsFindFirstArgs<ExtArgs>>
    ): Prisma__crpNPCCorporationDivisionsClient<$Result.GetResult<Prisma.$crpNPCCorporationDivisionsPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first CrpNPCCorporationDivisions that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {crpNPCCorporationDivisionsFindFirstOrThrowArgs} args - Arguments to find a CrpNPCCorporationDivisions
     * @example
     * // Get one CrpNPCCorporationDivisions
     * const crpNPCCorporationDivisions = await prisma.crpNPCCorporationDivisions.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends crpNPCCorporationDivisionsFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, crpNPCCorporationDivisionsFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__crpNPCCorporationDivisionsClient<$Result.GetResult<Prisma.$crpNPCCorporationDivisionsPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more CrpNPCCorporationDivisions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {crpNPCCorporationDivisionsFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CrpNPCCorporationDivisions
     * const crpNPCCorporationDivisions = await prisma.crpNPCCorporationDivisions.findMany()
     * 
     * // Get first 10 CrpNPCCorporationDivisions
     * const crpNPCCorporationDivisions = await prisma.crpNPCCorporationDivisions.findMany({ take: 10 })
     * 
     * // Only select the `corporationID`
     * const crpNPCCorporationDivisionsWithCorporationIDOnly = await prisma.crpNPCCorporationDivisions.findMany({ select: { corporationID: true } })
     * 
    **/
    findMany<T extends crpNPCCorporationDivisionsFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, crpNPCCorporationDivisionsFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$crpNPCCorporationDivisionsPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a CrpNPCCorporationDivisions.
     * @param {crpNPCCorporationDivisionsCreateArgs} args - Arguments to create a CrpNPCCorporationDivisions.
     * @example
     * // Create one CrpNPCCorporationDivisions
     * const CrpNPCCorporationDivisions = await prisma.crpNPCCorporationDivisions.create({
     *   data: {
     *     // ... data to create a CrpNPCCorporationDivisions
     *   }
     * })
     * 
    **/
    create<T extends crpNPCCorporationDivisionsCreateArgs<ExtArgs>>(
      args: SelectSubset<T, crpNPCCorporationDivisionsCreateArgs<ExtArgs>>
    ): Prisma__crpNPCCorporationDivisionsClient<$Result.GetResult<Prisma.$crpNPCCorporationDivisionsPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many CrpNPCCorporationDivisions.
     *     @param {crpNPCCorporationDivisionsCreateManyArgs} args - Arguments to create many CrpNPCCorporationDivisions.
     *     @example
     *     // Create many CrpNPCCorporationDivisions
     *     const crpNPCCorporationDivisions = await prisma.crpNPCCorporationDivisions.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends crpNPCCorporationDivisionsCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, crpNPCCorporationDivisionsCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a CrpNPCCorporationDivisions.
     * @param {crpNPCCorporationDivisionsDeleteArgs} args - Arguments to delete one CrpNPCCorporationDivisions.
     * @example
     * // Delete one CrpNPCCorporationDivisions
     * const CrpNPCCorporationDivisions = await prisma.crpNPCCorporationDivisions.delete({
     *   where: {
     *     // ... filter to delete one CrpNPCCorporationDivisions
     *   }
     * })
     * 
    **/
    delete<T extends crpNPCCorporationDivisionsDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, crpNPCCorporationDivisionsDeleteArgs<ExtArgs>>
    ): Prisma__crpNPCCorporationDivisionsClient<$Result.GetResult<Prisma.$crpNPCCorporationDivisionsPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one CrpNPCCorporationDivisions.
     * @param {crpNPCCorporationDivisionsUpdateArgs} args - Arguments to update one CrpNPCCorporationDivisions.
     * @example
     * // Update one CrpNPCCorporationDivisions
     * const crpNPCCorporationDivisions = await prisma.crpNPCCorporationDivisions.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends crpNPCCorporationDivisionsUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, crpNPCCorporationDivisionsUpdateArgs<ExtArgs>>
    ): Prisma__crpNPCCorporationDivisionsClient<$Result.GetResult<Prisma.$crpNPCCorporationDivisionsPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more CrpNPCCorporationDivisions.
     * @param {crpNPCCorporationDivisionsDeleteManyArgs} args - Arguments to filter CrpNPCCorporationDivisions to delete.
     * @example
     * // Delete a few CrpNPCCorporationDivisions
     * const { count } = await prisma.crpNPCCorporationDivisions.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends crpNPCCorporationDivisionsDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, crpNPCCorporationDivisionsDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CrpNPCCorporationDivisions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {crpNPCCorporationDivisionsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CrpNPCCorporationDivisions
     * const crpNPCCorporationDivisions = await prisma.crpNPCCorporationDivisions.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends crpNPCCorporationDivisionsUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, crpNPCCorporationDivisionsUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one CrpNPCCorporationDivisions.
     * @param {crpNPCCorporationDivisionsUpsertArgs} args - Arguments to update or create a CrpNPCCorporationDivisions.
     * @example
     * // Update or create a CrpNPCCorporationDivisions
     * const crpNPCCorporationDivisions = await prisma.crpNPCCorporationDivisions.upsert({
     *   create: {
     *     // ... data to create a CrpNPCCorporationDivisions
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CrpNPCCorporationDivisions we want to update
     *   }
     * })
    **/
    upsert<T extends crpNPCCorporationDivisionsUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, crpNPCCorporationDivisionsUpsertArgs<ExtArgs>>
    ): Prisma__crpNPCCorporationDivisionsClient<$Result.GetResult<Prisma.$crpNPCCorporationDivisionsPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of CrpNPCCorporationDivisions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {crpNPCCorporationDivisionsCountArgs} args - Arguments to filter CrpNPCCorporationDivisions to count.
     * @example
     * // Count the number of CrpNPCCorporationDivisions
     * const count = await prisma.crpNPCCorporationDivisions.count({
     *   where: {
     *     // ... the filter for the CrpNPCCorporationDivisions we want to count
     *   }
     * })
    **/
    count<T extends crpNPCCorporationDivisionsCountArgs>(
      args?: Subset<T, crpNPCCorporationDivisionsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CrpNPCCorporationDivisionsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CrpNPCCorporationDivisions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CrpNPCCorporationDivisionsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CrpNPCCorporationDivisionsAggregateArgs>(args: Subset<T, CrpNPCCorporationDivisionsAggregateArgs>): Prisma.PrismaPromise<GetCrpNPCCorporationDivisionsAggregateType<T>>

    /**
     * Group by CrpNPCCorporationDivisions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {crpNPCCorporationDivisionsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends crpNPCCorporationDivisionsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: crpNPCCorporationDivisionsGroupByArgs['orderBy'] }
        : { orderBy?: crpNPCCorporationDivisionsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, crpNPCCorporationDivisionsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCrpNPCCorporationDivisionsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the crpNPCCorporationDivisions model
   */
  readonly fields: crpNPCCorporationDivisionsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for crpNPCCorporationDivisions.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__crpNPCCorporationDivisionsClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';


    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the crpNPCCorporationDivisions model
   */ 
  interface crpNPCCorporationDivisionsFieldRefs {
    readonly corporationID: FieldRef<"crpNPCCorporationDivisions", 'Int'>
    readonly divisionID: FieldRef<"crpNPCCorporationDivisions", 'Int'>
    readonly size: FieldRef<"crpNPCCorporationDivisions", 'Int'>
  }
    

  // Custom InputTypes

  /**
   * crpNPCCorporationDivisions findUnique
   */
  export type crpNPCCorporationDivisionsFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the crpNPCCorporationDivisions
     */
    select?: crpNPCCorporationDivisionsSelect<ExtArgs> | null
    /**
     * Filter, which crpNPCCorporationDivisions to fetch.
     */
    where: crpNPCCorporationDivisionsWhereUniqueInput
  }


  /**
   * crpNPCCorporationDivisions findUniqueOrThrow
   */
  export type crpNPCCorporationDivisionsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the crpNPCCorporationDivisions
     */
    select?: crpNPCCorporationDivisionsSelect<ExtArgs> | null
    /**
     * Filter, which crpNPCCorporationDivisions to fetch.
     */
    where: crpNPCCorporationDivisionsWhereUniqueInput
  }


  /**
   * crpNPCCorporationDivisions findFirst
   */
  export type crpNPCCorporationDivisionsFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the crpNPCCorporationDivisions
     */
    select?: crpNPCCorporationDivisionsSelect<ExtArgs> | null
    /**
     * Filter, which crpNPCCorporationDivisions to fetch.
     */
    where?: crpNPCCorporationDivisionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of crpNPCCorporationDivisions to fetch.
     */
    orderBy?: crpNPCCorporationDivisionsOrderByWithRelationInput | crpNPCCorporationDivisionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for crpNPCCorporationDivisions.
     */
    cursor?: crpNPCCorporationDivisionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` crpNPCCorporationDivisions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` crpNPCCorporationDivisions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of crpNPCCorporationDivisions.
     */
    distinct?: CrpNPCCorporationDivisionsScalarFieldEnum | CrpNPCCorporationDivisionsScalarFieldEnum[]
  }


  /**
   * crpNPCCorporationDivisions findFirstOrThrow
   */
  export type crpNPCCorporationDivisionsFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the crpNPCCorporationDivisions
     */
    select?: crpNPCCorporationDivisionsSelect<ExtArgs> | null
    /**
     * Filter, which crpNPCCorporationDivisions to fetch.
     */
    where?: crpNPCCorporationDivisionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of crpNPCCorporationDivisions to fetch.
     */
    orderBy?: crpNPCCorporationDivisionsOrderByWithRelationInput | crpNPCCorporationDivisionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for crpNPCCorporationDivisions.
     */
    cursor?: crpNPCCorporationDivisionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` crpNPCCorporationDivisions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` crpNPCCorporationDivisions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of crpNPCCorporationDivisions.
     */
    distinct?: CrpNPCCorporationDivisionsScalarFieldEnum | CrpNPCCorporationDivisionsScalarFieldEnum[]
  }


  /**
   * crpNPCCorporationDivisions findMany
   */
  export type crpNPCCorporationDivisionsFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the crpNPCCorporationDivisions
     */
    select?: crpNPCCorporationDivisionsSelect<ExtArgs> | null
    /**
     * Filter, which crpNPCCorporationDivisions to fetch.
     */
    where?: crpNPCCorporationDivisionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of crpNPCCorporationDivisions to fetch.
     */
    orderBy?: crpNPCCorporationDivisionsOrderByWithRelationInput | crpNPCCorporationDivisionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing crpNPCCorporationDivisions.
     */
    cursor?: crpNPCCorporationDivisionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` crpNPCCorporationDivisions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` crpNPCCorporationDivisions.
     */
    skip?: number
    distinct?: CrpNPCCorporationDivisionsScalarFieldEnum | CrpNPCCorporationDivisionsScalarFieldEnum[]
  }


  /**
   * crpNPCCorporationDivisions create
   */
  export type crpNPCCorporationDivisionsCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the crpNPCCorporationDivisions
     */
    select?: crpNPCCorporationDivisionsSelect<ExtArgs> | null
    /**
     * The data needed to create a crpNPCCorporationDivisions.
     */
    data: XOR<crpNPCCorporationDivisionsCreateInput, crpNPCCorporationDivisionsUncheckedCreateInput>
  }


  /**
   * crpNPCCorporationDivisions createMany
   */
  export type crpNPCCorporationDivisionsCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many crpNPCCorporationDivisions.
     */
    data: crpNPCCorporationDivisionsCreateManyInput | crpNPCCorporationDivisionsCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * crpNPCCorporationDivisions update
   */
  export type crpNPCCorporationDivisionsUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the crpNPCCorporationDivisions
     */
    select?: crpNPCCorporationDivisionsSelect<ExtArgs> | null
    /**
     * The data needed to update a crpNPCCorporationDivisions.
     */
    data: XOR<crpNPCCorporationDivisionsUpdateInput, crpNPCCorporationDivisionsUncheckedUpdateInput>
    /**
     * Choose, which crpNPCCorporationDivisions to update.
     */
    where: crpNPCCorporationDivisionsWhereUniqueInput
  }


  /**
   * crpNPCCorporationDivisions updateMany
   */
  export type crpNPCCorporationDivisionsUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update crpNPCCorporationDivisions.
     */
    data: XOR<crpNPCCorporationDivisionsUpdateManyMutationInput, crpNPCCorporationDivisionsUncheckedUpdateManyInput>
    /**
     * Filter which crpNPCCorporationDivisions to update
     */
    where?: crpNPCCorporationDivisionsWhereInput
  }


  /**
   * crpNPCCorporationDivisions upsert
   */
  export type crpNPCCorporationDivisionsUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the crpNPCCorporationDivisions
     */
    select?: crpNPCCorporationDivisionsSelect<ExtArgs> | null
    /**
     * The filter to search for the crpNPCCorporationDivisions to update in case it exists.
     */
    where: crpNPCCorporationDivisionsWhereUniqueInput
    /**
     * In case the crpNPCCorporationDivisions found by the `where` argument doesn't exist, create a new crpNPCCorporationDivisions with this data.
     */
    create: XOR<crpNPCCorporationDivisionsCreateInput, crpNPCCorporationDivisionsUncheckedCreateInput>
    /**
     * In case the crpNPCCorporationDivisions was found with the provided `where` argument, update it with this data.
     */
    update: XOR<crpNPCCorporationDivisionsUpdateInput, crpNPCCorporationDivisionsUncheckedUpdateInput>
  }


  /**
   * crpNPCCorporationDivisions delete
   */
  export type crpNPCCorporationDivisionsDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the crpNPCCorporationDivisions
     */
    select?: crpNPCCorporationDivisionsSelect<ExtArgs> | null
    /**
     * Filter which crpNPCCorporationDivisions to delete.
     */
    where: crpNPCCorporationDivisionsWhereUniqueInput
  }


  /**
   * crpNPCCorporationDivisions deleteMany
   */
  export type crpNPCCorporationDivisionsDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which crpNPCCorporationDivisions to delete
     */
    where?: crpNPCCorporationDivisionsWhereInput
  }


  /**
   * crpNPCCorporationDivisions without action
   */
  export type crpNPCCorporationDivisionsDefaultArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the crpNPCCorporationDivisions
     */
    select?: crpNPCCorporationDivisionsSelect<ExtArgs> | null
  }



  /**
   * Model crpNPCCorporationResearchFields
   */

  export type AggregateCrpNPCCorporationResearchFields = {
    _count: CrpNPCCorporationResearchFieldsCountAggregateOutputType | null
    _avg: CrpNPCCorporationResearchFieldsAvgAggregateOutputType | null
    _sum: CrpNPCCorporationResearchFieldsSumAggregateOutputType | null
    _min: CrpNPCCorporationResearchFieldsMinAggregateOutputType | null
    _max: CrpNPCCorporationResearchFieldsMaxAggregateOutputType | null
  }

  export type CrpNPCCorporationResearchFieldsAvgAggregateOutputType = {
    skillID: number | null
    corporationID: number | null
  }

  export type CrpNPCCorporationResearchFieldsSumAggregateOutputType = {
    skillID: number | null
    corporationID: number | null
  }

  export type CrpNPCCorporationResearchFieldsMinAggregateOutputType = {
    skillID: number | null
    corporationID: number | null
  }

  export type CrpNPCCorporationResearchFieldsMaxAggregateOutputType = {
    skillID: number | null
    corporationID: number | null
  }

  export type CrpNPCCorporationResearchFieldsCountAggregateOutputType = {
    skillID: number
    corporationID: number
    _all: number
  }


  export type CrpNPCCorporationResearchFieldsAvgAggregateInputType = {
    skillID?: true
    corporationID?: true
  }

  export type CrpNPCCorporationResearchFieldsSumAggregateInputType = {
    skillID?: true
    corporationID?: true
  }

  export type CrpNPCCorporationResearchFieldsMinAggregateInputType = {
    skillID?: true
    corporationID?: true
  }

  export type CrpNPCCorporationResearchFieldsMaxAggregateInputType = {
    skillID?: true
    corporationID?: true
  }

  export type CrpNPCCorporationResearchFieldsCountAggregateInputType = {
    skillID?: true
    corporationID?: true
    _all?: true
  }

  export type CrpNPCCorporationResearchFieldsAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which crpNPCCorporationResearchFields to aggregate.
     */
    where?: crpNPCCorporationResearchFieldsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of crpNPCCorporationResearchFields to fetch.
     */
    orderBy?: crpNPCCorporationResearchFieldsOrderByWithRelationInput | crpNPCCorporationResearchFieldsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: crpNPCCorporationResearchFieldsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` crpNPCCorporationResearchFields from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` crpNPCCorporationResearchFields.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned crpNPCCorporationResearchFields
    **/
    _count?: true | CrpNPCCorporationResearchFieldsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CrpNPCCorporationResearchFieldsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CrpNPCCorporationResearchFieldsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CrpNPCCorporationResearchFieldsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CrpNPCCorporationResearchFieldsMaxAggregateInputType
  }

  export type GetCrpNPCCorporationResearchFieldsAggregateType<T extends CrpNPCCorporationResearchFieldsAggregateArgs> = {
        [P in keyof T & keyof AggregateCrpNPCCorporationResearchFields]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCrpNPCCorporationResearchFields[P]>
      : GetScalarType<T[P], AggregateCrpNPCCorporationResearchFields[P]>
  }




  export type crpNPCCorporationResearchFieldsGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: crpNPCCorporationResearchFieldsWhereInput
    orderBy?: crpNPCCorporationResearchFieldsOrderByWithAggregationInput | crpNPCCorporationResearchFieldsOrderByWithAggregationInput[]
    by: CrpNPCCorporationResearchFieldsScalarFieldEnum[] | CrpNPCCorporationResearchFieldsScalarFieldEnum
    having?: crpNPCCorporationResearchFieldsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CrpNPCCorporationResearchFieldsCountAggregateInputType | true
    _avg?: CrpNPCCorporationResearchFieldsAvgAggregateInputType
    _sum?: CrpNPCCorporationResearchFieldsSumAggregateInputType
    _min?: CrpNPCCorporationResearchFieldsMinAggregateInputType
    _max?: CrpNPCCorporationResearchFieldsMaxAggregateInputType
  }

  export type CrpNPCCorporationResearchFieldsGroupByOutputType = {
    skillID: number
    corporationID: number
    _count: CrpNPCCorporationResearchFieldsCountAggregateOutputType | null
    _avg: CrpNPCCorporationResearchFieldsAvgAggregateOutputType | null
    _sum: CrpNPCCorporationResearchFieldsSumAggregateOutputType | null
    _min: CrpNPCCorporationResearchFieldsMinAggregateOutputType | null
    _max: CrpNPCCorporationResearchFieldsMaxAggregateOutputType | null
  }

  type GetCrpNPCCorporationResearchFieldsGroupByPayload<T extends crpNPCCorporationResearchFieldsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CrpNPCCorporationResearchFieldsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CrpNPCCorporationResearchFieldsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CrpNPCCorporationResearchFieldsGroupByOutputType[P]>
            : GetScalarType<T[P], CrpNPCCorporationResearchFieldsGroupByOutputType[P]>
        }
      >
    >


  export type crpNPCCorporationResearchFieldsSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    skillID?: boolean
    corporationID?: boolean
  }, ExtArgs["result"]["crpNPCCorporationResearchFields"]>

  export type crpNPCCorporationResearchFieldsSelectScalar = {
    skillID?: boolean
    corporationID?: boolean
  }


  export type $crpNPCCorporationResearchFieldsPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    name: "crpNPCCorporationResearchFields"
    objects: {}
    scalars: $Extensions.GetResult<{
      skillID: number
      corporationID: number
    }, ExtArgs["result"]["crpNPCCorporationResearchFields"]>
    composites: {}
  }


  type crpNPCCorporationResearchFieldsGetPayload<S extends boolean | null | undefined | crpNPCCorporationResearchFieldsDefaultArgs> = $Result.GetResult<Prisma.$crpNPCCorporationResearchFieldsPayload, S>

  type crpNPCCorporationResearchFieldsCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<crpNPCCorporationResearchFieldsFindManyArgs, 'select' | 'include'> & {
      select?: CrpNPCCorporationResearchFieldsCountAggregateInputType | true
    }

  export interface crpNPCCorporationResearchFieldsDelegate<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['crpNPCCorporationResearchFields'], meta: { name: 'crpNPCCorporationResearchFields' } }
    /**
     * Find zero or one CrpNPCCorporationResearchFields that matches the filter.
     * @param {crpNPCCorporationResearchFieldsFindUniqueArgs} args - Arguments to find a CrpNPCCorporationResearchFields
     * @example
     * // Get one CrpNPCCorporationResearchFields
     * const crpNPCCorporationResearchFields = await prisma.crpNPCCorporationResearchFields.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends crpNPCCorporationResearchFieldsFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, crpNPCCorporationResearchFieldsFindUniqueArgs<ExtArgs>>
    ): Prisma__crpNPCCorporationResearchFieldsClient<$Result.GetResult<Prisma.$crpNPCCorporationResearchFieldsPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one CrpNPCCorporationResearchFields that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {crpNPCCorporationResearchFieldsFindUniqueOrThrowArgs} args - Arguments to find a CrpNPCCorporationResearchFields
     * @example
     * // Get one CrpNPCCorporationResearchFields
     * const crpNPCCorporationResearchFields = await prisma.crpNPCCorporationResearchFields.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends crpNPCCorporationResearchFieldsFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, crpNPCCorporationResearchFieldsFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__crpNPCCorporationResearchFieldsClient<$Result.GetResult<Prisma.$crpNPCCorporationResearchFieldsPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first CrpNPCCorporationResearchFields that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {crpNPCCorporationResearchFieldsFindFirstArgs} args - Arguments to find a CrpNPCCorporationResearchFields
     * @example
     * // Get one CrpNPCCorporationResearchFields
     * const crpNPCCorporationResearchFields = await prisma.crpNPCCorporationResearchFields.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends crpNPCCorporationResearchFieldsFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, crpNPCCorporationResearchFieldsFindFirstArgs<ExtArgs>>
    ): Prisma__crpNPCCorporationResearchFieldsClient<$Result.GetResult<Prisma.$crpNPCCorporationResearchFieldsPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first CrpNPCCorporationResearchFields that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {crpNPCCorporationResearchFieldsFindFirstOrThrowArgs} args - Arguments to find a CrpNPCCorporationResearchFields
     * @example
     * // Get one CrpNPCCorporationResearchFields
     * const crpNPCCorporationResearchFields = await prisma.crpNPCCorporationResearchFields.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends crpNPCCorporationResearchFieldsFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, crpNPCCorporationResearchFieldsFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__crpNPCCorporationResearchFieldsClient<$Result.GetResult<Prisma.$crpNPCCorporationResearchFieldsPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more CrpNPCCorporationResearchFields that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {crpNPCCorporationResearchFieldsFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CrpNPCCorporationResearchFields
     * const crpNPCCorporationResearchFields = await prisma.crpNPCCorporationResearchFields.findMany()
     * 
     * // Get first 10 CrpNPCCorporationResearchFields
     * const crpNPCCorporationResearchFields = await prisma.crpNPCCorporationResearchFields.findMany({ take: 10 })
     * 
     * // Only select the `skillID`
     * const crpNPCCorporationResearchFieldsWithSkillIDOnly = await prisma.crpNPCCorporationResearchFields.findMany({ select: { skillID: true } })
     * 
    **/
    findMany<T extends crpNPCCorporationResearchFieldsFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, crpNPCCorporationResearchFieldsFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$crpNPCCorporationResearchFieldsPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a CrpNPCCorporationResearchFields.
     * @param {crpNPCCorporationResearchFieldsCreateArgs} args - Arguments to create a CrpNPCCorporationResearchFields.
     * @example
     * // Create one CrpNPCCorporationResearchFields
     * const CrpNPCCorporationResearchFields = await prisma.crpNPCCorporationResearchFields.create({
     *   data: {
     *     // ... data to create a CrpNPCCorporationResearchFields
     *   }
     * })
     * 
    **/
    create<T extends crpNPCCorporationResearchFieldsCreateArgs<ExtArgs>>(
      args: SelectSubset<T, crpNPCCorporationResearchFieldsCreateArgs<ExtArgs>>
    ): Prisma__crpNPCCorporationResearchFieldsClient<$Result.GetResult<Prisma.$crpNPCCorporationResearchFieldsPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many CrpNPCCorporationResearchFields.
     *     @param {crpNPCCorporationResearchFieldsCreateManyArgs} args - Arguments to create many CrpNPCCorporationResearchFields.
     *     @example
     *     // Create many CrpNPCCorporationResearchFields
     *     const crpNPCCorporationResearchFields = await prisma.crpNPCCorporationResearchFields.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends crpNPCCorporationResearchFieldsCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, crpNPCCorporationResearchFieldsCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a CrpNPCCorporationResearchFields.
     * @param {crpNPCCorporationResearchFieldsDeleteArgs} args - Arguments to delete one CrpNPCCorporationResearchFields.
     * @example
     * // Delete one CrpNPCCorporationResearchFields
     * const CrpNPCCorporationResearchFields = await prisma.crpNPCCorporationResearchFields.delete({
     *   where: {
     *     // ... filter to delete one CrpNPCCorporationResearchFields
     *   }
     * })
     * 
    **/
    delete<T extends crpNPCCorporationResearchFieldsDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, crpNPCCorporationResearchFieldsDeleteArgs<ExtArgs>>
    ): Prisma__crpNPCCorporationResearchFieldsClient<$Result.GetResult<Prisma.$crpNPCCorporationResearchFieldsPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one CrpNPCCorporationResearchFields.
     * @param {crpNPCCorporationResearchFieldsUpdateArgs} args - Arguments to update one CrpNPCCorporationResearchFields.
     * @example
     * // Update one CrpNPCCorporationResearchFields
     * const crpNPCCorporationResearchFields = await prisma.crpNPCCorporationResearchFields.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends crpNPCCorporationResearchFieldsUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, crpNPCCorporationResearchFieldsUpdateArgs<ExtArgs>>
    ): Prisma__crpNPCCorporationResearchFieldsClient<$Result.GetResult<Prisma.$crpNPCCorporationResearchFieldsPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more CrpNPCCorporationResearchFields.
     * @param {crpNPCCorporationResearchFieldsDeleteManyArgs} args - Arguments to filter CrpNPCCorporationResearchFields to delete.
     * @example
     * // Delete a few CrpNPCCorporationResearchFields
     * const { count } = await prisma.crpNPCCorporationResearchFields.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends crpNPCCorporationResearchFieldsDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, crpNPCCorporationResearchFieldsDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CrpNPCCorporationResearchFields.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {crpNPCCorporationResearchFieldsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CrpNPCCorporationResearchFields
     * const crpNPCCorporationResearchFields = await prisma.crpNPCCorporationResearchFields.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends crpNPCCorporationResearchFieldsUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, crpNPCCorporationResearchFieldsUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one CrpNPCCorporationResearchFields.
     * @param {crpNPCCorporationResearchFieldsUpsertArgs} args - Arguments to update or create a CrpNPCCorporationResearchFields.
     * @example
     * // Update or create a CrpNPCCorporationResearchFields
     * const crpNPCCorporationResearchFields = await prisma.crpNPCCorporationResearchFields.upsert({
     *   create: {
     *     // ... data to create a CrpNPCCorporationResearchFields
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CrpNPCCorporationResearchFields we want to update
     *   }
     * })
    **/
    upsert<T extends crpNPCCorporationResearchFieldsUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, crpNPCCorporationResearchFieldsUpsertArgs<ExtArgs>>
    ): Prisma__crpNPCCorporationResearchFieldsClient<$Result.GetResult<Prisma.$crpNPCCorporationResearchFieldsPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of CrpNPCCorporationResearchFields.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {crpNPCCorporationResearchFieldsCountArgs} args - Arguments to filter CrpNPCCorporationResearchFields to count.
     * @example
     * // Count the number of CrpNPCCorporationResearchFields
     * const count = await prisma.crpNPCCorporationResearchFields.count({
     *   where: {
     *     // ... the filter for the CrpNPCCorporationResearchFields we want to count
     *   }
     * })
    **/
    count<T extends crpNPCCorporationResearchFieldsCountArgs>(
      args?: Subset<T, crpNPCCorporationResearchFieldsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CrpNPCCorporationResearchFieldsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CrpNPCCorporationResearchFields.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CrpNPCCorporationResearchFieldsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CrpNPCCorporationResearchFieldsAggregateArgs>(args: Subset<T, CrpNPCCorporationResearchFieldsAggregateArgs>): Prisma.PrismaPromise<GetCrpNPCCorporationResearchFieldsAggregateType<T>>

    /**
     * Group by CrpNPCCorporationResearchFields.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {crpNPCCorporationResearchFieldsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends crpNPCCorporationResearchFieldsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: crpNPCCorporationResearchFieldsGroupByArgs['orderBy'] }
        : { orderBy?: crpNPCCorporationResearchFieldsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, crpNPCCorporationResearchFieldsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCrpNPCCorporationResearchFieldsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the crpNPCCorporationResearchFields model
   */
  readonly fields: crpNPCCorporationResearchFieldsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for crpNPCCorporationResearchFields.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__crpNPCCorporationResearchFieldsClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';


    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the crpNPCCorporationResearchFields model
   */ 
  interface crpNPCCorporationResearchFieldsFieldRefs {
    readonly skillID: FieldRef<"crpNPCCorporationResearchFields", 'Int'>
    readonly corporationID: FieldRef<"crpNPCCorporationResearchFields", 'Int'>
  }
    

  // Custom InputTypes

  /**
   * crpNPCCorporationResearchFields findUnique
   */
  export type crpNPCCorporationResearchFieldsFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the crpNPCCorporationResearchFields
     */
    select?: crpNPCCorporationResearchFieldsSelect<ExtArgs> | null
    /**
     * Filter, which crpNPCCorporationResearchFields to fetch.
     */
    where: crpNPCCorporationResearchFieldsWhereUniqueInput
  }


  /**
   * crpNPCCorporationResearchFields findUniqueOrThrow
   */
  export type crpNPCCorporationResearchFieldsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the crpNPCCorporationResearchFields
     */
    select?: crpNPCCorporationResearchFieldsSelect<ExtArgs> | null
    /**
     * Filter, which crpNPCCorporationResearchFields to fetch.
     */
    where: crpNPCCorporationResearchFieldsWhereUniqueInput
  }


  /**
   * crpNPCCorporationResearchFields findFirst
   */
  export type crpNPCCorporationResearchFieldsFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the crpNPCCorporationResearchFields
     */
    select?: crpNPCCorporationResearchFieldsSelect<ExtArgs> | null
    /**
     * Filter, which crpNPCCorporationResearchFields to fetch.
     */
    where?: crpNPCCorporationResearchFieldsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of crpNPCCorporationResearchFields to fetch.
     */
    orderBy?: crpNPCCorporationResearchFieldsOrderByWithRelationInput | crpNPCCorporationResearchFieldsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for crpNPCCorporationResearchFields.
     */
    cursor?: crpNPCCorporationResearchFieldsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` crpNPCCorporationResearchFields from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` crpNPCCorporationResearchFields.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of crpNPCCorporationResearchFields.
     */
    distinct?: CrpNPCCorporationResearchFieldsScalarFieldEnum | CrpNPCCorporationResearchFieldsScalarFieldEnum[]
  }


  /**
   * crpNPCCorporationResearchFields findFirstOrThrow
   */
  export type crpNPCCorporationResearchFieldsFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the crpNPCCorporationResearchFields
     */
    select?: crpNPCCorporationResearchFieldsSelect<ExtArgs> | null
    /**
     * Filter, which crpNPCCorporationResearchFields to fetch.
     */
    where?: crpNPCCorporationResearchFieldsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of crpNPCCorporationResearchFields to fetch.
     */
    orderBy?: crpNPCCorporationResearchFieldsOrderByWithRelationInput | crpNPCCorporationResearchFieldsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for crpNPCCorporationResearchFields.
     */
    cursor?: crpNPCCorporationResearchFieldsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` crpNPCCorporationResearchFields from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` crpNPCCorporationResearchFields.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of crpNPCCorporationResearchFields.
     */
    distinct?: CrpNPCCorporationResearchFieldsScalarFieldEnum | CrpNPCCorporationResearchFieldsScalarFieldEnum[]
  }


  /**
   * crpNPCCorporationResearchFields findMany
   */
  export type crpNPCCorporationResearchFieldsFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the crpNPCCorporationResearchFields
     */
    select?: crpNPCCorporationResearchFieldsSelect<ExtArgs> | null
    /**
     * Filter, which crpNPCCorporationResearchFields to fetch.
     */
    where?: crpNPCCorporationResearchFieldsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of crpNPCCorporationResearchFields to fetch.
     */
    orderBy?: crpNPCCorporationResearchFieldsOrderByWithRelationInput | crpNPCCorporationResearchFieldsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing crpNPCCorporationResearchFields.
     */
    cursor?: crpNPCCorporationResearchFieldsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` crpNPCCorporationResearchFields from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` crpNPCCorporationResearchFields.
     */
    skip?: number
    distinct?: CrpNPCCorporationResearchFieldsScalarFieldEnum | CrpNPCCorporationResearchFieldsScalarFieldEnum[]
  }


  /**
   * crpNPCCorporationResearchFields create
   */
  export type crpNPCCorporationResearchFieldsCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the crpNPCCorporationResearchFields
     */
    select?: crpNPCCorporationResearchFieldsSelect<ExtArgs> | null
    /**
     * The data needed to create a crpNPCCorporationResearchFields.
     */
    data: XOR<crpNPCCorporationResearchFieldsCreateInput, crpNPCCorporationResearchFieldsUncheckedCreateInput>
  }


  /**
   * crpNPCCorporationResearchFields createMany
   */
  export type crpNPCCorporationResearchFieldsCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many crpNPCCorporationResearchFields.
     */
    data: crpNPCCorporationResearchFieldsCreateManyInput | crpNPCCorporationResearchFieldsCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * crpNPCCorporationResearchFields update
   */
  export type crpNPCCorporationResearchFieldsUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the crpNPCCorporationResearchFields
     */
    select?: crpNPCCorporationResearchFieldsSelect<ExtArgs> | null
    /**
     * The data needed to update a crpNPCCorporationResearchFields.
     */
    data: XOR<crpNPCCorporationResearchFieldsUpdateInput, crpNPCCorporationResearchFieldsUncheckedUpdateInput>
    /**
     * Choose, which crpNPCCorporationResearchFields to update.
     */
    where: crpNPCCorporationResearchFieldsWhereUniqueInput
  }


  /**
   * crpNPCCorporationResearchFields updateMany
   */
  export type crpNPCCorporationResearchFieldsUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update crpNPCCorporationResearchFields.
     */
    data: XOR<crpNPCCorporationResearchFieldsUpdateManyMutationInput, crpNPCCorporationResearchFieldsUncheckedUpdateManyInput>
    /**
     * Filter which crpNPCCorporationResearchFields to update
     */
    where?: crpNPCCorporationResearchFieldsWhereInput
  }


  /**
   * crpNPCCorporationResearchFields upsert
   */
  export type crpNPCCorporationResearchFieldsUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the crpNPCCorporationResearchFields
     */
    select?: crpNPCCorporationResearchFieldsSelect<ExtArgs> | null
    /**
     * The filter to search for the crpNPCCorporationResearchFields to update in case it exists.
     */
    where: crpNPCCorporationResearchFieldsWhereUniqueInput
    /**
     * In case the crpNPCCorporationResearchFields found by the `where` argument doesn't exist, create a new crpNPCCorporationResearchFields with this data.
     */
    create: XOR<crpNPCCorporationResearchFieldsCreateInput, crpNPCCorporationResearchFieldsUncheckedCreateInput>
    /**
     * In case the crpNPCCorporationResearchFields was found with the provided `where` argument, update it with this data.
     */
    update: XOR<crpNPCCorporationResearchFieldsUpdateInput, crpNPCCorporationResearchFieldsUncheckedUpdateInput>
  }


  /**
   * crpNPCCorporationResearchFields delete
   */
  export type crpNPCCorporationResearchFieldsDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the crpNPCCorporationResearchFields
     */
    select?: crpNPCCorporationResearchFieldsSelect<ExtArgs> | null
    /**
     * Filter which crpNPCCorporationResearchFields to delete.
     */
    where: crpNPCCorporationResearchFieldsWhereUniqueInput
  }


  /**
   * crpNPCCorporationResearchFields deleteMany
   */
  export type crpNPCCorporationResearchFieldsDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which crpNPCCorporationResearchFields to delete
     */
    where?: crpNPCCorporationResearchFieldsWhereInput
  }


  /**
   * crpNPCCorporationResearchFields without action
   */
  export type crpNPCCorporationResearchFieldsDefaultArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the crpNPCCorporationResearchFields
     */
    select?: crpNPCCorporationResearchFieldsSelect<ExtArgs> | null
  }



  /**
   * Model crpNPCCorporationTrades
   */

  export type AggregateCrpNPCCorporationTrades = {
    _count: CrpNPCCorporationTradesCountAggregateOutputType | null
    _avg: CrpNPCCorporationTradesAvgAggregateOutputType | null
    _sum: CrpNPCCorporationTradesSumAggregateOutputType | null
    _min: CrpNPCCorporationTradesMinAggregateOutputType | null
    _max: CrpNPCCorporationTradesMaxAggregateOutputType | null
  }

  export type CrpNPCCorporationTradesAvgAggregateOutputType = {
    corporationID: number | null
    typeID: number | null
  }

  export type CrpNPCCorporationTradesSumAggregateOutputType = {
    corporationID: number | null
    typeID: number | null
  }

  export type CrpNPCCorporationTradesMinAggregateOutputType = {
    corporationID: number | null
    typeID: number | null
  }

  export type CrpNPCCorporationTradesMaxAggregateOutputType = {
    corporationID: number | null
    typeID: number | null
  }

  export type CrpNPCCorporationTradesCountAggregateOutputType = {
    corporationID: number
    typeID: number
    _all: number
  }


  export type CrpNPCCorporationTradesAvgAggregateInputType = {
    corporationID?: true
    typeID?: true
  }

  export type CrpNPCCorporationTradesSumAggregateInputType = {
    corporationID?: true
    typeID?: true
  }

  export type CrpNPCCorporationTradesMinAggregateInputType = {
    corporationID?: true
    typeID?: true
  }

  export type CrpNPCCorporationTradesMaxAggregateInputType = {
    corporationID?: true
    typeID?: true
  }

  export type CrpNPCCorporationTradesCountAggregateInputType = {
    corporationID?: true
    typeID?: true
    _all?: true
  }

  export type CrpNPCCorporationTradesAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which crpNPCCorporationTrades to aggregate.
     */
    where?: crpNPCCorporationTradesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of crpNPCCorporationTrades to fetch.
     */
    orderBy?: crpNPCCorporationTradesOrderByWithRelationInput | crpNPCCorporationTradesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: crpNPCCorporationTradesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` crpNPCCorporationTrades from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` crpNPCCorporationTrades.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned crpNPCCorporationTrades
    **/
    _count?: true | CrpNPCCorporationTradesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CrpNPCCorporationTradesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CrpNPCCorporationTradesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CrpNPCCorporationTradesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CrpNPCCorporationTradesMaxAggregateInputType
  }

  export type GetCrpNPCCorporationTradesAggregateType<T extends CrpNPCCorporationTradesAggregateArgs> = {
        [P in keyof T & keyof AggregateCrpNPCCorporationTrades]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCrpNPCCorporationTrades[P]>
      : GetScalarType<T[P], AggregateCrpNPCCorporationTrades[P]>
  }




  export type crpNPCCorporationTradesGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: crpNPCCorporationTradesWhereInput
    orderBy?: crpNPCCorporationTradesOrderByWithAggregationInput | crpNPCCorporationTradesOrderByWithAggregationInput[]
    by: CrpNPCCorporationTradesScalarFieldEnum[] | CrpNPCCorporationTradesScalarFieldEnum
    having?: crpNPCCorporationTradesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CrpNPCCorporationTradesCountAggregateInputType | true
    _avg?: CrpNPCCorporationTradesAvgAggregateInputType
    _sum?: CrpNPCCorporationTradesSumAggregateInputType
    _min?: CrpNPCCorporationTradesMinAggregateInputType
    _max?: CrpNPCCorporationTradesMaxAggregateInputType
  }

  export type CrpNPCCorporationTradesGroupByOutputType = {
    corporationID: number
    typeID: number
    _count: CrpNPCCorporationTradesCountAggregateOutputType | null
    _avg: CrpNPCCorporationTradesAvgAggregateOutputType | null
    _sum: CrpNPCCorporationTradesSumAggregateOutputType | null
    _min: CrpNPCCorporationTradesMinAggregateOutputType | null
    _max: CrpNPCCorporationTradesMaxAggregateOutputType | null
  }

  type GetCrpNPCCorporationTradesGroupByPayload<T extends crpNPCCorporationTradesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CrpNPCCorporationTradesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CrpNPCCorporationTradesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CrpNPCCorporationTradesGroupByOutputType[P]>
            : GetScalarType<T[P], CrpNPCCorporationTradesGroupByOutputType[P]>
        }
      >
    >


  export type crpNPCCorporationTradesSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    corporationID?: boolean
    typeID?: boolean
  }, ExtArgs["result"]["crpNPCCorporationTrades"]>

  export type crpNPCCorporationTradesSelectScalar = {
    corporationID?: boolean
    typeID?: boolean
  }


  export type $crpNPCCorporationTradesPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    name: "crpNPCCorporationTrades"
    objects: {}
    scalars: $Extensions.GetResult<{
      corporationID: number
      typeID: number
    }, ExtArgs["result"]["crpNPCCorporationTrades"]>
    composites: {}
  }


  type crpNPCCorporationTradesGetPayload<S extends boolean | null | undefined | crpNPCCorporationTradesDefaultArgs> = $Result.GetResult<Prisma.$crpNPCCorporationTradesPayload, S>

  type crpNPCCorporationTradesCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<crpNPCCorporationTradesFindManyArgs, 'select' | 'include'> & {
      select?: CrpNPCCorporationTradesCountAggregateInputType | true
    }

  export interface crpNPCCorporationTradesDelegate<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['crpNPCCorporationTrades'], meta: { name: 'crpNPCCorporationTrades' } }
    /**
     * Find zero or one CrpNPCCorporationTrades that matches the filter.
     * @param {crpNPCCorporationTradesFindUniqueArgs} args - Arguments to find a CrpNPCCorporationTrades
     * @example
     * // Get one CrpNPCCorporationTrades
     * const crpNPCCorporationTrades = await prisma.crpNPCCorporationTrades.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends crpNPCCorporationTradesFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, crpNPCCorporationTradesFindUniqueArgs<ExtArgs>>
    ): Prisma__crpNPCCorporationTradesClient<$Result.GetResult<Prisma.$crpNPCCorporationTradesPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one CrpNPCCorporationTrades that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {crpNPCCorporationTradesFindUniqueOrThrowArgs} args - Arguments to find a CrpNPCCorporationTrades
     * @example
     * // Get one CrpNPCCorporationTrades
     * const crpNPCCorporationTrades = await prisma.crpNPCCorporationTrades.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends crpNPCCorporationTradesFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, crpNPCCorporationTradesFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__crpNPCCorporationTradesClient<$Result.GetResult<Prisma.$crpNPCCorporationTradesPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first CrpNPCCorporationTrades that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {crpNPCCorporationTradesFindFirstArgs} args - Arguments to find a CrpNPCCorporationTrades
     * @example
     * // Get one CrpNPCCorporationTrades
     * const crpNPCCorporationTrades = await prisma.crpNPCCorporationTrades.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends crpNPCCorporationTradesFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, crpNPCCorporationTradesFindFirstArgs<ExtArgs>>
    ): Prisma__crpNPCCorporationTradesClient<$Result.GetResult<Prisma.$crpNPCCorporationTradesPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first CrpNPCCorporationTrades that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {crpNPCCorporationTradesFindFirstOrThrowArgs} args - Arguments to find a CrpNPCCorporationTrades
     * @example
     * // Get one CrpNPCCorporationTrades
     * const crpNPCCorporationTrades = await prisma.crpNPCCorporationTrades.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends crpNPCCorporationTradesFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, crpNPCCorporationTradesFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__crpNPCCorporationTradesClient<$Result.GetResult<Prisma.$crpNPCCorporationTradesPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more CrpNPCCorporationTrades that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {crpNPCCorporationTradesFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CrpNPCCorporationTrades
     * const crpNPCCorporationTrades = await prisma.crpNPCCorporationTrades.findMany()
     * 
     * // Get first 10 CrpNPCCorporationTrades
     * const crpNPCCorporationTrades = await prisma.crpNPCCorporationTrades.findMany({ take: 10 })
     * 
     * // Only select the `corporationID`
     * const crpNPCCorporationTradesWithCorporationIDOnly = await prisma.crpNPCCorporationTrades.findMany({ select: { corporationID: true } })
     * 
    **/
    findMany<T extends crpNPCCorporationTradesFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, crpNPCCorporationTradesFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$crpNPCCorporationTradesPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a CrpNPCCorporationTrades.
     * @param {crpNPCCorporationTradesCreateArgs} args - Arguments to create a CrpNPCCorporationTrades.
     * @example
     * // Create one CrpNPCCorporationTrades
     * const CrpNPCCorporationTrades = await prisma.crpNPCCorporationTrades.create({
     *   data: {
     *     // ... data to create a CrpNPCCorporationTrades
     *   }
     * })
     * 
    **/
    create<T extends crpNPCCorporationTradesCreateArgs<ExtArgs>>(
      args: SelectSubset<T, crpNPCCorporationTradesCreateArgs<ExtArgs>>
    ): Prisma__crpNPCCorporationTradesClient<$Result.GetResult<Prisma.$crpNPCCorporationTradesPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many CrpNPCCorporationTrades.
     *     @param {crpNPCCorporationTradesCreateManyArgs} args - Arguments to create many CrpNPCCorporationTrades.
     *     @example
     *     // Create many CrpNPCCorporationTrades
     *     const crpNPCCorporationTrades = await prisma.crpNPCCorporationTrades.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends crpNPCCorporationTradesCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, crpNPCCorporationTradesCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a CrpNPCCorporationTrades.
     * @param {crpNPCCorporationTradesDeleteArgs} args - Arguments to delete one CrpNPCCorporationTrades.
     * @example
     * // Delete one CrpNPCCorporationTrades
     * const CrpNPCCorporationTrades = await prisma.crpNPCCorporationTrades.delete({
     *   where: {
     *     // ... filter to delete one CrpNPCCorporationTrades
     *   }
     * })
     * 
    **/
    delete<T extends crpNPCCorporationTradesDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, crpNPCCorporationTradesDeleteArgs<ExtArgs>>
    ): Prisma__crpNPCCorporationTradesClient<$Result.GetResult<Prisma.$crpNPCCorporationTradesPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one CrpNPCCorporationTrades.
     * @param {crpNPCCorporationTradesUpdateArgs} args - Arguments to update one CrpNPCCorporationTrades.
     * @example
     * // Update one CrpNPCCorporationTrades
     * const crpNPCCorporationTrades = await prisma.crpNPCCorporationTrades.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends crpNPCCorporationTradesUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, crpNPCCorporationTradesUpdateArgs<ExtArgs>>
    ): Prisma__crpNPCCorporationTradesClient<$Result.GetResult<Prisma.$crpNPCCorporationTradesPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more CrpNPCCorporationTrades.
     * @param {crpNPCCorporationTradesDeleteManyArgs} args - Arguments to filter CrpNPCCorporationTrades to delete.
     * @example
     * // Delete a few CrpNPCCorporationTrades
     * const { count } = await prisma.crpNPCCorporationTrades.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends crpNPCCorporationTradesDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, crpNPCCorporationTradesDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CrpNPCCorporationTrades.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {crpNPCCorporationTradesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CrpNPCCorporationTrades
     * const crpNPCCorporationTrades = await prisma.crpNPCCorporationTrades.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends crpNPCCorporationTradesUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, crpNPCCorporationTradesUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one CrpNPCCorporationTrades.
     * @param {crpNPCCorporationTradesUpsertArgs} args - Arguments to update or create a CrpNPCCorporationTrades.
     * @example
     * // Update or create a CrpNPCCorporationTrades
     * const crpNPCCorporationTrades = await prisma.crpNPCCorporationTrades.upsert({
     *   create: {
     *     // ... data to create a CrpNPCCorporationTrades
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CrpNPCCorporationTrades we want to update
     *   }
     * })
    **/
    upsert<T extends crpNPCCorporationTradesUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, crpNPCCorporationTradesUpsertArgs<ExtArgs>>
    ): Prisma__crpNPCCorporationTradesClient<$Result.GetResult<Prisma.$crpNPCCorporationTradesPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of CrpNPCCorporationTrades.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {crpNPCCorporationTradesCountArgs} args - Arguments to filter CrpNPCCorporationTrades to count.
     * @example
     * // Count the number of CrpNPCCorporationTrades
     * const count = await prisma.crpNPCCorporationTrades.count({
     *   where: {
     *     // ... the filter for the CrpNPCCorporationTrades we want to count
     *   }
     * })
    **/
    count<T extends crpNPCCorporationTradesCountArgs>(
      args?: Subset<T, crpNPCCorporationTradesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CrpNPCCorporationTradesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CrpNPCCorporationTrades.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CrpNPCCorporationTradesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CrpNPCCorporationTradesAggregateArgs>(args: Subset<T, CrpNPCCorporationTradesAggregateArgs>): Prisma.PrismaPromise<GetCrpNPCCorporationTradesAggregateType<T>>

    /**
     * Group by CrpNPCCorporationTrades.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {crpNPCCorporationTradesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends crpNPCCorporationTradesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: crpNPCCorporationTradesGroupByArgs['orderBy'] }
        : { orderBy?: crpNPCCorporationTradesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, crpNPCCorporationTradesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCrpNPCCorporationTradesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the crpNPCCorporationTrades model
   */
  readonly fields: crpNPCCorporationTradesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for crpNPCCorporationTrades.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__crpNPCCorporationTradesClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';


    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the crpNPCCorporationTrades model
   */ 
  interface crpNPCCorporationTradesFieldRefs {
    readonly corporationID: FieldRef<"crpNPCCorporationTrades", 'Int'>
    readonly typeID: FieldRef<"crpNPCCorporationTrades", 'Int'>
  }
    

  // Custom InputTypes

  /**
   * crpNPCCorporationTrades findUnique
   */
  export type crpNPCCorporationTradesFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the crpNPCCorporationTrades
     */
    select?: crpNPCCorporationTradesSelect<ExtArgs> | null
    /**
     * Filter, which crpNPCCorporationTrades to fetch.
     */
    where: crpNPCCorporationTradesWhereUniqueInput
  }


  /**
   * crpNPCCorporationTrades findUniqueOrThrow
   */
  export type crpNPCCorporationTradesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the crpNPCCorporationTrades
     */
    select?: crpNPCCorporationTradesSelect<ExtArgs> | null
    /**
     * Filter, which crpNPCCorporationTrades to fetch.
     */
    where: crpNPCCorporationTradesWhereUniqueInput
  }


  /**
   * crpNPCCorporationTrades findFirst
   */
  export type crpNPCCorporationTradesFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the crpNPCCorporationTrades
     */
    select?: crpNPCCorporationTradesSelect<ExtArgs> | null
    /**
     * Filter, which crpNPCCorporationTrades to fetch.
     */
    where?: crpNPCCorporationTradesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of crpNPCCorporationTrades to fetch.
     */
    orderBy?: crpNPCCorporationTradesOrderByWithRelationInput | crpNPCCorporationTradesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for crpNPCCorporationTrades.
     */
    cursor?: crpNPCCorporationTradesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` crpNPCCorporationTrades from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` crpNPCCorporationTrades.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of crpNPCCorporationTrades.
     */
    distinct?: CrpNPCCorporationTradesScalarFieldEnum | CrpNPCCorporationTradesScalarFieldEnum[]
  }


  /**
   * crpNPCCorporationTrades findFirstOrThrow
   */
  export type crpNPCCorporationTradesFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the crpNPCCorporationTrades
     */
    select?: crpNPCCorporationTradesSelect<ExtArgs> | null
    /**
     * Filter, which crpNPCCorporationTrades to fetch.
     */
    where?: crpNPCCorporationTradesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of crpNPCCorporationTrades to fetch.
     */
    orderBy?: crpNPCCorporationTradesOrderByWithRelationInput | crpNPCCorporationTradesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for crpNPCCorporationTrades.
     */
    cursor?: crpNPCCorporationTradesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` crpNPCCorporationTrades from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` crpNPCCorporationTrades.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of crpNPCCorporationTrades.
     */
    distinct?: CrpNPCCorporationTradesScalarFieldEnum | CrpNPCCorporationTradesScalarFieldEnum[]
  }


  /**
   * crpNPCCorporationTrades findMany
   */
  export type crpNPCCorporationTradesFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the crpNPCCorporationTrades
     */
    select?: crpNPCCorporationTradesSelect<ExtArgs> | null
    /**
     * Filter, which crpNPCCorporationTrades to fetch.
     */
    where?: crpNPCCorporationTradesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of crpNPCCorporationTrades to fetch.
     */
    orderBy?: crpNPCCorporationTradesOrderByWithRelationInput | crpNPCCorporationTradesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing crpNPCCorporationTrades.
     */
    cursor?: crpNPCCorporationTradesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` crpNPCCorporationTrades from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` crpNPCCorporationTrades.
     */
    skip?: number
    distinct?: CrpNPCCorporationTradesScalarFieldEnum | CrpNPCCorporationTradesScalarFieldEnum[]
  }


  /**
   * crpNPCCorporationTrades create
   */
  export type crpNPCCorporationTradesCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the crpNPCCorporationTrades
     */
    select?: crpNPCCorporationTradesSelect<ExtArgs> | null
    /**
     * The data needed to create a crpNPCCorporationTrades.
     */
    data: XOR<crpNPCCorporationTradesCreateInput, crpNPCCorporationTradesUncheckedCreateInput>
  }


  /**
   * crpNPCCorporationTrades createMany
   */
  export type crpNPCCorporationTradesCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many crpNPCCorporationTrades.
     */
    data: crpNPCCorporationTradesCreateManyInput | crpNPCCorporationTradesCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * crpNPCCorporationTrades update
   */
  export type crpNPCCorporationTradesUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the crpNPCCorporationTrades
     */
    select?: crpNPCCorporationTradesSelect<ExtArgs> | null
    /**
     * The data needed to update a crpNPCCorporationTrades.
     */
    data: XOR<crpNPCCorporationTradesUpdateInput, crpNPCCorporationTradesUncheckedUpdateInput>
    /**
     * Choose, which crpNPCCorporationTrades to update.
     */
    where: crpNPCCorporationTradesWhereUniqueInput
  }


  /**
   * crpNPCCorporationTrades updateMany
   */
  export type crpNPCCorporationTradesUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update crpNPCCorporationTrades.
     */
    data: XOR<crpNPCCorporationTradesUpdateManyMutationInput, crpNPCCorporationTradesUncheckedUpdateManyInput>
    /**
     * Filter which crpNPCCorporationTrades to update
     */
    where?: crpNPCCorporationTradesWhereInput
  }


  /**
   * crpNPCCorporationTrades upsert
   */
  export type crpNPCCorporationTradesUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the crpNPCCorporationTrades
     */
    select?: crpNPCCorporationTradesSelect<ExtArgs> | null
    /**
     * The filter to search for the crpNPCCorporationTrades to update in case it exists.
     */
    where: crpNPCCorporationTradesWhereUniqueInput
    /**
     * In case the crpNPCCorporationTrades found by the `where` argument doesn't exist, create a new crpNPCCorporationTrades with this data.
     */
    create: XOR<crpNPCCorporationTradesCreateInput, crpNPCCorporationTradesUncheckedCreateInput>
    /**
     * In case the crpNPCCorporationTrades was found with the provided `where` argument, update it with this data.
     */
    update: XOR<crpNPCCorporationTradesUpdateInput, crpNPCCorporationTradesUncheckedUpdateInput>
  }


  /**
   * crpNPCCorporationTrades delete
   */
  export type crpNPCCorporationTradesDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the crpNPCCorporationTrades
     */
    select?: crpNPCCorporationTradesSelect<ExtArgs> | null
    /**
     * Filter which crpNPCCorporationTrades to delete.
     */
    where: crpNPCCorporationTradesWhereUniqueInput
  }


  /**
   * crpNPCCorporationTrades deleteMany
   */
  export type crpNPCCorporationTradesDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which crpNPCCorporationTrades to delete
     */
    where?: crpNPCCorporationTradesWhereInput
  }


  /**
   * crpNPCCorporationTrades without action
   */
  export type crpNPCCorporationTradesDefaultArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the crpNPCCorporationTrades
     */
    select?: crpNPCCorporationTradesSelect<ExtArgs> | null
  }



  /**
   * Model crpNPCCorporations
   */

  export type AggregateCrpNPCCorporations = {
    _count: CrpNPCCorporationsCountAggregateOutputType | null
    _avg: CrpNPCCorporationsAvgAggregateOutputType | null
    _sum: CrpNPCCorporationsSumAggregateOutputType | null
    _min: CrpNPCCorporationsMinAggregateOutputType | null
    _max: CrpNPCCorporationsMaxAggregateOutputType | null
  }

  export type CrpNPCCorporationsAvgAggregateOutputType = {
    corporationID: number | null
    solarSystemID: number | null
    investorID1: number | null
    investorShares1: number | null
    investorID2: number | null
    investorShares2: number | null
    investorID3: number | null
    investorShares3: number | null
    investorID4: number | null
    investorShares4: number | null
    friendID: number | null
    enemyID: number | null
    publicShares: number | null
    initialPrice: number | null
    minSecurity: number | null
    fringe: number | null
    corridor: number | null
    hub: number | null
    border: number | null
    factionID: number | null
    sizeFactor: number | null
    stationCount: number | null
    stationSystemCount: number | null
    iconID: number | null
  }

  export type CrpNPCCorporationsSumAggregateOutputType = {
    corporationID: number | null
    solarSystemID: number | null
    investorID1: number | null
    investorShares1: number | null
    investorID2: number | null
    investorShares2: number | null
    investorID3: number | null
    investorShares3: number | null
    investorID4: number | null
    investorShares4: number | null
    friendID: number | null
    enemyID: number | null
    publicShares: number | null
    initialPrice: number | null
    minSecurity: number | null
    fringe: number | null
    corridor: number | null
    hub: number | null
    border: number | null
    factionID: number | null
    sizeFactor: number | null
    stationCount: number | null
    stationSystemCount: number | null
    iconID: number | null
  }

  export type CrpNPCCorporationsMinAggregateOutputType = {
    corporationID: number | null
    size: string | null
    extent: string | null
    solarSystemID: number | null
    investorID1: number | null
    investorShares1: number | null
    investorID2: number | null
    investorShares2: number | null
    investorID3: number | null
    investorShares3: number | null
    investorID4: number | null
    investorShares4: number | null
    friendID: number | null
    enemyID: number | null
    publicShares: number | null
    initialPrice: number | null
    minSecurity: number | null
    scattered: boolean | null
    fringe: number | null
    corridor: number | null
    hub: number | null
    border: number | null
    factionID: number | null
    sizeFactor: number | null
    stationCount: number | null
    stationSystemCount: number | null
    description: string | null
    iconID: number | null
  }

  export type CrpNPCCorporationsMaxAggregateOutputType = {
    corporationID: number | null
    size: string | null
    extent: string | null
    solarSystemID: number | null
    investorID1: number | null
    investorShares1: number | null
    investorID2: number | null
    investorShares2: number | null
    investorID3: number | null
    investorShares3: number | null
    investorID4: number | null
    investorShares4: number | null
    friendID: number | null
    enemyID: number | null
    publicShares: number | null
    initialPrice: number | null
    minSecurity: number | null
    scattered: boolean | null
    fringe: number | null
    corridor: number | null
    hub: number | null
    border: number | null
    factionID: number | null
    sizeFactor: number | null
    stationCount: number | null
    stationSystemCount: number | null
    description: string | null
    iconID: number | null
  }

  export type CrpNPCCorporationsCountAggregateOutputType = {
    corporationID: number
    size: number
    extent: number
    solarSystemID: number
    investorID1: number
    investorShares1: number
    investorID2: number
    investorShares2: number
    investorID3: number
    investorShares3: number
    investorID4: number
    investorShares4: number
    friendID: number
    enemyID: number
    publicShares: number
    initialPrice: number
    minSecurity: number
    scattered: number
    fringe: number
    corridor: number
    hub: number
    border: number
    factionID: number
    sizeFactor: number
    stationCount: number
    stationSystemCount: number
    description: number
    iconID: number
    _all: number
  }


  export type CrpNPCCorporationsAvgAggregateInputType = {
    corporationID?: true
    solarSystemID?: true
    investorID1?: true
    investorShares1?: true
    investorID2?: true
    investorShares2?: true
    investorID3?: true
    investorShares3?: true
    investorID4?: true
    investorShares4?: true
    friendID?: true
    enemyID?: true
    publicShares?: true
    initialPrice?: true
    minSecurity?: true
    fringe?: true
    corridor?: true
    hub?: true
    border?: true
    factionID?: true
    sizeFactor?: true
    stationCount?: true
    stationSystemCount?: true
    iconID?: true
  }

  export type CrpNPCCorporationsSumAggregateInputType = {
    corporationID?: true
    solarSystemID?: true
    investorID1?: true
    investorShares1?: true
    investorID2?: true
    investorShares2?: true
    investorID3?: true
    investorShares3?: true
    investorID4?: true
    investorShares4?: true
    friendID?: true
    enemyID?: true
    publicShares?: true
    initialPrice?: true
    minSecurity?: true
    fringe?: true
    corridor?: true
    hub?: true
    border?: true
    factionID?: true
    sizeFactor?: true
    stationCount?: true
    stationSystemCount?: true
    iconID?: true
  }

  export type CrpNPCCorporationsMinAggregateInputType = {
    corporationID?: true
    size?: true
    extent?: true
    solarSystemID?: true
    investorID1?: true
    investorShares1?: true
    investorID2?: true
    investorShares2?: true
    investorID3?: true
    investorShares3?: true
    investorID4?: true
    investorShares4?: true
    friendID?: true
    enemyID?: true
    publicShares?: true
    initialPrice?: true
    minSecurity?: true
    scattered?: true
    fringe?: true
    corridor?: true
    hub?: true
    border?: true
    factionID?: true
    sizeFactor?: true
    stationCount?: true
    stationSystemCount?: true
    description?: true
    iconID?: true
  }

  export type CrpNPCCorporationsMaxAggregateInputType = {
    corporationID?: true
    size?: true
    extent?: true
    solarSystemID?: true
    investorID1?: true
    investorShares1?: true
    investorID2?: true
    investorShares2?: true
    investorID3?: true
    investorShares3?: true
    investorID4?: true
    investorShares4?: true
    friendID?: true
    enemyID?: true
    publicShares?: true
    initialPrice?: true
    minSecurity?: true
    scattered?: true
    fringe?: true
    corridor?: true
    hub?: true
    border?: true
    factionID?: true
    sizeFactor?: true
    stationCount?: true
    stationSystemCount?: true
    description?: true
    iconID?: true
  }

  export type CrpNPCCorporationsCountAggregateInputType = {
    corporationID?: true
    size?: true
    extent?: true
    solarSystemID?: true
    investorID1?: true
    investorShares1?: true
    investorID2?: true
    investorShares2?: true
    investorID3?: true
    investorShares3?: true
    investorID4?: true
    investorShares4?: true
    friendID?: true
    enemyID?: true
    publicShares?: true
    initialPrice?: true
    minSecurity?: true
    scattered?: true
    fringe?: true
    corridor?: true
    hub?: true
    border?: true
    factionID?: true
    sizeFactor?: true
    stationCount?: true
    stationSystemCount?: true
    description?: true
    iconID?: true
    _all?: true
  }

  export type CrpNPCCorporationsAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which crpNPCCorporations to aggregate.
     */
    where?: crpNPCCorporationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of crpNPCCorporations to fetch.
     */
    orderBy?: crpNPCCorporationsOrderByWithRelationInput | crpNPCCorporationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: crpNPCCorporationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` crpNPCCorporations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` crpNPCCorporations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned crpNPCCorporations
    **/
    _count?: true | CrpNPCCorporationsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CrpNPCCorporationsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CrpNPCCorporationsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CrpNPCCorporationsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CrpNPCCorporationsMaxAggregateInputType
  }

  export type GetCrpNPCCorporationsAggregateType<T extends CrpNPCCorporationsAggregateArgs> = {
        [P in keyof T & keyof AggregateCrpNPCCorporations]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCrpNPCCorporations[P]>
      : GetScalarType<T[P], AggregateCrpNPCCorporations[P]>
  }




  export type crpNPCCorporationsGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: crpNPCCorporationsWhereInput
    orderBy?: crpNPCCorporationsOrderByWithAggregationInput | crpNPCCorporationsOrderByWithAggregationInput[]
    by: CrpNPCCorporationsScalarFieldEnum[] | CrpNPCCorporationsScalarFieldEnum
    having?: crpNPCCorporationsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CrpNPCCorporationsCountAggregateInputType | true
    _avg?: CrpNPCCorporationsAvgAggregateInputType
    _sum?: CrpNPCCorporationsSumAggregateInputType
    _min?: CrpNPCCorporationsMinAggregateInputType
    _max?: CrpNPCCorporationsMaxAggregateInputType
  }

  export type CrpNPCCorporationsGroupByOutputType = {
    corporationID: number
    size: string | null
    extent: string | null
    solarSystemID: number | null
    investorID1: number | null
    investorShares1: number | null
    investorID2: number | null
    investorShares2: number | null
    investorID3: number | null
    investorShares3: number | null
    investorID4: number | null
    investorShares4: number | null
    friendID: number | null
    enemyID: number | null
    publicShares: number | null
    initialPrice: number | null
    minSecurity: number | null
    scattered: boolean | null
    fringe: number | null
    corridor: number | null
    hub: number | null
    border: number | null
    factionID: number | null
    sizeFactor: number | null
    stationCount: number | null
    stationSystemCount: number | null
    description: string | null
    iconID: number | null
    _count: CrpNPCCorporationsCountAggregateOutputType | null
    _avg: CrpNPCCorporationsAvgAggregateOutputType | null
    _sum: CrpNPCCorporationsSumAggregateOutputType | null
    _min: CrpNPCCorporationsMinAggregateOutputType | null
    _max: CrpNPCCorporationsMaxAggregateOutputType | null
  }

  type GetCrpNPCCorporationsGroupByPayload<T extends crpNPCCorporationsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CrpNPCCorporationsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CrpNPCCorporationsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CrpNPCCorporationsGroupByOutputType[P]>
            : GetScalarType<T[P], CrpNPCCorporationsGroupByOutputType[P]>
        }
      >
    >


  export type crpNPCCorporationsSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    corporationID?: boolean
    size?: boolean
    extent?: boolean
    solarSystemID?: boolean
    investorID1?: boolean
    investorShares1?: boolean
    investorID2?: boolean
    investorShares2?: boolean
    investorID3?: boolean
    investorShares3?: boolean
    investorID4?: boolean
    investorShares4?: boolean
    friendID?: boolean
    enemyID?: boolean
    publicShares?: boolean
    initialPrice?: boolean
    minSecurity?: boolean
    scattered?: boolean
    fringe?: boolean
    corridor?: boolean
    hub?: boolean
    border?: boolean
    factionID?: boolean
    sizeFactor?: boolean
    stationCount?: boolean
    stationSystemCount?: boolean
    description?: boolean
    iconID?: boolean
  }, ExtArgs["result"]["crpNPCCorporations"]>

  export type crpNPCCorporationsSelectScalar = {
    corporationID?: boolean
    size?: boolean
    extent?: boolean
    solarSystemID?: boolean
    investorID1?: boolean
    investorShares1?: boolean
    investorID2?: boolean
    investorShares2?: boolean
    investorID3?: boolean
    investorShares3?: boolean
    investorID4?: boolean
    investorShares4?: boolean
    friendID?: boolean
    enemyID?: boolean
    publicShares?: boolean
    initialPrice?: boolean
    minSecurity?: boolean
    scattered?: boolean
    fringe?: boolean
    corridor?: boolean
    hub?: boolean
    border?: boolean
    factionID?: boolean
    sizeFactor?: boolean
    stationCount?: boolean
    stationSystemCount?: boolean
    description?: boolean
    iconID?: boolean
  }


  export type $crpNPCCorporationsPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    name: "crpNPCCorporations"
    objects: {}
    scalars: $Extensions.GetResult<{
      corporationID: number
      size: string | null
      extent: string | null
      solarSystemID: number | null
      investorID1: number | null
      investorShares1: number | null
      investorID2: number | null
      investorShares2: number | null
      investorID3: number | null
      investorShares3: number | null
      investorID4: number | null
      investorShares4: number | null
      friendID: number | null
      enemyID: number | null
      publicShares: number | null
      initialPrice: number | null
      minSecurity: number | null
      scattered: boolean | null
      fringe: number | null
      corridor: number | null
      hub: number | null
      border: number | null
      factionID: number | null
      sizeFactor: number | null
      stationCount: number | null
      stationSystemCount: number | null
      description: string | null
      iconID: number | null
    }, ExtArgs["result"]["crpNPCCorporations"]>
    composites: {}
  }


  type crpNPCCorporationsGetPayload<S extends boolean | null | undefined | crpNPCCorporationsDefaultArgs> = $Result.GetResult<Prisma.$crpNPCCorporationsPayload, S>

  type crpNPCCorporationsCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<crpNPCCorporationsFindManyArgs, 'select' | 'include'> & {
      select?: CrpNPCCorporationsCountAggregateInputType | true
    }

  export interface crpNPCCorporationsDelegate<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['crpNPCCorporations'], meta: { name: 'crpNPCCorporations' } }
    /**
     * Find zero or one CrpNPCCorporations that matches the filter.
     * @param {crpNPCCorporationsFindUniqueArgs} args - Arguments to find a CrpNPCCorporations
     * @example
     * // Get one CrpNPCCorporations
     * const crpNPCCorporations = await prisma.crpNPCCorporations.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends crpNPCCorporationsFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, crpNPCCorporationsFindUniqueArgs<ExtArgs>>
    ): Prisma__crpNPCCorporationsClient<$Result.GetResult<Prisma.$crpNPCCorporationsPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one CrpNPCCorporations that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {crpNPCCorporationsFindUniqueOrThrowArgs} args - Arguments to find a CrpNPCCorporations
     * @example
     * // Get one CrpNPCCorporations
     * const crpNPCCorporations = await prisma.crpNPCCorporations.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends crpNPCCorporationsFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, crpNPCCorporationsFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__crpNPCCorporationsClient<$Result.GetResult<Prisma.$crpNPCCorporationsPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first CrpNPCCorporations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {crpNPCCorporationsFindFirstArgs} args - Arguments to find a CrpNPCCorporations
     * @example
     * // Get one CrpNPCCorporations
     * const crpNPCCorporations = await prisma.crpNPCCorporations.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends crpNPCCorporationsFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, crpNPCCorporationsFindFirstArgs<ExtArgs>>
    ): Prisma__crpNPCCorporationsClient<$Result.GetResult<Prisma.$crpNPCCorporationsPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first CrpNPCCorporations that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {crpNPCCorporationsFindFirstOrThrowArgs} args - Arguments to find a CrpNPCCorporations
     * @example
     * // Get one CrpNPCCorporations
     * const crpNPCCorporations = await prisma.crpNPCCorporations.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends crpNPCCorporationsFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, crpNPCCorporationsFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__crpNPCCorporationsClient<$Result.GetResult<Prisma.$crpNPCCorporationsPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more CrpNPCCorporations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {crpNPCCorporationsFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CrpNPCCorporations
     * const crpNPCCorporations = await prisma.crpNPCCorporations.findMany()
     * 
     * // Get first 10 CrpNPCCorporations
     * const crpNPCCorporations = await prisma.crpNPCCorporations.findMany({ take: 10 })
     * 
     * // Only select the `corporationID`
     * const crpNPCCorporationsWithCorporationIDOnly = await prisma.crpNPCCorporations.findMany({ select: { corporationID: true } })
     * 
    **/
    findMany<T extends crpNPCCorporationsFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, crpNPCCorporationsFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$crpNPCCorporationsPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a CrpNPCCorporations.
     * @param {crpNPCCorporationsCreateArgs} args - Arguments to create a CrpNPCCorporations.
     * @example
     * // Create one CrpNPCCorporations
     * const CrpNPCCorporations = await prisma.crpNPCCorporations.create({
     *   data: {
     *     // ... data to create a CrpNPCCorporations
     *   }
     * })
     * 
    **/
    create<T extends crpNPCCorporationsCreateArgs<ExtArgs>>(
      args: SelectSubset<T, crpNPCCorporationsCreateArgs<ExtArgs>>
    ): Prisma__crpNPCCorporationsClient<$Result.GetResult<Prisma.$crpNPCCorporationsPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many CrpNPCCorporations.
     *     @param {crpNPCCorporationsCreateManyArgs} args - Arguments to create many CrpNPCCorporations.
     *     @example
     *     // Create many CrpNPCCorporations
     *     const crpNPCCorporations = await prisma.crpNPCCorporations.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends crpNPCCorporationsCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, crpNPCCorporationsCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a CrpNPCCorporations.
     * @param {crpNPCCorporationsDeleteArgs} args - Arguments to delete one CrpNPCCorporations.
     * @example
     * // Delete one CrpNPCCorporations
     * const CrpNPCCorporations = await prisma.crpNPCCorporations.delete({
     *   where: {
     *     // ... filter to delete one CrpNPCCorporations
     *   }
     * })
     * 
    **/
    delete<T extends crpNPCCorporationsDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, crpNPCCorporationsDeleteArgs<ExtArgs>>
    ): Prisma__crpNPCCorporationsClient<$Result.GetResult<Prisma.$crpNPCCorporationsPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one CrpNPCCorporations.
     * @param {crpNPCCorporationsUpdateArgs} args - Arguments to update one CrpNPCCorporations.
     * @example
     * // Update one CrpNPCCorporations
     * const crpNPCCorporations = await prisma.crpNPCCorporations.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends crpNPCCorporationsUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, crpNPCCorporationsUpdateArgs<ExtArgs>>
    ): Prisma__crpNPCCorporationsClient<$Result.GetResult<Prisma.$crpNPCCorporationsPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more CrpNPCCorporations.
     * @param {crpNPCCorporationsDeleteManyArgs} args - Arguments to filter CrpNPCCorporations to delete.
     * @example
     * // Delete a few CrpNPCCorporations
     * const { count } = await prisma.crpNPCCorporations.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends crpNPCCorporationsDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, crpNPCCorporationsDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CrpNPCCorporations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {crpNPCCorporationsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CrpNPCCorporations
     * const crpNPCCorporations = await prisma.crpNPCCorporations.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends crpNPCCorporationsUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, crpNPCCorporationsUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one CrpNPCCorporations.
     * @param {crpNPCCorporationsUpsertArgs} args - Arguments to update or create a CrpNPCCorporations.
     * @example
     * // Update or create a CrpNPCCorporations
     * const crpNPCCorporations = await prisma.crpNPCCorporations.upsert({
     *   create: {
     *     // ... data to create a CrpNPCCorporations
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CrpNPCCorporations we want to update
     *   }
     * })
    **/
    upsert<T extends crpNPCCorporationsUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, crpNPCCorporationsUpsertArgs<ExtArgs>>
    ): Prisma__crpNPCCorporationsClient<$Result.GetResult<Prisma.$crpNPCCorporationsPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of CrpNPCCorporations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {crpNPCCorporationsCountArgs} args - Arguments to filter CrpNPCCorporations to count.
     * @example
     * // Count the number of CrpNPCCorporations
     * const count = await prisma.crpNPCCorporations.count({
     *   where: {
     *     // ... the filter for the CrpNPCCorporations we want to count
     *   }
     * })
    **/
    count<T extends crpNPCCorporationsCountArgs>(
      args?: Subset<T, crpNPCCorporationsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CrpNPCCorporationsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CrpNPCCorporations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CrpNPCCorporationsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CrpNPCCorporationsAggregateArgs>(args: Subset<T, CrpNPCCorporationsAggregateArgs>): Prisma.PrismaPromise<GetCrpNPCCorporationsAggregateType<T>>

    /**
     * Group by CrpNPCCorporations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {crpNPCCorporationsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends crpNPCCorporationsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: crpNPCCorporationsGroupByArgs['orderBy'] }
        : { orderBy?: crpNPCCorporationsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, crpNPCCorporationsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCrpNPCCorporationsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the crpNPCCorporations model
   */
  readonly fields: crpNPCCorporationsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for crpNPCCorporations.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__crpNPCCorporationsClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';


    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the crpNPCCorporations model
   */ 
  interface crpNPCCorporationsFieldRefs {
    readonly corporationID: FieldRef<"crpNPCCorporations", 'Int'>
    readonly size: FieldRef<"crpNPCCorporations", 'String'>
    readonly extent: FieldRef<"crpNPCCorporations", 'String'>
    readonly solarSystemID: FieldRef<"crpNPCCorporations", 'Int'>
    readonly investorID1: FieldRef<"crpNPCCorporations", 'Int'>
    readonly investorShares1: FieldRef<"crpNPCCorporations", 'Int'>
    readonly investorID2: FieldRef<"crpNPCCorporations", 'Int'>
    readonly investorShares2: FieldRef<"crpNPCCorporations", 'Int'>
    readonly investorID3: FieldRef<"crpNPCCorporations", 'Int'>
    readonly investorShares3: FieldRef<"crpNPCCorporations", 'Int'>
    readonly investorID4: FieldRef<"crpNPCCorporations", 'Int'>
    readonly investorShares4: FieldRef<"crpNPCCorporations", 'Int'>
    readonly friendID: FieldRef<"crpNPCCorporations", 'Int'>
    readonly enemyID: FieldRef<"crpNPCCorporations", 'Int'>
    readonly publicShares: FieldRef<"crpNPCCorporations", 'Int'>
    readonly initialPrice: FieldRef<"crpNPCCorporations", 'Int'>
    readonly minSecurity: FieldRef<"crpNPCCorporations", 'Float'>
    readonly scattered: FieldRef<"crpNPCCorporations", 'Boolean'>
    readonly fringe: FieldRef<"crpNPCCorporations", 'Int'>
    readonly corridor: FieldRef<"crpNPCCorporations", 'Int'>
    readonly hub: FieldRef<"crpNPCCorporations", 'Int'>
    readonly border: FieldRef<"crpNPCCorporations", 'Int'>
    readonly factionID: FieldRef<"crpNPCCorporations", 'Int'>
    readonly sizeFactor: FieldRef<"crpNPCCorporations", 'Float'>
    readonly stationCount: FieldRef<"crpNPCCorporations", 'Int'>
    readonly stationSystemCount: FieldRef<"crpNPCCorporations", 'Int'>
    readonly description: FieldRef<"crpNPCCorporations", 'String'>
    readonly iconID: FieldRef<"crpNPCCorporations", 'Int'>
  }
    

  // Custom InputTypes

  /**
   * crpNPCCorporations findUnique
   */
  export type crpNPCCorporationsFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the crpNPCCorporations
     */
    select?: crpNPCCorporationsSelect<ExtArgs> | null
    /**
     * Filter, which crpNPCCorporations to fetch.
     */
    where: crpNPCCorporationsWhereUniqueInput
  }


  /**
   * crpNPCCorporations findUniqueOrThrow
   */
  export type crpNPCCorporationsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the crpNPCCorporations
     */
    select?: crpNPCCorporationsSelect<ExtArgs> | null
    /**
     * Filter, which crpNPCCorporations to fetch.
     */
    where: crpNPCCorporationsWhereUniqueInput
  }


  /**
   * crpNPCCorporations findFirst
   */
  export type crpNPCCorporationsFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the crpNPCCorporations
     */
    select?: crpNPCCorporationsSelect<ExtArgs> | null
    /**
     * Filter, which crpNPCCorporations to fetch.
     */
    where?: crpNPCCorporationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of crpNPCCorporations to fetch.
     */
    orderBy?: crpNPCCorporationsOrderByWithRelationInput | crpNPCCorporationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for crpNPCCorporations.
     */
    cursor?: crpNPCCorporationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` crpNPCCorporations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` crpNPCCorporations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of crpNPCCorporations.
     */
    distinct?: CrpNPCCorporationsScalarFieldEnum | CrpNPCCorporationsScalarFieldEnum[]
  }


  /**
   * crpNPCCorporations findFirstOrThrow
   */
  export type crpNPCCorporationsFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the crpNPCCorporations
     */
    select?: crpNPCCorporationsSelect<ExtArgs> | null
    /**
     * Filter, which crpNPCCorporations to fetch.
     */
    where?: crpNPCCorporationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of crpNPCCorporations to fetch.
     */
    orderBy?: crpNPCCorporationsOrderByWithRelationInput | crpNPCCorporationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for crpNPCCorporations.
     */
    cursor?: crpNPCCorporationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` crpNPCCorporations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` crpNPCCorporations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of crpNPCCorporations.
     */
    distinct?: CrpNPCCorporationsScalarFieldEnum | CrpNPCCorporationsScalarFieldEnum[]
  }


  /**
   * crpNPCCorporations findMany
   */
  export type crpNPCCorporationsFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the crpNPCCorporations
     */
    select?: crpNPCCorporationsSelect<ExtArgs> | null
    /**
     * Filter, which crpNPCCorporations to fetch.
     */
    where?: crpNPCCorporationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of crpNPCCorporations to fetch.
     */
    orderBy?: crpNPCCorporationsOrderByWithRelationInput | crpNPCCorporationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing crpNPCCorporations.
     */
    cursor?: crpNPCCorporationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` crpNPCCorporations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` crpNPCCorporations.
     */
    skip?: number
    distinct?: CrpNPCCorporationsScalarFieldEnum | CrpNPCCorporationsScalarFieldEnum[]
  }


  /**
   * crpNPCCorporations create
   */
  export type crpNPCCorporationsCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the crpNPCCorporations
     */
    select?: crpNPCCorporationsSelect<ExtArgs> | null
    /**
     * The data needed to create a crpNPCCorporations.
     */
    data: XOR<crpNPCCorporationsCreateInput, crpNPCCorporationsUncheckedCreateInput>
  }


  /**
   * crpNPCCorporations createMany
   */
  export type crpNPCCorporationsCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many crpNPCCorporations.
     */
    data: crpNPCCorporationsCreateManyInput | crpNPCCorporationsCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * crpNPCCorporations update
   */
  export type crpNPCCorporationsUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the crpNPCCorporations
     */
    select?: crpNPCCorporationsSelect<ExtArgs> | null
    /**
     * The data needed to update a crpNPCCorporations.
     */
    data: XOR<crpNPCCorporationsUpdateInput, crpNPCCorporationsUncheckedUpdateInput>
    /**
     * Choose, which crpNPCCorporations to update.
     */
    where: crpNPCCorporationsWhereUniqueInput
  }


  /**
   * crpNPCCorporations updateMany
   */
  export type crpNPCCorporationsUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update crpNPCCorporations.
     */
    data: XOR<crpNPCCorporationsUpdateManyMutationInput, crpNPCCorporationsUncheckedUpdateManyInput>
    /**
     * Filter which crpNPCCorporations to update
     */
    where?: crpNPCCorporationsWhereInput
  }


  /**
   * crpNPCCorporations upsert
   */
  export type crpNPCCorporationsUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the crpNPCCorporations
     */
    select?: crpNPCCorporationsSelect<ExtArgs> | null
    /**
     * The filter to search for the crpNPCCorporations to update in case it exists.
     */
    where: crpNPCCorporationsWhereUniqueInput
    /**
     * In case the crpNPCCorporations found by the `where` argument doesn't exist, create a new crpNPCCorporations with this data.
     */
    create: XOR<crpNPCCorporationsCreateInput, crpNPCCorporationsUncheckedCreateInput>
    /**
     * In case the crpNPCCorporations was found with the provided `where` argument, update it with this data.
     */
    update: XOR<crpNPCCorporationsUpdateInput, crpNPCCorporationsUncheckedUpdateInput>
  }


  /**
   * crpNPCCorporations delete
   */
  export type crpNPCCorporationsDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the crpNPCCorporations
     */
    select?: crpNPCCorporationsSelect<ExtArgs> | null
    /**
     * Filter which crpNPCCorporations to delete.
     */
    where: crpNPCCorporationsWhereUniqueInput
  }


  /**
   * crpNPCCorporations deleteMany
   */
  export type crpNPCCorporationsDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which crpNPCCorporations to delete
     */
    where?: crpNPCCorporationsWhereInput
  }


  /**
   * crpNPCCorporations without action
   */
  export type crpNPCCorporationsDefaultArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the crpNPCCorporations
     */
    select?: crpNPCCorporationsSelect<ExtArgs> | null
  }



  /**
   * Model crpNPCDivisions
   */

  export type AggregateCrpNPCDivisions = {
    _count: CrpNPCDivisionsCountAggregateOutputType | null
    _avg: CrpNPCDivisionsAvgAggregateOutputType | null
    _sum: CrpNPCDivisionsSumAggregateOutputType | null
    _min: CrpNPCDivisionsMinAggregateOutputType | null
    _max: CrpNPCDivisionsMaxAggregateOutputType | null
  }

  export type CrpNPCDivisionsAvgAggregateOutputType = {
    divisionID: number | null
  }

  export type CrpNPCDivisionsSumAggregateOutputType = {
    divisionID: number | null
  }

  export type CrpNPCDivisionsMinAggregateOutputType = {
    divisionID: number | null
    divisionName: string | null
    description: string | null
    leaderType: string | null
  }

  export type CrpNPCDivisionsMaxAggregateOutputType = {
    divisionID: number | null
    divisionName: string | null
    description: string | null
    leaderType: string | null
  }

  export type CrpNPCDivisionsCountAggregateOutputType = {
    divisionID: number
    divisionName: number
    description: number
    leaderType: number
    _all: number
  }


  export type CrpNPCDivisionsAvgAggregateInputType = {
    divisionID?: true
  }

  export type CrpNPCDivisionsSumAggregateInputType = {
    divisionID?: true
  }

  export type CrpNPCDivisionsMinAggregateInputType = {
    divisionID?: true
    divisionName?: true
    description?: true
    leaderType?: true
  }

  export type CrpNPCDivisionsMaxAggregateInputType = {
    divisionID?: true
    divisionName?: true
    description?: true
    leaderType?: true
  }

  export type CrpNPCDivisionsCountAggregateInputType = {
    divisionID?: true
    divisionName?: true
    description?: true
    leaderType?: true
    _all?: true
  }

  export type CrpNPCDivisionsAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which crpNPCDivisions to aggregate.
     */
    where?: crpNPCDivisionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of crpNPCDivisions to fetch.
     */
    orderBy?: crpNPCDivisionsOrderByWithRelationInput | crpNPCDivisionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: crpNPCDivisionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` crpNPCDivisions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` crpNPCDivisions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned crpNPCDivisions
    **/
    _count?: true | CrpNPCDivisionsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CrpNPCDivisionsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CrpNPCDivisionsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CrpNPCDivisionsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CrpNPCDivisionsMaxAggregateInputType
  }

  export type GetCrpNPCDivisionsAggregateType<T extends CrpNPCDivisionsAggregateArgs> = {
        [P in keyof T & keyof AggregateCrpNPCDivisions]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCrpNPCDivisions[P]>
      : GetScalarType<T[P], AggregateCrpNPCDivisions[P]>
  }




  export type crpNPCDivisionsGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: crpNPCDivisionsWhereInput
    orderBy?: crpNPCDivisionsOrderByWithAggregationInput | crpNPCDivisionsOrderByWithAggregationInput[]
    by: CrpNPCDivisionsScalarFieldEnum[] | CrpNPCDivisionsScalarFieldEnum
    having?: crpNPCDivisionsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CrpNPCDivisionsCountAggregateInputType | true
    _avg?: CrpNPCDivisionsAvgAggregateInputType
    _sum?: CrpNPCDivisionsSumAggregateInputType
    _min?: CrpNPCDivisionsMinAggregateInputType
    _max?: CrpNPCDivisionsMaxAggregateInputType
  }

  export type CrpNPCDivisionsGroupByOutputType = {
    divisionID: number
    divisionName: string | null
    description: string | null
    leaderType: string | null
    _count: CrpNPCDivisionsCountAggregateOutputType | null
    _avg: CrpNPCDivisionsAvgAggregateOutputType | null
    _sum: CrpNPCDivisionsSumAggregateOutputType | null
    _min: CrpNPCDivisionsMinAggregateOutputType | null
    _max: CrpNPCDivisionsMaxAggregateOutputType | null
  }

  type GetCrpNPCDivisionsGroupByPayload<T extends crpNPCDivisionsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CrpNPCDivisionsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CrpNPCDivisionsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CrpNPCDivisionsGroupByOutputType[P]>
            : GetScalarType<T[P], CrpNPCDivisionsGroupByOutputType[P]>
        }
      >
    >


  export type crpNPCDivisionsSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    divisionID?: boolean
    divisionName?: boolean
    description?: boolean
    leaderType?: boolean
  }, ExtArgs["result"]["crpNPCDivisions"]>

  export type crpNPCDivisionsSelectScalar = {
    divisionID?: boolean
    divisionName?: boolean
    description?: boolean
    leaderType?: boolean
  }


  export type $crpNPCDivisionsPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    name: "crpNPCDivisions"
    objects: {}
    scalars: $Extensions.GetResult<{
      divisionID: number
      divisionName: string | null
      description: string | null
      leaderType: string | null
    }, ExtArgs["result"]["crpNPCDivisions"]>
    composites: {}
  }


  type crpNPCDivisionsGetPayload<S extends boolean | null | undefined | crpNPCDivisionsDefaultArgs> = $Result.GetResult<Prisma.$crpNPCDivisionsPayload, S>

  type crpNPCDivisionsCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<crpNPCDivisionsFindManyArgs, 'select' | 'include'> & {
      select?: CrpNPCDivisionsCountAggregateInputType | true
    }

  export interface crpNPCDivisionsDelegate<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['crpNPCDivisions'], meta: { name: 'crpNPCDivisions' } }
    /**
     * Find zero or one CrpNPCDivisions that matches the filter.
     * @param {crpNPCDivisionsFindUniqueArgs} args - Arguments to find a CrpNPCDivisions
     * @example
     * // Get one CrpNPCDivisions
     * const crpNPCDivisions = await prisma.crpNPCDivisions.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends crpNPCDivisionsFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, crpNPCDivisionsFindUniqueArgs<ExtArgs>>
    ): Prisma__crpNPCDivisionsClient<$Result.GetResult<Prisma.$crpNPCDivisionsPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one CrpNPCDivisions that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {crpNPCDivisionsFindUniqueOrThrowArgs} args - Arguments to find a CrpNPCDivisions
     * @example
     * // Get one CrpNPCDivisions
     * const crpNPCDivisions = await prisma.crpNPCDivisions.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends crpNPCDivisionsFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, crpNPCDivisionsFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__crpNPCDivisionsClient<$Result.GetResult<Prisma.$crpNPCDivisionsPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first CrpNPCDivisions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {crpNPCDivisionsFindFirstArgs} args - Arguments to find a CrpNPCDivisions
     * @example
     * // Get one CrpNPCDivisions
     * const crpNPCDivisions = await prisma.crpNPCDivisions.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends crpNPCDivisionsFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, crpNPCDivisionsFindFirstArgs<ExtArgs>>
    ): Prisma__crpNPCDivisionsClient<$Result.GetResult<Prisma.$crpNPCDivisionsPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first CrpNPCDivisions that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {crpNPCDivisionsFindFirstOrThrowArgs} args - Arguments to find a CrpNPCDivisions
     * @example
     * // Get one CrpNPCDivisions
     * const crpNPCDivisions = await prisma.crpNPCDivisions.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends crpNPCDivisionsFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, crpNPCDivisionsFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__crpNPCDivisionsClient<$Result.GetResult<Prisma.$crpNPCDivisionsPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more CrpNPCDivisions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {crpNPCDivisionsFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CrpNPCDivisions
     * const crpNPCDivisions = await prisma.crpNPCDivisions.findMany()
     * 
     * // Get first 10 CrpNPCDivisions
     * const crpNPCDivisions = await prisma.crpNPCDivisions.findMany({ take: 10 })
     * 
     * // Only select the `divisionID`
     * const crpNPCDivisionsWithDivisionIDOnly = await prisma.crpNPCDivisions.findMany({ select: { divisionID: true } })
     * 
    **/
    findMany<T extends crpNPCDivisionsFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, crpNPCDivisionsFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$crpNPCDivisionsPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a CrpNPCDivisions.
     * @param {crpNPCDivisionsCreateArgs} args - Arguments to create a CrpNPCDivisions.
     * @example
     * // Create one CrpNPCDivisions
     * const CrpNPCDivisions = await prisma.crpNPCDivisions.create({
     *   data: {
     *     // ... data to create a CrpNPCDivisions
     *   }
     * })
     * 
    **/
    create<T extends crpNPCDivisionsCreateArgs<ExtArgs>>(
      args: SelectSubset<T, crpNPCDivisionsCreateArgs<ExtArgs>>
    ): Prisma__crpNPCDivisionsClient<$Result.GetResult<Prisma.$crpNPCDivisionsPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many CrpNPCDivisions.
     *     @param {crpNPCDivisionsCreateManyArgs} args - Arguments to create many CrpNPCDivisions.
     *     @example
     *     // Create many CrpNPCDivisions
     *     const crpNPCDivisions = await prisma.crpNPCDivisions.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends crpNPCDivisionsCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, crpNPCDivisionsCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a CrpNPCDivisions.
     * @param {crpNPCDivisionsDeleteArgs} args - Arguments to delete one CrpNPCDivisions.
     * @example
     * // Delete one CrpNPCDivisions
     * const CrpNPCDivisions = await prisma.crpNPCDivisions.delete({
     *   where: {
     *     // ... filter to delete one CrpNPCDivisions
     *   }
     * })
     * 
    **/
    delete<T extends crpNPCDivisionsDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, crpNPCDivisionsDeleteArgs<ExtArgs>>
    ): Prisma__crpNPCDivisionsClient<$Result.GetResult<Prisma.$crpNPCDivisionsPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one CrpNPCDivisions.
     * @param {crpNPCDivisionsUpdateArgs} args - Arguments to update one CrpNPCDivisions.
     * @example
     * // Update one CrpNPCDivisions
     * const crpNPCDivisions = await prisma.crpNPCDivisions.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends crpNPCDivisionsUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, crpNPCDivisionsUpdateArgs<ExtArgs>>
    ): Prisma__crpNPCDivisionsClient<$Result.GetResult<Prisma.$crpNPCDivisionsPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more CrpNPCDivisions.
     * @param {crpNPCDivisionsDeleteManyArgs} args - Arguments to filter CrpNPCDivisions to delete.
     * @example
     * // Delete a few CrpNPCDivisions
     * const { count } = await prisma.crpNPCDivisions.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends crpNPCDivisionsDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, crpNPCDivisionsDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CrpNPCDivisions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {crpNPCDivisionsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CrpNPCDivisions
     * const crpNPCDivisions = await prisma.crpNPCDivisions.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends crpNPCDivisionsUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, crpNPCDivisionsUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one CrpNPCDivisions.
     * @param {crpNPCDivisionsUpsertArgs} args - Arguments to update or create a CrpNPCDivisions.
     * @example
     * // Update or create a CrpNPCDivisions
     * const crpNPCDivisions = await prisma.crpNPCDivisions.upsert({
     *   create: {
     *     // ... data to create a CrpNPCDivisions
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CrpNPCDivisions we want to update
     *   }
     * })
    **/
    upsert<T extends crpNPCDivisionsUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, crpNPCDivisionsUpsertArgs<ExtArgs>>
    ): Prisma__crpNPCDivisionsClient<$Result.GetResult<Prisma.$crpNPCDivisionsPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of CrpNPCDivisions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {crpNPCDivisionsCountArgs} args - Arguments to filter CrpNPCDivisions to count.
     * @example
     * // Count the number of CrpNPCDivisions
     * const count = await prisma.crpNPCDivisions.count({
     *   where: {
     *     // ... the filter for the CrpNPCDivisions we want to count
     *   }
     * })
    **/
    count<T extends crpNPCDivisionsCountArgs>(
      args?: Subset<T, crpNPCDivisionsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CrpNPCDivisionsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CrpNPCDivisions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CrpNPCDivisionsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CrpNPCDivisionsAggregateArgs>(args: Subset<T, CrpNPCDivisionsAggregateArgs>): Prisma.PrismaPromise<GetCrpNPCDivisionsAggregateType<T>>

    /**
     * Group by CrpNPCDivisions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {crpNPCDivisionsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends crpNPCDivisionsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: crpNPCDivisionsGroupByArgs['orderBy'] }
        : { orderBy?: crpNPCDivisionsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, crpNPCDivisionsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCrpNPCDivisionsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the crpNPCDivisions model
   */
  readonly fields: crpNPCDivisionsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for crpNPCDivisions.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__crpNPCDivisionsClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';


    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the crpNPCDivisions model
   */ 
  interface crpNPCDivisionsFieldRefs {
    readonly divisionID: FieldRef<"crpNPCDivisions", 'Int'>
    readonly divisionName: FieldRef<"crpNPCDivisions", 'String'>
    readonly description: FieldRef<"crpNPCDivisions", 'String'>
    readonly leaderType: FieldRef<"crpNPCDivisions", 'String'>
  }
    

  // Custom InputTypes

  /**
   * crpNPCDivisions findUnique
   */
  export type crpNPCDivisionsFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the crpNPCDivisions
     */
    select?: crpNPCDivisionsSelect<ExtArgs> | null
    /**
     * Filter, which crpNPCDivisions to fetch.
     */
    where: crpNPCDivisionsWhereUniqueInput
  }


  /**
   * crpNPCDivisions findUniqueOrThrow
   */
  export type crpNPCDivisionsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the crpNPCDivisions
     */
    select?: crpNPCDivisionsSelect<ExtArgs> | null
    /**
     * Filter, which crpNPCDivisions to fetch.
     */
    where: crpNPCDivisionsWhereUniqueInput
  }


  /**
   * crpNPCDivisions findFirst
   */
  export type crpNPCDivisionsFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the crpNPCDivisions
     */
    select?: crpNPCDivisionsSelect<ExtArgs> | null
    /**
     * Filter, which crpNPCDivisions to fetch.
     */
    where?: crpNPCDivisionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of crpNPCDivisions to fetch.
     */
    orderBy?: crpNPCDivisionsOrderByWithRelationInput | crpNPCDivisionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for crpNPCDivisions.
     */
    cursor?: crpNPCDivisionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` crpNPCDivisions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` crpNPCDivisions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of crpNPCDivisions.
     */
    distinct?: CrpNPCDivisionsScalarFieldEnum | CrpNPCDivisionsScalarFieldEnum[]
  }


  /**
   * crpNPCDivisions findFirstOrThrow
   */
  export type crpNPCDivisionsFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the crpNPCDivisions
     */
    select?: crpNPCDivisionsSelect<ExtArgs> | null
    /**
     * Filter, which crpNPCDivisions to fetch.
     */
    where?: crpNPCDivisionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of crpNPCDivisions to fetch.
     */
    orderBy?: crpNPCDivisionsOrderByWithRelationInput | crpNPCDivisionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for crpNPCDivisions.
     */
    cursor?: crpNPCDivisionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` crpNPCDivisions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` crpNPCDivisions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of crpNPCDivisions.
     */
    distinct?: CrpNPCDivisionsScalarFieldEnum | CrpNPCDivisionsScalarFieldEnum[]
  }


  /**
   * crpNPCDivisions findMany
   */
  export type crpNPCDivisionsFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the crpNPCDivisions
     */
    select?: crpNPCDivisionsSelect<ExtArgs> | null
    /**
     * Filter, which crpNPCDivisions to fetch.
     */
    where?: crpNPCDivisionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of crpNPCDivisions to fetch.
     */
    orderBy?: crpNPCDivisionsOrderByWithRelationInput | crpNPCDivisionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing crpNPCDivisions.
     */
    cursor?: crpNPCDivisionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` crpNPCDivisions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` crpNPCDivisions.
     */
    skip?: number
    distinct?: CrpNPCDivisionsScalarFieldEnum | CrpNPCDivisionsScalarFieldEnum[]
  }


  /**
   * crpNPCDivisions create
   */
  export type crpNPCDivisionsCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the crpNPCDivisions
     */
    select?: crpNPCDivisionsSelect<ExtArgs> | null
    /**
     * The data needed to create a crpNPCDivisions.
     */
    data: XOR<crpNPCDivisionsCreateInput, crpNPCDivisionsUncheckedCreateInput>
  }


  /**
   * crpNPCDivisions createMany
   */
  export type crpNPCDivisionsCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many crpNPCDivisions.
     */
    data: crpNPCDivisionsCreateManyInput | crpNPCDivisionsCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * crpNPCDivisions update
   */
  export type crpNPCDivisionsUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the crpNPCDivisions
     */
    select?: crpNPCDivisionsSelect<ExtArgs> | null
    /**
     * The data needed to update a crpNPCDivisions.
     */
    data: XOR<crpNPCDivisionsUpdateInput, crpNPCDivisionsUncheckedUpdateInput>
    /**
     * Choose, which crpNPCDivisions to update.
     */
    where: crpNPCDivisionsWhereUniqueInput
  }


  /**
   * crpNPCDivisions updateMany
   */
  export type crpNPCDivisionsUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update crpNPCDivisions.
     */
    data: XOR<crpNPCDivisionsUpdateManyMutationInput, crpNPCDivisionsUncheckedUpdateManyInput>
    /**
     * Filter which crpNPCDivisions to update
     */
    where?: crpNPCDivisionsWhereInput
  }


  /**
   * crpNPCDivisions upsert
   */
  export type crpNPCDivisionsUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the crpNPCDivisions
     */
    select?: crpNPCDivisionsSelect<ExtArgs> | null
    /**
     * The filter to search for the crpNPCDivisions to update in case it exists.
     */
    where: crpNPCDivisionsWhereUniqueInput
    /**
     * In case the crpNPCDivisions found by the `where` argument doesn't exist, create a new crpNPCDivisions with this data.
     */
    create: XOR<crpNPCDivisionsCreateInput, crpNPCDivisionsUncheckedCreateInput>
    /**
     * In case the crpNPCDivisions was found with the provided `where` argument, update it with this data.
     */
    update: XOR<crpNPCDivisionsUpdateInput, crpNPCDivisionsUncheckedUpdateInput>
  }


  /**
   * crpNPCDivisions delete
   */
  export type crpNPCDivisionsDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the crpNPCDivisions
     */
    select?: crpNPCDivisionsSelect<ExtArgs> | null
    /**
     * Filter which crpNPCDivisions to delete.
     */
    where: crpNPCDivisionsWhereUniqueInput
  }


  /**
   * crpNPCDivisions deleteMany
   */
  export type crpNPCDivisionsDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which crpNPCDivisions to delete
     */
    where?: crpNPCDivisionsWhereInput
  }


  /**
   * crpNPCDivisions without action
   */
  export type crpNPCDivisionsDefaultArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the crpNPCDivisions
     */
    select?: crpNPCDivisionsSelect<ExtArgs> | null
  }



  /**
   * Model dgmAttributeCategories
   */

  export type AggregateDgmAttributeCategories = {
    _count: DgmAttributeCategoriesCountAggregateOutputType | null
    _avg: DgmAttributeCategoriesAvgAggregateOutputType | null
    _sum: DgmAttributeCategoriesSumAggregateOutputType | null
    _min: DgmAttributeCategoriesMinAggregateOutputType | null
    _max: DgmAttributeCategoriesMaxAggregateOutputType | null
  }

  export type DgmAttributeCategoriesAvgAggregateOutputType = {
    categoryID: number | null
  }

  export type DgmAttributeCategoriesSumAggregateOutputType = {
    categoryID: number | null
  }

  export type DgmAttributeCategoriesMinAggregateOutputType = {
    categoryID: number | null
    categoryName: string | null
    categoryDescription: string | null
  }

  export type DgmAttributeCategoriesMaxAggregateOutputType = {
    categoryID: number | null
    categoryName: string | null
    categoryDescription: string | null
  }

  export type DgmAttributeCategoriesCountAggregateOutputType = {
    categoryID: number
    categoryName: number
    categoryDescription: number
    _all: number
  }


  export type DgmAttributeCategoriesAvgAggregateInputType = {
    categoryID?: true
  }

  export type DgmAttributeCategoriesSumAggregateInputType = {
    categoryID?: true
  }

  export type DgmAttributeCategoriesMinAggregateInputType = {
    categoryID?: true
    categoryName?: true
    categoryDescription?: true
  }

  export type DgmAttributeCategoriesMaxAggregateInputType = {
    categoryID?: true
    categoryName?: true
    categoryDescription?: true
  }

  export type DgmAttributeCategoriesCountAggregateInputType = {
    categoryID?: true
    categoryName?: true
    categoryDescription?: true
    _all?: true
  }

  export type DgmAttributeCategoriesAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which dgmAttributeCategories to aggregate.
     */
    where?: dgmAttributeCategoriesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of dgmAttributeCategories to fetch.
     */
    orderBy?: dgmAttributeCategoriesOrderByWithRelationInput | dgmAttributeCategoriesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: dgmAttributeCategoriesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` dgmAttributeCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` dgmAttributeCategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned dgmAttributeCategories
    **/
    _count?: true | DgmAttributeCategoriesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DgmAttributeCategoriesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DgmAttributeCategoriesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DgmAttributeCategoriesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DgmAttributeCategoriesMaxAggregateInputType
  }

  export type GetDgmAttributeCategoriesAggregateType<T extends DgmAttributeCategoriesAggregateArgs> = {
        [P in keyof T & keyof AggregateDgmAttributeCategories]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDgmAttributeCategories[P]>
      : GetScalarType<T[P], AggregateDgmAttributeCategories[P]>
  }




  export type dgmAttributeCategoriesGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: dgmAttributeCategoriesWhereInput
    orderBy?: dgmAttributeCategoriesOrderByWithAggregationInput | dgmAttributeCategoriesOrderByWithAggregationInput[]
    by: DgmAttributeCategoriesScalarFieldEnum[] | DgmAttributeCategoriesScalarFieldEnum
    having?: dgmAttributeCategoriesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DgmAttributeCategoriesCountAggregateInputType | true
    _avg?: DgmAttributeCategoriesAvgAggregateInputType
    _sum?: DgmAttributeCategoriesSumAggregateInputType
    _min?: DgmAttributeCategoriesMinAggregateInputType
    _max?: DgmAttributeCategoriesMaxAggregateInputType
  }

  export type DgmAttributeCategoriesGroupByOutputType = {
    categoryID: number
    categoryName: string | null
    categoryDescription: string | null
    _count: DgmAttributeCategoriesCountAggregateOutputType | null
    _avg: DgmAttributeCategoriesAvgAggregateOutputType | null
    _sum: DgmAttributeCategoriesSumAggregateOutputType | null
    _min: DgmAttributeCategoriesMinAggregateOutputType | null
    _max: DgmAttributeCategoriesMaxAggregateOutputType | null
  }

  type GetDgmAttributeCategoriesGroupByPayload<T extends dgmAttributeCategoriesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DgmAttributeCategoriesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DgmAttributeCategoriesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DgmAttributeCategoriesGroupByOutputType[P]>
            : GetScalarType<T[P], DgmAttributeCategoriesGroupByOutputType[P]>
        }
      >
    >


  export type dgmAttributeCategoriesSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    categoryID?: boolean
    categoryName?: boolean
    categoryDescription?: boolean
  }, ExtArgs["result"]["dgmAttributeCategories"]>

  export type dgmAttributeCategoriesSelectScalar = {
    categoryID?: boolean
    categoryName?: boolean
    categoryDescription?: boolean
  }


  export type $dgmAttributeCategoriesPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    name: "dgmAttributeCategories"
    objects: {}
    scalars: $Extensions.GetResult<{
      categoryID: number
      categoryName: string | null
      categoryDescription: string | null
    }, ExtArgs["result"]["dgmAttributeCategories"]>
    composites: {}
  }


  type dgmAttributeCategoriesGetPayload<S extends boolean | null | undefined | dgmAttributeCategoriesDefaultArgs> = $Result.GetResult<Prisma.$dgmAttributeCategoriesPayload, S>

  type dgmAttributeCategoriesCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<dgmAttributeCategoriesFindManyArgs, 'select' | 'include'> & {
      select?: DgmAttributeCategoriesCountAggregateInputType | true
    }

  export interface dgmAttributeCategoriesDelegate<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['dgmAttributeCategories'], meta: { name: 'dgmAttributeCategories' } }
    /**
     * Find zero or one DgmAttributeCategories that matches the filter.
     * @param {dgmAttributeCategoriesFindUniqueArgs} args - Arguments to find a DgmAttributeCategories
     * @example
     * // Get one DgmAttributeCategories
     * const dgmAttributeCategories = await prisma.dgmAttributeCategories.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends dgmAttributeCategoriesFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, dgmAttributeCategoriesFindUniqueArgs<ExtArgs>>
    ): Prisma__dgmAttributeCategoriesClient<$Result.GetResult<Prisma.$dgmAttributeCategoriesPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one DgmAttributeCategories that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {dgmAttributeCategoriesFindUniqueOrThrowArgs} args - Arguments to find a DgmAttributeCategories
     * @example
     * // Get one DgmAttributeCategories
     * const dgmAttributeCategories = await prisma.dgmAttributeCategories.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends dgmAttributeCategoriesFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, dgmAttributeCategoriesFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__dgmAttributeCategoriesClient<$Result.GetResult<Prisma.$dgmAttributeCategoriesPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first DgmAttributeCategories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {dgmAttributeCategoriesFindFirstArgs} args - Arguments to find a DgmAttributeCategories
     * @example
     * // Get one DgmAttributeCategories
     * const dgmAttributeCategories = await prisma.dgmAttributeCategories.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends dgmAttributeCategoriesFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, dgmAttributeCategoriesFindFirstArgs<ExtArgs>>
    ): Prisma__dgmAttributeCategoriesClient<$Result.GetResult<Prisma.$dgmAttributeCategoriesPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first DgmAttributeCategories that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {dgmAttributeCategoriesFindFirstOrThrowArgs} args - Arguments to find a DgmAttributeCategories
     * @example
     * // Get one DgmAttributeCategories
     * const dgmAttributeCategories = await prisma.dgmAttributeCategories.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends dgmAttributeCategoriesFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, dgmAttributeCategoriesFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__dgmAttributeCategoriesClient<$Result.GetResult<Prisma.$dgmAttributeCategoriesPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more DgmAttributeCategories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {dgmAttributeCategoriesFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DgmAttributeCategories
     * const dgmAttributeCategories = await prisma.dgmAttributeCategories.findMany()
     * 
     * // Get first 10 DgmAttributeCategories
     * const dgmAttributeCategories = await prisma.dgmAttributeCategories.findMany({ take: 10 })
     * 
     * // Only select the `categoryID`
     * const dgmAttributeCategoriesWithCategoryIDOnly = await prisma.dgmAttributeCategories.findMany({ select: { categoryID: true } })
     * 
    **/
    findMany<T extends dgmAttributeCategoriesFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, dgmAttributeCategoriesFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$dgmAttributeCategoriesPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a DgmAttributeCategories.
     * @param {dgmAttributeCategoriesCreateArgs} args - Arguments to create a DgmAttributeCategories.
     * @example
     * // Create one DgmAttributeCategories
     * const DgmAttributeCategories = await prisma.dgmAttributeCategories.create({
     *   data: {
     *     // ... data to create a DgmAttributeCategories
     *   }
     * })
     * 
    **/
    create<T extends dgmAttributeCategoriesCreateArgs<ExtArgs>>(
      args: SelectSubset<T, dgmAttributeCategoriesCreateArgs<ExtArgs>>
    ): Prisma__dgmAttributeCategoriesClient<$Result.GetResult<Prisma.$dgmAttributeCategoriesPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many DgmAttributeCategories.
     *     @param {dgmAttributeCategoriesCreateManyArgs} args - Arguments to create many DgmAttributeCategories.
     *     @example
     *     // Create many DgmAttributeCategories
     *     const dgmAttributeCategories = await prisma.dgmAttributeCategories.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends dgmAttributeCategoriesCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, dgmAttributeCategoriesCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a DgmAttributeCategories.
     * @param {dgmAttributeCategoriesDeleteArgs} args - Arguments to delete one DgmAttributeCategories.
     * @example
     * // Delete one DgmAttributeCategories
     * const DgmAttributeCategories = await prisma.dgmAttributeCategories.delete({
     *   where: {
     *     // ... filter to delete one DgmAttributeCategories
     *   }
     * })
     * 
    **/
    delete<T extends dgmAttributeCategoriesDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, dgmAttributeCategoriesDeleteArgs<ExtArgs>>
    ): Prisma__dgmAttributeCategoriesClient<$Result.GetResult<Prisma.$dgmAttributeCategoriesPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one DgmAttributeCategories.
     * @param {dgmAttributeCategoriesUpdateArgs} args - Arguments to update one DgmAttributeCategories.
     * @example
     * // Update one DgmAttributeCategories
     * const dgmAttributeCategories = await prisma.dgmAttributeCategories.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends dgmAttributeCategoriesUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, dgmAttributeCategoriesUpdateArgs<ExtArgs>>
    ): Prisma__dgmAttributeCategoriesClient<$Result.GetResult<Prisma.$dgmAttributeCategoriesPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more DgmAttributeCategories.
     * @param {dgmAttributeCategoriesDeleteManyArgs} args - Arguments to filter DgmAttributeCategories to delete.
     * @example
     * // Delete a few DgmAttributeCategories
     * const { count } = await prisma.dgmAttributeCategories.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends dgmAttributeCategoriesDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, dgmAttributeCategoriesDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DgmAttributeCategories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {dgmAttributeCategoriesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DgmAttributeCategories
     * const dgmAttributeCategories = await prisma.dgmAttributeCategories.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends dgmAttributeCategoriesUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, dgmAttributeCategoriesUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one DgmAttributeCategories.
     * @param {dgmAttributeCategoriesUpsertArgs} args - Arguments to update or create a DgmAttributeCategories.
     * @example
     * // Update or create a DgmAttributeCategories
     * const dgmAttributeCategories = await prisma.dgmAttributeCategories.upsert({
     *   create: {
     *     // ... data to create a DgmAttributeCategories
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DgmAttributeCategories we want to update
     *   }
     * })
    **/
    upsert<T extends dgmAttributeCategoriesUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, dgmAttributeCategoriesUpsertArgs<ExtArgs>>
    ): Prisma__dgmAttributeCategoriesClient<$Result.GetResult<Prisma.$dgmAttributeCategoriesPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of DgmAttributeCategories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {dgmAttributeCategoriesCountArgs} args - Arguments to filter DgmAttributeCategories to count.
     * @example
     * // Count the number of DgmAttributeCategories
     * const count = await prisma.dgmAttributeCategories.count({
     *   where: {
     *     // ... the filter for the DgmAttributeCategories we want to count
     *   }
     * })
    **/
    count<T extends dgmAttributeCategoriesCountArgs>(
      args?: Subset<T, dgmAttributeCategoriesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DgmAttributeCategoriesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DgmAttributeCategories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DgmAttributeCategoriesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DgmAttributeCategoriesAggregateArgs>(args: Subset<T, DgmAttributeCategoriesAggregateArgs>): Prisma.PrismaPromise<GetDgmAttributeCategoriesAggregateType<T>>

    /**
     * Group by DgmAttributeCategories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {dgmAttributeCategoriesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends dgmAttributeCategoriesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: dgmAttributeCategoriesGroupByArgs['orderBy'] }
        : { orderBy?: dgmAttributeCategoriesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, dgmAttributeCategoriesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDgmAttributeCategoriesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the dgmAttributeCategories model
   */
  readonly fields: dgmAttributeCategoriesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for dgmAttributeCategories.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__dgmAttributeCategoriesClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';


    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the dgmAttributeCategories model
   */ 
  interface dgmAttributeCategoriesFieldRefs {
    readonly categoryID: FieldRef<"dgmAttributeCategories", 'Int'>
    readonly categoryName: FieldRef<"dgmAttributeCategories", 'String'>
    readonly categoryDescription: FieldRef<"dgmAttributeCategories", 'String'>
  }
    

  // Custom InputTypes

  /**
   * dgmAttributeCategories findUnique
   */
  export type dgmAttributeCategoriesFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the dgmAttributeCategories
     */
    select?: dgmAttributeCategoriesSelect<ExtArgs> | null
    /**
     * Filter, which dgmAttributeCategories to fetch.
     */
    where: dgmAttributeCategoriesWhereUniqueInput
  }


  /**
   * dgmAttributeCategories findUniqueOrThrow
   */
  export type dgmAttributeCategoriesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the dgmAttributeCategories
     */
    select?: dgmAttributeCategoriesSelect<ExtArgs> | null
    /**
     * Filter, which dgmAttributeCategories to fetch.
     */
    where: dgmAttributeCategoriesWhereUniqueInput
  }


  /**
   * dgmAttributeCategories findFirst
   */
  export type dgmAttributeCategoriesFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the dgmAttributeCategories
     */
    select?: dgmAttributeCategoriesSelect<ExtArgs> | null
    /**
     * Filter, which dgmAttributeCategories to fetch.
     */
    where?: dgmAttributeCategoriesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of dgmAttributeCategories to fetch.
     */
    orderBy?: dgmAttributeCategoriesOrderByWithRelationInput | dgmAttributeCategoriesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for dgmAttributeCategories.
     */
    cursor?: dgmAttributeCategoriesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` dgmAttributeCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` dgmAttributeCategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of dgmAttributeCategories.
     */
    distinct?: DgmAttributeCategoriesScalarFieldEnum | DgmAttributeCategoriesScalarFieldEnum[]
  }


  /**
   * dgmAttributeCategories findFirstOrThrow
   */
  export type dgmAttributeCategoriesFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the dgmAttributeCategories
     */
    select?: dgmAttributeCategoriesSelect<ExtArgs> | null
    /**
     * Filter, which dgmAttributeCategories to fetch.
     */
    where?: dgmAttributeCategoriesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of dgmAttributeCategories to fetch.
     */
    orderBy?: dgmAttributeCategoriesOrderByWithRelationInput | dgmAttributeCategoriesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for dgmAttributeCategories.
     */
    cursor?: dgmAttributeCategoriesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` dgmAttributeCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` dgmAttributeCategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of dgmAttributeCategories.
     */
    distinct?: DgmAttributeCategoriesScalarFieldEnum | DgmAttributeCategoriesScalarFieldEnum[]
  }


  /**
   * dgmAttributeCategories findMany
   */
  export type dgmAttributeCategoriesFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the dgmAttributeCategories
     */
    select?: dgmAttributeCategoriesSelect<ExtArgs> | null
    /**
     * Filter, which dgmAttributeCategories to fetch.
     */
    where?: dgmAttributeCategoriesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of dgmAttributeCategories to fetch.
     */
    orderBy?: dgmAttributeCategoriesOrderByWithRelationInput | dgmAttributeCategoriesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing dgmAttributeCategories.
     */
    cursor?: dgmAttributeCategoriesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` dgmAttributeCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` dgmAttributeCategories.
     */
    skip?: number
    distinct?: DgmAttributeCategoriesScalarFieldEnum | DgmAttributeCategoriesScalarFieldEnum[]
  }


  /**
   * dgmAttributeCategories create
   */
  export type dgmAttributeCategoriesCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the dgmAttributeCategories
     */
    select?: dgmAttributeCategoriesSelect<ExtArgs> | null
    /**
     * The data needed to create a dgmAttributeCategories.
     */
    data: XOR<dgmAttributeCategoriesCreateInput, dgmAttributeCategoriesUncheckedCreateInput>
  }


  /**
   * dgmAttributeCategories createMany
   */
  export type dgmAttributeCategoriesCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many dgmAttributeCategories.
     */
    data: dgmAttributeCategoriesCreateManyInput | dgmAttributeCategoriesCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * dgmAttributeCategories update
   */
  export type dgmAttributeCategoriesUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the dgmAttributeCategories
     */
    select?: dgmAttributeCategoriesSelect<ExtArgs> | null
    /**
     * The data needed to update a dgmAttributeCategories.
     */
    data: XOR<dgmAttributeCategoriesUpdateInput, dgmAttributeCategoriesUncheckedUpdateInput>
    /**
     * Choose, which dgmAttributeCategories to update.
     */
    where: dgmAttributeCategoriesWhereUniqueInput
  }


  /**
   * dgmAttributeCategories updateMany
   */
  export type dgmAttributeCategoriesUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update dgmAttributeCategories.
     */
    data: XOR<dgmAttributeCategoriesUpdateManyMutationInput, dgmAttributeCategoriesUncheckedUpdateManyInput>
    /**
     * Filter which dgmAttributeCategories to update
     */
    where?: dgmAttributeCategoriesWhereInput
  }


  /**
   * dgmAttributeCategories upsert
   */
  export type dgmAttributeCategoriesUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the dgmAttributeCategories
     */
    select?: dgmAttributeCategoriesSelect<ExtArgs> | null
    /**
     * The filter to search for the dgmAttributeCategories to update in case it exists.
     */
    where: dgmAttributeCategoriesWhereUniqueInput
    /**
     * In case the dgmAttributeCategories found by the `where` argument doesn't exist, create a new dgmAttributeCategories with this data.
     */
    create: XOR<dgmAttributeCategoriesCreateInput, dgmAttributeCategoriesUncheckedCreateInput>
    /**
     * In case the dgmAttributeCategories was found with the provided `where` argument, update it with this data.
     */
    update: XOR<dgmAttributeCategoriesUpdateInput, dgmAttributeCategoriesUncheckedUpdateInput>
  }


  /**
   * dgmAttributeCategories delete
   */
  export type dgmAttributeCategoriesDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the dgmAttributeCategories
     */
    select?: dgmAttributeCategoriesSelect<ExtArgs> | null
    /**
     * Filter which dgmAttributeCategories to delete.
     */
    where: dgmAttributeCategoriesWhereUniqueInput
  }


  /**
   * dgmAttributeCategories deleteMany
   */
  export type dgmAttributeCategoriesDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which dgmAttributeCategories to delete
     */
    where?: dgmAttributeCategoriesWhereInput
  }


  /**
   * dgmAttributeCategories without action
   */
  export type dgmAttributeCategoriesDefaultArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the dgmAttributeCategories
     */
    select?: dgmAttributeCategoriesSelect<ExtArgs> | null
  }



  /**
   * Model dgmAttributeTypes
   */

  export type AggregateDgmAttributeTypes = {
    _count: DgmAttributeTypesCountAggregateOutputType | null
    _avg: DgmAttributeTypesAvgAggregateOutputType | null
    _sum: DgmAttributeTypesSumAggregateOutputType | null
    _min: DgmAttributeTypesMinAggregateOutputType | null
    _max: DgmAttributeTypesMaxAggregateOutputType | null
  }

  export type DgmAttributeTypesAvgAggregateOutputType = {
    attributeID: number | null
    iconID: number | null
    defaultValue: number | null
    unitID: number | null
    categoryID: number | null
  }

  export type DgmAttributeTypesSumAggregateOutputType = {
    attributeID: number | null
    iconID: number | null
    defaultValue: number | null
    unitID: number | null
    categoryID: number | null
  }

  export type DgmAttributeTypesMinAggregateOutputType = {
    attributeID: number | null
    attributeName: string | null
    description: string | null
    iconID: number | null
    defaultValue: number | null
    published: boolean | null
    displayName: string | null
    unitID: number | null
    stackable: boolean | null
    highIsGood: boolean | null
    categoryID: number | null
  }

  export type DgmAttributeTypesMaxAggregateOutputType = {
    attributeID: number | null
    attributeName: string | null
    description: string | null
    iconID: number | null
    defaultValue: number | null
    published: boolean | null
    displayName: string | null
    unitID: number | null
    stackable: boolean | null
    highIsGood: boolean | null
    categoryID: number | null
  }

  export type DgmAttributeTypesCountAggregateOutputType = {
    attributeID: number
    attributeName: number
    description: number
    iconID: number
    defaultValue: number
    published: number
    displayName: number
    unitID: number
    stackable: number
    highIsGood: number
    categoryID: number
    _all: number
  }


  export type DgmAttributeTypesAvgAggregateInputType = {
    attributeID?: true
    iconID?: true
    defaultValue?: true
    unitID?: true
    categoryID?: true
  }

  export type DgmAttributeTypesSumAggregateInputType = {
    attributeID?: true
    iconID?: true
    defaultValue?: true
    unitID?: true
    categoryID?: true
  }

  export type DgmAttributeTypesMinAggregateInputType = {
    attributeID?: true
    attributeName?: true
    description?: true
    iconID?: true
    defaultValue?: true
    published?: true
    displayName?: true
    unitID?: true
    stackable?: true
    highIsGood?: true
    categoryID?: true
  }

  export type DgmAttributeTypesMaxAggregateInputType = {
    attributeID?: true
    attributeName?: true
    description?: true
    iconID?: true
    defaultValue?: true
    published?: true
    displayName?: true
    unitID?: true
    stackable?: true
    highIsGood?: true
    categoryID?: true
  }

  export type DgmAttributeTypesCountAggregateInputType = {
    attributeID?: true
    attributeName?: true
    description?: true
    iconID?: true
    defaultValue?: true
    published?: true
    displayName?: true
    unitID?: true
    stackable?: true
    highIsGood?: true
    categoryID?: true
    _all?: true
  }

  export type DgmAttributeTypesAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which dgmAttributeTypes to aggregate.
     */
    where?: dgmAttributeTypesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of dgmAttributeTypes to fetch.
     */
    orderBy?: dgmAttributeTypesOrderByWithRelationInput | dgmAttributeTypesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: dgmAttributeTypesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` dgmAttributeTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` dgmAttributeTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned dgmAttributeTypes
    **/
    _count?: true | DgmAttributeTypesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DgmAttributeTypesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DgmAttributeTypesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DgmAttributeTypesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DgmAttributeTypesMaxAggregateInputType
  }

  export type GetDgmAttributeTypesAggregateType<T extends DgmAttributeTypesAggregateArgs> = {
        [P in keyof T & keyof AggregateDgmAttributeTypes]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDgmAttributeTypes[P]>
      : GetScalarType<T[P], AggregateDgmAttributeTypes[P]>
  }




  export type dgmAttributeTypesGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: dgmAttributeTypesWhereInput
    orderBy?: dgmAttributeTypesOrderByWithAggregationInput | dgmAttributeTypesOrderByWithAggregationInput[]
    by: DgmAttributeTypesScalarFieldEnum[] | DgmAttributeTypesScalarFieldEnum
    having?: dgmAttributeTypesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DgmAttributeTypesCountAggregateInputType | true
    _avg?: DgmAttributeTypesAvgAggregateInputType
    _sum?: DgmAttributeTypesSumAggregateInputType
    _min?: DgmAttributeTypesMinAggregateInputType
    _max?: DgmAttributeTypesMaxAggregateInputType
  }

  export type DgmAttributeTypesGroupByOutputType = {
    attributeID: number
    attributeName: string | null
    description: string | null
    iconID: number | null
    defaultValue: number | null
    published: boolean | null
    displayName: string | null
    unitID: number | null
    stackable: boolean | null
    highIsGood: boolean | null
    categoryID: number | null
    _count: DgmAttributeTypesCountAggregateOutputType | null
    _avg: DgmAttributeTypesAvgAggregateOutputType | null
    _sum: DgmAttributeTypesSumAggregateOutputType | null
    _min: DgmAttributeTypesMinAggregateOutputType | null
    _max: DgmAttributeTypesMaxAggregateOutputType | null
  }

  type GetDgmAttributeTypesGroupByPayload<T extends dgmAttributeTypesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DgmAttributeTypesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DgmAttributeTypesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DgmAttributeTypesGroupByOutputType[P]>
            : GetScalarType<T[P], DgmAttributeTypesGroupByOutputType[P]>
        }
      >
    >


  export type dgmAttributeTypesSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    attributeID?: boolean
    attributeName?: boolean
    description?: boolean
    iconID?: boolean
    defaultValue?: boolean
    published?: boolean
    displayName?: boolean
    unitID?: boolean
    stackable?: boolean
    highIsGood?: boolean
    categoryID?: boolean
  }, ExtArgs["result"]["dgmAttributeTypes"]>

  export type dgmAttributeTypesSelectScalar = {
    attributeID?: boolean
    attributeName?: boolean
    description?: boolean
    iconID?: boolean
    defaultValue?: boolean
    published?: boolean
    displayName?: boolean
    unitID?: boolean
    stackable?: boolean
    highIsGood?: boolean
    categoryID?: boolean
  }


  export type $dgmAttributeTypesPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    name: "dgmAttributeTypes"
    objects: {}
    scalars: $Extensions.GetResult<{
      attributeID: number
      attributeName: string | null
      description: string | null
      iconID: number | null
      defaultValue: number | null
      published: boolean | null
      displayName: string | null
      unitID: number | null
      stackable: boolean | null
      highIsGood: boolean | null
      categoryID: number | null
    }, ExtArgs["result"]["dgmAttributeTypes"]>
    composites: {}
  }


  type dgmAttributeTypesGetPayload<S extends boolean | null | undefined | dgmAttributeTypesDefaultArgs> = $Result.GetResult<Prisma.$dgmAttributeTypesPayload, S>

  type dgmAttributeTypesCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<dgmAttributeTypesFindManyArgs, 'select' | 'include'> & {
      select?: DgmAttributeTypesCountAggregateInputType | true
    }

  export interface dgmAttributeTypesDelegate<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['dgmAttributeTypes'], meta: { name: 'dgmAttributeTypes' } }
    /**
     * Find zero or one DgmAttributeTypes that matches the filter.
     * @param {dgmAttributeTypesFindUniqueArgs} args - Arguments to find a DgmAttributeTypes
     * @example
     * // Get one DgmAttributeTypes
     * const dgmAttributeTypes = await prisma.dgmAttributeTypes.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends dgmAttributeTypesFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, dgmAttributeTypesFindUniqueArgs<ExtArgs>>
    ): Prisma__dgmAttributeTypesClient<$Result.GetResult<Prisma.$dgmAttributeTypesPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one DgmAttributeTypes that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {dgmAttributeTypesFindUniqueOrThrowArgs} args - Arguments to find a DgmAttributeTypes
     * @example
     * // Get one DgmAttributeTypes
     * const dgmAttributeTypes = await prisma.dgmAttributeTypes.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends dgmAttributeTypesFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, dgmAttributeTypesFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__dgmAttributeTypesClient<$Result.GetResult<Prisma.$dgmAttributeTypesPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first DgmAttributeTypes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {dgmAttributeTypesFindFirstArgs} args - Arguments to find a DgmAttributeTypes
     * @example
     * // Get one DgmAttributeTypes
     * const dgmAttributeTypes = await prisma.dgmAttributeTypes.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends dgmAttributeTypesFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, dgmAttributeTypesFindFirstArgs<ExtArgs>>
    ): Prisma__dgmAttributeTypesClient<$Result.GetResult<Prisma.$dgmAttributeTypesPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first DgmAttributeTypes that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {dgmAttributeTypesFindFirstOrThrowArgs} args - Arguments to find a DgmAttributeTypes
     * @example
     * // Get one DgmAttributeTypes
     * const dgmAttributeTypes = await prisma.dgmAttributeTypes.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends dgmAttributeTypesFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, dgmAttributeTypesFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__dgmAttributeTypesClient<$Result.GetResult<Prisma.$dgmAttributeTypesPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more DgmAttributeTypes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {dgmAttributeTypesFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DgmAttributeTypes
     * const dgmAttributeTypes = await prisma.dgmAttributeTypes.findMany()
     * 
     * // Get first 10 DgmAttributeTypes
     * const dgmAttributeTypes = await prisma.dgmAttributeTypes.findMany({ take: 10 })
     * 
     * // Only select the `attributeID`
     * const dgmAttributeTypesWithAttributeIDOnly = await prisma.dgmAttributeTypes.findMany({ select: { attributeID: true } })
     * 
    **/
    findMany<T extends dgmAttributeTypesFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, dgmAttributeTypesFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$dgmAttributeTypesPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a DgmAttributeTypes.
     * @param {dgmAttributeTypesCreateArgs} args - Arguments to create a DgmAttributeTypes.
     * @example
     * // Create one DgmAttributeTypes
     * const DgmAttributeTypes = await prisma.dgmAttributeTypes.create({
     *   data: {
     *     // ... data to create a DgmAttributeTypes
     *   }
     * })
     * 
    **/
    create<T extends dgmAttributeTypesCreateArgs<ExtArgs>>(
      args: SelectSubset<T, dgmAttributeTypesCreateArgs<ExtArgs>>
    ): Prisma__dgmAttributeTypesClient<$Result.GetResult<Prisma.$dgmAttributeTypesPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many DgmAttributeTypes.
     *     @param {dgmAttributeTypesCreateManyArgs} args - Arguments to create many DgmAttributeTypes.
     *     @example
     *     // Create many DgmAttributeTypes
     *     const dgmAttributeTypes = await prisma.dgmAttributeTypes.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends dgmAttributeTypesCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, dgmAttributeTypesCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a DgmAttributeTypes.
     * @param {dgmAttributeTypesDeleteArgs} args - Arguments to delete one DgmAttributeTypes.
     * @example
     * // Delete one DgmAttributeTypes
     * const DgmAttributeTypes = await prisma.dgmAttributeTypes.delete({
     *   where: {
     *     // ... filter to delete one DgmAttributeTypes
     *   }
     * })
     * 
    **/
    delete<T extends dgmAttributeTypesDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, dgmAttributeTypesDeleteArgs<ExtArgs>>
    ): Prisma__dgmAttributeTypesClient<$Result.GetResult<Prisma.$dgmAttributeTypesPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one DgmAttributeTypes.
     * @param {dgmAttributeTypesUpdateArgs} args - Arguments to update one DgmAttributeTypes.
     * @example
     * // Update one DgmAttributeTypes
     * const dgmAttributeTypes = await prisma.dgmAttributeTypes.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends dgmAttributeTypesUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, dgmAttributeTypesUpdateArgs<ExtArgs>>
    ): Prisma__dgmAttributeTypesClient<$Result.GetResult<Prisma.$dgmAttributeTypesPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more DgmAttributeTypes.
     * @param {dgmAttributeTypesDeleteManyArgs} args - Arguments to filter DgmAttributeTypes to delete.
     * @example
     * // Delete a few DgmAttributeTypes
     * const { count } = await prisma.dgmAttributeTypes.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends dgmAttributeTypesDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, dgmAttributeTypesDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DgmAttributeTypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {dgmAttributeTypesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DgmAttributeTypes
     * const dgmAttributeTypes = await prisma.dgmAttributeTypes.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends dgmAttributeTypesUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, dgmAttributeTypesUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one DgmAttributeTypes.
     * @param {dgmAttributeTypesUpsertArgs} args - Arguments to update or create a DgmAttributeTypes.
     * @example
     * // Update or create a DgmAttributeTypes
     * const dgmAttributeTypes = await prisma.dgmAttributeTypes.upsert({
     *   create: {
     *     // ... data to create a DgmAttributeTypes
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DgmAttributeTypes we want to update
     *   }
     * })
    **/
    upsert<T extends dgmAttributeTypesUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, dgmAttributeTypesUpsertArgs<ExtArgs>>
    ): Prisma__dgmAttributeTypesClient<$Result.GetResult<Prisma.$dgmAttributeTypesPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of DgmAttributeTypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {dgmAttributeTypesCountArgs} args - Arguments to filter DgmAttributeTypes to count.
     * @example
     * // Count the number of DgmAttributeTypes
     * const count = await prisma.dgmAttributeTypes.count({
     *   where: {
     *     // ... the filter for the DgmAttributeTypes we want to count
     *   }
     * })
    **/
    count<T extends dgmAttributeTypesCountArgs>(
      args?: Subset<T, dgmAttributeTypesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DgmAttributeTypesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DgmAttributeTypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DgmAttributeTypesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DgmAttributeTypesAggregateArgs>(args: Subset<T, DgmAttributeTypesAggregateArgs>): Prisma.PrismaPromise<GetDgmAttributeTypesAggregateType<T>>

    /**
     * Group by DgmAttributeTypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {dgmAttributeTypesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends dgmAttributeTypesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: dgmAttributeTypesGroupByArgs['orderBy'] }
        : { orderBy?: dgmAttributeTypesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, dgmAttributeTypesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDgmAttributeTypesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the dgmAttributeTypes model
   */
  readonly fields: dgmAttributeTypesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for dgmAttributeTypes.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__dgmAttributeTypesClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';


    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the dgmAttributeTypes model
   */ 
  interface dgmAttributeTypesFieldRefs {
    readonly attributeID: FieldRef<"dgmAttributeTypes", 'Int'>
    readonly attributeName: FieldRef<"dgmAttributeTypes", 'String'>
    readonly description: FieldRef<"dgmAttributeTypes", 'String'>
    readonly iconID: FieldRef<"dgmAttributeTypes", 'Int'>
    readonly defaultValue: FieldRef<"dgmAttributeTypes", 'Float'>
    readonly published: FieldRef<"dgmAttributeTypes", 'Boolean'>
    readonly displayName: FieldRef<"dgmAttributeTypes", 'String'>
    readonly unitID: FieldRef<"dgmAttributeTypes", 'Int'>
    readonly stackable: FieldRef<"dgmAttributeTypes", 'Boolean'>
    readonly highIsGood: FieldRef<"dgmAttributeTypes", 'Boolean'>
    readonly categoryID: FieldRef<"dgmAttributeTypes", 'Int'>
  }
    

  // Custom InputTypes

  /**
   * dgmAttributeTypes findUnique
   */
  export type dgmAttributeTypesFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the dgmAttributeTypes
     */
    select?: dgmAttributeTypesSelect<ExtArgs> | null
    /**
     * Filter, which dgmAttributeTypes to fetch.
     */
    where: dgmAttributeTypesWhereUniqueInput
  }


  /**
   * dgmAttributeTypes findUniqueOrThrow
   */
  export type dgmAttributeTypesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the dgmAttributeTypes
     */
    select?: dgmAttributeTypesSelect<ExtArgs> | null
    /**
     * Filter, which dgmAttributeTypes to fetch.
     */
    where: dgmAttributeTypesWhereUniqueInput
  }


  /**
   * dgmAttributeTypes findFirst
   */
  export type dgmAttributeTypesFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the dgmAttributeTypes
     */
    select?: dgmAttributeTypesSelect<ExtArgs> | null
    /**
     * Filter, which dgmAttributeTypes to fetch.
     */
    where?: dgmAttributeTypesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of dgmAttributeTypes to fetch.
     */
    orderBy?: dgmAttributeTypesOrderByWithRelationInput | dgmAttributeTypesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for dgmAttributeTypes.
     */
    cursor?: dgmAttributeTypesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` dgmAttributeTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` dgmAttributeTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of dgmAttributeTypes.
     */
    distinct?: DgmAttributeTypesScalarFieldEnum | DgmAttributeTypesScalarFieldEnum[]
  }


  /**
   * dgmAttributeTypes findFirstOrThrow
   */
  export type dgmAttributeTypesFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the dgmAttributeTypes
     */
    select?: dgmAttributeTypesSelect<ExtArgs> | null
    /**
     * Filter, which dgmAttributeTypes to fetch.
     */
    where?: dgmAttributeTypesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of dgmAttributeTypes to fetch.
     */
    orderBy?: dgmAttributeTypesOrderByWithRelationInput | dgmAttributeTypesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for dgmAttributeTypes.
     */
    cursor?: dgmAttributeTypesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` dgmAttributeTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` dgmAttributeTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of dgmAttributeTypes.
     */
    distinct?: DgmAttributeTypesScalarFieldEnum | DgmAttributeTypesScalarFieldEnum[]
  }


  /**
   * dgmAttributeTypes findMany
   */
  export type dgmAttributeTypesFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the dgmAttributeTypes
     */
    select?: dgmAttributeTypesSelect<ExtArgs> | null
    /**
     * Filter, which dgmAttributeTypes to fetch.
     */
    where?: dgmAttributeTypesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of dgmAttributeTypes to fetch.
     */
    orderBy?: dgmAttributeTypesOrderByWithRelationInput | dgmAttributeTypesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing dgmAttributeTypes.
     */
    cursor?: dgmAttributeTypesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` dgmAttributeTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` dgmAttributeTypes.
     */
    skip?: number
    distinct?: DgmAttributeTypesScalarFieldEnum | DgmAttributeTypesScalarFieldEnum[]
  }


  /**
   * dgmAttributeTypes create
   */
  export type dgmAttributeTypesCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the dgmAttributeTypes
     */
    select?: dgmAttributeTypesSelect<ExtArgs> | null
    /**
     * The data needed to create a dgmAttributeTypes.
     */
    data: XOR<dgmAttributeTypesCreateInput, dgmAttributeTypesUncheckedCreateInput>
  }


  /**
   * dgmAttributeTypes createMany
   */
  export type dgmAttributeTypesCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many dgmAttributeTypes.
     */
    data: dgmAttributeTypesCreateManyInput | dgmAttributeTypesCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * dgmAttributeTypes update
   */
  export type dgmAttributeTypesUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the dgmAttributeTypes
     */
    select?: dgmAttributeTypesSelect<ExtArgs> | null
    /**
     * The data needed to update a dgmAttributeTypes.
     */
    data: XOR<dgmAttributeTypesUpdateInput, dgmAttributeTypesUncheckedUpdateInput>
    /**
     * Choose, which dgmAttributeTypes to update.
     */
    where: dgmAttributeTypesWhereUniqueInput
  }


  /**
   * dgmAttributeTypes updateMany
   */
  export type dgmAttributeTypesUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update dgmAttributeTypes.
     */
    data: XOR<dgmAttributeTypesUpdateManyMutationInput, dgmAttributeTypesUncheckedUpdateManyInput>
    /**
     * Filter which dgmAttributeTypes to update
     */
    where?: dgmAttributeTypesWhereInput
  }


  /**
   * dgmAttributeTypes upsert
   */
  export type dgmAttributeTypesUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the dgmAttributeTypes
     */
    select?: dgmAttributeTypesSelect<ExtArgs> | null
    /**
     * The filter to search for the dgmAttributeTypes to update in case it exists.
     */
    where: dgmAttributeTypesWhereUniqueInput
    /**
     * In case the dgmAttributeTypes found by the `where` argument doesn't exist, create a new dgmAttributeTypes with this data.
     */
    create: XOR<dgmAttributeTypesCreateInput, dgmAttributeTypesUncheckedCreateInput>
    /**
     * In case the dgmAttributeTypes was found with the provided `where` argument, update it with this data.
     */
    update: XOR<dgmAttributeTypesUpdateInput, dgmAttributeTypesUncheckedUpdateInput>
  }


  /**
   * dgmAttributeTypes delete
   */
  export type dgmAttributeTypesDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the dgmAttributeTypes
     */
    select?: dgmAttributeTypesSelect<ExtArgs> | null
    /**
     * Filter which dgmAttributeTypes to delete.
     */
    where: dgmAttributeTypesWhereUniqueInput
  }


  /**
   * dgmAttributeTypes deleteMany
   */
  export type dgmAttributeTypesDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which dgmAttributeTypes to delete
     */
    where?: dgmAttributeTypesWhereInput
  }


  /**
   * dgmAttributeTypes without action
   */
  export type dgmAttributeTypesDefaultArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the dgmAttributeTypes
     */
    select?: dgmAttributeTypesSelect<ExtArgs> | null
  }



  /**
   * Model dgmEffects
   */

  export type AggregateDgmEffects = {
    _count: DgmEffectsCountAggregateOutputType | null
    _avg: DgmEffectsAvgAggregateOutputType | null
    _sum: DgmEffectsSumAggregateOutputType | null
    _min: DgmEffectsMinAggregateOutputType | null
    _max: DgmEffectsMaxAggregateOutputType | null
  }

  export type DgmEffectsAvgAggregateOutputType = {
    effectID: number | null
    effectCategory: number | null
    preExpression: number | null
    postExpression: number | null
    iconID: number | null
    durationAttributeID: number | null
    trackingSpeedAttributeID: number | null
    dischargeAttributeID: number | null
    rangeAttributeID: number | null
    falloffAttributeID: number | null
    distribution: number | null
    npcUsageChanceAttributeID: number | null
    npcActivationChanceAttributeID: number | null
    fittingUsageChanceAttributeID: number | null
  }

  export type DgmEffectsSumAggregateOutputType = {
    effectID: number | null
    effectCategory: number | null
    preExpression: number | null
    postExpression: number | null
    iconID: number | null
    durationAttributeID: number | null
    trackingSpeedAttributeID: number | null
    dischargeAttributeID: number | null
    rangeAttributeID: number | null
    falloffAttributeID: number | null
    distribution: number | null
    npcUsageChanceAttributeID: number | null
    npcActivationChanceAttributeID: number | null
    fittingUsageChanceAttributeID: number | null
  }

  export type DgmEffectsMinAggregateOutputType = {
    effectID: number | null
    effectName: string | null
    effectCategory: number | null
    preExpression: number | null
    postExpression: number | null
    description: string | null
    guid: string | null
    iconID: number | null
    isOffensive: boolean | null
    isAssistance: boolean | null
    durationAttributeID: number | null
    trackingSpeedAttributeID: number | null
    dischargeAttributeID: number | null
    rangeAttributeID: number | null
    falloffAttributeID: number | null
    disallowAutoRepeat: boolean | null
    published: boolean | null
    displayName: string | null
    isWarpSafe: boolean | null
    rangeChance: boolean | null
    electronicChance: boolean | null
    propulsionChance: boolean | null
    distribution: number | null
    sfxName: string | null
    npcUsageChanceAttributeID: number | null
    npcActivationChanceAttributeID: number | null
    fittingUsageChanceAttributeID: number | null
    modifierInfo: string | null
  }

  export type DgmEffectsMaxAggregateOutputType = {
    effectID: number | null
    effectName: string | null
    effectCategory: number | null
    preExpression: number | null
    postExpression: number | null
    description: string | null
    guid: string | null
    iconID: number | null
    isOffensive: boolean | null
    isAssistance: boolean | null
    durationAttributeID: number | null
    trackingSpeedAttributeID: number | null
    dischargeAttributeID: number | null
    rangeAttributeID: number | null
    falloffAttributeID: number | null
    disallowAutoRepeat: boolean | null
    published: boolean | null
    displayName: string | null
    isWarpSafe: boolean | null
    rangeChance: boolean | null
    electronicChance: boolean | null
    propulsionChance: boolean | null
    distribution: number | null
    sfxName: string | null
    npcUsageChanceAttributeID: number | null
    npcActivationChanceAttributeID: number | null
    fittingUsageChanceAttributeID: number | null
    modifierInfo: string | null
  }

  export type DgmEffectsCountAggregateOutputType = {
    effectID: number
    effectName: number
    effectCategory: number
    preExpression: number
    postExpression: number
    description: number
    guid: number
    iconID: number
    isOffensive: number
    isAssistance: number
    durationAttributeID: number
    trackingSpeedAttributeID: number
    dischargeAttributeID: number
    rangeAttributeID: number
    falloffAttributeID: number
    disallowAutoRepeat: number
    published: number
    displayName: number
    isWarpSafe: number
    rangeChance: number
    electronicChance: number
    propulsionChance: number
    distribution: number
    sfxName: number
    npcUsageChanceAttributeID: number
    npcActivationChanceAttributeID: number
    fittingUsageChanceAttributeID: number
    modifierInfo: number
    _all: number
  }


  export type DgmEffectsAvgAggregateInputType = {
    effectID?: true
    effectCategory?: true
    preExpression?: true
    postExpression?: true
    iconID?: true
    durationAttributeID?: true
    trackingSpeedAttributeID?: true
    dischargeAttributeID?: true
    rangeAttributeID?: true
    falloffAttributeID?: true
    distribution?: true
    npcUsageChanceAttributeID?: true
    npcActivationChanceAttributeID?: true
    fittingUsageChanceAttributeID?: true
  }

  export type DgmEffectsSumAggregateInputType = {
    effectID?: true
    effectCategory?: true
    preExpression?: true
    postExpression?: true
    iconID?: true
    durationAttributeID?: true
    trackingSpeedAttributeID?: true
    dischargeAttributeID?: true
    rangeAttributeID?: true
    falloffAttributeID?: true
    distribution?: true
    npcUsageChanceAttributeID?: true
    npcActivationChanceAttributeID?: true
    fittingUsageChanceAttributeID?: true
  }

  export type DgmEffectsMinAggregateInputType = {
    effectID?: true
    effectName?: true
    effectCategory?: true
    preExpression?: true
    postExpression?: true
    description?: true
    guid?: true
    iconID?: true
    isOffensive?: true
    isAssistance?: true
    durationAttributeID?: true
    trackingSpeedAttributeID?: true
    dischargeAttributeID?: true
    rangeAttributeID?: true
    falloffAttributeID?: true
    disallowAutoRepeat?: true
    published?: true
    displayName?: true
    isWarpSafe?: true
    rangeChance?: true
    electronicChance?: true
    propulsionChance?: true
    distribution?: true
    sfxName?: true
    npcUsageChanceAttributeID?: true
    npcActivationChanceAttributeID?: true
    fittingUsageChanceAttributeID?: true
    modifierInfo?: true
  }

  export type DgmEffectsMaxAggregateInputType = {
    effectID?: true
    effectName?: true
    effectCategory?: true
    preExpression?: true
    postExpression?: true
    description?: true
    guid?: true
    iconID?: true
    isOffensive?: true
    isAssistance?: true
    durationAttributeID?: true
    trackingSpeedAttributeID?: true
    dischargeAttributeID?: true
    rangeAttributeID?: true
    falloffAttributeID?: true
    disallowAutoRepeat?: true
    published?: true
    displayName?: true
    isWarpSafe?: true
    rangeChance?: true
    electronicChance?: true
    propulsionChance?: true
    distribution?: true
    sfxName?: true
    npcUsageChanceAttributeID?: true
    npcActivationChanceAttributeID?: true
    fittingUsageChanceAttributeID?: true
    modifierInfo?: true
  }

  export type DgmEffectsCountAggregateInputType = {
    effectID?: true
    effectName?: true
    effectCategory?: true
    preExpression?: true
    postExpression?: true
    description?: true
    guid?: true
    iconID?: true
    isOffensive?: true
    isAssistance?: true
    durationAttributeID?: true
    trackingSpeedAttributeID?: true
    dischargeAttributeID?: true
    rangeAttributeID?: true
    falloffAttributeID?: true
    disallowAutoRepeat?: true
    published?: true
    displayName?: true
    isWarpSafe?: true
    rangeChance?: true
    electronicChance?: true
    propulsionChance?: true
    distribution?: true
    sfxName?: true
    npcUsageChanceAttributeID?: true
    npcActivationChanceAttributeID?: true
    fittingUsageChanceAttributeID?: true
    modifierInfo?: true
    _all?: true
  }

  export type DgmEffectsAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which dgmEffects to aggregate.
     */
    where?: dgmEffectsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of dgmEffects to fetch.
     */
    orderBy?: dgmEffectsOrderByWithRelationInput | dgmEffectsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: dgmEffectsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` dgmEffects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` dgmEffects.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned dgmEffects
    **/
    _count?: true | DgmEffectsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DgmEffectsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DgmEffectsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DgmEffectsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DgmEffectsMaxAggregateInputType
  }

  export type GetDgmEffectsAggregateType<T extends DgmEffectsAggregateArgs> = {
        [P in keyof T & keyof AggregateDgmEffects]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDgmEffects[P]>
      : GetScalarType<T[P], AggregateDgmEffects[P]>
  }




  export type dgmEffectsGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: dgmEffectsWhereInput
    orderBy?: dgmEffectsOrderByWithAggregationInput | dgmEffectsOrderByWithAggregationInput[]
    by: DgmEffectsScalarFieldEnum[] | DgmEffectsScalarFieldEnum
    having?: dgmEffectsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DgmEffectsCountAggregateInputType | true
    _avg?: DgmEffectsAvgAggregateInputType
    _sum?: DgmEffectsSumAggregateInputType
    _min?: DgmEffectsMinAggregateInputType
    _max?: DgmEffectsMaxAggregateInputType
  }

  export type DgmEffectsGroupByOutputType = {
    effectID: number
    effectName: string | null
    effectCategory: number | null
    preExpression: number | null
    postExpression: number | null
    description: string | null
    guid: string | null
    iconID: number | null
    isOffensive: boolean | null
    isAssistance: boolean | null
    durationAttributeID: number | null
    trackingSpeedAttributeID: number | null
    dischargeAttributeID: number | null
    rangeAttributeID: number | null
    falloffAttributeID: number | null
    disallowAutoRepeat: boolean | null
    published: boolean | null
    displayName: string | null
    isWarpSafe: boolean | null
    rangeChance: boolean | null
    electronicChance: boolean | null
    propulsionChance: boolean | null
    distribution: number | null
    sfxName: string | null
    npcUsageChanceAttributeID: number | null
    npcActivationChanceAttributeID: number | null
    fittingUsageChanceAttributeID: number | null
    modifierInfo: string | null
    _count: DgmEffectsCountAggregateOutputType | null
    _avg: DgmEffectsAvgAggregateOutputType | null
    _sum: DgmEffectsSumAggregateOutputType | null
    _min: DgmEffectsMinAggregateOutputType | null
    _max: DgmEffectsMaxAggregateOutputType | null
  }

  type GetDgmEffectsGroupByPayload<T extends dgmEffectsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DgmEffectsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DgmEffectsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DgmEffectsGroupByOutputType[P]>
            : GetScalarType<T[P], DgmEffectsGroupByOutputType[P]>
        }
      >
    >


  export type dgmEffectsSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    effectID?: boolean
    effectName?: boolean
    effectCategory?: boolean
    preExpression?: boolean
    postExpression?: boolean
    description?: boolean
    guid?: boolean
    iconID?: boolean
    isOffensive?: boolean
    isAssistance?: boolean
    durationAttributeID?: boolean
    trackingSpeedAttributeID?: boolean
    dischargeAttributeID?: boolean
    rangeAttributeID?: boolean
    falloffAttributeID?: boolean
    disallowAutoRepeat?: boolean
    published?: boolean
    displayName?: boolean
    isWarpSafe?: boolean
    rangeChance?: boolean
    electronicChance?: boolean
    propulsionChance?: boolean
    distribution?: boolean
    sfxName?: boolean
    npcUsageChanceAttributeID?: boolean
    npcActivationChanceAttributeID?: boolean
    fittingUsageChanceAttributeID?: boolean
    modifierInfo?: boolean
  }, ExtArgs["result"]["dgmEffects"]>

  export type dgmEffectsSelectScalar = {
    effectID?: boolean
    effectName?: boolean
    effectCategory?: boolean
    preExpression?: boolean
    postExpression?: boolean
    description?: boolean
    guid?: boolean
    iconID?: boolean
    isOffensive?: boolean
    isAssistance?: boolean
    durationAttributeID?: boolean
    trackingSpeedAttributeID?: boolean
    dischargeAttributeID?: boolean
    rangeAttributeID?: boolean
    falloffAttributeID?: boolean
    disallowAutoRepeat?: boolean
    published?: boolean
    displayName?: boolean
    isWarpSafe?: boolean
    rangeChance?: boolean
    electronicChance?: boolean
    propulsionChance?: boolean
    distribution?: boolean
    sfxName?: boolean
    npcUsageChanceAttributeID?: boolean
    npcActivationChanceAttributeID?: boolean
    fittingUsageChanceAttributeID?: boolean
    modifierInfo?: boolean
  }


  export type $dgmEffectsPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    name: "dgmEffects"
    objects: {}
    scalars: $Extensions.GetResult<{
      effectID: number
      effectName: string | null
      effectCategory: number | null
      preExpression: number | null
      postExpression: number | null
      description: string | null
      guid: string | null
      iconID: number | null
      isOffensive: boolean | null
      isAssistance: boolean | null
      durationAttributeID: number | null
      trackingSpeedAttributeID: number | null
      dischargeAttributeID: number | null
      rangeAttributeID: number | null
      falloffAttributeID: number | null
      disallowAutoRepeat: boolean | null
      published: boolean | null
      displayName: string | null
      isWarpSafe: boolean | null
      rangeChance: boolean | null
      electronicChance: boolean | null
      propulsionChance: boolean | null
      distribution: number | null
      sfxName: string | null
      npcUsageChanceAttributeID: number | null
      npcActivationChanceAttributeID: number | null
      fittingUsageChanceAttributeID: number | null
      modifierInfo: string | null
    }, ExtArgs["result"]["dgmEffects"]>
    composites: {}
  }


  type dgmEffectsGetPayload<S extends boolean | null | undefined | dgmEffectsDefaultArgs> = $Result.GetResult<Prisma.$dgmEffectsPayload, S>

  type dgmEffectsCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<dgmEffectsFindManyArgs, 'select' | 'include'> & {
      select?: DgmEffectsCountAggregateInputType | true
    }

  export interface dgmEffectsDelegate<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['dgmEffects'], meta: { name: 'dgmEffects' } }
    /**
     * Find zero or one DgmEffects that matches the filter.
     * @param {dgmEffectsFindUniqueArgs} args - Arguments to find a DgmEffects
     * @example
     * // Get one DgmEffects
     * const dgmEffects = await prisma.dgmEffects.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends dgmEffectsFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, dgmEffectsFindUniqueArgs<ExtArgs>>
    ): Prisma__dgmEffectsClient<$Result.GetResult<Prisma.$dgmEffectsPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one DgmEffects that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {dgmEffectsFindUniqueOrThrowArgs} args - Arguments to find a DgmEffects
     * @example
     * // Get one DgmEffects
     * const dgmEffects = await prisma.dgmEffects.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends dgmEffectsFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, dgmEffectsFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__dgmEffectsClient<$Result.GetResult<Prisma.$dgmEffectsPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first DgmEffects that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {dgmEffectsFindFirstArgs} args - Arguments to find a DgmEffects
     * @example
     * // Get one DgmEffects
     * const dgmEffects = await prisma.dgmEffects.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends dgmEffectsFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, dgmEffectsFindFirstArgs<ExtArgs>>
    ): Prisma__dgmEffectsClient<$Result.GetResult<Prisma.$dgmEffectsPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first DgmEffects that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {dgmEffectsFindFirstOrThrowArgs} args - Arguments to find a DgmEffects
     * @example
     * // Get one DgmEffects
     * const dgmEffects = await prisma.dgmEffects.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends dgmEffectsFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, dgmEffectsFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__dgmEffectsClient<$Result.GetResult<Prisma.$dgmEffectsPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more DgmEffects that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {dgmEffectsFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DgmEffects
     * const dgmEffects = await prisma.dgmEffects.findMany()
     * 
     * // Get first 10 DgmEffects
     * const dgmEffects = await prisma.dgmEffects.findMany({ take: 10 })
     * 
     * // Only select the `effectID`
     * const dgmEffectsWithEffectIDOnly = await prisma.dgmEffects.findMany({ select: { effectID: true } })
     * 
    **/
    findMany<T extends dgmEffectsFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, dgmEffectsFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$dgmEffectsPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a DgmEffects.
     * @param {dgmEffectsCreateArgs} args - Arguments to create a DgmEffects.
     * @example
     * // Create one DgmEffects
     * const DgmEffects = await prisma.dgmEffects.create({
     *   data: {
     *     // ... data to create a DgmEffects
     *   }
     * })
     * 
    **/
    create<T extends dgmEffectsCreateArgs<ExtArgs>>(
      args: SelectSubset<T, dgmEffectsCreateArgs<ExtArgs>>
    ): Prisma__dgmEffectsClient<$Result.GetResult<Prisma.$dgmEffectsPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many DgmEffects.
     *     @param {dgmEffectsCreateManyArgs} args - Arguments to create many DgmEffects.
     *     @example
     *     // Create many DgmEffects
     *     const dgmEffects = await prisma.dgmEffects.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends dgmEffectsCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, dgmEffectsCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a DgmEffects.
     * @param {dgmEffectsDeleteArgs} args - Arguments to delete one DgmEffects.
     * @example
     * // Delete one DgmEffects
     * const DgmEffects = await prisma.dgmEffects.delete({
     *   where: {
     *     // ... filter to delete one DgmEffects
     *   }
     * })
     * 
    **/
    delete<T extends dgmEffectsDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, dgmEffectsDeleteArgs<ExtArgs>>
    ): Prisma__dgmEffectsClient<$Result.GetResult<Prisma.$dgmEffectsPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one DgmEffects.
     * @param {dgmEffectsUpdateArgs} args - Arguments to update one DgmEffects.
     * @example
     * // Update one DgmEffects
     * const dgmEffects = await prisma.dgmEffects.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends dgmEffectsUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, dgmEffectsUpdateArgs<ExtArgs>>
    ): Prisma__dgmEffectsClient<$Result.GetResult<Prisma.$dgmEffectsPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more DgmEffects.
     * @param {dgmEffectsDeleteManyArgs} args - Arguments to filter DgmEffects to delete.
     * @example
     * // Delete a few DgmEffects
     * const { count } = await prisma.dgmEffects.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends dgmEffectsDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, dgmEffectsDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DgmEffects.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {dgmEffectsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DgmEffects
     * const dgmEffects = await prisma.dgmEffects.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends dgmEffectsUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, dgmEffectsUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one DgmEffects.
     * @param {dgmEffectsUpsertArgs} args - Arguments to update or create a DgmEffects.
     * @example
     * // Update or create a DgmEffects
     * const dgmEffects = await prisma.dgmEffects.upsert({
     *   create: {
     *     // ... data to create a DgmEffects
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DgmEffects we want to update
     *   }
     * })
    **/
    upsert<T extends dgmEffectsUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, dgmEffectsUpsertArgs<ExtArgs>>
    ): Prisma__dgmEffectsClient<$Result.GetResult<Prisma.$dgmEffectsPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of DgmEffects.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {dgmEffectsCountArgs} args - Arguments to filter DgmEffects to count.
     * @example
     * // Count the number of DgmEffects
     * const count = await prisma.dgmEffects.count({
     *   where: {
     *     // ... the filter for the DgmEffects we want to count
     *   }
     * })
    **/
    count<T extends dgmEffectsCountArgs>(
      args?: Subset<T, dgmEffectsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DgmEffectsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DgmEffects.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DgmEffectsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DgmEffectsAggregateArgs>(args: Subset<T, DgmEffectsAggregateArgs>): Prisma.PrismaPromise<GetDgmEffectsAggregateType<T>>

    /**
     * Group by DgmEffects.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {dgmEffectsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends dgmEffectsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: dgmEffectsGroupByArgs['orderBy'] }
        : { orderBy?: dgmEffectsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, dgmEffectsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDgmEffectsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the dgmEffects model
   */
  readonly fields: dgmEffectsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for dgmEffects.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__dgmEffectsClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';


    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the dgmEffects model
   */ 
  interface dgmEffectsFieldRefs {
    readonly effectID: FieldRef<"dgmEffects", 'Int'>
    readonly effectName: FieldRef<"dgmEffects", 'String'>
    readonly effectCategory: FieldRef<"dgmEffects", 'Int'>
    readonly preExpression: FieldRef<"dgmEffects", 'Int'>
    readonly postExpression: FieldRef<"dgmEffects", 'Int'>
    readonly description: FieldRef<"dgmEffects", 'String'>
    readonly guid: FieldRef<"dgmEffects", 'String'>
    readonly iconID: FieldRef<"dgmEffects", 'Int'>
    readonly isOffensive: FieldRef<"dgmEffects", 'Boolean'>
    readonly isAssistance: FieldRef<"dgmEffects", 'Boolean'>
    readonly durationAttributeID: FieldRef<"dgmEffects", 'Int'>
    readonly trackingSpeedAttributeID: FieldRef<"dgmEffects", 'Int'>
    readonly dischargeAttributeID: FieldRef<"dgmEffects", 'Int'>
    readonly rangeAttributeID: FieldRef<"dgmEffects", 'Int'>
    readonly falloffAttributeID: FieldRef<"dgmEffects", 'Int'>
    readonly disallowAutoRepeat: FieldRef<"dgmEffects", 'Boolean'>
    readonly published: FieldRef<"dgmEffects", 'Boolean'>
    readonly displayName: FieldRef<"dgmEffects", 'String'>
    readonly isWarpSafe: FieldRef<"dgmEffects", 'Boolean'>
    readonly rangeChance: FieldRef<"dgmEffects", 'Boolean'>
    readonly electronicChance: FieldRef<"dgmEffects", 'Boolean'>
    readonly propulsionChance: FieldRef<"dgmEffects", 'Boolean'>
    readonly distribution: FieldRef<"dgmEffects", 'Int'>
    readonly sfxName: FieldRef<"dgmEffects", 'String'>
    readonly npcUsageChanceAttributeID: FieldRef<"dgmEffects", 'Int'>
    readonly npcActivationChanceAttributeID: FieldRef<"dgmEffects", 'Int'>
    readonly fittingUsageChanceAttributeID: FieldRef<"dgmEffects", 'Int'>
    readonly modifierInfo: FieldRef<"dgmEffects", 'String'>
  }
    

  // Custom InputTypes

  /**
   * dgmEffects findUnique
   */
  export type dgmEffectsFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the dgmEffects
     */
    select?: dgmEffectsSelect<ExtArgs> | null
    /**
     * Filter, which dgmEffects to fetch.
     */
    where: dgmEffectsWhereUniqueInput
  }


  /**
   * dgmEffects findUniqueOrThrow
   */
  export type dgmEffectsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the dgmEffects
     */
    select?: dgmEffectsSelect<ExtArgs> | null
    /**
     * Filter, which dgmEffects to fetch.
     */
    where: dgmEffectsWhereUniqueInput
  }


  /**
   * dgmEffects findFirst
   */
  export type dgmEffectsFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the dgmEffects
     */
    select?: dgmEffectsSelect<ExtArgs> | null
    /**
     * Filter, which dgmEffects to fetch.
     */
    where?: dgmEffectsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of dgmEffects to fetch.
     */
    orderBy?: dgmEffectsOrderByWithRelationInput | dgmEffectsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for dgmEffects.
     */
    cursor?: dgmEffectsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` dgmEffects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` dgmEffects.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of dgmEffects.
     */
    distinct?: DgmEffectsScalarFieldEnum | DgmEffectsScalarFieldEnum[]
  }


  /**
   * dgmEffects findFirstOrThrow
   */
  export type dgmEffectsFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the dgmEffects
     */
    select?: dgmEffectsSelect<ExtArgs> | null
    /**
     * Filter, which dgmEffects to fetch.
     */
    where?: dgmEffectsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of dgmEffects to fetch.
     */
    orderBy?: dgmEffectsOrderByWithRelationInput | dgmEffectsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for dgmEffects.
     */
    cursor?: dgmEffectsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` dgmEffects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` dgmEffects.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of dgmEffects.
     */
    distinct?: DgmEffectsScalarFieldEnum | DgmEffectsScalarFieldEnum[]
  }


  /**
   * dgmEffects findMany
   */
  export type dgmEffectsFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the dgmEffects
     */
    select?: dgmEffectsSelect<ExtArgs> | null
    /**
     * Filter, which dgmEffects to fetch.
     */
    where?: dgmEffectsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of dgmEffects to fetch.
     */
    orderBy?: dgmEffectsOrderByWithRelationInput | dgmEffectsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing dgmEffects.
     */
    cursor?: dgmEffectsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` dgmEffects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` dgmEffects.
     */
    skip?: number
    distinct?: DgmEffectsScalarFieldEnum | DgmEffectsScalarFieldEnum[]
  }


  /**
   * dgmEffects create
   */
  export type dgmEffectsCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the dgmEffects
     */
    select?: dgmEffectsSelect<ExtArgs> | null
    /**
     * The data needed to create a dgmEffects.
     */
    data: XOR<dgmEffectsCreateInput, dgmEffectsUncheckedCreateInput>
  }


  /**
   * dgmEffects createMany
   */
  export type dgmEffectsCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many dgmEffects.
     */
    data: dgmEffectsCreateManyInput | dgmEffectsCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * dgmEffects update
   */
  export type dgmEffectsUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the dgmEffects
     */
    select?: dgmEffectsSelect<ExtArgs> | null
    /**
     * The data needed to update a dgmEffects.
     */
    data: XOR<dgmEffectsUpdateInput, dgmEffectsUncheckedUpdateInput>
    /**
     * Choose, which dgmEffects to update.
     */
    where: dgmEffectsWhereUniqueInput
  }


  /**
   * dgmEffects updateMany
   */
  export type dgmEffectsUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update dgmEffects.
     */
    data: XOR<dgmEffectsUpdateManyMutationInput, dgmEffectsUncheckedUpdateManyInput>
    /**
     * Filter which dgmEffects to update
     */
    where?: dgmEffectsWhereInput
  }


  /**
   * dgmEffects upsert
   */
  export type dgmEffectsUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the dgmEffects
     */
    select?: dgmEffectsSelect<ExtArgs> | null
    /**
     * The filter to search for the dgmEffects to update in case it exists.
     */
    where: dgmEffectsWhereUniqueInput
    /**
     * In case the dgmEffects found by the `where` argument doesn't exist, create a new dgmEffects with this data.
     */
    create: XOR<dgmEffectsCreateInput, dgmEffectsUncheckedCreateInput>
    /**
     * In case the dgmEffects was found with the provided `where` argument, update it with this data.
     */
    update: XOR<dgmEffectsUpdateInput, dgmEffectsUncheckedUpdateInput>
  }


  /**
   * dgmEffects delete
   */
  export type dgmEffectsDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the dgmEffects
     */
    select?: dgmEffectsSelect<ExtArgs> | null
    /**
     * Filter which dgmEffects to delete.
     */
    where: dgmEffectsWhereUniqueInput
  }


  /**
   * dgmEffects deleteMany
   */
  export type dgmEffectsDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which dgmEffects to delete
     */
    where?: dgmEffectsWhereInput
  }


  /**
   * dgmEffects without action
   */
  export type dgmEffectsDefaultArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the dgmEffects
     */
    select?: dgmEffectsSelect<ExtArgs> | null
  }



  /**
   * Model dgmExpressions
   */

  export type AggregateDgmExpressions = {
    _count: DgmExpressionsCountAggregateOutputType | null
    _avg: DgmExpressionsAvgAggregateOutputType | null
    _sum: DgmExpressionsSumAggregateOutputType | null
    _min: DgmExpressionsMinAggregateOutputType | null
    _max: DgmExpressionsMaxAggregateOutputType | null
  }

  export type DgmExpressionsAvgAggregateOutputType = {
    expressionID: number | null
    operandID: number | null
    arg1: number | null
    arg2: number | null
    expressionTypeID: number | null
    expressionGroupID: number | null
    expressionAttributeID: number | null
  }

  export type DgmExpressionsSumAggregateOutputType = {
    expressionID: number | null
    operandID: number | null
    arg1: number | null
    arg2: number | null
    expressionTypeID: number | null
    expressionGroupID: number | null
    expressionAttributeID: number | null
  }

  export type DgmExpressionsMinAggregateOutputType = {
    expressionID: number | null
    operandID: number | null
    arg1: number | null
    arg2: number | null
    expressionValue: string | null
    description: string | null
    expressionName: string | null
    expressionTypeID: number | null
    expressionGroupID: number | null
    expressionAttributeID: number | null
  }

  export type DgmExpressionsMaxAggregateOutputType = {
    expressionID: number | null
    operandID: number | null
    arg1: number | null
    arg2: number | null
    expressionValue: string | null
    description: string | null
    expressionName: string | null
    expressionTypeID: number | null
    expressionGroupID: number | null
    expressionAttributeID: number | null
  }

  export type DgmExpressionsCountAggregateOutputType = {
    expressionID: number
    operandID: number
    arg1: number
    arg2: number
    expressionValue: number
    description: number
    expressionName: number
    expressionTypeID: number
    expressionGroupID: number
    expressionAttributeID: number
    _all: number
  }


  export type DgmExpressionsAvgAggregateInputType = {
    expressionID?: true
    operandID?: true
    arg1?: true
    arg2?: true
    expressionTypeID?: true
    expressionGroupID?: true
    expressionAttributeID?: true
  }

  export type DgmExpressionsSumAggregateInputType = {
    expressionID?: true
    operandID?: true
    arg1?: true
    arg2?: true
    expressionTypeID?: true
    expressionGroupID?: true
    expressionAttributeID?: true
  }

  export type DgmExpressionsMinAggregateInputType = {
    expressionID?: true
    operandID?: true
    arg1?: true
    arg2?: true
    expressionValue?: true
    description?: true
    expressionName?: true
    expressionTypeID?: true
    expressionGroupID?: true
    expressionAttributeID?: true
  }

  export type DgmExpressionsMaxAggregateInputType = {
    expressionID?: true
    operandID?: true
    arg1?: true
    arg2?: true
    expressionValue?: true
    description?: true
    expressionName?: true
    expressionTypeID?: true
    expressionGroupID?: true
    expressionAttributeID?: true
  }

  export type DgmExpressionsCountAggregateInputType = {
    expressionID?: true
    operandID?: true
    arg1?: true
    arg2?: true
    expressionValue?: true
    description?: true
    expressionName?: true
    expressionTypeID?: true
    expressionGroupID?: true
    expressionAttributeID?: true
    _all?: true
  }

  export type DgmExpressionsAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which dgmExpressions to aggregate.
     */
    where?: dgmExpressionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of dgmExpressions to fetch.
     */
    orderBy?: dgmExpressionsOrderByWithRelationInput | dgmExpressionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: dgmExpressionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` dgmExpressions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` dgmExpressions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned dgmExpressions
    **/
    _count?: true | DgmExpressionsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DgmExpressionsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DgmExpressionsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DgmExpressionsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DgmExpressionsMaxAggregateInputType
  }

  export type GetDgmExpressionsAggregateType<T extends DgmExpressionsAggregateArgs> = {
        [P in keyof T & keyof AggregateDgmExpressions]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDgmExpressions[P]>
      : GetScalarType<T[P], AggregateDgmExpressions[P]>
  }




  export type dgmExpressionsGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: dgmExpressionsWhereInput
    orderBy?: dgmExpressionsOrderByWithAggregationInput | dgmExpressionsOrderByWithAggregationInput[]
    by: DgmExpressionsScalarFieldEnum[] | DgmExpressionsScalarFieldEnum
    having?: dgmExpressionsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DgmExpressionsCountAggregateInputType | true
    _avg?: DgmExpressionsAvgAggregateInputType
    _sum?: DgmExpressionsSumAggregateInputType
    _min?: DgmExpressionsMinAggregateInputType
    _max?: DgmExpressionsMaxAggregateInputType
  }

  export type DgmExpressionsGroupByOutputType = {
    expressionID: number
    operandID: number | null
    arg1: number | null
    arg2: number | null
    expressionValue: string | null
    description: string | null
    expressionName: string | null
    expressionTypeID: number | null
    expressionGroupID: number | null
    expressionAttributeID: number | null
    _count: DgmExpressionsCountAggregateOutputType | null
    _avg: DgmExpressionsAvgAggregateOutputType | null
    _sum: DgmExpressionsSumAggregateOutputType | null
    _min: DgmExpressionsMinAggregateOutputType | null
    _max: DgmExpressionsMaxAggregateOutputType | null
  }

  type GetDgmExpressionsGroupByPayload<T extends dgmExpressionsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DgmExpressionsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DgmExpressionsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DgmExpressionsGroupByOutputType[P]>
            : GetScalarType<T[P], DgmExpressionsGroupByOutputType[P]>
        }
      >
    >


  export type dgmExpressionsSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    expressionID?: boolean
    operandID?: boolean
    arg1?: boolean
    arg2?: boolean
    expressionValue?: boolean
    description?: boolean
    expressionName?: boolean
    expressionTypeID?: boolean
    expressionGroupID?: boolean
    expressionAttributeID?: boolean
  }, ExtArgs["result"]["dgmExpressions"]>

  export type dgmExpressionsSelectScalar = {
    expressionID?: boolean
    operandID?: boolean
    arg1?: boolean
    arg2?: boolean
    expressionValue?: boolean
    description?: boolean
    expressionName?: boolean
    expressionTypeID?: boolean
    expressionGroupID?: boolean
    expressionAttributeID?: boolean
  }


  export type $dgmExpressionsPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    name: "dgmExpressions"
    objects: {}
    scalars: $Extensions.GetResult<{
      expressionID: number
      operandID: number | null
      arg1: number | null
      arg2: number | null
      expressionValue: string | null
      description: string | null
      expressionName: string | null
      expressionTypeID: number | null
      expressionGroupID: number | null
      expressionAttributeID: number | null
    }, ExtArgs["result"]["dgmExpressions"]>
    composites: {}
  }


  type dgmExpressionsGetPayload<S extends boolean | null | undefined | dgmExpressionsDefaultArgs> = $Result.GetResult<Prisma.$dgmExpressionsPayload, S>

  type dgmExpressionsCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<dgmExpressionsFindManyArgs, 'select' | 'include'> & {
      select?: DgmExpressionsCountAggregateInputType | true
    }

  export interface dgmExpressionsDelegate<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['dgmExpressions'], meta: { name: 'dgmExpressions' } }
    /**
     * Find zero or one DgmExpressions that matches the filter.
     * @param {dgmExpressionsFindUniqueArgs} args - Arguments to find a DgmExpressions
     * @example
     * // Get one DgmExpressions
     * const dgmExpressions = await prisma.dgmExpressions.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends dgmExpressionsFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, dgmExpressionsFindUniqueArgs<ExtArgs>>
    ): Prisma__dgmExpressionsClient<$Result.GetResult<Prisma.$dgmExpressionsPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one DgmExpressions that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {dgmExpressionsFindUniqueOrThrowArgs} args - Arguments to find a DgmExpressions
     * @example
     * // Get one DgmExpressions
     * const dgmExpressions = await prisma.dgmExpressions.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends dgmExpressionsFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, dgmExpressionsFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__dgmExpressionsClient<$Result.GetResult<Prisma.$dgmExpressionsPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first DgmExpressions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {dgmExpressionsFindFirstArgs} args - Arguments to find a DgmExpressions
     * @example
     * // Get one DgmExpressions
     * const dgmExpressions = await prisma.dgmExpressions.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends dgmExpressionsFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, dgmExpressionsFindFirstArgs<ExtArgs>>
    ): Prisma__dgmExpressionsClient<$Result.GetResult<Prisma.$dgmExpressionsPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first DgmExpressions that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {dgmExpressionsFindFirstOrThrowArgs} args - Arguments to find a DgmExpressions
     * @example
     * // Get one DgmExpressions
     * const dgmExpressions = await prisma.dgmExpressions.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends dgmExpressionsFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, dgmExpressionsFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__dgmExpressionsClient<$Result.GetResult<Prisma.$dgmExpressionsPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more DgmExpressions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {dgmExpressionsFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DgmExpressions
     * const dgmExpressions = await prisma.dgmExpressions.findMany()
     * 
     * // Get first 10 DgmExpressions
     * const dgmExpressions = await prisma.dgmExpressions.findMany({ take: 10 })
     * 
     * // Only select the `expressionID`
     * const dgmExpressionsWithExpressionIDOnly = await prisma.dgmExpressions.findMany({ select: { expressionID: true } })
     * 
    **/
    findMany<T extends dgmExpressionsFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, dgmExpressionsFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$dgmExpressionsPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a DgmExpressions.
     * @param {dgmExpressionsCreateArgs} args - Arguments to create a DgmExpressions.
     * @example
     * // Create one DgmExpressions
     * const DgmExpressions = await prisma.dgmExpressions.create({
     *   data: {
     *     // ... data to create a DgmExpressions
     *   }
     * })
     * 
    **/
    create<T extends dgmExpressionsCreateArgs<ExtArgs>>(
      args: SelectSubset<T, dgmExpressionsCreateArgs<ExtArgs>>
    ): Prisma__dgmExpressionsClient<$Result.GetResult<Prisma.$dgmExpressionsPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many DgmExpressions.
     *     @param {dgmExpressionsCreateManyArgs} args - Arguments to create many DgmExpressions.
     *     @example
     *     // Create many DgmExpressions
     *     const dgmExpressions = await prisma.dgmExpressions.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends dgmExpressionsCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, dgmExpressionsCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a DgmExpressions.
     * @param {dgmExpressionsDeleteArgs} args - Arguments to delete one DgmExpressions.
     * @example
     * // Delete one DgmExpressions
     * const DgmExpressions = await prisma.dgmExpressions.delete({
     *   where: {
     *     // ... filter to delete one DgmExpressions
     *   }
     * })
     * 
    **/
    delete<T extends dgmExpressionsDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, dgmExpressionsDeleteArgs<ExtArgs>>
    ): Prisma__dgmExpressionsClient<$Result.GetResult<Prisma.$dgmExpressionsPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one DgmExpressions.
     * @param {dgmExpressionsUpdateArgs} args - Arguments to update one DgmExpressions.
     * @example
     * // Update one DgmExpressions
     * const dgmExpressions = await prisma.dgmExpressions.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends dgmExpressionsUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, dgmExpressionsUpdateArgs<ExtArgs>>
    ): Prisma__dgmExpressionsClient<$Result.GetResult<Prisma.$dgmExpressionsPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more DgmExpressions.
     * @param {dgmExpressionsDeleteManyArgs} args - Arguments to filter DgmExpressions to delete.
     * @example
     * // Delete a few DgmExpressions
     * const { count } = await prisma.dgmExpressions.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends dgmExpressionsDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, dgmExpressionsDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DgmExpressions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {dgmExpressionsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DgmExpressions
     * const dgmExpressions = await prisma.dgmExpressions.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends dgmExpressionsUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, dgmExpressionsUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one DgmExpressions.
     * @param {dgmExpressionsUpsertArgs} args - Arguments to update or create a DgmExpressions.
     * @example
     * // Update or create a DgmExpressions
     * const dgmExpressions = await prisma.dgmExpressions.upsert({
     *   create: {
     *     // ... data to create a DgmExpressions
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DgmExpressions we want to update
     *   }
     * })
    **/
    upsert<T extends dgmExpressionsUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, dgmExpressionsUpsertArgs<ExtArgs>>
    ): Prisma__dgmExpressionsClient<$Result.GetResult<Prisma.$dgmExpressionsPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of DgmExpressions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {dgmExpressionsCountArgs} args - Arguments to filter DgmExpressions to count.
     * @example
     * // Count the number of DgmExpressions
     * const count = await prisma.dgmExpressions.count({
     *   where: {
     *     // ... the filter for the DgmExpressions we want to count
     *   }
     * })
    **/
    count<T extends dgmExpressionsCountArgs>(
      args?: Subset<T, dgmExpressionsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DgmExpressionsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DgmExpressions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DgmExpressionsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DgmExpressionsAggregateArgs>(args: Subset<T, DgmExpressionsAggregateArgs>): Prisma.PrismaPromise<GetDgmExpressionsAggregateType<T>>

    /**
     * Group by DgmExpressions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {dgmExpressionsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends dgmExpressionsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: dgmExpressionsGroupByArgs['orderBy'] }
        : { orderBy?: dgmExpressionsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, dgmExpressionsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDgmExpressionsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the dgmExpressions model
   */
  readonly fields: dgmExpressionsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for dgmExpressions.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__dgmExpressionsClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';


    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the dgmExpressions model
   */ 
  interface dgmExpressionsFieldRefs {
    readonly expressionID: FieldRef<"dgmExpressions", 'Int'>
    readonly operandID: FieldRef<"dgmExpressions", 'Int'>
    readonly arg1: FieldRef<"dgmExpressions", 'Int'>
    readonly arg2: FieldRef<"dgmExpressions", 'Int'>
    readonly expressionValue: FieldRef<"dgmExpressions", 'String'>
    readonly description: FieldRef<"dgmExpressions", 'String'>
    readonly expressionName: FieldRef<"dgmExpressions", 'String'>
    readonly expressionTypeID: FieldRef<"dgmExpressions", 'Int'>
    readonly expressionGroupID: FieldRef<"dgmExpressions", 'Int'>
    readonly expressionAttributeID: FieldRef<"dgmExpressions", 'Int'>
  }
    

  // Custom InputTypes

  /**
   * dgmExpressions findUnique
   */
  export type dgmExpressionsFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the dgmExpressions
     */
    select?: dgmExpressionsSelect<ExtArgs> | null
    /**
     * Filter, which dgmExpressions to fetch.
     */
    where: dgmExpressionsWhereUniqueInput
  }


  /**
   * dgmExpressions findUniqueOrThrow
   */
  export type dgmExpressionsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the dgmExpressions
     */
    select?: dgmExpressionsSelect<ExtArgs> | null
    /**
     * Filter, which dgmExpressions to fetch.
     */
    where: dgmExpressionsWhereUniqueInput
  }


  /**
   * dgmExpressions findFirst
   */
  export type dgmExpressionsFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the dgmExpressions
     */
    select?: dgmExpressionsSelect<ExtArgs> | null
    /**
     * Filter, which dgmExpressions to fetch.
     */
    where?: dgmExpressionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of dgmExpressions to fetch.
     */
    orderBy?: dgmExpressionsOrderByWithRelationInput | dgmExpressionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for dgmExpressions.
     */
    cursor?: dgmExpressionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` dgmExpressions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` dgmExpressions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of dgmExpressions.
     */
    distinct?: DgmExpressionsScalarFieldEnum | DgmExpressionsScalarFieldEnum[]
  }


  /**
   * dgmExpressions findFirstOrThrow
   */
  export type dgmExpressionsFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the dgmExpressions
     */
    select?: dgmExpressionsSelect<ExtArgs> | null
    /**
     * Filter, which dgmExpressions to fetch.
     */
    where?: dgmExpressionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of dgmExpressions to fetch.
     */
    orderBy?: dgmExpressionsOrderByWithRelationInput | dgmExpressionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for dgmExpressions.
     */
    cursor?: dgmExpressionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` dgmExpressions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` dgmExpressions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of dgmExpressions.
     */
    distinct?: DgmExpressionsScalarFieldEnum | DgmExpressionsScalarFieldEnum[]
  }


  /**
   * dgmExpressions findMany
   */
  export type dgmExpressionsFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the dgmExpressions
     */
    select?: dgmExpressionsSelect<ExtArgs> | null
    /**
     * Filter, which dgmExpressions to fetch.
     */
    where?: dgmExpressionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of dgmExpressions to fetch.
     */
    orderBy?: dgmExpressionsOrderByWithRelationInput | dgmExpressionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing dgmExpressions.
     */
    cursor?: dgmExpressionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` dgmExpressions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` dgmExpressions.
     */
    skip?: number
    distinct?: DgmExpressionsScalarFieldEnum | DgmExpressionsScalarFieldEnum[]
  }


  /**
   * dgmExpressions create
   */
  export type dgmExpressionsCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the dgmExpressions
     */
    select?: dgmExpressionsSelect<ExtArgs> | null
    /**
     * The data needed to create a dgmExpressions.
     */
    data: XOR<dgmExpressionsCreateInput, dgmExpressionsUncheckedCreateInput>
  }


  /**
   * dgmExpressions createMany
   */
  export type dgmExpressionsCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many dgmExpressions.
     */
    data: dgmExpressionsCreateManyInput | dgmExpressionsCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * dgmExpressions update
   */
  export type dgmExpressionsUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the dgmExpressions
     */
    select?: dgmExpressionsSelect<ExtArgs> | null
    /**
     * The data needed to update a dgmExpressions.
     */
    data: XOR<dgmExpressionsUpdateInput, dgmExpressionsUncheckedUpdateInput>
    /**
     * Choose, which dgmExpressions to update.
     */
    where: dgmExpressionsWhereUniqueInput
  }


  /**
   * dgmExpressions updateMany
   */
  export type dgmExpressionsUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update dgmExpressions.
     */
    data: XOR<dgmExpressionsUpdateManyMutationInput, dgmExpressionsUncheckedUpdateManyInput>
    /**
     * Filter which dgmExpressions to update
     */
    where?: dgmExpressionsWhereInput
  }


  /**
   * dgmExpressions upsert
   */
  export type dgmExpressionsUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the dgmExpressions
     */
    select?: dgmExpressionsSelect<ExtArgs> | null
    /**
     * The filter to search for the dgmExpressions to update in case it exists.
     */
    where: dgmExpressionsWhereUniqueInput
    /**
     * In case the dgmExpressions found by the `where` argument doesn't exist, create a new dgmExpressions with this data.
     */
    create: XOR<dgmExpressionsCreateInput, dgmExpressionsUncheckedCreateInput>
    /**
     * In case the dgmExpressions was found with the provided `where` argument, update it with this data.
     */
    update: XOR<dgmExpressionsUpdateInput, dgmExpressionsUncheckedUpdateInput>
  }


  /**
   * dgmExpressions delete
   */
  export type dgmExpressionsDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the dgmExpressions
     */
    select?: dgmExpressionsSelect<ExtArgs> | null
    /**
     * Filter which dgmExpressions to delete.
     */
    where: dgmExpressionsWhereUniqueInput
  }


  /**
   * dgmExpressions deleteMany
   */
  export type dgmExpressionsDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which dgmExpressions to delete
     */
    where?: dgmExpressionsWhereInput
  }


  /**
   * dgmExpressions without action
   */
  export type dgmExpressionsDefaultArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the dgmExpressions
     */
    select?: dgmExpressionsSelect<ExtArgs> | null
  }



  /**
   * Model dgmTypeAttributes
   */

  export type AggregateDgmTypeAttributes = {
    _count: DgmTypeAttributesCountAggregateOutputType | null
    _avg: DgmTypeAttributesAvgAggregateOutputType | null
    _sum: DgmTypeAttributesSumAggregateOutputType | null
    _min: DgmTypeAttributesMinAggregateOutputType | null
    _max: DgmTypeAttributesMaxAggregateOutputType | null
  }

  export type DgmTypeAttributesAvgAggregateOutputType = {
    typeID: number | null
    attributeID: number | null
    valueInt: number | null
    valueFloat: number | null
  }

  export type DgmTypeAttributesSumAggregateOutputType = {
    typeID: number | null
    attributeID: number | null
    valueInt: number | null
    valueFloat: number | null
  }

  export type DgmTypeAttributesMinAggregateOutputType = {
    typeID: number | null
    attributeID: number | null
    valueInt: number | null
    valueFloat: number | null
  }

  export type DgmTypeAttributesMaxAggregateOutputType = {
    typeID: number | null
    attributeID: number | null
    valueInt: number | null
    valueFloat: number | null
  }

  export type DgmTypeAttributesCountAggregateOutputType = {
    typeID: number
    attributeID: number
    valueInt: number
    valueFloat: number
    _all: number
  }


  export type DgmTypeAttributesAvgAggregateInputType = {
    typeID?: true
    attributeID?: true
    valueInt?: true
    valueFloat?: true
  }

  export type DgmTypeAttributesSumAggregateInputType = {
    typeID?: true
    attributeID?: true
    valueInt?: true
    valueFloat?: true
  }

  export type DgmTypeAttributesMinAggregateInputType = {
    typeID?: true
    attributeID?: true
    valueInt?: true
    valueFloat?: true
  }

  export type DgmTypeAttributesMaxAggregateInputType = {
    typeID?: true
    attributeID?: true
    valueInt?: true
    valueFloat?: true
  }

  export type DgmTypeAttributesCountAggregateInputType = {
    typeID?: true
    attributeID?: true
    valueInt?: true
    valueFloat?: true
    _all?: true
  }

  export type DgmTypeAttributesAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which dgmTypeAttributes to aggregate.
     */
    where?: dgmTypeAttributesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of dgmTypeAttributes to fetch.
     */
    orderBy?: dgmTypeAttributesOrderByWithRelationInput | dgmTypeAttributesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: dgmTypeAttributesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` dgmTypeAttributes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` dgmTypeAttributes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned dgmTypeAttributes
    **/
    _count?: true | DgmTypeAttributesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DgmTypeAttributesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DgmTypeAttributesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DgmTypeAttributesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DgmTypeAttributesMaxAggregateInputType
  }

  export type GetDgmTypeAttributesAggregateType<T extends DgmTypeAttributesAggregateArgs> = {
        [P in keyof T & keyof AggregateDgmTypeAttributes]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDgmTypeAttributes[P]>
      : GetScalarType<T[P], AggregateDgmTypeAttributes[P]>
  }




  export type dgmTypeAttributesGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: dgmTypeAttributesWhereInput
    orderBy?: dgmTypeAttributesOrderByWithAggregationInput | dgmTypeAttributesOrderByWithAggregationInput[]
    by: DgmTypeAttributesScalarFieldEnum[] | DgmTypeAttributesScalarFieldEnum
    having?: dgmTypeAttributesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DgmTypeAttributesCountAggregateInputType | true
    _avg?: DgmTypeAttributesAvgAggregateInputType
    _sum?: DgmTypeAttributesSumAggregateInputType
    _min?: DgmTypeAttributesMinAggregateInputType
    _max?: DgmTypeAttributesMaxAggregateInputType
  }

  export type DgmTypeAttributesGroupByOutputType = {
    typeID: number
    attributeID: number
    valueInt: number | null
    valueFloat: number | null
    _count: DgmTypeAttributesCountAggregateOutputType | null
    _avg: DgmTypeAttributesAvgAggregateOutputType | null
    _sum: DgmTypeAttributesSumAggregateOutputType | null
    _min: DgmTypeAttributesMinAggregateOutputType | null
    _max: DgmTypeAttributesMaxAggregateOutputType | null
  }

  type GetDgmTypeAttributesGroupByPayload<T extends dgmTypeAttributesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DgmTypeAttributesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DgmTypeAttributesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DgmTypeAttributesGroupByOutputType[P]>
            : GetScalarType<T[P], DgmTypeAttributesGroupByOutputType[P]>
        }
      >
    >


  export type dgmTypeAttributesSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    typeID?: boolean
    attributeID?: boolean
    valueInt?: boolean
    valueFloat?: boolean
  }, ExtArgs["result"]["dgmTypeAttributes"]>

  export type dgmTypeAttributesSelectScalar = {
    typeID?: boolean
    attributeID?: boolean
    valueInt?: boolean
    valueFloat?: boolean
  }


  export type $dgmTypeAttributesPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    name: "dgmTypeAttributes"
    objects: {}
    scalars: $Extensions.GetResult<{
      typeID: number
      attributeID: number
      valueInt: number | null
      valueFloat: number | null
    }, ExtArgs["result"]["dgmTypeAttributes"]>
    composites: {}
  }


  type dgmTypeAttributesGetPayload<S extends boolean | null | undefined | dgmTypeAttributesDefaultArgs> = $Result.GetResult<Prisma.$dgmTypeAttributesPayload, S>

  type dgmTypeAttributesCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<dgmTypeAttributesFindManyArgs, 'select' | 'include'> & {
      select?: DgmTypeAttributesCountAggregateInputType | true
    }

  export interface dgmTypeAttributesDelegate<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['dgmTypeAttributes'], meta: { name: 'dgmTypeAttributes' } }
    /**
     * Find zero or one DgmTypeAttributes that matches the filter.
     * @param {dgmTypeAttributesFindUniqueArgs} args - Arguments to find a DgmTypeAttributes
     * @example
     * // Get one DgmTypeAttributes
     * const dgmTypeAttributes = await prisma.dgmTypeAttributes.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends dgmTypeAttributesFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, dgmTypeAttributesFindUniqueArgs<ExtArgs>>
    ): Prisma__dgmTypeAttributesClient<$Result.GetResult<Prisma.$dgmTypeAttributesPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one DgmTypeAttributes that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {dgmTypeAttributesFindUniqueOrThrowArgs} args - Arguments to find a DgmTypeAttributes
     * @example
     * // Get one DgmTypeAttributes
     * const dgmTypeAttributes = await prisma.dgmTypeAttributes.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends dgmTypeAttributesFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, dgmTypeAttributesFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__dgmTypeAttributesClient<$Result.GetResult<Prisma.$dgmTypeAttributesPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first DgmTypeAttributes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {dgmTypeAttributesFindFirstArgs} args - Arguments to find a DgmTypeAttributes
     * @example
     * // Get one DgmTypeAttributes
     * const dgmTypeAttributes = await prisma.dgmTypeAttributes.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends dgmTypeAttributesFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, dgmTypeAttributesFindFirstArgs<ExtArgs>>
    ): Prisma__dgmTypeAttributesClient<$Result.GetResult<Prisma.$dgmTypeAttributesPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first DgmTypeAttributes that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {dgmTypeAttributesFindFirstOrThrowArgs} args - Arguments to find a DgmTypeAttributes
     * @example
     * // Get one DgmTypeAttributes
     * const dgmTypeAttributes = await prisma.dgmTypeAttributes.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends dgmTypeAttributesFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, dgmTypeAttributesFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__dgmTypeAttributesClient<$Result.GetResult<Prisma.$dgmTypeAttributesPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more DgmTypeAttributes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {dgmTypeAttributesFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DgmTypeAttributes
     * const dgmTypeAttributes = await prisma.dgmTypeAttributes.findMany()
     * 
     * // Get first 10 DgmTypeAttributes
     * const dgmTypeAttributes = await prisma.dgmTypeAttributes.findMany({ take: 10 })
     * 
     * // Only select the `typeID`
     * const dgmTypeAttributesWithTypeIDOnly = await prisma.dgmTypeAttributes.findMany({ select: { typeID: true } })
     * 
    **/
    findMany<T extends dgmTypeAttributesFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, dgmTypeAttributesFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$dgmTypeAttributesPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a DgmTypeAttributes.
     * @param {dgmTypeAttributesCreateArgs} args - Arguments to create a DgmTypeAttributes.
     * @example
     * // Create one DgmTypeAttributes
     * const DgmTypeAttributes = await prisma.dgmTypeAttributes.create({
     *   data: {
     *     // ... data to create a DgmTypeAttributes
     *   }
     * })
     * 
    **/
    create<T extends dgmTypeAttributesCreateArgs<ExtArgs>>(
      args: SelectSubset<T, dgmTypeAttributesCreateArgs<ExtArgs>>
    ): Prisma__dgmTypeAttributesClient<$Result.GetResult<Prisma.$dgmTypeAttributesPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many DgmTypeAttributes.
     *     @param {dgmTypeAttributesCreateManyArgs} args - Arguments to create many DgmTypeAttributes.
     *     @example
     *     // Create many DgmTypeAttributes
     *     const dgmTypeAttributes = await prisma.dgmTypeAttributes.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends dgmTypeAttributesCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, dgmTypeAttributesCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a DgmTypeAttributes.
     * @param {dgmTypeAttributesDeleteArgs} args - Arguments to delete one DgmTypeAttributes.
     * @example
     * // Delete one DgmTypeAttributes
     * const DgmTypeAttributes = await prisma.dgmTypeAttributes.delete({
     *   where: {
     *     // ... filter to delete one DgmTypeAttributes
     *   }
     * })
     * 
    **/
    delete<T extends dgmTypeAttributesDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, dgmTypeAttributesDeleteArgs<ExtArgs>>
    ): Prisma__dgmTypeAttributesClient<$Result.GetResult<Prisma.$dgmTypeAttributesPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one DgmTypeAttributes.
     * @param {dgmTypeAttributesUpdateArgs} args - Arguments to update one DgmTypeAttributes.
     * @example
     * // Update one DgmTypeAttributes
     * const dgmTypeAttributes = await prisma.dgmTypeAttributes.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends dgmTypeAttributesUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, dgmTypeAttributesUpdateArgs<ExtArgs>>
    ): Prisma__dgmTypeAttributesClient<$Result.GetResult<Prisma.$dgmTypeAttributesPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more DgmTypeAttributes.
     * @param {dgmTypeAttributesDeleteManyArgs} args - Arguments to filter DgmTypeAttributes to delete.
     * @example
     * // Delete a few DgmTypeAttributes
     * const { count } = await prisma.dgmTypeAttributes.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends dgmTypeAttributesDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, dgmTypeAttributesDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DgmTypeAttributes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {dgmTypeAttributesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DgmTypeAttributes
     * const dgmTypeAttributes = await prisma.dgmTypeAttributes.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends dgmTypeAttributesUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, dgmTypeAttributesUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one DgmTypeAttributes.
     * @param {dgmTypeAttributesUpsertArgs} args - Arguments to update or create a DgmTypeAttributes.
     * @example
     * // Update or create a DgmTypeAttributes
     * const dgmTypeAttributes = await prisma.dgmTypeAttributes.upsert({
     *   create: {
     *     // ... data to create a DgmTypeAttributes
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DgmTypeAttributes we want to update
     *   }
     * })
    **/
    upsert<T extends dgmTypeAttributesUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, dgmTypeAttributesUpsertArgs<ExtArgs>>
    ): Prisma__dgmTypeAttributesClient<$Result.GetResult<Prisma.$dgmTypeAttributesPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of DgmTypeAttributes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {dgmTypeAttributesCountArgs} args - Arguments to filter DgmTypeAttributes to count.
     * @example
     * // Count the number of DgmTypeAttributes
     * const count = await prisma.dgmTypeAttributes.count({
     *   where: {
     *     // ... the filter for the DgmTypeAttributes we want to count
     *   }
     * })
    **/
    count<T extends dgmTypeAttributesCountArgs>(
      args?: Subset<T, dgmTypeAttributesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DgmTypeAttributesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DgmTypeAttributes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DgmTypeAttributesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DgmTypeAttributesAggregateArgs>(args: Subset<T, DgmTypeAttributesAggregateArgs>): Prisma.PrismaPromise<GetDgmTypeAttributesAggregateType<T>>

    /**
     * Group by DgmTypeAttributes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {dgmTypeAttributesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends dgmTypeAttributesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: dgmTypeAttributesGroupByArgs['orderBy'] }
        : { orderBy?: dgmTypeAttributesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, dgmTypeAttributesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDgmTypeAttributesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the dgmTypeAttributes model
   */
  readonly fields: dgmTypeAttributesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for dgmTypeAttributes.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__dgmTypeAttributesClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';


    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the dgmTypeAttributes model
   */ 
  interface dgmTypeAttributesFieldRefs {
    readonly typeID: FieldRef<"dgmTypeAttributes", 'Int'>
    readonly attributeID: FieldRef<"dgmTypeAttributes", 'Int'>
    readonly valueInt: FieldRef<"dgmTypeAttributes", 'Int'>
    readonly valueFloat: FieldRef<"dgmTypeAttributes", 'Float'>
  }
    

  // Custom InputTypes

  /**
   * dgmTypeAttributes findUnique
   */
  export type dgmTypeAttributesFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the dgmTypeAttributes
     */
    select?: dgmTypeAttributesSelect<ExtArgs> | null
    /**
     * Filter, which dgmTypeAttributes to fetch.
     */
    where: dgmTypeAttributesWhereUniqueInput
  }


  /**
   * dgmTypeAttributes findUniqueOrThrow
   */
  export type dgmTypeAttributesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the dgmTypeAttributes
     */
    select?: dgmTypeAttributesSelect<ExtArgs> | null
    /**
     * Filter, which dgmTypeAttributes to fetch.
     */
    where: dgmTypeAttributesWhereUniqueInput
  }


  /**
   * dgmTypeAttributes findFirst
   */
  export type dgmTypeAttributesFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the dgmTypeAttributes
     */
    select?: dgmTypeAttributesSelect<ExtArgs> | null
    /**
     * Filter, which dgmTypeAttributes to fetch.
     */
    where?: dgmTypeAttributesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of dgmTypeAttributes to fetch.
     */
    orderBy?: dgmTypeAttributesOrderByWithRelationInput | dgmTypeAttributesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for dgmTypeAttributes.
     */
    cursor?: dgmTypeAttributesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` dgmTypeAttributes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` dgmTypeAttributes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of dgmTypeAttributes.
     */
    distinct?: DgmTypeAttributesScalarFieldEnum | DgmTypeAttributesScalarFieldEnum[]
  }


  /**
   * dgmTypeAttributes findFirstOrThrow
   */
  export type dgmTypeAttributesFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the dgmTypeAttributes
     */
    select?: dgmTypeAttributesSelect<ExtArgs> | null
    /**
     * Filter, which dgmTypeAttributes to fetch.
     */
    where?: dgmTypeAttributesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of dgmTypeAttributes to fetch.
     */
    orderBy?: dgmTypeAttributesOrderByWithRelationInput | dgmTypeAttributesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for dgmTypeAttributes.
     */
    cursor?: dgmTypeAttributesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` dgmTypeAttributes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` dgmTypeAttributes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of dgmTypeAttributes.
     */
    distinct?: DgmTypeAttributesScalarFieldEnum | DgmTypeAttributesScalarFieldEnum[]
  }


  /**
   * dgmTypeAttributes findMany
   */
  export type dgmTypeAttributesFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the dgmTypeAttributes
     */
    select?: dgmTypeAttributesSelect<ExtArgs> | null
    /**
     * Filter, which dgmTypeAttributes to fetch.
     */
    where?: dgmTypeAttributesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of dgmTypeAttributes to fetch.
     */
    orderBy?: dgmTypeAttributesOrderByWithRelationInput | dgmTypeAttributesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing dgmTypeAttributes.
     */
    cursor?: dgmTypeAttributesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` dgmTypeAttributes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` dgmTypeAttributes.
     */
    skip?: number
    distinct?: DgmTypeAttributesScalarFieldEnum | DgmTypeAttributesScalarFieldEnum[]
  }


  /**
   * dgmTypeAttributes create
   */
  export type dgmTypeAttributesCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the dgmTypeAttributes
     */
    select?: dgmTypeAttributesSelect<ExtArgs> | null
    /**
     * The data needed to create a dgmTypeAttributes.
     */
    data: XOR<dgmTypeAttributesCreateInput, dgmTypeAttributesUncheckedCreateInput>
  }


  /**
   * dgmTypeAttributes createMany
   */
  export type dgmTypeAttributesCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many dgmTypeAttributes.
     */
    data: dgmTypeAttributesCreateManyInput | dgmTypeAttributesCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * dgmTypeAttributes update
   */
  export type dgmTypeAttributesUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the dgmTypeAttributes
     */
    select?: dgmTypeAttributesSelect<ExtArgs> | null
    /**
     * The data needed to update a dgmTypeAttributes.
     */
    data: XOR<dgmTypeAttributesUpdateInput, dgmTypeAttributesUncheckedUpdateInput>
    /**
     * Choose, which dgmTypeAttributes to update.
     */
    where: dgmTypeAttributesWhereUniqueInput
  }


  /**
   * dgmTypeAttributes updateMany
   */
  export type dgmTypeAttributesUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update dgmTypeAttributes.
     */
    data: XOR<dgmTypeAttributesUpdateManyMutationInput, dgmTypeAttributesUncheckedUpdateManyInput>
    /**
     * Filter which dgmTypeAttributes to update
     */
    where?: dgmTypeAttributesWhereInput
  }


  /**
   * dgmTypeAttributes upsert
   */
  export type dgmTypeAttributesUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the dgmTypeAttributes
     */
    select?: dgmTypeAttributesSelect<ExtArgs> | null
    /**
     * The filter to search for the dgmTypeAttributes to update in case it exists.
     */
    where: dgmTypeAttributesWhereUniqueInput
    /**
     * In case the dgmTypeAttributes found by the `where` argument doesn't exist, create a new dgmTypeAttributes with this data.
     */
    create: XOR<dgmTypeAttributesCreateInput, dgmTypeAttributesUncheckedCreateInput>
    /**
     * In case the dgmTypeAttributes was found with the provided `where` argument, update it with this data.
     */
    update: XOR<dgmTypeAttributesUpdateInput, dgmTypeAttributesUncheckedUpdateInput>
  }


  /**
   * dgmTypeAttributes delete
   */
  export type dgmTypeAttributesDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the dgmTypeAttributes
     */
    select?: dgmTypeAttributesSelect<ExtArgs> | null
    /**
     * Filter which dgmTypeAttributes to delete.
     */
    where: dgmTypeAttributesWhereUniqueInput
  }


  /**
   * dgmTypeAttributes deleteMany
   */
  export type dgmTypeAttributesDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which dgmTypeAttributes to delete
     */
    where?: dgmTypeAttributesWhereInput
  }


  /**
   * dgmTypeAttributes without action
   */
  export type dgmTypeAttributesDefaultArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the dgmTypeAttributes
     */
    select?: dgmTypeAttributesSelect<ExtArgs> | null
  }



  /**
   * Model dgmTypeEffects
   */

  export type AggregateDgmTypeEffects = {
    _count: DgmTypeEffectsCountAggregateOutputType | null
    _avg: DgmTypeEffectsAvgAggregateOutputType | null
    _sum: DgmTypeEffectsSumAggregateOutputType | null
    _min: DgmTypeEffectsMinAggregateOutputType | null
    _max: DgmTypeEffectsMaxAggregateOutputType | null
  }

  export type DgmTypeEffectsAvgAggregateOutputType = {
    typeID: number | null
    effectID: number | null
  }

  export type DgmTypeEffectsSumAggregateOutputType = {
    typeID: number | null
    effectID: number | null
  }

  export type DgmTypeEffectsMinAggregateOutputType = {
    typeID: number | null
    effectID: number | null
    isDefault: boolean | null
  }

  export type DgmTypeEffectsMaxAggregateOutputType = {
    typeID: number | null
    effectID: number | null
    isDefault: boolean | null
  }

  export type DgmTypeEffectsCountAggregateOutputType = {
    typeID: number
    effectID: number
    isDefault: number
    _all: number
  }


  export type DgmTypeEffectsAvgAggregateInputType = {
    typeID?: true
    effectID?: true
  }

  export type DgmTypeEffectsSumAggregateInputType = {
    typeID?: true
    effectID?: true
  }

  export type DgmTypeEffectsMinAggregateInputType = {
    typeID?: true
    effectID?: true
    isDefault?: true
  }

  export type DgmTypeEffectsMaxAggregateInputType = {
    typeID?: true
    effectID?: true
    isDefault?: true
  }

  export type DgmTypeEffectsCountAggregateInputType = {
    typeID?: true
    effectID?: true
    isDefault?: true
    _all?: true
  }

  export type DgmTypeEffectsAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which dgmTypeEffects to aggregate.
     */
    where?: dgmTypeEffectsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of dgmTypeEffects to fetch.
     */
    orderBy?: dgmTypeEffectsOrderByWithRelationInput | dgmTypeEffectsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: dgmTypeEffectsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` dgmTypeEffects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` dgmTypeEffects.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned dgmTypeEffects
    **/
    _count?: true | DgmTypeEffectsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DgmTypeEffectsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DgmTypeEffectsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DgmTypeEffectsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DgmTypeEffectsMaxAggregateInputType
  }

  export type GetDgmTypeEffectsAggregateType<T extends DgmTypeEffectsAggregateArgs> = {
        [P in keyof T & keyof AggregateDgmTypeEffects]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDgmTypeEffects[P]>
      : GetScalarType<T[P], AggregateDgmTypeEffects[P]>
  }




  export type dgmTypeEffectsGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: dgmTypeEffectsWhereInput
    orderBy?: dgmTypeEffectsOrderByWithAggregationInput | dgmTypeEffectsOrderByWithAggregationInput[]
    by: DgmTypeEffectsScalarFieldEnum[] | DgmTypeEffectsScalarFieldEnum
    having?: dgmTypeEffectsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DgmTypeEffectsCountAggregateInputType | true
    _avg?: DgmTypeEffectsAvgAggregateInputType
    _sum?: DgmTypeEffectsSumAggregateInputType
    _min?: DgmTypeEffectsMinAggregateInputType
    _max?: DgmTypeEffectsMaxAggregateInputType
  }

  export type DgmTypeEffectsGroupByOutputType = {
    typeID: number
    effectID: number
    isDefault: boolean | null
    _count: DgmTypeEffectsCountAggregateOutputType | null
    _avg: DgmTypeEffectsAvgAggregateOutputType | null
    _sum: DgmTypeEffectsSumAggregateOutputType | null
    _min: DgmTypeEffectsMinAggregateOutputType | null
    _max: DgmTypeEffectsMaxAggregateOutputType | null
  }

  type GetDgmTypeEffectsGroupByPayload<T extends dgmTypeEffectsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DgmTypeEffectsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DgmTypeEffectsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DgmTypeEffectsGroupByOutputType[P]>
            : GetScalarType<T[P], DgmTypeEffectsGroupByOutputType[P]>
        }
      >
    >


  export type dgmTypeEffectsSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    typeID?: boolean
    effectID?: boolean
    isDefault?: boolean
  }, ExtArgs["result"]["dgmTypeEffects"]>

  export type dgmTypeEffectsSelectScalar = {
    typeID?: boolean
    effectID?: boolean
    isDefault?: boolean
  }


  export type $dgmTypeEffectsPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    name: "dgmTypeEffects"
    objects: {}
    scalars: $Extensions.GetResult<{
      typeID: number
      effectID: number
      isDefault: boolean | null
    }, ExtArgs["result"]["dgmTypeEffects"]>
    composites: {}
  }


  type dgmTypeEffectsGetPayload<S extends boolean | null | undefined | dgmTypeEffectsDefaultArgs> = $Result.GetResult<Prisma.$dgmTypeEffectsPayload, S>

  type dgmTypeEffectsCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<dgmTypeEffectsFindManyArgs, 'select' | 'include'> & {
      select?: DgmTypeEffectsCountAggregateInputType | true
    }

  export interface dgmTypeEffectsDelegate<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['dgmTypeEffects'], meta: { name: 'dgmTypeEffects' } }
    /**
     * Find zero or one DgmTypeEffects that matches the filter.
     * @param {dgmTypeEffectsFindUniqueArgs} args - Arguments to find a DgmTypeEffects
     * @example
     * // Get one DgmTypeEffects
     * const dgmTypeEffects = await prisma.dgmTypeEffects.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends dgmTypeEffectsFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, dgmTypeEffectsFindUniqueArgs<ExtArgs>>
    ): Prisma__dgmTypeEffectsClient<$Result.GetResult<Prisma.$dgmTypeEffectsPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one DgmTypeEffects that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {dgmTypeEffectsFindUniqueOrThrowArgs} args - Arguments to find a DgmTypeEffects
     * @example
     * // Get one DgmTypeEffects
     * const dgmTypeEffects = await prisma.dgmTypeEffects.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends dgmTypeEffectsFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, dgmTypeEffectsFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__dgmTypeEffectsClient<$Result.GetResult<Prisma.$dgmTypeEffectsPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first DgmTypeEffects that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {dgmTypeEffectsFindFirstArgs} args - Arguments to find a DgmTypeEffects
     * @example
     * // Get one DgmTypeEffects
     * const dgmTypeEffects = await prisma.dgmTypeEffects.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends dgmTypeEffectsFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, dgmTypeEffectsFindFirstArgs<ExtArgs>>
    ): Prisma__dgmTypeEffectsClient<$Result.GetResult<Prisma.$dgmTypeEffectsPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first DgmTypeEffects that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {dgmTypeEffectsFindFirstOrThrowArgs} args - Arguments to find a DgmTypeEffects
     * @example
     * // Get one DgmTypeEffects
     * const dgmTypeEffects = await prisma.dgmTypeEffects.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends dgmTypeEffectsFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, dgmTypeEffectsFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__dgmTypeEffectsClient<$Result.GetResult<Prisma.$dgmTypeEffectsPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more DgmTypeEffects that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {dgmTypeEffectsFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DgmTypeEffects
     * const dgmTypeEffects = await prisma.dgmTypeEffects.findMany()
     * 
     * // Get first 10 DgmTypeEffects
     * const dgmTypeEffects = await prisma.dgmTypeEffects.findMany({ take: 10 })
     * 
     * // Only select the `typeID`
     * const dgmTypeEffectsWithTypeIDOnly = await prisma.dgmTypeEffects.findMany({ select: { typeID: true } })
     * 
    **/
    findMany<T extends dgmTypeEffectsFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, dgmTypeEffectsFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$dgmTypeEffectsPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a DgmTypeEffects.
     * @param {dgmTypeEffectsCreateArgs} args - Arguments to create a DgmTypeEffects.
     * @example
     * // Create one DgmTypeEffects
     * const DgmTypeEffects = await prisma.dgmTypeEffects.create({
     *   data: {
     *     // ... data to create a DgmTypeEffects
     *   }
     * })
     * 
    **/
    create<T extends dgmTypeEffectsCreateArgs<ExtArgs>>(
      args: SelectSubset<T, dgmTypeEffectsCreateArgs<ExtArgs>>
    ): Prisma__dgmTypeEffectsClient<$Result.GetResult<Prisma.$dgmTypeEffectsPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many DgmTypeEffects.
     *     @param {dgmTypeEffectsCreateManyArgs} args - Arguments to create many DgmTypeEffects.
     *     @example
     *     // Create many DgmTypeEffects
     *     const dgmTypeEffects = await prisma.dgmTypeEffects.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends dgmTypeEffectsCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, dgmTypeEffectsCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a DgmTypeEffects.
     * @param {dgmTypeEffectsDeleteArgs} args - Arguments to delete one DgmTypeEffects.
     * @example
     * // Delete one DgmTypeEffects
     * const DgmTypeEffects = await prisma.dgmTypeEffects.delete({
     *   where: {
     *     // ... filter to delete one DgmTypeEffects
     *   }
     * })
     * 
    **/
    delete<T extends dgmTypeEffectsDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, dgmTypeEffectsDeleteArgs<ExtArgs>>
    ): Prisma__dgmTypeEffectsClient<$Result.GetResult<Prisma.$dgmTypeEffectsPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one DgmTypeEffects.
     * @param {dgmTypeEffectsUpdateArgs} args - Arguments to update one DgmTypeEffects.
     * @example
     * // Update one DgmTypeEffects
     * const dgmTypeEffects = await prisma.dgmTypeEffects.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends dgmTypeEffectsUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, dgmTypeEffectsUpdateArgs<ExtArgs>>
    ): Prisma__dgmTypeEffectsClient<$Result.GetResult<Prisma.$dgmTypeEffectsPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more DgmTypeEffects.
     * @param {dgmTypeEffectsDeleteManyArgs} args - Arguments to filter DgmTypeEffects to delete.
     * @example
     * // Delete a few DgmTypeEffects
     * const { count } = await prisma.dgmTypeEffects.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends dgmTypeEffectsDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, dgmTypeEffectsDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DgmTypeEffects.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {dgmTypeEffectsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DgmTypeEffects
     * const dgmTypeEffects = await prisma.dgmTypeEffects.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends dgmTypeEffectsUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, dgmTypeEffectsUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one DgmTypeEffects.
     * @param {dgmTypeEffectsUpsertArgs} args - Arguments to update or create a DgmTypeEffects.
     * @example
     * // Update or create a DgmTypeEffects
     * const dgmTypeEffects = await prisma.dgmTypeEffects.upsert({
     *   create: {
     *     // ... data to create a DgmTypeEffects
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DgmTypeEffects we want to update
     *   }
     * })
    **/
    upsert<T extends dgmTypeEffectsUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, dgmTypeEffectsUpsertArgs<ExtArgs>>
    ): Prisma__dgmTypeEffectsClient<$Result.GetResult<Prisma.$dgmTypeEffectsPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of DgmTypeEffects.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {dgmTypeEffectsCountArgs} args - Arguments to filter DgmTypeEffects to count.
     * @example
     * // Count the number of DgmTypeEffects
     * const count = await prisma.dgmTypeEffects.count({
     *   where: {
     *     // ... the filter for the DgmTypeEffects we want to count
     *   }
     * })
    **/
    count<T extends dgmTypeEffectsCountArgs>(
      args?: Subset<T, dgmTypeEffectsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DgmTypeEffectsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DgmTypeEffects.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DgmTypeEffectsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DgmTypeEffectsAggregateArgs>(args: Subset<T, DgmTypeEffectsAggregateArgs>): Prisma.PrismaPromise<GetDgmTypeEffectsAggregateType<T>>

    /**
     * Group by DgmTypeEffects.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {dgmTypeEffectsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends dgmTypeEffectsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: dgmTypeEffectsGroupByArgs['orderBy'] }
        : { orderBy?: dgmTypeEffectsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, dgmTypeEffectsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDgmTypeEffectsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the dgmTypeEffects model
   */
  readonly fields: dgmTypeEffectsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for dgmTypeEffects.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__dgmTypeEffectsClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';


    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the dgmTypeEffects model
   */ 
  interface dgmTypeEffectsFieldRefs {
    readonly typeID: FieldRef<"dgmTypeEffects", 'Int'>
    readonly effectID: FieldRef<"dgmTypeEffects", 'Int'>
    readonly isDefault: FieldRef<"dgmTypeEffects", 'Boolean'>
  }
    

  // Custom InputTypes

  /**
   * dgmTypeEffects findUnique
   */
  export type dgmTypeEffectsFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the dgmTypeEffects
     */
    select?: dgmTypeEffectsSelect<ExtArgs> | null
    /**
     * Filter, which dgmTypeEffects to fetch.
     */
    where: dgmTypeEffectsWhereUniqueInput
  }


  /**
   * dgmTypeEffects findUniqueOrThrow
   */
  export type dgmTypeEffectsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the dgmTypeEffects
     */
    select?: dgmTypeEffectsSelect<ExtArgs> | null
    /**
     * Filter, which dgmTypeEffects to fetch.
     */
    where: dgmTypeEffectsWhereUniqueInput
  }


  /**
   * dgmTypeEffects findFirst
   */
  export type dgmTypeEffectsFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the dgmTypeEffects
     */
    select?: dgmTypeEffectsSelect<ExtArgs> | null
    /**
     * Filter, which dgmTypeEffects to fetch.
     */
    where?: dgmTypeEffectsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of dgmTypeEffects to fetch.
     */
    orderBy?: dgmTypeEffectsOrderByWithRelationInput | dgmTypeEffectsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for dgmTypeEffects.
     */
    cursor?: dgmTypeEffectsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` dgmTypeEffects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` dgmTypeEffects.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of dgmTypeEffects.
     */
    distinct?: DgmTypeEffectsScalarFieldEnum | DgmTypeEffectsScalarFieldEnum[]
  }


  /**
   * dgmTypeEffects findFirstOrThrow
   */
  export type dgmTypeEffectsFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the dgmTypeEffects
     */
    select?: dgmTypeEffectsSelect<ExtArgs> | null
    /**
     * Filter, which dgmTypeEffects to fetch.
     */
    where?: dgmTypeEffectsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of dgmTypeEffects to fetch.
     */
    orderBy?: dgmTypeEffectsOrderByWithRelationInput | dgmTypeEffectsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for dgmTypeEffects.
     */
    cursor?: dgmTypeEffectsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` dgmTypeEffects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` dgmTypeEffects.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of dgmTypeEffects.
     */
    distinct?: DgmTypeEffectsScalarFieldEnum | DgmTypeEffectsScalarFieldEnum[]
  }


  /**
   * dgmTypeEffects findMany
   */
  export type dgmTypeEffectsFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the dgmTypeEffects
     */
    select?: dgmTypeEffectsSelect<ExtArgs> | null
    /**
     * Filter, which dgmTypeEffects to fetch.
     */
    where?: dgmTypeEffectsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of dgmTypeEffects to fetch.
     */
    orderBy?: dgmTypeEffectsOrderByWithRelationInput | dgmTypeEffectsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing dgmTypeEffects.
     */
    cursor?: dgmTypeEffectsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` dgmTypeEffects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` dgmTypeEffects.
     */
    skip?: number
    distinct?: DgmTypeEffectsScalarFieldEnum | DgmTypeEffectsScalarFieldEnum[]
  }


  /**
   * dgmTypeEffects create
   */
  export type dgmTypeEffectsCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the dgmTypeEffects
     */
    select?: dgmTypeEffectsSelect<ExtArgs> | null
    /**
     * The data needed to create a dgmTypeEffects.
     */
    data: XOR<dgmTypeEffectsCreateInput, dgmTypeEffectsUncheckedCreateInput>
  }


  /**
   * dgmTypeEffects createMany
   */
  export type dgmTypeEffectsCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many dgmTypeEffects.
     */
    data: dgmTypeEffectsCreateManyInput | dgmTypeEffectsCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * dgmTypeEffects update
   */
  export type dgmTypeEffectsUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the dgmTypeEffects
     */
    select?: dgmTypeEffectsSelect<ExtArgs> | null
    /**
     * The data needed to update a dgmTypeEffects.
     */
    data: XOR<dgmTypeEffectsUpdateInput, dgmTypeEffectsUncheckedUpdateInput>
    /**
     * Choose, which dgmTypeEffects to update.
     */
    where: dgmTypeEffectsWhereUniqueInput
  }


  /**
   * dgmTypeEffects updateMany
   */
  export type dgmTypeEffectsUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update dgmTypeEffects.
     */
    data: XOR<dgmTypeEffectsUpdateManyMutationInput, dgmTypeEffectsUncheckedUpdateManyInput>
    /**
     * Filter which dgmTypeEffects to update
     */
    where?: dgmTypeEffectsWhereInput
  }


  /**
   * dgmTypeEffects upsert
   */
  export type dgmTypeEffectsUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the dgmTypeEffects
     */
    select?: dgmTypeEffectsSelect<ExtArgs> | null
    /**
     * The filter to search for the dgmTypeEffects to update in case it exists.
     */
    where: dgmTypeEffectsWhereUniqueInput
    /**
     * In case the dgmTypeEffects found by the `where` argument doesn't exist, create a new dgmTypeEffects with this data.
     */
    create: XOR<dgmTypeEffectsCreateInput, dgmTypeEffectsUncheckedCreateInput>
    /**
     * In case the dgmTypeEffects was found with the provided `where` argument, update it with this data.
     */
    update: XOR<dgmTypeEffectsUpdateInput, dgmTypeEffectsUncheckedUpdateInput>
  }


  /**
   * dgmTypeEffects delete
   */
  export type dgmTypeEffectsDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the dgmTypeEffects
     */
    select?: dgmTypeEffectsSelect<ExtArgs> | null
    /**
     * Filter which dgmTypeEffects to delete.
     */
    where: dgmTypeEffectsWhereUniqueInput
  }


  /**
   * dgmTypeEffects deleteMany
   */
  export type dgmTypeEffectsDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which dgmTypeEffects to delete
     */
    where?: dgmTypeEffectsWhereInput
  }


  /**
   * dgmTypeEffects without action
   */
  export type dgmTypeEffectsDefaultArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the dgmTypeEffects
     */
    select?: dgmTypeEffectsSelect<ExtArgs> | null
  }



  /**
   * Model eveGraphics
   */

  export type AggregateEveGraphics = {
    _count: EveGraphicsCountAggregateOutputType | null
    _avg: EveGraphicsAvgAggregateOutputType | null
    _sum: EveGraphicsSumAggregateOutputType | null
    _min: EveGraphicsMinAggregateOutputType | null
    _max: EveGraphicsMaxAggregateOutputType | null
  }

  export type EveGraphicsAvgAggregateOutputType = {
    graphicID: number | null
  }

  export type EveGraphicsSumAggregateOutputType = {
    graphicID: number | null
  }

  export type EveGraphicsMinAggregateOutputType = {
    graphicID: number | null
    sofFactionName: string | null
    graphicFile: string | null
    sofHullName: string | null
    sofRaceName: string | null
    description: string | null
  }

  export type EveGraphicsMaxAggregateOutputType = {
    graphicID: number | null
    sofFactionName: string | null
    graphicFile: string | null
    sofHullName: string | null
    sofRaceName: string | null
    description: string | null
  }

  export type EveGraphicsCountAggregateOutputType = {
    graphicID: number
    sofFactionName: number
    graphicFile: number
    sofHullName: number
    sofRaceName: number
    description: number
    _all: number
  }


  export type EveGraphicsAvgAggregateInputType = {
    graphicID?: true
  }

  export type EveGraphicsSumAggregateInputType = {
    graphicID?: true
  }

  export type EveGraphicsMinAggregateInputType = {
    graphicID?: true
    sofFactionName?: true
    graphicFile?: true
    sofHullName?: true
    sofRaceName?: true
    description?: true
  }

  export type EveGraphicsMaxAggregateInputType = {
    graphicID?: true
    sofFactionName?: true
    graphicFile?: true
    sofHullName?: true
    sofRaceName?: true
    description?: true
  }

  export type EveGraphicsCountAggregateInputType = {
    graphicID?: true
    sofFactionName?: true
    graphicFile?: true
    sofHullName?: true
    sofRaceName?: true
    description?: true
    _all?: true
  }

  export type EveGraphicsAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which eveGraphics to aggregate.
     */
    where?: eveGraphicsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of eveGraphics to fetch.
     */
    orderBy?: eveGraphicsOrderByWithRelationInput | eveGraphicsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: eveGraphicsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` eveGraphics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` eveGraphics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned eveGraphics
    **/
    _count?: true | EveGraphicsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: EveGraphicsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: EveGraphicsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EveGraphicsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EveGraphicsMaxAggregateInputType
  }

  export type GetEveGraphicsAggregateType<T extends EveGraphicsAggregateArgs> = {
        [P in keyof T & keyof AggregateEveGraphics]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEveGraphics[P]>
      : GetScalarType<T[P], AggregateEveGraphics[P]>
  }




  export type eveGraphicsGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: eveGraphicsWhereInput
    orderBy?: eveGraphicsOrderByWithAggregationInput | eveGraphicsOrderByWithAggregationInput[]
    by: EveGraphicsScalarFieldEnum[] | EveGraphicsScalarFieldEnum
    having?: eveGraphicsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EveGraphicsCountAggregateInputType | true
    _avg?: EveGraphicsAvgAggregateInputType
    _sum?: EveGraphicsSumAggregateInputType
    _min?: EveGraphicsMinAggregateInputType
    _max?: EveGraphicsMaxAggregateInputType
  }

  export type EveGraphicsGroupByOutputType = {
    graphicID: number
    sofFactionName: string | null
    graphicFile: string | null
    sofHullName: string | null
    sofRaceName: string | null
    description: string | null
    _count: EveGraphicsCountAggregateOutputType | null
    _avg: EveGraphicsAvgAggregateOutputType | null
    _sum: EveGraphicsSumAggregateOutputType | null
    _min: EveGraphicsMinAggregateOutputType | null
    _max: EveGraphicsMaxAggregateOutputType | null
  }

  type GetEveGraphicsGroupByPayload<T extends eveGraphicsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EveGraphicsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EveGraphicsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EveGraphicsGroupByOutputType[P]>
            : GetScalarType<T[P], EveGraphicsGroupByOutputType[P]>
        }
      >
    >


  export type eveGraphicsSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    graphicID?: boolean
    sofFactionName?: boolean
    graphicFile?: boolean
    sofHullName?: boolean
    sofRaceName?: boolean
    description?: boolean
  }, ExtArgs["result"]["eveGraphics"]>

  export type eveGraphicsSelectScalar = {
    graphicID?: boolean
    sofFactionName?: boolean
    graphicFile?: boolean
    sofHullName?: boolean
    sofRaceName?: boolean
    description?: boolean
  }


  export type $eveGraphicsPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    name: "eveGraphics"
    objects: {}
    scalars: $Extensions.GetResult<{
      graphicID: number
      sofFactionName: string | null
      graphicFile: string | null
      sofHullName: string | null
      sofRaceName: string | null
      description: string | null
    }, ExtArgs["result"]["eveGraphics"]>
    composites: {}
  }


  type eveGraphicsGetPayload<S extends boolean | null | undefined | eveGraphicsDefaultArgs> = $Result.GetResult<Prisma.$eveGraphicsPayload, S>

  type eveGraphicsCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<eveGraphicsFindManyArgs, 'select' | 'include'> & {
      select?: EveGraphicsCountAggregateInputType | true
    }

  export interface eveGraphicsDelegate<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['eveGraphics'], meta: { name: 'eveGraphics' } }
    /**
     * Find zero or one EveGraphics that matches the filter.
     * @param {eveGraphicsFindUniqueArgs} args - Arguments to find a EveGraphics
     * @example
     * // Get one EveGraphics
     * const eveGraphics = await prisma.eveGraphics.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends eveGraphicsFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, eveGraphicsFindUniqueArgs<ExtArgs>>
    ): Prisma__eveGraphicsClient<$Result.GetResult<Prisma.$eveGraphicsPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one EveGraphics that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {eveGraphicsFindUniqueOrThrowArgs} args - Arguments to find a EveGraphics
     * @example
     * // Get one EveGraphics
     * const eveGraphics = await prisma.eveGraphics.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends eveGraphicsFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, eveGraphicsFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__eveGraphicsClient<$Result.GetResult<Prisma.$eveGraphicsPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first EveGraphics that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {eveGraphicsFindFirstArgs} args - Arguments to find a EveGraphics
     * @example
     * // Get one EveGraphics
     * const eveGraphics = await prisma.eveGraphics.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends eveGraphicsFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, eveGraphicsFindFirstArgs<ExtArgs>>
    ): Prisma__eveGraphicsClient<$Result.GetResult<Prisma.$eveGraphicsPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first EveGraphics that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {eveGraphicsFindFirstOrThrowArgs} args - Arguments to find a EveGraphics
     * @example
     * // Get one EveGraphics
     * const eveGraphics = await prisma.eveGraphics.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends eveGraphicsFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, eveGraphicsFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__eveGraphicsClient<$Result.GetResult<Prisma.$eveGraphicsPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more EveGraphics that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {eveGraphicsFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all EveGraphics
     * const eveGraphics = await prisma.eveGraphics.findMany()
     * 
     * // Get first 10 EveGraphics
     * const eveGraphics = await prisma.eveGraphics.findMany({ take: 10 })
     * 
     * // Only select the `graphicID`
     * const eveGraphicsWithGraphicIDOnly = await prisma.eveGraphics.findMany({ select: { graphicID: true } })
     * 
    **/
    findMany<T extends eveGraphicsFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, eveGraphicsFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$eveGraphicsPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a EveGraphics.
     * @param {eveGraphicsCreateArgs} args - Arguments to create a EveGraphics.
     * @example
     * // Create one EveGraphics
     * const EveGraphics = await prisma.eveGraphics.create({
     *   data: {
     *     // ... data to create a EveGraphics
     *   }
     * })
     * 
    **/
    create<T extends eveGraphicsCreateArgs<ExtArgs>>(
      args: SelectSubset<T, eveGraphicsCreateArgs<ExtArgs>>
    ): Prisma__eveGraphicsClient<$Result.GetResult<Prisma.$eveGraphicsPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many EveGraphics.
     *     @param {eveGraphicsCreateManyArgs} args - Arguments to create many EveGraphics.
     *     @example
     *     // Create many EveGraphics
     *     const eveGraphics = await prisma.eveGraphics.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends eveGraphicsCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, eveGraphicsCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a EveGraphics.
     * @param {eveGraphicsDeleteArgs} args - Arguments to delete one EveGraphics.
     * @example
     * // Delete one EveGraphics
     * const EveGraphics = await prisma.eveGraphics.delete({
     *   where: {
     *     // ... filter to delete one EveGraphics
     *   }
     * })
     * 
    **/
    delete<T extends eveGraphicsDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, eveGraphicsDeleteArgs<ExtArgs>>
    ): Prisma__eveGraphicsClient<$Result.GetResult<Prisma.$eveGraphicsPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one EveGraphics.
     * @param {eveGraphicsUpdateArgs} args - Arguments to update one EveGraphics.
     * @example
     * // Update one EveGraphics
     * const eveGraphics = await prisma.eveGraphics.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends eveGraphicsUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, eveGraphicsUpdateArgs<ExtArgs>>
    ): Prisma__eveGraphicsClient<$Result.GetResult<Prisma.$eveGraphicsPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more EveGraphics.
     * @param {eveGraphicsDeleteManyArgs} args - Arguments to filter EveGraphics to delete.
     * @example
     * // Delete a few EveGraphics
     * const { count } = await prisma.eveGraphics.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends eveGraphicsDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, eveGraphicsDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EveGraphics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {eveGraphicsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many EveGraphics
     * const eveGraphics = await prisma.eveGraphics.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends eveGraphicsUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, eveGraphicsUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one EveGraphics.
     * @param {eveGraphicsUpsertArgs} args - Arguments to update or create a EveGraphics.
     * @example
     * // Update or create a EveGraphics
     * const eveGraphics = await prisma.eveGraphics.upsert({
     *   create: {
     *     // ... data to create a EveGraphics
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the EveGraphics we want to update
     *   }
     * })
    **/
    upsert<T extends eveGraphicsUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, eveGraphicsUpsertArgs<ExtArgs>>
    ): Prisma__eveGraphicsClient<$Result.GetResult<Prisma.$eveGraphicsPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of EveGraphics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {eveGraphicsCountArgs} args - Arguments to filter EveGraphics to count.
     * @example
     * // Count the number of EveGraphics
     * const count = await prisma.eveGraphics.count({
     *   where: {
     *     // ... the filter for the EveGraphics we want to count
     *   }
     * })
    **/
    count<T extends eveGraphicsCountArgs>(
      args?: Subset<T, eveGraphicsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EveGraphicsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a EveGraphics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EveGraphicsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EveGraphicsAggregateArgs>(args: Subset<T, EveGraphicsAggregateArgs>): Prisma.PrismaPromise<GetEveGraphicsAggregateType<T>>

    /**
     * Group by EveGraphics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {eveGraphicsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends eveGraphicsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: eveGraphicsGroupByArgs['orderBy'] }
        : { orderBy?: eveGraphicsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, eveGraphicsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEveGraphicsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the eveGraphics model
   */
  readonly fields: eveGraphicsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for eveGraphics.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__eveGraphicsClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';


    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the eveGraphics model
   */ 
  interface eveGraphicsFieldRefs {
    readonly graphicID: FieldRef<"eveGraphics", 'Int'>
    readonly sofFactionName: FieldRef<"eveGraphics", 'String'>
    readonly graphicFile: FieldRef<"eveGraphics", 'String'>
    readonly sofHullName: FieldRef<"eveGraphics", 'String'>
    readonly sofRaceName: FieldRef<"eveGraphics", 'String'>
    readonly description: FieldRef<"eveGraphics", 'String'>
  }
    

  // Custom InputTypes

  /**
   * eveGraphics findUnique
   */
  export type eveGraphicsFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the eveGraphics
     */
    select?: eveGraphicsSelect<ExtArgs> | null
    /**
     * Filter, which eveGraphics to fetch.
     */
    where: eveGraphicsWhereUniqueInput
  }


  /**
   * eveGraphics findUniqueOrThrow
   */
  export type eveGraphicsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the eveGraphics
     */
    select?: eveGraphicsSelect<ExtArgs> | null
    /**
     * Filter, which eveGraphics to fetch.
     */
    where: eveGraphicsWhereUniqueInput
  }


  /**
   * eveGraphics findFirst
   */
  export type eveGraphicsFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the eveGraphics
     */
    select?: eveGraphicsSelect<ExtArgs> | null
    /**
     * Filter, which eveGraphics to fetch.
     */
    where?: eveGraphicsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of eveGraphics to fetch.
     */
    orderBy?: eveGraphicsOrderByWithRelationInput | eveGraphicsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for eveGraphics.
     */
    cursor?: eveGraphicsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` eveGraphics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` eveGraphics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of eveGraphics.
     */
    distinct?: EveGraphicsScalarFieldEnum | EveGraphicsScalarFieldEnum[]
  }


  /**
   * eveGraphics findFirstOrThrow
   */
  export type eveGraphicsFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the eveGraphics
     */
    select?: eveGraphicsSelect<ExtArgs> | null
    /**
     * Filter, which eveGraphics to fetch.
     */
    where?: eveGraphicsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of eveGraphics to fetch.
     */
    orderBy?: eveGraphicsOrderByWithRelationInput | eveGraphicsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for eveGraphics.
     */
    cursor?: eveGraphicsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` eveGraphics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` eveGraphics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of eveGraphics.
     */
    distinct?: EveGraphicsScalarFieldEnum | EveGraphicsScalarFieldEnum[]
  }


  /**
   * eveGraphics findMany
   */
  export type eveGraphicsFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the eveGraphics
     */
    select?: eveGraphicsSelect<ExtArgs> | null
    /**
     * Filter, which eveGraphics to fetch.
     */
    where?: eveGraphicsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of eveGraphics to fetch.
     */
    orderBy?: eveGraphicsOrderByWithRelationInput | eveGraphicsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing eveGraphics.
     */
    cursor?: eveGraphicsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` eveGraphics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` eveGraphics.
     */
    skip?: number
    distinct?: EveGraphicsScalarFieldEnum | EveGraphicsScalarFieldEnum[]
  }


  /**
   * eveGraphics create
   */
  export type eveGraphicsCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the eveGraphics
     */
    select?: eveGraphicsSelect<ExtArgs> | null
    /**
     * The data needed to create a eveGraphics.
     */
    data: XOR<eveGraphicsCreateInput, eveGraphicsUncheckedCreateInput>
  }


  /**
   * eveGraphics createMany
   */
  export type eveGraphicsCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many eveGraphics.
     */
    data: eveGraphicsCreateManyInput | eveGraphicsCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * eveGraphics update
   */
  export type eveGraphicsUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the eveGraphics
     */
    select?: eveGraphicsSelect<ExtArgs> | null
    /**
     * The data needed to update a eveGraphics.
     */
    data: XOR<eveGraphicsUpdateInput, eveGraphicsUncheckedUpdateInput>
    /**
     * Choose, which eveGraphics to update.
     */
    where: eveGraphicsWhereUniqueInput
  }


  /**
   * eveGraphics updateMany
   */
  export type eveGraphicsUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update eveGraphics.
     */
    data: XOR<eveGraphicsUpdateManyMutationInput, eveGraphicsUncheckedUpdateManyInput>
    /**
     * Filter which eveGraphics to update
     */
    where?: eveGraphicsWhereInput
  }


  /**
   * eveGraphics upsert
   */
  export type eveGraphicsUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the eveGraphics
     */
    select?: eveGraphicsSelect<ExtArgs> | null
    /**
     * The filter to search for the eveGraphics to update in case it exists.
     */
    where: eveGraphicsWhereUniqueInput
    /**
     * In case the eveGraphics found by the `where` argument doesn't exist, create a new eveGraphics with this data.
     */
    create: XOR<eveGraphicsCreateInput, eveGraphicsUncheckedCreateInput>
    /**
     * In case the eveGraphics was found with the provided `where` argument, update it with this data.
     */
    update: XOR<eveGraphicsUpdateInput, eveGraphicsUncheckedUpdateInput>
  }


  /**
   * eveGraphics delete
   */
  export type eveGraphicsDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the eveGraphics
     */
    select?: eveGraphicsSelect<ExtArgs> | null
    /**
     * Filter which eveGraphics to delete.
     */
    where: eveGraphicsWhereUniqueInput
  }


  /**
   * eveGraphics deleteMany
   */
  export type eveGraphicsDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which eveGraphics to delete
     */
    where?: eveGraphicsWhereInput
  }


  /**
   * eveGraphics without action
   */
  export type eveGraphicsDefaultArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the eveGraphics
     */
    select?: eveGraphicsSelect<ExtArgs> | null
  }



  /**
   * Model eveIcons
   */

  export type AggregateEveIcons = {
    _count: EveIconsCountAggregateOutputType | null
    _avg: EveIconsAvgAggregateOutputType | null
    _sum: EveIconsSumAggregateOutputType | null
    _min: EveIconsMinAggregateOutputType | null
    _max: EveIconsMaxAggregateOutputType | null
  }

  export type EveIconsAvgAggregateOutputType = {
    iconID: number | null
  }

  export type EveIconsSumAggregateOutputType = {
    iconID: number | null
  }

  export type EveIconsMinAggregateOutputType = {
    iconID: number | null
    iconFile: string | null
    description: string | null
  }

  export type EveIconsMaxAggregateOutputType = {
    iconID: number | null
    iconFile: string | null
    description: string | null
  }

  export type EveIconsCountAggregateOutputType = {
    iconID: number
    iconFile: number
    description: number
    _all: number
  }


  export type EveIconsAvgAggregateInputType = {
    iconID?: true
  }

  export type EveIconsSumAggregateInputType = {
    iconID?: true
  }

  export type EveIconsMinAggregateInputType = {
    iconID?: true
    iconFile?: true
    description?: true
  }

  export type EveIconsMaxAggregateInputType = {
    iconID?: true
    iconFile?: true
    description?: true
  }

  export type EveIconsCountAggregateInputType = {
    iconID?: true
    iconFile?: true
    description?: true
    _all?: true
  }

  export type EveIconsAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which eveIcons to aggregate.
     */
    where?: eveIconsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of eveIcons to fetch.
     */
    orderBy?: eveIconsOrderByWithRelationInput | eveIconsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: eveIconsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` eveIcons from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` eveIcons.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned eveIcons
    **/
    _count?: true | EveIconsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: EveIconsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: EveIconsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EveIconsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EveIconsMaxAggregateInputType
  }

  export type GetEveIconsAggregateType<T extends EveIconsAggregateArgs> = {
        [P in keyof T & keyof AggregateEveIcons]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEveIcons[P]>
      : GetScalarType<T[P], AggregateEveIcons[P]>
  }




  export type eveIconsGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: eveIconsWhereInput
    orderBy?: eveIconsOrderByWithAggregationInput | eveIconsOrderByWithAggregationInput[]
    by: EveIconsScalarFieldEnum[] | EveIconsScalarFieldEnum
    having?: eveIconsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EveIconsCountAggregateInputType | true
    _avg?: EveIconsAvgAggregateInputType
    _sum?: EveIconsSumAggregateInputType
    _min?: EveIconsMinAggregateInputType
    _max?: EveIconsMaxAggregateInputType
  }

  export type EveIconsGroupByOutputType = {
    iconID: number
    iconFile: string | null
    description: string | null
    _count: EveIconsCountAggregateOutputType | null
    _avg: EveIconsAvgAggregateOutputType | null
    _sum: EveIconsSumAggregateOutputType | null
    _min: EveIconsMinAggregateOutputType | null
    _max: EveIconsMaxAggregateOutputType | null
  }

  type GetEveIconsGroupByPayload<T extends eveIconsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EveIconsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EveIconsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EveIconsGroupByOutputType[P]>
            : GetScalarType<T[P], EveIconsGroupByOutputType[P]>
        }
      >
    >


  export type eveIconsSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    iconID?: boolean
    iconFile?: boolean
    description?: boolean
  }, ExtArgs["result"]["eveIcons"]>

  export type eveIconsSelectScalar = {
    iconID?: boolean
    iconFile?: boolean
    description?: boolean
  }


  export type $eveIconsPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    name: "eveIcons"
    objects: {}
    scalars: $Extensions.GetResult<{
      iconID: number
      iconFile: string | null
      description: string | null
    }, ExtArgs["result"]["eveIcons"]>
    composites: {}
  }


  type eveIconsGetPayload<S extends boolean | null | undefined | eveIconsDefaultArgs> = $Result.GetResult<Prisma.$eveIconsPayload, S>

  type eveIconsCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<eveIconsFindManyArgs, 'select' | 'include'> & {
      select?: EveIconsCountAggregateInputType | true
    }

  export interface eveIconsDelegate<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['eveIcons'], meta: { name: 'eveIcons' } }
    /**
     * Find zero or one EveIcons that matches the filter.
     * @param {eveIconsFindUniqueArgs} args - Arguments to find a EveIcons
     * @example
     * // Get one EveIcons
     * const eveIcons = await prisma.eveIcons.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends eveIconsFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, eveIconsFindUniqueArgs<ExtArgs>>
    ): Prisma__eveIconsClient<$Result.GetResult<Prisma.$eveIconsPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one EveIcons that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {eveIconsFindUniqueOrThrowArgs} args - Arguments to find a EveIcons
     * @example
     * // Get one EveIcons
     * const eveIcons = await prisma.eveIcons.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends eveIconsFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, eveIconsFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__eveIconsClient<$Result.GetResult<Prisma.$eveIconsPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first EveIcons that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {eveIconsFindFirstArgs} args - Arguments to find a EveIcons
     * @example
     * // Get one EveIcons
     * const eveIcons = await prisma.eveIcons.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends eveIconsFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, eveIconsFindFirstArgs<ExtArgs>>
    ): Prisma__eveIconsClient<$Result.GetResult<Prisma.$eveIconsPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first EveIcons that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {eveIconsFindFirstOrThrowArgs} args - Arguments to find a EveIcons
     * @example
     * // Get one EveIcons
     * const eveIcons = await prisma.eveIcons.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends eveIconsFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, eveIconsFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__eveIconsClient<$Result.GetResult<Prisma.$eveIconsPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more EveIcons that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {eveIconsFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all EveIcons
     * const eveIcons = await prisma.eveIcons.findMany()
     * 
     * // Get first 10 EveIcons
     * const eveIcons = await prisma.eveIcons.findMany({ take: 10 })
     * 
     * // Only select the `iconID`
     * const eveIconsWithIconIDOnly = await prisma.eveIcons.findMany({ select: { iconID: true } })
     * 
    **/
    findMany<T extends eveIconsFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, eveIconsFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$eveIconsPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a EveIcons.
     * @param {eveIconsCreateArgs} args - Arguments to create a EveIcons.
     * @example
     * // Create one EveIcons
     * const EveIcons = await prisma.eveIcons.create({
     *   data: {
     *     // ... data to create a EveIcons
     *   }
     * })
     * 
    **/
    create<T extends eveIconsCreateArgs<ExtArgs>>(
      args: SelectSubset<T, eveIconsCreateArgs<ExtArgs>>
    ): Prisma__eveIconsClient<$Result.GetResult<Prisma.$eveIconsPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many EveIcons.
     *     @param {eveIconsCreateManyArgs} args - Arguments to create many EveIcons.
     *     @example
     *     // Create many EveIcons
     *     const eveIcons = await prisma.eveIcons.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends eveIconsCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, eveIconsCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a EveIcons.
     * @param {eveIconsDeleteArgs} args - Arguments to delete one EveIcons.
     * @example
     * // Delete one EveIcons
     * const EveIcons = await prisma.eveIcons.delete({
     *   where: {
     *     // ... filter to delete one EveIcons
     *   }
     * })
     * 
    **/
    delete<T extends eveIconsDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, eveIconsDeleteArgs<ExtArgs>>
    ): Prisma__eveIconsClient<$Result.GetResult<Prisma.$eveIconsPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one EveIcons.
     * @param {eveIconsUpdateArgs} args - Arguments to update one EveIcons.
     * @example
     * // Update one EveIcons
     * const eveIcons = await prisma.eveIcons.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends eveIconsUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, eveIconsUpdateArgs<ExtArgs>>
    ): Prisma__eveIconsClient<$Result.GetResult<Prisma.$eveIconsPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more EveIcons.
     * @param {eveIconsDeleteManyArgs} args - Arguments to filter EveIcons to delete.
     * @example
     * // Delete a few EveIcons
     * const { count } = await prisma.eveIcons.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends eveIconsDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, eveIconsDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EveIcons.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {eveIconsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many EveIcons
     * const eveIcons = await prisma.eveIcons.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends eveIconsUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, eveIconsUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one EveIcons.
     * @param {eveIconsUpsertArgs} args - Arguments to update or create a EveIcons.
     * @example
     * // Update or create a EveIcons
     * const eveIcons = await prisma.eveIcons.upsert({
     *   create: {
     *     // ... data to create a EveIcons
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the EveIcons we want to update
     *   }
     * })
    **/
    upsert<T extends eveIconsUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, eveIconsUpsertArgs<ExtArgs>>
    ): Prisma__eveIconsClient<$Result.GetResult<Prisma.$eveIconsPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of EveIcons.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {eveIconsCountArgs} args - Arguments to filter EveIcons to count.
     * @example
     * // Count the number of EveIcons
     * const count = await prisma.eveIcons.count({
     *   where: {
     *     // ... the filter for the EveIcons we want to count
     *   }
     * })
    **/
    count<T extends eveIconsCountArgs>(
      args?: Subset<T, eveIconsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EveIconsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a EveIcons.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EveIconsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EveIconsAggregateArgs>(args: Subset<T, EveIconsAggregateArgs>): Prisma.PrismaPromise<GetEveIconsAggregateType<T>>

    /**
     * Group by EveIcons.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {eveIconsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends eveIconsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: eveIconsGroupByArgs['orderBy'] }
        : { orderBy?: eveIconsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, eveIconsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEveIconsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the eveIcons model
   */
  readonly fields: eveIconsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for eveIcons.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__eveIconsClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';


    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the eveIcons model
   */ 
  interface eveIconsFieldRefs {
    readonly iconID: FieldRef<"eveIcons", 'Int'>
    readonly iconFile: FieldRef<"eveIcons", 'String'>
    readonly description: FieldRef<"eveIcons", 'String'>
  }
    

  // Custom InputTypes

  /**
   * eveIcons findUnique
   */
  export type eveIconsFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the eveIcons
     */
    select?: eveIconsSelect<ExtArgs> | null
    /**
     * Filter, which eveIcons to fetch.
     */
    where: eveIconsWhereUniqueInput
  }


  /**
   * eveIcons findUniqueOrThrow
   */
  export type eveIconsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the eveIcons
     */
    select?: eveIconsSelect<ExtArgs> | null
    /**
     * Filter, which eveIcons to fetch.
     */
    where: eveIconsWhereUniqueInput
  }


  /**
   * eveIcons findFirst
   */
  export type eveIconsFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the eveIcons
     */
    select?: eveIconsSelect<ExtArgs> | null
    /**
     * Filter, which eveIcons to fetch.
     */
    where?: eveIconsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of eveIcons to fetch.
     */
    orderBy?: eveIconsOrderByWithRelationInput | eveIconsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for eveIcons.
     */
    cursor?: eveIconsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` eveIcons from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` eveIcons.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of eveIcons.
     */
    distinct?: EveIconsScalarFieldEnum | EveIconsScalarFieldEnum[]
  }


  /**
   * eveIcons findFirstOrThrow
   */
  export type eveIconsFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the eveIcons
     */
    select?: eveIconsSelect<ExtArgs> | null
    /**
     * Filter, which eveIcons to fetch.
     */
    where?: eveIconsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of eveIcons to fetch.
     */
    orderBy?: eveIconsOrderByWithRelationInput | eveIconsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for eveIcons.
     */
    cursor?: eveIconsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` eveIcons from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` eveIcons.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of eveIcons.
     */
    distinct?: EveIconsScalarFieldEnum | EveIconsScalarFieldEnum[]
  }


  /**
   * eveIcons findMany
   */
  export type eveIconsFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the eveIcons
     */
    select?: eveIconsSelect<ExtArgs> | null
    /**
     * Filter, which eveIcons to fetch.
     */
    where?: eveIconsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of eveIcons to fetch.
     */
    orderBy?: eveIconsOrderByWithRelationInput | eveIconsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing eveIcons.
     */
    cursor?: eveIconsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` eveIcons from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` eveIcons.
     */
    skip?: number
    distinct?: EveIconsScalarFieldEnum | EveIconsScalarFieldEnum[]
  }


  /**
   * eveIcons create
   */
  export type eveIconsCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the eveIcons
     */
    select?: eveIconsSelect<ExtArgs> | null
    /**
     * The data needed to create a eveIcons.
     */
    data: XOR<eveIconsCreateInput, eveIconsUncheckedCreateInput>
  }


  /**
   * eveIcons createMany
   */
  export type eveIconsCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many eveIcons.
     */
    data: eveIconsCreateManyInput | eveIconsCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * eveIcons update
   */
  export type eveIconsUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the eveIcons
     */
    select?: eveIconsSelect<ExtArgs> | null
    /**
     * The data needed to update a eveIcons.
     */
    data: XOR<eveIconsUpdateInput, eveIconsUncheckedUpdateInput>
    /**
     * Choose, which eveIcons to update.
     */
    where: eveIconsWhereUniqueInput
  }


  /**
   * eveIcons updateMany
   */
  export type eveIconsUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update eveIcons.
     */
    data: XOR<eveIconsUpdateManyMutationInput, eveIconsUncheckedUpdateManyInput>
    /**
     * Filter which eveIcons to update
     */
    where?: eveIconsWhereInput
  }


  /**
   * eveIcons upsert
   */
  export type eveIconsUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the eveIcons
     */
    select?: eveIconsSelect<ExtArgs> | null
    /**
     * The filter to search for the eveIcons to update in case it exists.
     */
    where: eveIconsWhereUniqueInput
    /**
     * In case the eveIcons found by the `where` argument doesn't exist, create a new eveIcons with this data.
     */
    create: XOR<eveIconsCreateInput, eveIconsUncheckedCreateInput>
    /**
     * In case the eveIcons was found with the provided `where` argument, update it with this data.
     */
    update: XOR<eveIconsUpdateInput, eveIconsUncheckedUpdateInput>
  }


  /**
   * eveIcons delete
   */
  export type eveIconsDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the eveIcons
     */
    select?: eveIconsSelect<ExtArgs> | null
    /**
     * Filter which eveIcons to delete.
     */
    where: eveIconsWhereUniqueInput
  }


  /**
   * eveIcons deleteMany
   */
  export type eveIconsDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which eveIcons to delete
     */
    where?: eveIconsWhereInput
  }


  /**
   * eveIcons without action
   */
  export type eveIconsDefaultArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the eveIcons
     */
    select?: eveIconsSelect<ExtArgs> | null
  }



  /**
   * Model eveUnits
   */

  export type AggregateEveUnits = {
    _count: EveUnitsCountAggregateOutputType | null
    _avg: EveUnitsAvgAggregateOutputType | null
    _sum: EveUnitsSumAggregateOutputType | null
    _min: EveUnitsMinAggregateOutputType | null
    _max: EveUnitsMaxAggregateOutputType | null
  }

  export type EveUnitsAvgAggregateOutputType = {
    unitID: number | null
  }

  export type EveUnitsSumAggregateOutputType = {
    unitID: number | null
  }

  export type EveUnitsMinAggregateOutputType = {
    unitID: number | null
    unitName: string | null
    displayName: string | null
    description: string | null
  }

  export type EveUnitsMaxAggregateOutputType = {
    unitID: number | null
    unitName: string | null
    displayName: string | null
    description: string | null
  }

  export type EveUnitsCountAggregateOutputType = {
    unitID: number
    unitName: number
    displayName: number
    description: number
    _all: number
  }


  export type EveUnitsAvgAggregateInputType = {
    unitID?: true
  }

  export type EveUnitsSumAggregateInputType = {
    unitID?: true
  }

  export type EveUnitsMinAggregateInputType = {
    unitID?: true
    unitName?: true
    displayName?: true
    description?: true
  }

  export type EveUnitsMaxAggregateInputType = {
    unitID?: true
    unitName?: true
    displayName?: true
    description?: true
  }

  export type EveUnitsCountAggregateInputType = {
    unitID?: true
    unitName?: true
    displayName?: true
    description?: true
    _all?: true
  }

  export type EveUnitsAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which eveUnits to aggregate.
     */
    where?: eveUnitsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of eveUnits to fetch.
     */
    orderBy?: eveUnitsOrderByWithRelationInput | eveUnitsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: eveUnitsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` eveUnits from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` eveUnits.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned eveUnits
    **/
    _count?: true | EveUnitsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: EveUnitsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: EveUnitsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EveUnitsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EveUnitsMaxAggregateInputType
  }

  export type GetEveUnitsAggregateType<T extends EveUnitsAggregateArgs> = {
        [P in keyof T & keyof AggregateEveUnits]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEveUnits[P]>
      : GetScalarType<T[P], AggregateEveUnits[P]>
  }




  export type eveUnitsGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: eveUnitsWhereInput
    orderBy?: eveUnitsOrderByWithAggregationInput | eveUnitsOrderByWithAggregationInput[]
    by: EveUnitsScalarFieldEnum[] | EveUnitsScalarFieldEnum
    having?: eveUnitsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EveUnitsCountAggregateInputType | true
    _avg?: EveUnitsAvgAggregateInputType
    _sum?: EveUnitsSumAggregateInputType
    _min?: EveUnitsMinAggregateInputType
    _max?: EveUnitsMaxAggregateInputType
  }

  export type EveUnitsGroupByOutputType = {
    unitID: number
    unitName: string | null
    displayName: string | null
    description: string | null
    _count: EveUnitsCountAggregateOutputType | null
    _avg: EveUnitsAvgAggregateOutputType | null
    _sum: EveUnitsSumAggregateOutputType | null
    _min: EveUnitsMinAggregateOutputType | null
    _max: EveUnitsMaxAggregateOutputType | null
  }

  type GetEveUnitsGroupByPayload<T extends eveUnitsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EveUnitsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EveUnitsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EveUnitsGroupByOutputType[P]>
            : GetScalarType<T[P], EveUnitsGroupByOutputType[P]>
        }
      >
    >


  export type eveUnitsSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    unitID?: boolean
    unitName?: boolean
    displayName?: boolean
    description?: boolean
  }, ExtArgs["result"]["eveUnits"]>

  export type eveUnitsSelectScalar = {
    unitID?: boolean
    unitName?: boolean
    displayName?: boolean
    description?: boolean
  }


  export type $eveUnitsPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    name: "eveUnits"
    objects: {}
    scalars: $Extensions.GetResult<{
      unitID: number
      unitName: string | null
      displayName: string | null
      description: string | null
    }, ExtArgs["result"]["eveUnits"]>
    composites: {}
  }


  type eveUnitsGetPayload<S extends boolean | null | undefined | eveUnitsDefaultArgs> = $Result.GetResult<Prisma.$eveUnitsPayload, S>

  type eveUnitsCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<eveUnitsFindManyArgs, 'select' | 'include'> & {
      select?: EveUnitsCountAggregateInputType | true
    }

  export interface eveUnitsDelegate<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['eveUnits'], meta: { name: 'eveUnits' } }
    /**
     * Find zero or one EveUnits that matches the filter.
     * @param {eveUnitsFindUniqueArgs} args - Arguments to find a EveUnits
     * @example
     * // Get one EveUnits
     * const eveUnits = await prisma.eveUnits.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends eveUnitsFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, eveUnitsFindUniqueArgs<ExtArgs>>
    ): Prisma__eveUnitsClient<$Result.GetResult<Prisma.$eveUnitsPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one EveUnits that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {eveUnitsFindUniqueOrThrowArgs} args - Arguments to find a EveUnits
     * @example
     * // Get one EveUnits
     * const eveUnits = await prisma.eveUnits.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends eveUnitsFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, eveUnitsFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__eveUnitsClient<$Result.GetResult<Prisma.$eveUnitsPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first EveUnits that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {eveUnitsFindFirstArgs} args - Arguments to find a EveUnits
     * @example
     * // Get one EveUnits
     * const eveUnits = await prisma.eveUnits.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends eveUnitsFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, eveUnitsFindFirstArgs<ExtArgs>>
    ): Prisma__eveUnitsClient<$Result.GetResult<Prisma.$eveUnitsPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first EveUnits that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {eveUnitsFindFirstOrThrowArgs} args - Arguments to find a EveUnits
     * @example
     * // Get one EveUnits
     * const eveUnits = await prisma.eveUnits.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends eveUnitsFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, eveUnitsFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__eveUnitsClient<$Result.GetResult<Prisma.$eveUnitsPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more EveUnits that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {eveUnitsFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all EveUnits
     * const eveUnits = await prisma.eveUnits.findMany()
     * 
     * // Get first 10 EveUnits
     * const eveUnits = await prisma.eveUnits.findMany({ take: 10 })
     * 
     * // Only select the `unitID`
     * const eveUnitsWithUnitIDOnly = await prisma.eveUnits.findMany({ select: { unitID: true } })
     * 
    **/
    findMany<T extends eveUnitsFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, eveUnitsFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$eveUnitsPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a EveUnits.
     * @param {eveUnitsCreateArgs} args - Arguments to create a EveUnits.
     * @example
     * // Create one EveUnits
     * const EveUnits = await prisma.eveUnits.create({
     *   data: {
     *     // ... data to create a EveUnits
     *   }
     * })
     * 
    **/
    create<T extends eveUnitsCreateArgs<ExtArgs>>(
      args: SelectSubset<T, eveUnitsCreateArgs<ExtArgs>>
    ): Prisma__eveUnitsClient<$Result.GetResult<Prisma.$eveUnitsPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many EveUnits.
     *     @param {eveUnitsCreateManyArgs} args - Arguments to create many EveUnits.
     *     @example
     *     // Create many EveUnits
     *     const eveUnits = await prisma.eveUnits.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends eveUnitsCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, eveUnitsCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a EveUnits.
     * @param {eveUnitsDeleteArgs} args - Arguments to delete one EveUnits.
     * @example
     * // Delete one EveUnits
     * const EveUnits = await prisma.eveUnits.delete({
     *   where: {
     *     // ... filter to delete one EveUnits
     *   }
     * })
     * 
    **/
    delete<T extends eveUnitsDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, eveUnitsDeleteArgs<ExtArgs>>
    ): Prisma__eveUnitsClient<$Result.GetResult<Prisma.$eveUnitsPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one EveUnits.
     * @param {eveUnitsUpdateArgs} args - Arguments to update one EveUnits.
     * @example
     * // Update one EveUnits
     * const eveUnits = await prisma.eveUnits.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends eveUnitsUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, eveUnitsUpdateArgs<ExtArgs>>
    ): Prisma__eveUnitsClient<$Result.GetResult<Prisma.$eveUnitsPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more EveUnits.
     * @param {eveUnitsDeleteManyArgs} args - Arguments to filter EveUnits to delete.
     * @example
     * // Delete a few EveUnits
     * const { count } = await prisma.eveUnits.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends eveUnitsDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, eveUnitsDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EveUnits.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {eveUnitsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many EveUnits
     * const eveUnits = await prisma.eveUnits.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends eveUnitsUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, eveUnitsUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one EveUnits.
     * @param {eveUnitsUpsertArgs} args - Arguments to update or create a EveUnits.
     * @example
     * // Update or create a EveUnits
     * const eveUnits = await prisma.eveUnits.upsert({
     *   create: {
     *     // ... data to create a EveUnits
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the EveUnits we want to update
     *   }
     * })
    **/
    upsert<T extends eveUnitsUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, eveUnitsUpsertArgs<ExtArgs>>
    ): Prisma__eveUnitsClient<$Result.GetResult<Prisma.$eveUnitsPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of EveUnits.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {eveUnitsCountArgs} args - Arguments to filter EveUnits to count.
     * @example
     * // Count the number of EveUnits
     * const count = await prisma.eveUnits.count({
     *   where: {
     *     // ... the filter for the EveUnits we want to count
     *   }
     * })
    **/
    count<T extends eveUnitsCountArgs>(
      args?: Subset<T, eveUnitsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EveUnitsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a EveUnits.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EveUnitsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EveUnitsAggregateArgs>(args: Subset<T, EveUnitsAggregateArgs>): Prisma.PrismaPromise<GetEveUnitsAggregateType<T>>

    /**
     * Group by EveUnits.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {eveUnitsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends eveUnitsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: eveUnitsGroupByArgs['orderBy'] }
        : { orderBy?: eveUnitsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, eveUnitsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEveUnitsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the eveUnits model
   */
  readonly fields: eveUnitsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for eveUnits.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__eveUnitsClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';


    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the eveUnits model
   */ 
  interface eveUnitsFieldRefs {
    readonly unitID: FieldRef<"eveUnits", 'Int'>
    readonly unitName: FieldRef<"eveUnits", 'String'>
    readonly displayName: FieldRef<"eveUnits", 'String'>
    readonly description: FieldRef<"eveUnits", 'String'>
  }
    

  // Custom InputTypes

  /**
   * eveUnits findUnique
   */
  export type eveUnitsFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the eveUnits
     */
    select?: eveUnitsSelect<ExtArgs> | null
    /**
     * Filter, which eveUnits to fetch.
     */
    where: eveUnitsWhereUniqueInput
  }


  /**
   * eveUnits findUniqueOrThrow
   */
  export type eveUnitsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the eveUnits
     */
    select?: eveUnitsSelect<ExtArgs> | null
    /**
     * Filter, which eveUnits to fetch.
     */
    where: eveUnitsWhereUniqueInput
  }


  /**
   * eveUnits findFirst
   */
  export type eveUnitsFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the eveUnits
     */
    select?: eveUnitsSelect<ExtArgs> | null
    /**
     * Filter, which eveUnits to fetch.
     */
    where?: eveUnitsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of eveUnits to fetch.
     */
    orderBy?: eveUnitsOrderByWithRelationInput | eveUnitsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for eveUnits.
     */
    cursor?: eveUnitsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` eveUnits from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` eveUnits.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of eveUnits.
     */
    distinct?: EveUnitsScalarFieldEnum | EveUnitsScalarFieldEnum[]
  }


  /**
   * eveUnits findFirstOrThrow
   */
  export type eveUnitsFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the eveUnits
     */
    select?: eveUnitsSelect<ExtArgs> | null
    /**
     * Filter, which eveUnits to fetch.
     */
    where?: eveUnitsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of eveUnits to fetch.
     */
    orderBy?: eveUnitsOrderByWithRelationInput | eveUnitsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for eveUnits.
     */
    cursor?: eveUnitsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` eveUnits from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` eveUnits.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of eveUnits.
     */
    distinct?: EveUnitsScalarFieldEnum | EveUnitsScalarFieldEnum[]
  }


  /**
   * eveUnits findMany
   */
  export type eveUnitsFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the eveUnits
     */
    select?: eveUnitsSelect<ExtArgs> | null
    /**
     * Filter, which eveUnits to fetch.
     */
    where?: eveUnitsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of eveUnits to fetch.
     */
    orderBy?: eveUnitsOrderByWithRelationInput | eveUnitsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing eveUnits.
     */
    cursor?: eveUnitsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` eveUnits from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` eveUnits.
     */
    skip?: number
    distinct?: EveUnitsScalarFieldEnum | EveUnitsScalarFieldEnum[]
  }


  /**
   * eveUnits create
   */
  export type eveUnitsCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the eveUnits
     */
    select?: eveUnitsSelect<ExtArgs> | null
    /**
     * The data needed to create a eveUnits.
     */
    data: XOR<eveUnitsCreateInput, eveUnitsUncheckedCreateInput>
  }


  /**
   * eveUnits createMany
   */
  export type eveUnitsCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many eveUnits.
     */
    data: eveUnitsCreateManyInput | eveUnitsCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * eveUnits update
   */
  export type eveUnitsUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the eveUnits
     */
    select?: eveUnitsSelect<ExtArgs> | null
    /**
     * The data needed to update a eveUnits.
     */
    data: XOR<eveUnitsUpdateInput, eveUnitsUncheckedUpdateInput>
    /**
     * Choose, which eveUnits to update.
     */
    where: eveUnitsWhereUniqueInput
  }


  /**
   * eveUnits updateMany
   */
  export type eveUnitsUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update eveUnits.
     */
    data: XOR<eveUnitsUpdateManyMutationInput, eveUnitsUncheckedUpdateManyInput>
    /**
     * Filter which eveUnits to update
     */
    where?: eveUnitsWhereInput
  }


  /**
   * eveUnits upsert
   */
  export type eveUnitsUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the eveUnits
     */
    select?: eveUnitsSelect<ExtArgs> | null
    /**
     * The filter to search for the eveUnits to update in case it exists.
     */
    where: eveUnitsWhereUniqueInput
    /**
     * In case the eveUnits found by the `where` argument doesn't exist, create a new eveUnits with this data.
     */
    create: XOR<eveUnitsCreateInput, eveUnitsUncheckedCreateInput>
    /**
     * In case the eveUnits was found with the provided `where` argument, update it with this data.
     */
    update: XOR<eveUnitsUpdateInput, eveUnitsUncheckedUpdateInput>
  }


  /**
   * eveUnits delete
   */
  export type eveUnitsDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the eveUnits
     */
    select?: eveUnitsSelect<ExtArgs> | null
    /**
     * Filter which eveUnits to delete.
     */
    where: eveUnitsWhereUniqueInput
  }


  /**
   * eveUnits deleteMany
   */
  export type eveUnitsDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which eveUnits to delete
     */
    where?: eveUnitsWhereInput
  }


  /**
   * eveUnits without action
   */
  export type eveUnitsDefaultArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the eveUnits
     */
    select?: eveUnitsSelect<ExtArgs> | null
  }



  /**
   * Model industryActivity
   */

  export type AggregateIndustryActivity = {
    _count: IndustryActivityCountAggregateOutputType | null
    _avg: IndustryActivityAvgAggregateOutputType | null
    _sum: IndustryActivitySumAggregateOutputType | null
    _min: IndustryActivityMinAggregateOutputType | null
    _max: IndustryActivityMaxAggregateOutputType | null
  }

  export type IndustryActivityAvgAggregateOutputType = {
    typeID: number | null
    activityID: number | null
    time: number | null
  }

  export type IndustryActivitySumAggregateOutputType = {
    typeID: number | null
    activityID: number | null
    time: number | null
  }

  export type IndustryActivityMinAggregateOutputType = {
    typeID: number | null
    activityID: number | null
    time: number | null
  }

  export type IndustryActivityMaxAggregateOutputType = {
    typeID: number | null
    activityID: number | null
    time: number | null
  }

  export type IndustryActivityCountAggregateOutputType = {
    typeID: number
    activityID: number
    time: number
    _all: number
  }


  export type IndustryActivityAvgAggregateInputType = {
    typeID?: true
    activityID?: true
    time?: true
  }

  export type IndustryActivitySumAggregateInputType = {
    typeID?: true
    activityID?: true
    time?: true
  }

  export type IndustryActivityMinAggregateInputType = {
    typeID?: true
    activityID?: true
    time?: true
  }

  export type IndustryActivityMaxAggregateInputType = {
    typeID?: true
    activityID?: true
    time?: true
  }

  export type IndustryActivityCountAggregateInputType = {
    typeID?: true
    activityID?: true
    time?: true
    _all?: true
  }

  export type IndustryActivityAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which industryActivity to aggregate.
     */
    where?: industryActivityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of industryActivities to fetch.
     */
    orderBy?: industryActivityOrderByWithRelationInput | industryActivityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: industryActivityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` industryActivities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` industryActivities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned industryActivities
    **/
    _count?: true | IndustryActivityCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: IndustryActivityAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: IndustryActivitySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: IndustryActivityMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: IndustryActivityMaxAggregateInputType
  }

  export type GetIndustryActivityAggregateType<T extends IndustryActivityAggregateArgs> = {
        [P in keyof T & keyof AggregateIndustryActivity]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateIndustryActivity[P]>
      : GetScalarType<T[P], AggregateIndustryActivity[P]>
  }




  export type industryActivityGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: industryActivityWhereInput
    orderBy?: industryActivityOrderByWithAggregationInput | industryActivityOrderByWithAggregationInput[]
    by: IndustryActivityScalarFieldEnum[] | IndustryActivityScalarFieldEnum
    having?: industryActivityScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: IndustryActivityCountAggregateInputType | true
    _avg?: IndustryActivityAvgAggregateInputType
    _sum?: IndustryActivitySumAggregateInputType
    _min?: IndustryActivityMinAggregateInputType
    _max?: IndustryActivityMaxAggregateInputType
  }

  export type IndustryActivityGroupByOutputType = {
    typeID: number
    activityID: number
    time: number | null
    _count: IndustryActivityCountAggregateOutputType | null
    _avg: IndustryActivityAvgAggregateOutputType | null
    _sum: IndustryActivitySumAggregateOutputType | null
    _min: IndustryActivityMinAggregateOutputType | null
    _max: IndustryActivityMaxAggregateOutputType | null
  }

  type GetIndustryActivityGroupByPayload<T extends industryActivityGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<IndustryActivityGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof IndustryActivityGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], IndustryActivityGroupByOutputType[P]>
            : GetScalarType<T[P], IndustryActivityGroupByOutputType[P]>
        }
      >
    >


  export type industryActivitySelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    typeID?: boolean
    activityID?: boolean
    time?: boolean
  }, ExtArgs["result"]["industryActivity"]>

  export type industryActivitySelectScalar = {
    typeID?: boolean
    activityID?: boolean
    time?: boolean
  }


  export type $industryActivityPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    name: "industryActivity"
    objects: {}
    scalars: $Extensions.GetResult<{
      typeID: number
      activityID: number
      time: number | null
    }, ExtArgs["result"]["industryActivity"]>
    composites: {}
  }


  type industryActivityGetPayload<S extends boolean | null | undefined | industryActivityDefaultArgs> = $Result.GetResult<Prisma.$industryActivityPayload, S>

  type industryActivityCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<industryActivityFindManyArgs, 'select' | 'include'> & {
      select?: IndustryActivityCountAggregateInputType | true
    }

  export interface industryActivityDelegate<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['industryActivity'], meta: { name: 'industryActivity' } }
    /**
     * Find zero or one IndustryActivity that matches the filter.
     * @param {industryActivityFindUniqueArgs} args - Arguments to find a IndustryActivity
     * @example
     * // Get one IndustryActivity
     * const industryActivity = await prisma.industryActivity.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends industryActivityFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, industryActivityFindUniqueArgs<ExtArgs>>
    ): Prisma__industryActivityClient<$Result.GetResult<Prisma.$industryActivityPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one IndustryActivity that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {industryActivityFindUniqueOrThrowArgs} args - Arguments to find a IndustryActivity
     * @example
     * // Get one IndustryActivity
     * const industryActivity = await prisma.industryActivity.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends industryActivityFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, industryActivityFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__industryActivityClient<$Result.GetResult<Prisma.$industryActivityPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first IndustryActivity that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {industryActivityFindFirstArgs} args - Arguments to find a IndustryActivity
     * @example
     * // Get one IndustryActivity
     * const industryActivity = await prisma.industryActivity.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends industryActivityFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, industryActivityFindFirstArgs<ExtArgs>>
    ): Prisma__industryActivityClient<$Result.GetResult<Prisma.$industryActivityPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first IndustryActivity that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {industryActivityFindFirstOrThrowArgs} args - Arguments to find a IndustryActivity
     * @example
     * // Get one IndustryActivity
     * const industryActivity = await prisma.industryActivity.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends industryActivityFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, industryActivityFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__industryActivityClient<$Result.GetResult<Prisma.$industryActivityPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more IndustryActivities that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {industryActivityFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all IndustryActivities
     * const industryActivities = await prisma.industryActivity.findMany()
     * 
     * // Get first 10 IndustryActivities
     * const industryActivities = await prisma.industryActivity.findMany({ take: 10 })
     * 
     * // Only select the `typeID`
     * const industryActivityWithTypeIDOnly = await prisma.industryActivity.findMany({ select: { typeID: true } })
     * 
    **/
    findMany<T extends industryActivityFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, industryActivityFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$industryActivityPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a IndustryActivity.
     * @param {industryActivityCreateArgs} args - Arguments to create a IndustryActivity.
     * @example
     * // Create one IndustryActivity
     * const IndustryActivity = await prisma.industryActivity.create({
     *   data: {
     *     // ... data to create a IndustryActivity
     *   }
     * })
     * 
    **/
    create<T extends industryActivityCreateArgs<ExtArgs>>(
      args: SelectSubset<T, industryActivityCreateArgs<ExtArgs>>
    ): Prisma__industryActivityClient<$Result.GetResult<Prisma.$industryActivityPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many IndustryActivities.
     *     @param {industryActivityCreateManyArgs} args - Arguments to create many IndustryActivities.
     *     @example
     *     // Create many IndustryActivities
     *     const industryActivity = await prisma.industryActivity.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends industryActivityCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, industryActivityCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a IndustryActivity.
     * @param {industryActivityDeleteArgs} args - Arguments to delete one IndustryActivity.
     * @example
     * // Delete one IndustryActivity
     * const IndustryActivity = await prisma.industryActivity.delete({
     *   where: {
     *     // ... filter to delete one IndustryActivity
     *   }
     * })
     * 
    **/
    delete<T extends industryActivityDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, industryActivityDeleteArgs<ExtArgs>>
    ): Prisma__industryActivityClient<$Result.GetResult<Prisma.$industryActivityPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one IndustryActivity.
     * @param {industryActivityUpdateArgs} args - Arguments to update one IndustryActivity.
     * @example
     * // Update one IndustryActivity
     * const industryActivity = await prisma.industryActivity.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends industryActivityUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, industryActivityUpdateArgs<ExtArgs>>
    ): Prisma__industryActivityClient<$Result.GetResult<Prisma.$industryActivityPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more IndustryActivities.
     * @param {industryActivityDeleteManyArgs} args - Arguments to filter IndustryActivities to delete.
     * @example
     * // Delete a few IndustryActivities
     * const { count } = await prisma.industryActivity.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends industryActivityDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, industryActivityDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more IndustryActivities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {industryActivityUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many IndustryActivities
     * const industryActivity = await prisma.industryActivity.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends industryActivityUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, industryActivityUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one IndustryActivity.
     * @param {industryActivityUpsertArgs} args - Arguments to update or create a IndustryActivity.
     * @example
     * // Update or create a IndustryActivity
     * const industryActivity = await prisma.industryActivity.upsert({
     *   create: {
     *     // ... data to create a IndustryActivity
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the IndustryActivity we want to update
     *   }
     * })
    **/
    upsert<T extends industryActivityUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, industryActivityUpsertArgs<ExtArgs>>
    ): Prisma__industryActivityClient<$Result.GetResult<Prisma.$industryActivityPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of IndustryActivities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {industryActivityCountArgs} args - Arguments to filter IndustryActivities to count.
     * @example
     * // Count the number of IndustryActivities
     * const count = await prisma.industryActivity.count({
     *   where: {
     *     // ... the filter for the IndustryActivities we want to count
     *   }
     * })
    **/
    count<T extends industryActivityCountArgs>(
      args?: Subset<T, industryActivityCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], IndustryActivityCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a IndustryActivity.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IndustryActivityAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends IndustryActivityAggregateArgs>(args: Subset<T, IndustryActivityAggregateArgs>): Prisma.PrismaPromise<GetIndustryActivityAggregateType<T>>

    /**
     * Group by IndustryActivity.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {industryActivityGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends industryActivityGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: industryActivityGroupByArgs['orderBy'] }
        : { orderBy?: industryActivityGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, industryActivityGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetIndustryActivityGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the industryActivity model
   */
  readonly fields: industryActivityFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for industryActivity.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__industryActivityClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';


    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the industryActivity model
   */ 
  interface industryActivityFieldRefs {
    readonly typeID: FieldRef<"industryActivity", 'Int'>
    readonly activityID: FieldRef<"industryActivity", 'Int'>
    readonly time: FieldRef<"industryActivity", 'Int'>
  }
    

  // Custom InputTypes

  /**
   * industryActivity findUnique
   */
  export type industryActivityFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the industryActivity
     */
    select?: industryActivitySelect<ExtArgs> | null
    /**
     * Filter, which industryActivity to fetch.
     */
    where: industryActivityWhereUniqueInput
  }


  /**
   * industryActivity findUniqueOrThrow
   */
  export type industryActivityFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the industryActivity
     */
    select?: industryActivitySelect<ExtArgs> | null
    /**
     * Filter, which industryActivity to fetch.
     */
    where: industryActivityWhereUniqueInput
  }


  /**
   * industryActivity findFirst
   */
  export type industryActivityFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the industryActivity
     */
    select?: industryActivitySelect<ExtArgs> | null
    /**
     * Filter, which industryActivity to fetch.
     */
    where?: industryActivityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of industryActivities to fetch.
     */
    orderBy?: industryActivityOrderByWithRelationInput | industryActivityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for industryActivities.
     */
    cursor?: industryActivityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` industryActivities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` industryActivities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of industryActivities.
     */
    distinct?: IndustryActivityScalarFieldEnum | IndustryActivityScalarFieldEnum[]
  }


  /**
   * industryActivity findFirstOrThrow
   */
  export type industryActivityFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the industryActivity
     */
    select?: industryActivitySelect<ExtArgs> | null
    /**
     * Filter, which industryActivity to fetch.
     */
    where?: industryActivityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of industryActivities to fetch.
     */
    orderBy?: industryActivityOrderByWithRelationInput | industryActivityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for industryActivities.
     */
    cursor?: industryActivityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` industryActivities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` industryActivities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of industryActivities.
     */
    distinct?: IndustryActivityScalarFieldEnum | IndustryActivityScalarFieldEnum[]
  }


  /**
   * industryActivity findMany
   */
  export type industryActivityFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the industryActivity
     */
    select?: industryActivitySelect<ExtArgs> | null
    /**
     * Filter, which industryActivities to fetch.
     */
    where?: industryActivityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of industryActivities to fetch.
     */
    orderBy?: industryActivityOrderByWithRelationInput | industryActivityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing industryActivities.
     */
    cursor?: industryActivityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` industryActivities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` industryActivities.
     */
    skip?: number
    distinct?: IndustryActivityScalarFieldEnum | IndustryActivityScalarFieldEnum[]
  }


  /**
   * industryActivity create
   */
  export type industryActivityCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the industryActivity
     */
    select?: industryActivitySelect<ExtArgs> | null
    /**
     * The data needed to create a industryActivity.
     */
    data: XOR<industryActivityCreateInput, industryActivityUncheckedCreateInput>
  }


  /**
   * industryActivity createMany
   */
  export type industryActivityCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many industryActivities.
     */
    data: industryActivityCreateManyInput | industryActivityCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * industryActivity update
   */
  export type industryActivityUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the industryActivity
     */
    select?: industryActivitySelect<ExtArgs> | null
    /**
     * The data needed to update a industryActivity.
     */
    data: XOR<industryActivityUpdateInput, industryActivityUncheckedUpdateInput>
    /**
     * Choose, which industryActivity to update.
     */
    where: industryActivityWhereUniqueInput
  }


  /**
   * industryActivity updateMany
   */
  export type industryActivityUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update industryActivities.
     */
    data: XOR<industryActivityUpdateManyMutationInput, industryActivityUncheckedUpdateManyInput>
    /**
     * Filter which industryActivities to update
     */
    where?: industryActivityWhereInput
  }


  /**
   * industryActivity upsert
   */
  export type industryActivityUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the industryActivity
     */
    select?: industryActivitySelect<ExtArgs> | null
    /**
     * The filter to search for the industryActivity to update in case it exists.
     */
    where: industryActivityWhereUniqueInput
    /**
     * In case the industryActivity found by the `where` argument doesn't exist, create a new industryActivity with this data.
     */
    create: XOR<industryActivityCreateInput, industryActivityUncheckedCreateInput>
    /**
     * In case the industryActivity was found with the provided `where` argument, update it with this data.
     */
    update: XOR<industryActivityUpdateInput, industryActivityUncheckedUpdateInput>
  }


  /**
   * industryActivity delete
   */
  export type industryActivityDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the industryActivity
     */
    select?: industryActivitySelect<ExtArgs> | null
    /**
     * Filter which industryActivity to delete.
     */
    where: industryActivityWhereUniqueInput
  }


  /**
   * industryActivity deleteMany
   */
  export type industryActivityDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which industryActivities to delete
     */
    where?: industryActivityWhereInput
  }


  /**
   * industryActivity without action
   */
  export type industryActivityDefaultArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the industryActivity
     */
    select?: industryActivitySelect<ExtArgs> | null
  }



  /**
   * Model industryBlueprints
   */

  export type AggregateIndustryBlueprints = {
    _count: IndustryBlueprintsCountAggregateOutputType | null
    _avg: IndustryBlueprintsAvgAggregateOutputType | null
    _sum: IndustryBlueprintsSumAggregateOutputType | null
    _min: IndustryBlueprintsMinAggregateOutputType | null
    _max: IndustryBlueprintsMaxAggregateOutputType | null
  }

  export type IndustryBlueprintsAvgAggregateOutputType = {
    typeID: number | null
    maxProductionLimit: number | null
  }

  export type IndustryBlueprintsSumAggregateOutputType = {
    typeID: number | null
    maxProductionLimit: number | null
  }

  export type IndustryBlueprintsMinAggregateOutputType = {
    typeID: number | null
    maxProductionLimit: number | null
  }

  export type IndustryBlueprintsMaxAggregateOutputType = {
    typeID: number | null
    maxProductionLimit: number | null
  }

  export type IndustryBlueprintsCountAggregateOutputType = {
    typeID: number
    maxProductionLimit: number
    _all: number
  }


  export type IndustryBlueprintsAvgAggregateInputType = {
    typeID?: true
    maxProductionLimit?: true
  }

  export type IndustryBlueprintsSumAggregateInputType = {
    typeID?: true
    maxProductionLimit?: true
  }

  export type IndustryBlueprintsMinAggregateInputType = {
    typeID?: true
    maxProductionLimit?: true
  }

  export type IndustryBlueprintsMaxAggregateInputType = {
    typeID?: true
    maxProductionLimit?: true
  }

  export type IndustryBlueprintsCountAggregateInputType = {
    typeID?: true
    maxProductionLimit?: true
    _all?: true
  }

  export type IndustryBlueprintsAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which industryBlueprints to aggregate.
     */
    where?: industryBlueprintsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of industryBlueprints to fetch.
     */
    orderBy?: industryBlueprintsOrderByWithRelationInput | industryBlueprintsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: industryBlueprintsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` industryBlueprints from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` industryBlueprints.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned industryBlueprints
    **/
    _count?: true | IndustryBlueprintsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: IndustryBlueprintsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: IndustryBlueprintsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: IndustryBlueprintsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: IndustryBlueprintsMaxAggregateInputType
  }

  export type GetIndustryBlueprintsAggregateType<T extends IndustryBlueprintsAggregateArgs> = {
        [P in keyof T & keyof AggregateIndustryBlueprints]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateIndustryBlueprints[P]>
      : GetScalarType<T[P], AggregateIndustryBlueprints[P]>
  }




  export type industryBlueprintsGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: industryBlueprintsWhereInput
    orderBy?: industryBlueprintsOrderByWithAggregationInput | industryBlueprintsOrderByWithAggregationInput[]
    by: IndustryBlueprintsScalarFieldEnum[] | IndustryBlueprintsScalarFieldEnum
    having?: industryBlueprintsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: IndustryBlueprintsCountAggregateInputType | true
    _avg?: IndustryBlueprintsAvgAggregateInputType
    _sum?: IndustryBlueprintsSumAggregateInputType
    _min?: IndustryBlueprintsMinAggregateInputType
    _max?: IndustryBlueprintsMaxAggregateInputType
  }

  export type IndustryBlueprintsGroupByOutputType = {
    typeID: number
    maxProductionLimit: number | null
    _count: IndustryBlueprintsCountAggregateOutputType | null
    _avg: IndustryBlueprintsAvgAggregateOutputType | null
    _sum: IndustryBlueprintsSumAggregateOutputType | null
    _min: IndustryBlueprintsMinAggregateOutputType | null
    _max: IndustryBlueprintsMaxAggregateOutputType | null
  }

  type GetIndustryBlueprintsGroupByPayload<T extends industryBlueprintsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<IndustryBlueprintsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof IndustryBlueprintsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], IndustryBlueprintsGroupByOutputType[P]>
            : GetScalarType<T[P], IndustryBlueprintsGroupByOutputType[P]>
        }
      >
    >


  export type industryBlueprintsSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    typeID?: boolean
    maxProductionLimit?: boolean
  }, ExtArgs["result"]["industryBlueprints"]>

  export type industryBlueprintsSelectScalar = {
    typeID?: boolean
    maxProductionLimit?: boolean
  }


  export type $industryBlueprintsPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    name: "industryBlueprints"
    objects: {}
    scalars: $Extensions.GetResult<{
      typeID: number
      maxProductionLimit: number | null
    }, ExtArgs["result"]["industryBlueprints"]>
    composites: {}
  }


  type industryBlueprintsGetPayload<S extends boolean | null | undefined | industryBlueprintsDefaultArgs> = $Result.GetResult<Prisma.$industryBlueprintsPayload, S>

  type industryBlueprintsCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<industryBlueprintsFindManyArgs, 'select' | 'include'> & {
      select?: IndustryBlueprintsCountAggregateInputType | true
    }

  export interface industryBlueprintsDelegate<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['industryBlueprints'], meta: { name: 'industryBlueprints' } }
    /**
     * Find zero or one IndustryBlueprints that matches the filter.
     * @param {industryBlueprintsFindUniqueArgs} args - Arguments to find a IndustryBlueprints
     * @example
     * // Get one IndustryBlueprints
     * const industryBlueprints = await prisma.industryBlueprints.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends industryBlueprintsFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, industryBlueprintsFindUniqueArgs<ExtArgs>>
    ): Prisma__industryBlueprintsClient<$Result.GetResult<Prisma.$industryBlueprintsPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one IndustryBlueprints that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {industryBlueprintsFindUniqueOrThrowArgs} args - Arguments to find a IndustryBlueprints
     * @example
     * // Get one IndustryBlueprints
     * const industryBlueprints = await prisma.industryBlueprints.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends industryBlueprintsFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, industryBlueprintsFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__industryBlueprintsClient<$Result.GetResult<Prisma.$industryBlueprintsPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first IndustryBlueprints that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {industryBlueprintsFindFirstArgs} args - Arguments to find a IndustryBlueprints
     * @example
     * // Get one IndustryBlueprints
     * const industryBlueprints = await prisma.industryBlueprints.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends industryBlueprintsFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, industryBlueprintsFindFirstArgs<ExtArgs>>
    ): Prisma__industryBlueprintsClient<$Result.GetResult<Prisma.$industryBlueprintsPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first IndustryBlueprints that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {industryBlueprintsFindFirstOrThrowArgs} args - Arguments to find a IndustryBlueprints
     * @example
     * // Get one IndustryBlueprints
     * const industryBlueprints = await prisma.industryBlueprints.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends industryBlueprintsFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, industryBlueprintsFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__industryBlueprintsClient<$Result.GetResult<Prisma.$industryBlueprintsPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more IndustryBlueprints that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {industryBlueprintsFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all IndustryBlueprints
     * const industryBlueprints = await prisma.industryBlueprints.findMany()
     * 
     * // Get first 10 IndustryBlueprints
     * const industryBlueprints = await prisma.industryBlueprints.findMany({ take: 10 })
     * 
     * // Only select the `typeID`
     * const industryBlueprintsWithTypeIDOnly = await prisma.industryBlueprints.findMany({ select: { typeID: true } })
     * 
    **/
    findMany<T extends industryBlueprintsFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, industryBlueprintsFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$industryBlueprintsPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a IndustryBlueprints.
     * @param {industryBlueprintsCreateArgs} args - Arguments to create a IndustryBlueprints.
     * @example
     * // Create one IndustryBlueprints
     * const IndustryBlueprints = await prisma.industryBlueprints.create({
     *   data: {
     *     // ... data to create a IndustryBlueprints
     *   }
     * })
     * 
    **/
    create<T extends industryBlueprintsCreateArgs<ExtArgs>>(
      args: SelectSubset<T, industryBlueprintsCreateArgs<ExtArgs>>
    ): Prisma__industryBlueprintsClient<$Result.GetResult<Prisma.$industryBlueprintsPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many IndustryBlueprints.
     *     @param {industryBlueprintsCreateManyArgs} args - Arguments to create many IndustryBlueprints.
     *     @example
     *     // Create many IndustryBlueprints
     *     const industryBlueprints = await prisma.industryBlueprints.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends industryBlueprintsCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, industryBlueprintsCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a IndustryBlueprints.
     * @param {industryBlueprintsDeleteArgs} args - Arguments to delete one IndustryBlueprints.
     * @example
     * // Delete one IndustryBlueprints
     * const IndustryBlueprints = await prisma.industryBlueprints.delete({
     *   where: {
     *     // ... filter to delete one IndustryBlueprints
     *   }
     * })
     * 
    **/
    delete<T extends industryBlueprintsDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, industryBlueprintsDeleteArgs<ExtArgs>>
    ): Prisma__industryBlueprintsClient<$Result.GetResult<Prisma.$industryBlueprintsPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one IndustryBlueprints.
     * @param {industryBlueprintsUpdateArgs} args - Arguments to update one IndustryBlueprints.
     * @example
     * // Update one IndustryBlueprints
     * const industryBlueprints = await prisma.industryBlueprints.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends industryBlueprintsUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, industryBlueprintsUpdateArgs<ExtArgs>>
    ): Prisma__industryBlueprintsClient<$Result.GetResult<Prisma.$industryBlueprintsPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more IndustryBlueprints.
     * @param {industryBlueprintsDeleteManyArgs} args - Arguments to filter IndustryBlueprints to delete.
     * @example
     * // Delete a few IndustryBlueprints
     * const { count } = await prisma.industryBlueprints.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends industryBlueprintsDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, industryBlueprintsDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more IndustryBlueprints.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {industryBlueprintsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many IndustryBlueprints
     * const industryBlueprints = await prisma.industryBlueprints.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends industryBlueprintsUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, industryBlueprintsUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one IndustryBlueprints.
     * @param {industryBlueprintsUpsertArgs} args - Arguments to update or create a IndustryBlueprints.
     * @example
     * // Update or create a IndustryBlueprints
     * const industryBlueprints = await prisma.industryBlueprints.upsert({
     *   create: {
     *     // ... data to create a IndustryBlueprints
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the IndustryBlueprints we want to update
     *   }
     * })
    **/
    upsert<T extends industryBlueprintsUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, industryBlueprintsUpsertArgs<ExtArgs>>
    ): Prisma__industryBlueprintsClient<$Result.GetResult<Prisma.$industryBlueprintsPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of IndustryBlueprints.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {industryBlueprintsCountArgs} args - Arguments to filter IndustryBlueprints to count.
     * @example
     * // Count the number of IndustryBlueprints
     * const count = await prisma.industryBlueprints.count({
     *   where: {
     *     // ... the filter for the IndustryBlueprints we want to count
     *   }
     * })
    **/
    count<T extends industryBlueprintsCountArgs>(
      args?: Subset<T, industryBlueprintsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], IndustryBlueprintsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a IndustryBlueprints.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IndustryBlueprintsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends IndustryBlueprintsAggregateArgs>(args: Subset<T, IndustryBlueprintsAggregateArgs>): Prisma.PrismaPromise<GetIndustryBlueprintsAggregateType<T>>

    /**
     * Group by IndustryBlueprints.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {industryBlueprintsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends industryBlueprintsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: industryBlueprintsGroupByArgs['orderBy'] }
        : { orderBy?: industryBlueprintsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, industryBlueprintsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetIndustryBlueprintsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the industryBlueprints model
   */
  readonly fields: industryBlueprintsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for industryBlueprints.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__industryBlueprintsClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';


    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the industryBlueprints model
   */ 
  interface industryBlueprintsFieldRefs {
    readonly typeID: FieldRef<"industryBlueprints", 'Int'>
    readonly maxProductionLimit: FieldRef<"industryBlueprints", 'Int'>
  }
    

  // Custom InputTypes

  /**
   * industryBlueprints findUnique
   */
  export type industryBlueprintsFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the industryBlueprints
     */
    select?: industryBlueprintsSelect<ExtArgs> | null
    /**
     * Filter, which industryBlueprints to fetch.
     */
    where: industryBlueprintsWhereUniqueInput
  }


  /**
   * industryBlueprints findUniqueOrThrow
   */
  export type industryBlueprintsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the industryBlueprints
     */
    select?: industryBlueprintsSelect<ExtArgs> | null
    /**
     * Filter, which industryBlueprints to fetch.
     */
    where: industryBlueprintsWhereUniqueInput
  }


  /**
   * industryBlueprints findFirst
   */
  export type industryBlueprintsFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the industryBlueprints
     */
    select?: industryBlueprintsSelect<ExtArgs> | null
    /**
     * Filter, which industryBlueprints to fetch.
     */
    where?: industryBlueprintsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of industryBlueprints to fetch.
     */
    orderBy?: industryBlueprintsOrderByWithRelationInput | industryBlueprintsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for industryBlueprints.
     */
    cursor?: industryBlueprintsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` industryBlueprints from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` industryBlueprints.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of industryBlueprints.
     */
    distinct?: IndustryBlueprintsScalarFieldEnum | IndustryBlueprintsScalarFieldEnum[]
  }


  /**
   * industryBlueprints findFirstOrThrow
   */
  export type industryBlueprintsFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the industryBlueprints
     */
    select?: industryBlueprintsSelect<ExtArgs> | null
    /**
     * Filter, which industryBlueprints to fetch.
     */
    where?: industryBlueprintsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of industryBlueprints to fetch.
     */
    orderBy?: industryBlueprintsOrderByWithRelationInput | industryBlueprintsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for industryBlueprints.
     */
    cursor?: industryBlueprintsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` industryBlueprints from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` industryBlueprints.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of industryBlueprints.
     */
    distinct?: IndustryBlueprintsScalarFieldEnum | IndustryBlueprintsScalarFieldEnum[]
  }


  /**
   * industryBlueprints findMany
   */
  export type industryBlueprintsFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the industryBlueprints
     */
    select?: industryBlueprintsSelect<ExtArgs> | null
    /**
     * Filter, which industryBlueprints to fetch.
     */
    where?: industryBlueprintsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of industryBlueprints to fetch.
     */
    orderBy?: industryBlueprintsOrderByWithRelationInput | industryBlueprintsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing industryBlueprints.
     */
    cursor?: industryBlueprintsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` industryBlueprints from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` industryBlueprints.
     */
    skip?: number
    distinct?: IndustryBlueprintsScalarFieldEnum | IndustryBlueprintsScalarFieldEnum[]
  }


  /**
   * industryBlueprints create
   */
  export type industryBlueprintsCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the industryBlueprints
     */
    select?: industryBlueprintsSelect<ExtArgs> | null
    /**
     * The data needed to create a industryBlueprints.
     */
    data: XOR<industryBlueprintsCreateInput, industryBlueprintsUncheckedCreateInput>
  }


  /**
   * industryBlueprints createMany
   */
  export type industryBlueprintsCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many industryBlueprints.
     */
    data: industryBlueprintsCreateManyInput | industryBlueprintsCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * industryBlueprints update
   */
  export type industryBlueprintsUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the industryBlueprints
     */
    select?: industryBlueprintsSelect<ExtArgs> | null
    /**
     * The data needed to update a industryBlueprints.
     */
    data: XOR<industryBlueprintsUpdateInput, industryBlueprintsUncheckedUpdateInput>
    /**
     * Choose, which industryBlueprints to update.
     */
    where: industryBlueprintsWhereUniqueInput
  }


  /**
   * industryBlueprints updateMany
   */
  export type industryBlueprintsUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update industryBlueprints.
     */
    data: XOR<industryBlueprintsUpdateManyMutationInput, industryBlueprintsUncheckedUpdateManyInput>
    /**
     * Filter which industryBlueprints to update
     */
    where?: industryBlueprintsWhereInput
  }


  /**
   * industryBlueprints upsert
   */
  export type industryBlueprintsUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the industryBlueprints
     */
    select?: industryBlueprintsSelect<ExtArgs> | null
    /**
     * The filter to search for the industryBlueprints to update in case it exists.
     */
    where: industryBlueprintsWhereUniqueInput
    /**
     * In case the industryBlueprints found by the `where` argument doesn't exist, create a new industryBlueprints with this data.
     */
    create: XOR<industryBlueprintsCreateInput, industryBlueprintsUncheckedCreateInput>
    /**
     * In case the industryBlueprints was found with the provided `where` argument, update it with this data.
     */
    update: XOR<industryBlueprintsUpdateInput, industryBlueprintsUncheckedUpdateInput>
  }


  /**
   * industryBlueprints delete
   */
  export type industryBlueprintsDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the industryBlueprints
     */
    select?: industryBlueprintsSelect<ExtArgs> | null
    /**
     * Filter which industryBlueprints to delete.
     */
    where: industryBlueprintsWhereUniqueInput
  }


  /**
   * industryBlueprints deleteMany
   */
  export type industryBlueprintsDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which industryBlueprints to delete
     */
    where?: industryBlueprintsWhereInput
  }


  /**
   * industryBlueprints without action
   */
  export type industryBlueprintsDefaultArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the industryBlueprints
     */
    select?: industryBlueprintsSelect<ExtArgs> | null
  }



  /**
   * Model invCategories
   */

  export type AggregateInvCategories = {
    _count: InvCategoriesCountAggregateOutputType | null
    _avg: InvCategoriesAvgAggregateOutputType | null
    _sum: InvCategoriesSumAggregateOutputType | null
    _min: InvCategoriesMinAggregateOutputType | null
    _max: InvCategoriesMaxAggregateOutputType | null
  }

  export type InvCategoriesAvgAggregateOutputType = {
    categoryID: number | null
    iconID: number | null
  }

  export type InvCategoriesSumAggregateOutputType = {
    categoryID: number | null
    iconID: number | null
  }

  export type InvCategoriesMinAggregateOutputType = {
    categoryID: number | null
    categoryName: string | null
    iconID: number | null
    published: boolean | null
  }

  export type InvCategoriesMaxAggregateOutputType = {
    categoryID: number | null
    categoryName: string | null
    iconID: number | null
    published: boolean | null
  }

  export type InvCategoriesCountAggregateOutputType = {
    categoryID: number
    categoryName: number
    iconID: number
    published: number
    _all: number
  }


  export type InvCategoriesAvgAggregateInputType = {
    categoryID?: true
    iconID?: true
  }

  export type InvCategoriesSumAggregateInputType = {
    categoryID?: true
    iconID?: true
  }

  export type InvCategoriesMinAggregateInputType = {
    categoryID?: true
    categoryName?: true
    iconID?: true
    published?: true
  }

  export type InvCategoriesMaxAggregateInputType = {
    categoryID?: true
    categoryName?: true
    iconID?: true
    published?: true
  }

  export type InvCategoriesCountAggregateInputType = {
    categoryID?: true
    categoryName?: true
    iconID?: true
    published?: true
    _all?: true
  }

  export type InvCategoriesAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which invCategories to aggregate.
     */
    where?: invCategoriesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of invCategories to fetch.
     */
    orderBy?: invCategoriesOrderByWithRelationInput | invCategoriesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: invCategoriesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` invCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` invCategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned invCategories
    **/
    _count?: true | InvCategoriesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: InvCategoriesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: InvCategoriesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: InvCategoriesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: InvCategoriesMaxAggregateInputType
  }

  export type GetInvCategoriesAggregateType<T extends InvCategoriesAggregateArgs> = {
        [P in keyof T & keyof AggregateInvCategories]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInvCategories[P]>
      : GetScalarType<T[P], AggregateInvCategories[P]>
  }




  export type invCategoriesGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: invCategoriesWhereInput
    orderBy?: invCategoriesOrderByWithAggregationInput | invCategoriesOrderByWithAggregationInput[]
    by: InvCategoriesScalarFieldEnum[] | InvCategoriesScalarFieldEnum
    having?: invCategoriesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: InvCategoriesCountAggregateInputType | true
    _avg?: InvCategoriesAvgAggregateInputType
    _sum?: InvCategoriesSumAggregateInputType
    _min?: InvCategoriesMinAggregateInputType
    _max?: InvCategoriesMaxAggregateInputType
  }

  export type InvCategoriesGroupByOutputType = {
    categoryID: number
    categoryName: string | null
    iconID: number | null
    published: boolean | null
    _count: InvCategoriesCountAggregateOutputType | null
    _avg: InvCategoriesAvgAggregateOutputType | null
    _sum: InvCategoriesSumAggregateOutputType | null
    _min: InvCategoriesMinAggregateOutputType | null
    _max: InvCategoriesMaxAggregateOutputType | null
  }

  type GetInvCategoriesGroupByPayload<T extends invCategoriesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<InvCategoriesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof InvCategoriesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], InvCategoriesGroupByOutputType[P]>
            : GetScalarType<T[P], InvCategoriesGroupByOutputType[P]>
        }
      >
    >


  export type invCategoriesSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    categoryID?: boolean
    categoryName?: boolean
    iconID?: boolean
    published?: boolean
  }, ExtArgs["result"]["invCategories"]>

  export type invCategoriesSelectScalar = {
    categoryID?: boolean
    categoryName?: boolean
    iconID?: boolean
    published?: boolean
  }


  export type $invCategoriesPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    name: "invCategories"
    objects: {}
    scalars: $Extensions.GetResult<{
      categoryID: number
      categoryName: string | null
      iconID: number | null
      published: boolean | null
    }, ExtArgs["result"]["invCategories"]>
    composites: {}
  }


  type invCategoriesGetPayload<S extends boolean | null | undefined | invCategoriesDefaultArgs> = $Result.GetResult<Prisma.$invCategoriesPayload, S>

  type invCategoriesCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<invCategoriesFindManyArgs, 'select' | 'include'> & {
      select?: InvCategoriesCountAggregateInputType | true
    }

  export interface invCategoriesDelegate<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['invCategories'], meta: { name: 'invCategories' } }
    /**
     * Find zero or one InvCategories that matches the filter.
     * @param {invCategoriesFindUniqueArgs} args - Arguments to find a InvCategories
     * @example
     * // Get one InvCategories
     * const invCategories = await prisma.invCategories.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends invCategoriesFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, invCategoriesFindUniqueArgs<ExtArgs>>
    ): Prisma__invCategoriesClient<$Result.GetResult<Prisma.$invCategoriesPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one InvCategories that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {invCategoriesFindUniqueOrThrowArgs} args - Arguments to find a InvCategories
     * @example
     * // Get one InvCategories
     * const invCategories = await prisma.invCategories.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends invCategoriesFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, invCategoriesFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__invCategoriesClient<$Result.GetResult<Prisma.$invCategoriesPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first InvCategories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {invCategoriesFindFirstArgs} args - Arguments to find a InvCategories
     * @example
     * // Get one InvCategories
     * const invCategories = await prisma.invCategories.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends invCategoriesFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, invCategoriesFindFirstArgs<ExtArgs>>
    ): Prisma__invCategoriesClient<$Result.GetResult<Prisma.$invCategoriesPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first InvCategories that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {invCategoriesFindFirstOrThrowArgs} args - Arguments to find a InvCategories
     * @example
     * // Get one InvCategories
     * const invCategories = await prisma.invCategories.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends invCategoriesFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, invCategoriesFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__invCategoriesClient<$Result.GetResult<Prisma.$invCategoriesPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more InvCategories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {invCategoriesFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all InvCategories
     * const invCategories = await prisma.invCategories.findMany()
     * 
     * // Get first 10 InvCategories
     * const invCategories = await prisma.invCategories.findMany({ take: 10 })
     * 
     * // Only select the `categoryID`
     * const invCategoriesWithCategoryIDOnly = await prisma.invCategories.findMany({ select: { categoryID: true } })
     * 
    **/
    findMany<T extends invCategoriesFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, invCategoriesFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$invCategoriesPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a InvCategories.
     * @param {invCategoriesCreateArgs} args - Arguments to create a InvCategories.
     * @example
     * // Create one InvCategories
     * const InvCategories = await prisma.invCategories.create({
     *   data: {
     *     // ... data to create a InvCategories
     *   }
     * })
     * 
    **/
    create<T extends invCategoriesCreateArgs<ExtArgs>>(
      args: SelectSubset<T, invCategoriesCreateArgs<ExtArgs>>
    ): Prisma__invCategoriesClient<$Result.GetResult<Prisma.$invCategoriesPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many InvCategories.
     *     @param {invCategoriesCreateManyArgs} args - Arguments to create many InvCategories.
     *     @example
     *     // Create many InvCategories
     *     const invCategories = await prisma.invCategories.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends invCategoriesCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, invCategoriesCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a InvCategories.
     * @param {invCategoriesDeleteArgs} args - Arguments to delete one InvCategories.
     * @example
     * // Delete one InvCategories
     * const InvCategories = await prisma.invCategories.delete({
     *   where: {
     *     // ... filter to delete one InvCategories
     *   }
     * })
     * 
    **/
    delete<T extends invCategoriesDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, invCategoriesDeleteArgs<ExtArgs>>
    ): Prisma__invCategoriesClient<$Result.GetResult<Prisma.$invCategoriesPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one InvCategories.
     * @param {invCategoriesUpdateArgs} args - Arguments to update one InvCategories.
     * @example
     * // Update one InvCategories
     * const invCategories = await prisma.invCategories.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends invCategoriesUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, invCategoriesUpdateArgs<ExtArgs>>
    ): Prisma__invCategoriesClient<$Result.GetResult<Prisma.$invCategoriesPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more InvCategories.
     * @param {invCategoriesDeleteManyArgs} args - Arguments to filter InvCategories to delete.
     * @example
     * // Delete a few InvCategories
     * const { count } = await prisma.invCategories.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends invCategoriesDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, invCategoriesDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more InvCategories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {invCategoriesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many InvCategories
     * const invCategories = await prisma.invCategories.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends invCategoriesUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, invCategoriesUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one InvCategories.
     * @param {invCategoriesUpsertArgs} args - Arguments to update or create a InvCategories.
     * @example
     * // Update or create a InvCategories
     * const invCategories = await prisma.invCategories.upsert({
     *   create: {
     *     // ... data to create a InvCategories
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the InvCategories we want to update
     *   }
     * })
    **/
    upsert<T extends invCategoriesUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, invCategoriesUpsertArgs<ExtArgs>>
    ): Prisma__invCategoriesClient<$Result.GetResult<Prisma.$invCategoriesPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of InvCategories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {invCategoriesCountArgs} args - Arguments to filter InvCategories to count.
     * @example
     * // Count the number of InvCategories
     * const count = await prisma.invCategories.count({
     *   where: {
     *     // ... the filter for the InvCategories we want to count
     *   }
     * })
    **/
    count<T extends invCategoriesCountArgs>(
      args?: Subset<T, invCategoriesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], InvCategoriesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a InvCategories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvCategoriesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends InvCategoriesAggregateArgs>(args: Subset<T, InvCategoriesAggregateArgs>): Prisma.PrismaPromise<GetInvCategoriesAggregateType<T>>

    /**
     * Group by InvCategories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {invCategoriesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends invCategoriesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: invCategoriesGroupByArgs['orderBy'] }
        : { orderBy?: invCategoriesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, invCategoriesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInvCategoriesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the invCategories model
   */
  readonly fields: invCategoriesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for invCategories.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__invCategoriesClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';


    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the invCategories model
   */ 
  interface invCategoriesFieldRefs {
    readonly categoryID: FieldRef<"invCategories", 'Int'>
    readonly categoryName: FieldRef<"invCategories", 'String'>
    readonly iconID: FieldRef<"invCategories", 'Int'>
    readonly published: FieldRef<"invCategories", 'Boolean'>
  }
    

  // Custom InputTypes

  /**
   * invCategories findUnique
   */
  export type invCategoriesFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the invCategories
     */
    select?: invCategoriesSelect<ExtArgs> | null
    /**
     * Filter, which invCategories to fetch.
     */
    where: invCategoriesWhereUniqueInput
  }


  /**
   * invCategories findUniqueOrThrow
   */
  export type invCategoriesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the invCategories
     */
    select?: invCategoriesSelect<ExtArgs> | null
    /**
     * Filter, which invCategories to fetch.
     */
    where: invCategoriesWhereUniqueInput
  }


  /**
   * invCategories findFirst
   */
  export type invCategoriesFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the invCategories
     */
    select?: invCategoriesSelect<ExtArgs> | null
    /**
     * Filter, which invCategories to fetch.
     */
    where?: invCategoriesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of invCategories to fetch.
     */
    orderBy?: invCategoriesOrderByWithRelationInput | invCategoriesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for invCategories.
     */
    cursor?: invCategoriesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` invCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` invCategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of invCategories.
     */
    distinct?: InvCategoriesScalarFieldEnum | InvCategoriesScalarFieldEnum[]
  }


  /**
   * invCategories findFirstOrThrow
   */
  export type invCategoriesFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the invCategories
     */
    select?: invCategoriesSelect<ExtArgs> | null
    /**
     * Filter, which invCategories to fetch.
     */
    where?: invCategoriesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of invCategories to fetch.
     */
    orderBy?: invCategoriesOrderByWithRelationInput | invCategoriesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for invCategories.
     */
    cursor?: invCategoriesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` invCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` invCategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of invCategories.
     */
    distinct?: InvCategoriesScalarFieldEnum | InvCategoriesScalarFieldEnum[]
  }


  /**
   * invCategories findMany
   */
  export type invCategoriesFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the invCategories
     */
    select?: invCategoriesSelect<ExtArgs> | null
    /**
     * Filter, which invCategories to fetch.
     */
    where?: invCategoriesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of invCategories to fetch.
     */
    orderBy?: invCategoriesOrderByWithRelationInput | invCategoriesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing invCategories.
     */
    cursor?: invCategoriesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` invCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` invCategories.
     */
    skip?: number
    distinct?: InvCategoriesScalarFieldEnum | InvCategoriesScalarFieldEnum[]
  }


  /**
   * invCategories create
   */
  export type invCategoriesCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the invCategories
     */
    select?: invCategoriesSelect<ExtArgs> | null
    /**
     * The data needed to create a invCategories.
     */
    data: XOR<invCategoriesCreateInput, invCategoriesUncheckedCreateInput>
  }


  /**
   * invCategories createMany
   */
  export type invCategoriesCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many invCategories.
     */
    data: invCategoriesCreateManyInput | invCategoriesCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * invCategories update
   */
  export type invCategoriesUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the invCategories
     */
    select?: invCategoriesSelect<ExtArgs> | null
    /**
     * The data needed to update a invCategories.
     */
    data: XOR<invCategoriesUpdateInput, invCategoriesUncheckedUpdateInput>
    /**
     * Choose, which invCategories to update.
     */
    where: invCategoriesWhereUniqueInput
  }


  /**
   * invCategories updateMany
   */
  export type invCategoriesUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update invCategories.
     */
    data: XOR<invCategoriesUpdateManyMutationInput, invCategoriesUncheckedUpdateManyInput>
    /**
     * Filter which invCategories to update
     */
    where?: invCategoriesWhereInput
  }


  /**
   * invCategories upsert
   */
  export type invCategoriesUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the invCategories
     */
    select?: invCategoriesSelect<ExtArgs> | null
    /**
     * The filter to search for the invCategories to update in case it exists.
     */
    where: invCategoriesWhereUniqueInput
    /**
     * In case the invCategories found by the `where` argument doesn't exist, create a new invCategories with this data.
     */
    create: XOR<invCategoriesCreateInput, invCategoriesUncheckedCreateInput>
    /**
     * In case the invCategories was found with the provided `where` argument, update it with this data.
     */
    update: XOR<invCategoriesUpdateInput, invCategoriesUncheckedUpdateInput>
  }


  /**
   * invCategories delete
   */
  export type invCategoriesDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the invCategories
     */
    select?: invCategoriesSelect<ExtArgs> | null
    /**
     * Filter which invCategories to delete.
     */
    where: invCategoriesWhereUniqueInput
  }


  /**
   * invCategories deleteMany
   */
  export type invCategoriesDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which invCategories to delete
     */
    where?: invCategoriesWhereInput
  }


  /**
   * invCategories without action
   */
  export type invCategoriesDefaultArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the invCategories
     */
    select?: invCategoriesSelect<ExtArgs> | null
  }



  /**
   * Model invContrabandTypes
   */

  export type AggregateInvContrabandTypes = {
    _count: InvContrabandTypesCountAggregateOutputType | null
    _avg: InvContrabandTypesAvgAggregateOutputType | null
    _sum: InvContrabandTypesSumAggregateOutputType | null
    _min: InvContrabandTypesMinAggregateOutputType | null
    _max: InvContrabandTypesMaxAggregateOutputType | null
  }

  export type InvContrabandTypesAvgAggregateOutputType = {
    factionID: number | null
    typeID: number | null
    standingLoss: number | null
    confiscateMinSec: number | null
    fineByValue: number | null
    attackMinSec: number | null
  }

  export type InvContrabandTypesSumAggregateOutputType = {
    factionID: number | null
    typeID: number | null
    standingLoss: number | null
    confiscateMinSec: number | null
    fineByValue: number | null
    attackMinSec: number | null
  }

  export type InvContrabandTypesMinAggregateOutputType = {
    factionID: number | null
    typeID: number | null
    standingLoss: number | null
    confiscateMinSec: number | null
    fineByValue: number | null
    attackMinSec: number | null
  }

  export type InvContrabandTypesMaxAggregateOutputType = {
    factionID: number | null
    typeID: number | null
    standingLoss: number | null
    confiscateMinSec: number | null
    fineByValue: number | null
    attackMinSec: number | null
  }

  export type InvContrabandTypesCountAggregateOutputType = {
    factionID: number
    typeID: number
    standingLoss: number
    confiscateMinSec: number
    fineByValue: number
    attackMinSec: number
    _all: number
  }


  export type InvContrabandTypesAvgAggregateInputType = {
    factionID?: true
    typeID?: true
    standingLoss?: true
    confiscateMinSec?: true
    fineByValue?: true
    attackMinSec?: true
  }

  export type InvContrabandTypesSumAggregateInputType = {
    factionID?: true
    typeID?: true
    standingLoss?: true
    confiscateMinSec?: true
    fineByValue?: true
    attackMinSec?: true
  }

  export type InvContrabandTypesMinAggregateInputType = {
    factionID?: true
    typeID?: true
    standingLoss?: true
    confiscateMinSec?: true
    fineByValue?: true
    attackMinSec?: true
  }

  export type InvContrabandTypesMaxAggregateInputType = {
    factionID?: true
    typeID?: true
    standingLoss?: true
    confiscateMinSec?: true
    fineByValue?: true
    attackMinSec?: true
  }

  export type InvContrabandTypesCountAggregateInputType = {
    factionID?: true
    typeID?: true
    standingLoss?: true
    confiscateMinSec?: true
    fineByValue?: true
    attackMinSec?: true
    _all?: true
  }

  export type InvContrabandTypesAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which invContrabandTypes to aggregate.
     */
    where?: invContrabandTypesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of invContrabandTypes to fetch.
     */
    orderBy?: invContrabandTypesOrderByWithRelationInput | invContrabandTypesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: invContrabandTypesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` invContrabandTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` invContrabandTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned invContrabandTypes
    **/
    _count?: true | InvContrabandTypesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: InvContrabandTypesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: InvContrabandTypesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: InvContrabandTypesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: InvContrabandTypesMaxAggregateInputType
  }

  export type GetInvContrabandTypesAggregateType<T extends InvContrabandTypesAggregateArgs> = {
        [P in keyof T & keyof AggregateInvContrabandTypes]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInvContrabandTypes[P]>
      : GetScalarType<T[P], AggregateInvContrabandTypes[P]>
  }




  export type invContrabandTypesGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: invContrabandTypesWhereInput
    orderBy?: invContrabandTypesOrderByWithAggregationInput | invContrabandTypesOrderByWithAggregationInput[]
    by: InvContrabandTypesScalarFieldEnum[] | InvContrabandTypesScalarFieldEnum
    having?: invContrabandTypesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: InvContrabandTypesCountAggregateInputType | true
    _avg?: InvContrabandTypesAvgAggregateInputType
    _sum?: InvContrabandTypesSumAggregateInputType
    _min?: InvContrabandTypesMinAggregateInputType
    _max?: InvContrabandTypesMaxAggregateInputType
  }

  export type InvContrabandTypesGroupByOutputType = {
    factionID: number
    typeID: number
    standingLoss: number | null
    confiscateMinSec: number | null
    fineByValue: number | null
    attackMinSec: number | null
    _count: InvContrabandTypesCountAggregateOutputType | null
    _avg: InvContrabandTypesAvgAggregateOutputType | null
    _sum: InvContrabandTypesSumAggregateOutputType | null
    _min: InvContrabandTypesMinAggregateOutputType | null
    _max: InvContrabandTypesMaxAggregateOutputType | null
  }

  type GetInvContrabandTypesGroupByPayload<T extends invContrabandTypesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<InvContrabandTypesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof InvContrabandTypesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], InvContrabandTypesGroupByOutputType[P]>
            : GetScalarType<T[P], InvContrabandTypesGroupByOutputType[P]>
        }
      >
    >


  export type invContrabandTypesSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    factionID?: boolean
    typeID?: boolean
    standingLoss?: boolean
    confiscateMinSec?: boolean
    fineByValue?: boolean
    attackMinSec?: boolean
  }, ExtArgs["result"]["invContrabandTypes"]>

  export type invContrabandTypesSelectScalar = {
    factionID?: boolean
    typeID?: boolean
    standingLoss?: boolean
    confiscateMinSec?: boolean
    fineByValue?: boolean
    attackMinSec?: boolean
  }


  export type $invContrabandTypesPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    name: "invContrabandTypes"
    objects: {}
    scalars: $Extensions.GetResult<{
      factionID: number
      typeID: number
      standingLoss: number | null
      confiscateMinSec: number | null
      fineByValue: number | null
      attackMinSec: number | null
    }, ExtArgs["result"]["invContrabandTypes"]>
    composites: {}
  }


  type invContrabandTypesGetPayload<S extends boolean | null | undefined | invContrabandTypesDefaultArgs> = $Result.GetResult<Prisma.$invContrabandTypesPayload, S>

  type invContrabandTypesCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<invContrabandTypesFindManyArgs, 'select' | 'include'> & {
      select?: InvContrabandTypesCountAggregateInputType | true
    }

  export interface invContrabandTypesDelegate<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['invContrabandTypes'], meta: { name: 'invContrabandTypes' } }
    /**
     * Find zero or one InvContrabandTypes that matches the filter.
     * @param {invContrabandTypesFindUniqueArgs} args - Arguments to find a InvContrabandTypes
     * @example
     * // Get one InvContrabandTypes
     * const invContrabandTypes = await prisma.invContrabandTypes.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends invContrabandTypesFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, invContrabandTypesFindUniqueArgs<ExtArgs>>
    ): Prisma__invContrabandTypesClient<$Result.GetResult<Prisma.$invContrabandTypesPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one InvContrabandTypes that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {invContrabandTypesFindUniqueOrThrowArgs} args - Arguments to find a InvContrabandTypes
     * @example
     * // Get one InvContrabandTypes
     * const invContrabandTypes = await prisma.invContrabandTypes.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends invContrabandTypesFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, invContrabandTypesFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__invContrabandTypesClient<$Result.GetResult<Prisma.$invContrabandTypesPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first InvContrabandTypes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {invContrabandTypesFindFirstArgs} args - Arguments to find a InvContrabandTypes
     * @example
     * // Get one InvContrabandTypes
     * const invContrabandTypes = await prisma.invContrabandTypes.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends invContrabandTypesFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, invContrabandTypesFindFirstArgs<ExtArgs>>
    ): Prisma__invContrabandTypesClient<$Result.GetResult<Prisma.$invContrabandTypesPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first InvContrabandTypes that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {invContrabandTypesFindFirstOrThrowArgs} args - Arguments to find a InvContrabandTypes
     * @example
     * // Get one InvContrabandTypes
     * const invContrabandTypes = await prisma.invContrabandTypes.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends invContrabandTypesFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, invContrabandTypesFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__invContrabandTypesClient<$Result.GetResult<Prisma.$invContrabandTypesPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more InvContrabandTypes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {invContrabandTypesFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all InvContrabandTypes
     * const invContrabandTypes = await prisma.invContrabandTypes.findMany()
     * 
     * // Get first 10 InvContrabandTypes
     * const invContrabandTypes = await prisma.invContrabandTypes.findMany({ take: 10 })
     * 
     * // Only select the `factionID`
     * const invContrabandTypesWithFactionIDOnly = await prisma.invContrabandTypes.findMany({ select: { factionID: true } })
     * 
    **/
    findMany<T extends invContrabandTypesFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, invContrabandTypesFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$invContrabandTypesPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a InvContrabandTypes.
     * @param {invContrabandTypesCreateArgs} args - Arguments to create a InvContrabandTypes.
     * @example
     * // Create one InvContrabandTypes
     * const InvContrabandTypes = await prisma.invContrabandTypes.create({
     *   data: {
     *     // ... data to create a InvContrabandTypes
     *   }
     * })
     * 
    **/
    create<T extends invContrabandTypesCreateArgs<ExtArgs>>(
      args: SelectSubset<T, invContrabandTypesCreateArgs<ExtArgs>>
    ): Prisma__invContrabandTypesClient<$Result.GetResult<Prisma.$invContrabandTypesPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many InvContrabandTypes.
     *     @param {invContrabandTypesCreateManyArgs} args - Arguments to create many InvContrabandTypes.
     *     @example
     *     // Create many InvContrabandTypes
     *     const invContrabandTypes = await prisma.invContrabandTypes.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends invContrabandTypesCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, invContrabandTypesCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a InvContrabandTypes.
     * @param {invContrabandTypesDeleteArgs} args - Arguments to delete one InvContrabandTypes.
     * @example
     * // Delete one InvContrabandTypes
     * const InvContrabandTypes = await prisma.invContrabandTypes.delete({
     *   where: {
     *     // ... filter to delete one InvContrabandTypes
     *   }
     * })
     * 
    **/
    delete<T extends invContrabandTypesDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, invContrabandTypesDeleteArgs<ExtArgs>>
    ): Prisma__invContrabandTypesClient<$Result.GetResult<Prisma.$invContrabandTypesPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one InvContrabandTypes.
     * @param {invContrabandTypesUpdateArgs} args - Arguments to update one InvContrabandTypes.
     * @example
     * // Update one InvContrabandTypes
     * const invContrabandTypes = await prisma.invContrabandTypes.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends invContrabandTypesUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, invContrabandTypesUpdateArgs<ExtArgs>>
    ): Prisma__invContrabandTypesClient<$Result.GetResult<Prisma.$invContrabandTypesPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more InvContrabandTypes.
     * @param {invContrabandTypesDeleteManyArgs} args - Arguments to filter InvContrabandTypes to delete.
     * @example
     * // Delete a few InvContrabandTypes
     * const { count } = await prisma.invContrabandTypes.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends invContrabandTypesDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, invContrabandTypesDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more InvContrabandTypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {invContrabandTypesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many InvContrabandTypes
     * const invContrabandTypes = await prisma.invContrabandTypes.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends invContrabandTypesUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, invContrabandTypesUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one InvContrabandTypes.
     * @param {invContrabandTypesUpsertArgs} args - Arguments to update or create a InvContrabandTypes.
     * @example
     * // Update or create a InvContrabandTypes
     * const invContrabandTypes = await prisma.invContrabandTypes.upsert({
     *   create: {
     *     // ... data to create a InvContrabandTypes
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the InvContrabandTypes we want to update
     *   }
     * })
    **/
    upsert<T extends invContrabandTypesUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, invContrabandTypesUpsertArgs<ExtArgs>>
    ): Prisma__invContrabandTypesClient<$Result.GetResult<Prisma.$invContrabandTypesPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of InvContrabandTypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {invContrabandTypesCountArgs} args - Arguments to filter InvContrabandTypes to count.
     * @example
     * // Count the number of InvContrabandTypes
     * const count = await prisma.invContrabandTypes.count({
     *   where: {
     *     // ... the filter for the InvContrabandTypes we want to count
     *   }
     * })
    **/
    count<T extends invContrabandTypesCountArgs>(
      args?: Subset<T, invContrabandTypesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], InvContrabandTypesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a InvContrabandTypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvContrabandTypesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends InvContrabandTypesAggregateArgs>(args: Subset<T, InvContrabandTypesAggregateArgs>): Prisma.PrismaPromise<GetInvContrabandTypesAggregateType<T>>

    /**
     * Group by InvContrabandTypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {invContrabandTypesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends invContrabandTypesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: invContrabandTypesGroupByArgs['orderBy'] }
        : { orderBy?: invContrabandTypesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, invContrabandTypesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInvContrabandTypesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the invContrabandTypes model
   */
  readonly fields: invContrabandTypesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for invContrabandTypes.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__invContrabandTypesClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';


    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the invContrabandTypes model
   */ 
  interface invContrabandTypesFieldRefs {
    readonly factionID: FieldRef<"invContrabandTypes", 'Int'>
    readonly typeID: FieldRef<"invContrabandTypes", 'Int'>
    readonly standingLoss: FieldRef<"invContrabandTypes", 'Float'>
    readonly confiscateMinSec: FieldRef<"invContrabandTypes", 'Float'>
    readonly fineByValue: FieldRef<"invContrabandTypes", 'Float'>
    readonly attackMinSec: FieldRef<"invContrabandTypes", 'Float'>
  }
    

  // Custom InputTypes

  /**
   * invContrabandTypes findUnique
   */
  export type invContrabandTypesFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the invContrabandTypes
     */
    select?: invContrabandTypesSelect<ExtArgs> | null
    /**
     * Filter, which invContrabandTypes to fetch.
     */
    where: invContrabandTypesWhereUniqueInput
  }


  /**
   * invContrabandTypes findUniqueOrThrow
   */
  export type invContrabandTypesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the invContrabandTypes
     */
    select?: invContrabandTypesSelect<ExtArgs> | null
    /**
     * Filter, which invContrabandTypes to fetch.
     */
    where: invContrabandTypesWhereUniqueInput
  }


  /**
   * invContrabandTypes findFirst
   */
  export type invContrabandTypesFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the invContrabandTypes
     */
    select?: invContrabandTypesSelect<ExtArgs> | null
    /**
     * Filter, which invContrabandTypes to fetch.
     */
    where?: invContrabandTypesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of invContrabandTypes to fetch.
     */
    orderBy?: invContrabandTypesOrderByWithRelationInput | invContrabandTypesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for invContrabandTypes.
     */
    cursor?: invContrabandTypesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` invContrabandTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` invContrabandTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of invContrabandTypes.
     */
    distinct?: InvContrabandTypesScalarFieldEnum | InvContrabandTypesScalarFieldEnum[]
  }


  /**
   * invContrabandTypes findFirstOrThrow
   */
  export type invContrabandTypesFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the invContrabandTypes
     */
    select?: invContrabandTypesSelect<ExtArgs> | null
    /**
     * Filter, which invContrabandTypes to fetch.
     */
    where?: invContrabandTypesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of invContrabandTypes to fetch.
     */
    orderBy?: invContrabandTypesOrderByWithRelationInput | invContrabandTypesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for invContrabandTypes.
     */
    cursor?: invContrabandTypesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` invContrabandTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` invContrabandTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of invContrabandTypes.
     */
    distinct?: InvContrabandTypesScalarFieldEnum | InvContrabandTypesScalarFieldEnum[]
  }


  /**
   * invContrabandTypes findMany
   */
  export type invContrabandTypesFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the invContrabandTypes
     */
    select?: invContrabandTypesSelect<ExtArgs> | null
    /**
     * Filter, which invContrabandTypes to fetch.
     */
    where?: invContrabandTypesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of invContrabandTypes to fetch.
     */
    orderBy?: invContrabandTypesOrderByWithRelationInput | invContrabandTypesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing invContrabandTypes.
     */
    cursor?: invContrabandTypesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` invContrabandTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` invContrabandTypes.
     */
    skip?: number
    distinct?: InvContrabandTypesScalarFieldEnum | InvContrabandTypesScalarFieldEnum[]
  }


  /**
   * invContrabandTypes create
   */
  export type invContrabandTypesCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the invContrabandTypes
     */
    select?: invContrabandTypesSelect<ExtArgs> | null
    /**
     * The data needed to create a invContrabandTypes.
     */
    data: XOR<invContrabandTypesCreateInput, invContrabandTypesUncheckedCreateInput>
  }


  /**
   * invContrabandTypes createMany
   */
  export type invContrabandTypesCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many invContrabandTypes.
     */
    data: invContrabandTypesCreateManyInput | invContrabandTypesCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * invContrabandTypes update
   */
  export type invContrabandTypesUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the invContrabandTypes
     */
    select?: invContrabandTypesSelect<ExtArgs> | null
    /**
     * The data needed to update a invContrabandTypes.
     */
    data: XOR<invContrabandTypesUpdateInput, invContrabandTypesUncheckedUpdateInput>
    /**
     * Choose, which invContrabandTypes to update.
     */
    where: invContrabandTypesWhereUniqueInput
  }


  /**
   * invContrabandTypes updateMany
   */
  export type invContrabandTypesUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update invContrabandTypes.
     */
    data: XOR<invContrabandTypesUpdateManyMutationInput, invContrabandTypesUncheckedUpdateManyInput>
    /**
     * Filter which invContrabandTypes to update
     */
    where?: invContrabandTypesWhereInput
  }


  /**
   * invContrabandTypes upsert
   */
  export type invContrabandTypesUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the invContrabandTypes
     */
    select?: invContrabandTypesSelect<ExtArgs> | null
    /**
     * The filter to search for the invContrabandTypes to update in case it exists.
     */
    where: invContrabandTypesWhereUniqueInput
    /**
     * In case the invContrabandTypes found by the `where` argument doesn't exist, create a new invContrabandTypes with this data.
     */
    create: XOR<invContrabandTypesCreateInput, invContrabandTypesUncheckedCreateInput>
    /**
     * In case the invContrabandTypes was found with the provided `where` argument, update it with this data.
     */
    update: XOR<invContrabandTypesUpdateInput, invContrabandTypesUncheckedUpdateInput>
  }


  /**
   * invContrabandTypes delete
   */
  export type invContrabandTypesDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the invContrabandTypes
     */
    select?: invContrabandTypesSelect<ExtArgs> | null
    /**
     * Filter which invContrabandTypes to delete.
     */
    where: invContrabandTypesWhereUniqueInput
  }


  /**
   * invContrabandTypes deleteMany
   */
  export type invContrabandTypesDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which invContrabandTypes to delete
     */
    where?: invContrabandTypesWhereInput
  }


  /**
   * invContrabandTypes without action
   */
  export type invContrabandTypesDefaultArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the invContrabandTypes
     */
    select?: invContrabandTypesSelect<ExtArgs> | null
  }



  /**
   * Model invControlTowerResourcePurposes
   */

  export type AggregateInvControlTowerResourcePurposes = {
    _count: InvControlTowerResourcePurposesCountAggregateOutputType | null
    _avg: InvControlTowerResourcePurposesAvgAggregateOutputType | null
    _sum: InvControlTowerResourcePurposesSumAggregateOutputType | null
    _min: InvControlTowerResourcePurposesMinAggregateOutputType | null
    _max: InvControlTowerResourcePurposesMaxAggregateOutputType | null
  }

  export type InvControlTowerResourcePurposesAvgAggregateOutputType = {
    purpose: number | null
  }

  export type InvControlTowerResourcePurposesSumAggregateOutputType = {
    purpose: number | null
  }

  export type InvControlTowerResourcePurposesMinAggregateOutputType = {
    purpose: number | null
    purposeText: string | null
  }

  export type InvControlTowerResourcePurposesMaxAggregateOutputType = {
    purpose: number | null
    purposeText: string | null
  }

  export type InvControlTowerResourcePurposesCountAggregateOutputType = {
    purpose: number
    purposeText: number
    _all: number
  }


  export type InvControlTowerResourcePurposesAvgAggregateInputType = {
    purpose?: true
  }

  export type InvControlTowerResourcePurposesSumAggregateInputType = {
    purpose?: true
  }

  export type InvControlTowerResourcePurposesMinAggregateInputType = {
    purpose?: true
    purposeText?: true
  }

  export type InvControlTowerResourcePurposesMaxAggregateInputType = {
    purpose?: true
    purposeText?: true
  }

  export type InvControlTowerResourcePurposesCountAggregateInputType = {
    purpose?: true
    purposeText?: true
    _all?: true
  }

  export type InvControlTowerResourcePurposesAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which invControlTowerResourcePurposes to aggregate.
     */
    where?: invControlTowerResourcePurposesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of invControlTowerResourcePurposes to fetch.
     */
    orderBy?: invControlTowerResourcePurposesOrderByWithRelationInput | invControlTowerResourcePurposesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: invControlTowerResourcePurposesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` invControlTowerResourcePurposes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` invControlTowerResourcePurposes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned invControlTowerResourcePurposes
    **/
    _count?: true | InvControlTowerResourcePurposesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: InvControlTowerResourcePurposesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: InvControlTowerResourcePurposesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: InvControlTowerResourcePurposesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: InvControlTowerResourcePurposesMaxAggregateInputType
  }

  export type GetInvControlTowerResourcePurposesAggregateType<T extends InvControlTowerResourcePurposesAggregateArgs> = {
        [P in keyof T & keyof AggregateInvControlTowerResourcePurposes]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInvControlTowerResourcePurposes[P]>
      : GetScalarType<T[P], AggregateInvControlTowerResourcePurposes[P]>
  }




  export type invControlTowerResourcePurposesGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: invControlTowerResourcePurposesWhereInput
    orderBy?: invControlTowerResourcePurposesOrderByWithAggregationInput | invControlTowerResourcePurposesOrderByWithAggregationInput[]
    by: InvControlTowerResourcePurposesScalarFieldEnum[] | InvControlTowerResourcePurposesScalarFieldEnum
    having?: invControlTowerResourcePurposesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: InvControlTowerResourcePurposesCountAggregateInputType | true
    _avg?: InvControlTowerResourcePurposesAvgAggregateInputType
    _sum?: InvControlTowerResourcePurposesSumAggregateInputType
    _min?: InvControlTowerResourcePurposesMinAggregateInputType
    _max?: InvControlTowerResourcePurposesMaxAggregateInputType
  }

  export type InvControlTowerResourcePurposesGroupByOutputType = {
    purpose: number
    purposeText: string | null
    _count: InvControlTowerResourcePurposesCountAggregateOutputType | null
    _avg: InvControlTowerResourcePurposesAvgAggregateOutputType | null
    _sum: InvControlTowerResourcePurposesSumAggregateOutputType | null
    _min: InvControlTowerResourcePurposesMinAggregateOutputType | null
    _max: InvControlTowerResourcePurposesMaxAggregateOutputType | null
  }

  type GetInvControlTowerResourcePurposesGroupByPayload<T extends invControlTowerResourcePurposesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<InvControlTowerResourcePurposesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof InvControlTowerResourcePurposesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], InvControlTowerResourcePurposesGroupByOutputType[P]>
            : GetScalarType<T[P], InvControlTowerResourcePurposesGroupByOutputType[P]>
        }
      >
    >


  export type invControlTowerResourcePurposesSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    purpose?: boolean
    purposeText?: boolean
  }, ExtArgs["result"]["invControlTowerResourcePurposes"]>

  export type invControlTowerResourcePurposesSelectScalar = {
    purpose?: boolean
    purposeText?: boolean
  }


  export type $invControlTowerResourcePurposesPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    name: "invControlTowerResourcePurposes"
    objects: {}
    scalars: $Extensions.GetResult<{
      purpose: number
      purposeText: string | null
    }, ExtArgs["result"]["invControlTowerResourcePurposes"]>
    composites: {}
  }


  type invControlTowerResourcePurposesGetPayload<S extends boolean | null | undefined | invControlTowerResourcePurposesDefaultArgs> = $Result.GetResult<Prisma.$invControlTowerResourcePurposesPayload, S>

  type invControlTowerResourcePurposesCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<invControlTowerResourcePurposesFindManyArgs, 'select' | 'include'> & {
      select?: InvControlTowerResourcePurposesCountAggregateInputType | true
    }

  export interface invControlTowerResourcePurposesDelegate<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['invControlTowerResourcePurposes'], meta: { name: 'invControlTowerResourcePurposes' } }
    /**
     * Find zero or one InvControlTowerResourcePurposes that matches the filter.
     * @param {invControlTowerResourcePurposesFindUniqueArgs} args - Arguments to find a InvControlTowerResourcePurposes
     * @example
     * // Get one InvControlTowerResourcePurposes
     * const invControlTowerResourcePurposes = await prisma.invControlTowerResourcePurposes.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends invControlTowerResourcePurposesFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, invControlTowerResourcePurposesFindUniqueArgs<ExtArgs>>
    ): Prisma__invControlTowerResourcePurposesClient<$Result.GetResult<Prisma.$invControlTowerResourcePurposesPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one InvControlTowerResourcePurposes that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {invControlTowerResourcePurposesFindUniqueOrThrowArgs} args - Arguments to find a InvControlTowerResourcePurposes
     * @example
     * // Get one InvControlTowerResourcePurposes
     * const invControlTowerResourcePurposes = await prisma.invControlTowerResourcePurposes.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends invControlTowerResourcePurposesFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, invControlTowerResourcePurposesFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__invControlTowerResourcePurposesClient<$Result.GetResult<Prisma.$invControlTowerResourcePurposesPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first InvControlTowerResourcePurposes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {invControlTowerResourcePurposesFindFirstArgs} args - Arguments to find a InvControlTowerResourcePurposes
     * @example
     * // Get one InvControlTowerResourcePurposes
     * const invControlTowerResourcePurposes = await prisma.invControlTowerResourcePurposes.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends invControlTowerResourcePurposesFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, invControlTowerResourcePurposesFindFirstArgs<ExtArgs>>
    ): Prisma__invControlTowerResourcePurposesClient<$Result.GetResult<Prisma.$invControlTowerResourcePurposesPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first InvControlTowerResourcePurposes that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {invControlTowerResourcePurposesFindFirstOrThrowArgs} args - Arguments to find a InvControlTowerResourcePurposes
     * @example
     * // Get one InvControlTowerResourcePurposes
     * const invControlTowerResourcePurposes = await prisma.invControlTowerResourcePurposes.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends invControlTowerResourcePurposesFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, invControlTowerResourcePurposesFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__invControlTowerResourcePurposesClient<$Result.GetResult<Prisma.$invControlTowerResourcePurposesPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more InvControlTowerResourcePurposes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {invControlTowerResourcePurposesFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all InvControlTowerResourcePurposes
     * const invControlTowerResourcePurposes = await prisma.invControlTowerResourcePurposes.findMany()
     * 
     * // Get first 10 InvControlTowerResourcePurposes
     * const invControlTowerResourcePurposes = await prisma.invControlTowerResourcePurposes.findMany({ take: 10 })
     * 
     * // Only select the `purpose`
     * const invControlTowerResourcePurposesWithPurposeOnly = await prisma.invControlTowerResourcePurposes.findMany({ select: { purpose: true } })
     * 
    **/
    findMany<T extends invControlTowerResourcePurposesFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, invControlTowerResourcePurposesFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$invControlTowerResourcePurposesPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a InvControlTowerResourcePurposes.
     * @param {invControlTowerResourcePurposesCreateArgs} args - Arguments to create a InvControlTowerResourcePurposes.
     * @example
     * // Create one InvControlTowerResourcePurposes
     * const InvControlTowerResourcePurposes = await prisma.invControlTowerResourcePurposes.create({
     *   data: {
     *     // ... data to create a InvControlTowerResourcePurposes
     *   }
     * })
     * 
    **/
    create<T extends invControlTowerResourcePurposesCreateArgs<ExtArgs>>(
      args: SelectSubset<T, invControlTowerResourcePurposesCreateArgs<ExtArgs>>
    ): Prisma__invControlTowerResourcePurposesClient<$Result.GetResult<Prisma.$invControlTowerResourcePurposesPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many InvControlTowerResourcePurposes.
     *     @param {invControlTowerResourcePurposesCreateManyArgs} args - Arguments to create many InvControlTowerResourcePurposes.
     *     @example
     *     // Create many InvControlTowerResourcePurposes
     *     const invControlTowerResourcePurposes = await prisma.invControlTowerResourcePurposes.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends invControlTowerResourcePurposesCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, invControlTowerResourcePurposesCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a InvControlTowerResourcePurposes.
     * @param {invControlTowerResourcePurposesDeleteArgs} args - Arguments to delete one InvControlTowerResourcePurposes.
     * @example
     * // Delete one InvControlTowerResourcePurposes
     * const InvControlTowerResourcePurposes = await prisma.invControlTowerResourcePurposes.delete({
     *   where: {
     *     // ... filter to delete one InvControlTowerResourcePurposes
     *   }
     * })
     * 
    **/
    delete<T extends invControlTowerResourcePurposesDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, invControlTowerResourcePurposesDeleteArgs<ExtArgs>>
    ): Prisma__invControlTowerResourcePurposesClient<$Result.GetResult<Prisma.$invControlTowerResourcePurposesPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one InvControlTowerResourcePurposes.
     * @param {invControlTowerResourcePurposesUpdateArgs} args - Arguments to update one InvControlTowerResourcePurposes.
     * @example
     * // Update one InvControlTowerResourcePurposes
     * const invControlTowerResourcePurposes = await prisma.invControlTowerResourcePurposes.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends invControlTowerResourcePurposesUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, invControlTowerResourcePurposesUpdateArgs<ExtArgs>>
    ): Prisma__invControlTowerResourcePurposesClient<$Result.GetResult<Prisma.$invControlTowerResourcePurposesPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more InvControlTowerResourcePurposes.
     * @param {invControlTowerResourcePurposesDeleteManyArgs} args - Arguments to filter InvControlTowerResourcePurposes to delete.
     * @example
     * // Delete a few InvControlTowerResourcePurposes
     * const { count } = await prisma.invControlTowerResourcePurposes.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends invControlTowerResourcePurposesDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, invControlTowerResourcePurposesDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more InvControlTowerResourcePurposes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {invControlTowerResourcePurposesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many InvControlTowerResourcePurposes
     * const invControlTowerResourcePurposes = await prisma.invControlTowerResourcePurposes.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends invControlTowerResourcePurposesUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, invControlTowerResourcePurposesUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one InvControlTowerResourcePurposes.
     * @param {invControlTowerResourcePurposesUpsertArgs} args - Arguments to update or create a InvControlTowerResourcePurposes.
     * @example
     * // Update or create a InvControlTowerResourcePurposes
     * const invControlTowerResourcePurposes = await prisma.invControlTowerResourcePurposes.upsert({
     *   create: {
     *     // ... data to create a InvControlTowerResourcePurposes
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the InvControlTowerResourcePurposes we want to update
     *   }
     * })
    **/
    upsert<T extends invControlTowerResourcePurposesUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, invControlTowerResourcePurposesUpsertArgs<ExtArgs>>
    ): Prisma__invControlTowerResourcePurposesClient<$Result.GetResult<Prisma.$invControlTowerResourcePurposesPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of InvControlTowerResourcePurposes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {invControlTowerResourcePurposesCountArgs} args - Arguments to filter InvControlTowerResourcePurposes to count.
     * @example
     * // Count the number of InvControlTowerResourcePurposes
     * const count = await prisma.invControlTowerResourcePurposes.count({
     *   where: {
     *     // ... the filter for the InvControlTowerResourcePurposes we want to count
     *   }
     * })
    **/
    count<T extends invControlTowerResourcePurposesCountArgs>(
      args?: Subset<T, invControlTowerResourcePurposesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], InvControlTowerResourcePurposesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a InvControlTowerResourcePurposes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvControlTowerResourcePurposesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends InvControlTowerResourcePurposesAggregateArgs>(args: Subset<T, InvControlTowerResourcePurposesAggregateArgs>): Prisma.PrismaPromise<GetInvControlTowerResourcePurposesAggregateType<T>>

    /**
     * Group by InvControlTowerResourcePurposes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {invControlTowerResourcePurposesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends invControlTowerResourcePurposesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: invControlTowerResourcePurposesGroupByArgs['orderBy'] }
        : { orderBy?: invControlTowerResourcePurposesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, invControlTowerResourcePurposesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInvControlTowerResourcePurposesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the invControlTowerResourcePurposes model
   */
  readonly fields: invControlTowerResourcePurposesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for invControlTowerResourcePurposes.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__invControlTowerResourcePurposesClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';


    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the invControlTowerResourcePurposes model
   */ 
  interface invControlTowerResourcePurposesFieldRefs {
    readonly purpose: FieldRef<"invControlTowerResourcePurposes", 'Int'>
    readonly purposeText: FieldRef<"invControlTowerResourcePurposes", 'String'>
  }
    

  // Custom InputTypes

  /**
   * invControlTowerResourcePurposes findUnique
   */
  export type invControlTowerResourcePurposesFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the invControlTowerResourcePurposes
     */
    select?: invControlTowerResourcePurposesSelect<ExtArgs> | null
    /**
     * Filter, which invControlTowerResourcePurposes to fetch.
     */
    where: invControlTowerResourcePurposesWhereUniqueInput
  }


  /**
   * invControlTowerResourcePurposes findUniqueOrThrow
   */
  export type invControlTowerResourcePurposesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the invControlTowerResourcePurposes
     */
    select?: invControlTowerResourcePurposesSelect<ExtArgs> | null
    /**
     * Filter, which invControlTowerResourcePurposes to fetch.
     */
    where: invControlTowerResourcePurposesWhereUniqueInput
  }


  /**
   * invControlTowerResourcePurposes findFirst
   */
  export type invControlTowerResourcePurposesFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the invControlTowerResourcePurposes
     */
    select?: invControlTowerResourcePurposesSelect<ExtArgs> | null
    /**
     * Filter, which invControlTowerResourcePurposes to fetch.
     */
    where?: invControlTowerResourcePurposesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of invControlTowerResourcePurposes to fetch.
     */
    orderBy?: invControlTowerResourcePurposesOrderByWithRelationInput | invControlTowerResourcePurposesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for invControlTowerResourcePurposes.
     */
    cursor?: invControlTowerResourcePurposesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` invControlTowerResourcePurposes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` invControlTowerResourcePurposes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of invControlTowerResourcePurposes.
     */
    distinct?: InvControlTowerResourcePurposesScalarFieldEnum | InvControlTowerResourcePurposesScalarFieldEnum[]
  }


  /**
   * invControlTowerResourcePurposes findFirstOrThrow
   */
  export type invControlTowerResourcePurposesFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the invControlTowerResourcePurposes
     */
    select?: invControlTowerResourcePurposesSelect<ExtArgs> | null
    /**
     * Filter, which invControlTowerResourcePurposes to fetch.
     */
    where?: invControlTowerResourcePurposesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of invControlTowerResourcePurposes to fetch.
     */
    orderBy?: invControlTowerResourcePurposesOrderByWithRelationInput | invControlTowerResourcePurposesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for invControlTowerResourcePurposes.
     */
    cursor?: invControlTowerResourcePurposesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` invControlTowerResourcePurposes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` invControlTowerResourcePurposes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of invControlTowerResourcePurposes.
     */
    distinct?: InvControlTowerResourcePurposesScalarFieldEnum | InvControlTowerResourcePurposesScalarFieldEnum[]
  }


  /**
   * invControlTowerResourcePurposes findMany
   */
  export type invControlTowerResourcePurposesFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the invControlTowerResourcePurposes
     */
    select?: invControlTowerResourcePurposesSelect<ExtArgs> | null
    /**
     * Filter, which invControlTowerResourcePurposes to fetch.
     */
    where?: invControlTowerResourcePurposesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of invControlTowerResourcePurposes to fetch.
     */
    orderBy?: invControlTowerResourcePurposesOrderByWithRelationInput | invControlTowerResourcePurposesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing invControlTowerResourcePurposes.
     */
    cursor?: invControlTowerResourcePurposesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` invControlTowerResourcePurposes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` invControlTowerResourcePurposes.
     */
    skip?: number
    distinct?: InvControlTowerResourcePurposesScalarFieldEnum | InvControlTowerResourcePurposesScalarFieldEnum[]
  }


  /**
   * invControlTowerResourcePurposes create
   */
  export type invControlTowerResourcePurposesCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the invControlTowerResourcePurposes
     */
    select?: invControlTowerResourcePurposesSelect<ExtArgs> | null
    /**
     * The data needed to create a invControlTowerResourcePurposes.
     */
    data: XOR<invControlTowerResourcePurposesCreateInput, invControlTowerResourcePurposesUncheckedCreateInput>
  }


  /**
   * invControlTowerResourcePurposes createMany
   */
  export type invControlTowerResourcePurposesCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many invControlTowerResourcePurposes.
     */
    data: invControlTowerResourcePurposesCreateManyInput | invControlTowerResourcePurposesCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * invControlTowerResourcePurposes update
   */
  export type invControlTowerResourcePurposesUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the invControlTowerResourcePurposes
     */
    select?: invControlTowerResourcePurposesSelect<ExtArgs> | null
    /**
     * The data needed to update a invControlTowerResourcePurposes.
     */
    data: XOR<invControlTowerResourcePurposesUpdateInput, invControlTowerResourcePurposesUncheckedUpdateInput>
    /**
     * Choose, which invControlTowerResourcePurposes to update.
     */
    where: invControlTowerResourcePurposesWhereUniqueInput
  }


  /**
   * invControlTowerResourcePurposes updateMany
   */
  export type invControlTowerResourcePurposesUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update invControlTowerResourcePurposes.
     */
    data: XOR<invControlTowerResourcePurposesUpdateManyMutationInput, invControlTowerResourcePurposesUncheckedUpdateManyInput>
    /**
     * Filter which invControlTowerResourcePurposes to update
     */
    where?: invControlTowerResourcePurposesWhereInput
  }


  /**
   * invControlTowerResourcePurposes upsert
   */
  export type invControlTowerResourcePurposesUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the invControlTowerResourcePurposes
     */
    select?: invControlTowerResourcePurposesSelect<ExtArgs> | null
    /**
     * The filter to search for the invControlTowerResourcePurposes to update in case it exists.
     */
    where: invControlTowerResourcePurposesWhereUniqueInput
    /**
     * In case the invControlTowerResourcePurposes found by the `where` argument doesn't exist, create a new invControlTowerResourcePurposes with this data.
     */
    create: XOR<invControlTowerResourcePurposesCreateInput, invControlTowerResourcePurposesUncheckedCreateInput>
    /**
     * In case the invControlTowerResourcePurposes was found with the provided `where` argument, update it with this data.
     */
    update: XOR<invControlTowerResourcePurposesUpdateInput, invControlTowerResourcePurposesUncheckedUpdateInput>
  }


  /**
   * invControlTowerResourcePurposes delete
   */
  export type invControlTowerResourcePurposesDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the invControlTowerResourcePurposes
     */
    select?: invControlTowerResourcePurposesSelect<ExtArgs> | null
    /**
     * Filter which invControlTowerResourcePurposes to delete.
     */
    where: invControlTowerResourcePurposesWhereUniqueInput
  }


  /**
   * invControlTowerResourcePurposes deleteMany
   */
  export type invControlTowerResourcePurposesDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which invControlTowerResourcePurposes to delete
     */
    where?: invControlTowerResourcePurposesWhereInput
  }


  /**
   * invControlTowerResourcePurposes without action
   */
  export type invControlTowerResourcePurposesDefaultArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the invControlTowerResourcePurposes
     */
    select?: invControlTowerResourcePurposesSelect<ExtArgs> | null
  }



  /**
   * Model invControlTowerResources
   */

  export type AggregateInvControlTowerResources = {
    _count: InvControlTowerResourcesCountAggregateOutputType | null
    _avg: InvControlTowerResourcesAvgAggregateOutputType | null
    _sum: InvControlTowerResourcesSumAggregateOutputType | null
    _min: InvControlTowerResourcesMinAggregateOutputType | null
    _max: InvControlTowerResourcesMaxAggregateOutputType | null
  }

  export type InvControlTowerResourcesAvgAggregateOutputType = {
    controlTowerTypeID: number | null
    resourceTypeID: number | null
    purpose: number | null
    quantity: number | null
    minSecurityLevel: number | null
    factionID: number | null
  }

  export type InvControlTowerResourcesSumAggregateOutputType = {
    controlTowerTypeID: number | null
    resourceTypeID: number | null
    purpose: number | null
    quantity: number | null
    minSecurityLevel: number | null
    factionID: number | null
  }

  export type InvControlTowerResourcesMinAggregateOutputType = {
    controlTowerTypeID: number | null
    resourceTypeID: number | null
    purpose: number | null
    quantity: number | null
    minSecurityLevel: number | null
    factionID: number | null
  }

  export type InvControlTowerResourcesMaxAggregateOutputType = {
    controlTowerTypeID: number | null
    resourceTypeID: number | null
    purpose: number | null
    quantity: number | null
    minSecurityLevel: number | null
    factionID: number | null
  }

  export type InvControlTowerResourcesCountAggregateOutputType = {
    controlTowerTypeID: number
    resourceTypeID: number
    purpose: number
    quantity: number
    minSecurityLevel: number
    factionID: number
    _all: number
  }


  export type InvControlTowerResourcesAvgAggregateInputType = {
    controlTowerTypeID?: true
    resourceTypeID?: true
    purpose?: true
    quantity?: true
    minSecurityLevel?: true
    factionID?: true
  }

  export type InvControlTowerResourcesSumAggregateInputType = {
    controlTowerTypeID?: true
    resourceTypeID?: true
    purpose?: true
    quantity?: true
    minSecurityLevel?: true
    factionID?: true
  }

  export type InvControlTowerResourcesMinAggregateInputType = {
    controlTowerTypeID?: true
    resourceTypeID?: true
    purpose?: true
    quantity?: true
    minSecurityLevel?: true
    factionID?: true
  }

  export type InvControlTowerResourcesMaxAggregateInputType = {
    controlTowerTypeID?: true
    resourceTypeID?: true
    purpose?: true
    quantity?: true
    minSecurityLevel?: true
    factionID?: true
  }

  export type InvControlTowerResourcesCountAggregateInputType = {
    controlTowerTypeID?: true
    resourceTypeID?: true
    purpose?: true
    quantity?: true
    minSecurityLevel?: true
    factionID?: true
    _all?: true
  }

  export type InvControlTowerResourcesAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which invControlTowerResources to aggregate.
     */
    where?: invControlTowerResourcesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of invControlTowerResources to fetch.
     */
    orderBy?: invControlTowerResourcesOrderByWithRelationInput | invControlTowerResourcesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: invControlTowerResourcesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` invControlTowerResources from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` invControlTowerResources.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned invControlTowerResources
    **/
    _count?: true | InvControlTowerResourcesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: InvControlTowerResourcesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: InvControlTowerResourcesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: InvControlTowerResourcesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: InvControlTowerResourcesMaxAggregateInputType
  }

  export type GetInvControlTowerResourcesAggregateType<T extends InvControlTowerResourcesAggregateArgs> = {
        [P in keyof T & keyof AggregateInvControlTowerResources]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInvControlTowerResources[P]>
      : GetScalarType<T[P], AggregateInvControlTowerResources[P]>
  }




  export type invControlTowerResourcesGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: invControlTowerResourcesWhereInput
    orderBy?: invControlTowerResourcesOrderByWithAggregationInput | invControlTowerResourcesOrderByWithAggregationInput[]
    by: InvControlTowerResourcesScalarFieldEnum[] | InvControlTowerResourcesScalarFieldEnum
    having?: invControlTowerResourcesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: InvControlTowerResourcesCountAggregateInputType | true
    _avg?: InvControlTowerResourcesAvgAggregateInputType
    _sum?: InvControlTowerResourcesSumAggregateInputType
    _min?: InvControlTowerResourcesMinAggregateInputType
    _max?: InvControlTowerResourcesMaxAggregateInputType
  }

  export type InvControlTowerResourcesGroupByOutputType = {
    controlTowerTypeID: number
    resourceTypeID: number
    purpose: number | null
    quantity: number | null
    minSecurityLevel: number | null
    factionID: number | null
    _count: InvControlTowerResourcesCountAggregateOutputType | null
    _avg: InvControlTowerResourcesAvgAggregateOutputType | null
    _sum: InvControlTowerResourcesSumAggregateOutputType | null
    _min: InvControlTowerResourcesMinAggregateOutputType | null
    _max: InvControlTowerResourcesMaxAggregateOutputType | null
  }

  type GetInvControlTowerResourcesGroupByPayload<T extends invControlTowerResourcesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<InvControlTowerResourcesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof InvControlTowerResourcesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], InvControlTowerResourcesGroupByOutputType[P]>
            : GetScalarType<T[P], InvControlTowerResourcesGroupByOutputType[P]>
        }
      >
    >


  export type invControlTowerResourcesSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    controlTowerTypeID?: boolean
    resourceTypeID?: boolean
    purpose?: boolean
    quantity?: boolean
    minSecurityLevel?: boolean
    factionID?: boolean
  }, ExtArgs["result"]["invControlTowerResources"]>

  export type invControlTowerResourcesSelectScalar = {
    controlTowerTypeID?: boolean
    resourceTypeID?: boolean
    purpose?: boolean
    quantity?: boolean
    minSecurityLevel?: boolean
    factionID?: boolean
  }


  export type $invControlTowerResourcesPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    name: "invControlTowerResources"
    objects: {}
    scalars: $Extensions.GetResult<{
      controlTowerTypeID: number
      resourceTypeID: number
      purpose: number | null
      quantity: number | null
      minSecurityLevel: number | null
      factionID: number | null
    }, ExtArgs["result"]["invControlTowerResources"]>
    composites: {}
  }


  type invControlTowerResourcesGetPayload<S extends boolean | null | undefined | invControlTowerResourcesDefaultArgs> = $Result.GetResult<Prisma.$invControlTowerResourcesPayload, S>

  type invControlTowerResourcesCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<invControlTowerResourcesFindManyArgs, 'select' | 'include'> & {
      select?: InvControlTowerResourcesCountAggregateInputType | true
    }

  export interface invControlTowerResourcesDelegate<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['invControlTowerResources'], meta: { name: 'invControlTowerResources' } }
    /**
     * Find zero or one InvControlTowerResources that matches the filter.
     * @param {invControlTowerResourcesFindUniqueArgs} args - Arguments to find a InvControlTowerResources
     * @example
     * // Get one InvControlTowerResources
     * const invControlTowerResources = await prisma.invControlTowerResources.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends invControlTowerResourcesFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, invControlTowerResourcesFindUniqueArgs<ExtArgs>>
    ): Prisma__invControlTowerResourcesClient<$Result.GetResult<Prisma.$invControlTowerResourcesPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one InvControlTowerResources that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {invControlTowerResourcesFindUniqueOrThrowArgs} args - Arguments to find a InvControlTowerResources
     * @example
     * // Get one InvControlTowerResources
     * const invControlTowerResources = await prisma.invControlTowerResources.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends invControlTowerResourcesFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, invControlTowerResourcesFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__invControlTowerResourcesClient<$Result.GetResult<Prisma.$invControlTowerResourcesPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first InvControlTowerResources that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {invControlTowerResourcesFindFirstArgs} args - Arguments to find a InvControlTowerResources
     * @example
     * // Get one InvControlTowerResources
     * const invControlTowerResources = await prisma.invControlTowerResources.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends invControlTowerResourcesFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, invControlTowerResourcesFindFirstArgs<ExtArgs>>
    ): Prisma__invControlTowerResourcesClient<$Result.GetResult<Prisma.$invControlTowerResourcesPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first InvControlTowerResources that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {invControlTowerResourcesFindFirstOrThrowArgs} args - Arguments to find a InvControlTowerResources
     * @example
     * // Get one InvControlTowerResources
     * const invControlTowerResources = await prisma.invControlTowerResources.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends invControlTowerResourcesFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, invControlTowerResourcesFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__invControlTowerResourcesClient<$Result.GetResult<Prisma.$invControlTowerResourcesPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more InvControlTowerResources that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {invControlTowerResourcesFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all InvControlTowerResources
     * const invControlTowerResources = await prisma.invControlTowerResources.findMany()
     * 
     * // Get first 10 InvControlTowerResources
     * const invControlTowerResources = await prisma.invControlTowerResources.findMany({ take: 10 })
     * 
     * // Only select the `controlTowerTypeID`
     * const invControlTowerResourcesWithControlTowerTypeIDOnly = await prisma.invControlTowerResources.findMany({ select: { controlTowerTypeID: true } })
     * 
    **/
    findMany<T extends invControlTowerResourcesFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, invControlTowerResourcesFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$invControlTowerResourcesPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a InvControlTowerResources.
     * @param {invControlTowerResourcesCreateArgs} args - Arguments to create a InvControlTowerResources.
     * @example
     * // Create one InvControlTowerResources
     * const InvControlTowerResources = await prisma.invControlTowerResources.create({
     *   data: {
     *     // ... data to create a InvControlTowerResources
     *   }
     * })
     * 
    **/
    create<T extends invControlTowerResourcesCreateArgs<ExtArgs>>(
      args: SelectSubset<T, invControlTowerResourcesCreateArgs<ExtArgs>>
    ): Prisma__invControlTowerResourcesClient<$Result.GetResult<Prisma.$invControlTowerResourcesPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many InvControlTowerResources.
     *     @param {invControlTowerResourcesCreateManyArgs} args - Arguments to create many InvControlTowerResources.
     *     @example
     *     // Create many InvControlTowerResources
     *     const invControlTowerResources = await prisma.invControlTowerResources.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends invControlTowerResourcesCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, invControlTowerResourcesCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a InvControlTowerResources.
     * @param {invControlTowerResourcesDeleteArgs} args - Arguments to delete one InvControlTowerResources.
     * @example
     * // Delete one InvControlTowerResources
     * const InvControlTowerResources = await prisma.invControlTowerResources.delete({
     *   where: {
     *     // ... filter to delete one InvControlTowerResources
     *   }
     * })
     * 
    **/
    delete<T extends invControlTowerResourcesDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, invControlTowerResourcesDeleteArgs<ExtArgs>>
    ): Prisma__invControlTowerResourcesClient<$Result.GetResult<Prisma.$invControlTowerResourcesPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one InvControlTowerResources.
     * @param {invControlTowerResourcesUpdateArgs} args - Arguments to update one InvControlTowerResources.
     * @example
     * // Update one InvControlTowerResources
     * const invControlTowerResources = await prisma.invControlTowerResources.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends invControlTowerResourcesUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, invControlTowerResourcesUpdateArgs<ExtArgs>>
    ): Prisma__invControlTowerResourcesClient<$Result.GetResult<Prisma.$invControlTowerResourcesPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more InvControlTowerResources.
     * @param {invControlTowerResourcesDeleteManyArgs} args - Arguments to filter InvControlTowerResources to delete.
     * @example
     * // Delete a few InvControlTowerResources
     * const { count } = await prisma.invControlTowerResources.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends invControlTowerResourcesDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, invControlTowerResourcesDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more InvControlTowerResources.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {invControlTowerResourcesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many InvControlTowerResources
     * const invControlTowerResources = await prisma.invControlTowerResources.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends invControlTowerResourcesUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, invControlTowerResourcesUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one InvControlTowerResources.
     * @param {invControlTowerResourcesUpsertArgs} args - Arguments to update or create a InvControlTowerResources.
     * @example
     * // Update or create a InvControlTowerResources
     * const invControlTowerResources = await prisma.invControlTowerResources.upsert({
     *   create: {
     *     // ... data to create a InvControlTowerResources
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the InvControlTowerResources we want to update
     *   }
     * })
    **/
    upsert<T extends invControlTowerResourcesUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, invControlTowerResourcesUpsertArgs<ExtArgs>>
    ): Prisma__invControlTowerResourcesClient<$Result.GetResult<Prisma.$invControlTowerResourcesPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of InvControlTowerResources.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {invControlTowerResourcesCountArgs} args - Arguments to filter InvControlTowerResources to count.
     * @example
     * // Count the number of InvControlTowerResources
     * const count = await prisma.invControlTowerResources.count({
     *   where: {
     *     // ... the filter for the InvControlTowerResources we want to count
     *   }
     * })
    **/
    count<T extends invControlTowerResourcesCountArgs>(
      args?: Subset<T, invControlTowerResourcesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], InvControlTowerResourcesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a InvControlTowerResources.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvControlTowerResourcesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends InvControlTowerResourcesAggregateArgs>(args: Subset<T, InvControlTowerResourcesAggregateArgs>): Prisma.PrismaPromise<GetInvControlTowerResourcesAggregateType<T>>

    /**
     * Group by InvControlTowerResources.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {invControlTowerResourcesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends invControlTowerResourcesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: invControlTowerResourcesGroupByArgs['orderBy'] }
        : { orderBy?: invControlTowerResourcesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, invControlTowerResourcesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInvControlTowerResourcesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the invControlTowerResources model
   */
  readonly fields: invControlTowerResourcesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for invControlTowerResources.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__invControlTowerResourcesClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';


    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the invControlTowerResources model
   */ 
  interface invControlTowerResourcesFieldRefs {
    readonly controlTowerTypeID: FieldRef<"invControlTowerResources", 'Int'>
    readonly resourceTypeID: FieldRef<"invControlTowerResources", 'Int'>
    readonly purpose: FieldRef<"invControlTowerResources", 'Int'>
    readonly quantity: FieldRef<"invControlTowerResources", 'Int'>
    readonly minSecurityLevel: FieldRef<"invControlTowerResources", 'Float'>
    readonly factionID: FieldRef<"invControlTowerResources", 'Int'>
  }
    

  // Custom InputTypes

  /**
   * invControlTowerResources findUnique
   */
  export type invControlTowerResourcesFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the invControlTowerResources
     */
    select?: invControlTowerResourcesSelect<ExtArgs> | null
    /**
     * Filter, which invControlTowerResources to fetch.
     */
    where: invControlTowerResourcesWhereUniqueInput
  }


  /**
   * invControlTowerResources findUniqueOrThrow
   */
  export type invControlTowerResourcesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the invControlTowerResources
     */
    select?: invControlTowerResourcesSelect<ExtArgs> | null
    /**
     * Filter, which invControlTowerResources to fetch.
     */
    where: invControlTowerResourcesWhereUniqueInput
  }


  /**
   * invControlTowerResources findFirst
   */
  export type invControlTowerResourcesFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the invControlTowerResources
     */
    select?: invControlTowerResourcesSelect<ExtArgs> | null
    /**
     * Filter, which invControlTowerResources to fetch.
     */
    where?: invControlTowerResourcesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of invControlTowerResources to fetch.
     */
    orderBy?: invControlTowerResourcesOrderByWithRelationInput | invControlTowerResourcesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for invControlTowerResources.
     */
    cursor?: invControlTowerResourcesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` invControlTowerResources from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` invControlTowerResources.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of invControlTowerResources.
     */
    distinct?: InvControlTowerResourcesScalarFieldEnum | InvControlTowerResourcesScalarFieldEnum[]
  }


  /**
   * invControlTowerResources findFirstOrThrow
   */
  export type invControlTowerResourcesFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the invControlTowerResources
     */
    select?: invControlTowerResourcesSelect<ExtArgs> | null
    /**
     * Filter, which invControlTowerResources to fetch.
     */
    where?: invControlTowerResourcesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of invControlTowerResources to fetch.
     */
    orderBy?: invControlTowerResourcesOrderByWithRelationInput | invControlTowerResourcesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for invControlTowerResources.
     */
    cursor?: invControlTowerResourcesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` invControlTowerResources from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` invControlTowerResources.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of invControlTowerResources.
     */
    distinct?: InvControlTowerResourcesScalarFieldEnum | InvControlTowerResourcesScalarFieldEnum[]
  }


  /**
   * invControlTowerResources findMany
   */
  export type invControlTowerResourcesFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the invControlTowerResources
     */
    select?: invControlTowerResourcesSelect<ExtArgs> | null
    /**
     * Filter, which invControlTowerResources to fetch.
     */
    where?: invControlTowerResourcesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of invControlTowerResources to fetch.
     */
    orderBy?: invControlTowerResourcesOrderByWithRelationInput | invControlTowerResourcesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing invControlTowerResources.
     */
    cursor?: invControlTowerResourcesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` invControlTowerResources from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` invControlTowerResources.
     */
    skip?: number
    distinct?: InvControlTowerResourcesScalarFieldEnum | InvControlTowerResourcesScalarFieldEnum[]
  }


  /**
   * invControlTowerResources create
   */
  export type invControlTowerResourcesCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the invControlTowerResources
     */
    select?: invControlTowerResourcesSelect<ExtArgs> | null
    /**
     * The data needed to create a invControlTowerResources.
     */
    data: XOR<invControlTowerResourcesCreateInput, invControlTowerResourcesUncheckedCreateInput>
  }


  /**
   * invControlTowerResources createMany
   */
  export type invControlTowerResourcesCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many invControlTowerResources.
     */
    data: invControlTowerResourcesCreateManyInput | invControlTowerResourcesCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * invControlTowerResources update
   */
  export type invControlTowerResourcesUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the invControlTowerResources
     */
    select?: invControlTowerResourcesSelect<ExtArgs> | null
    /**
     * The data needed to update a invControlTowerResources.
     */
    data: XOR<invControlTowerResourcesUpdateInput, invControlTowerResourcesUncheckedUpdateInput>
    /**
     * Choose, which invControlTowerResources to update.
     */
    where: invControlTowerResourcesWhereUniqueInput
  }


  /**
   * invControlTowerResources updateMany
   */
  export type invControlTowerResourcesUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update invControlTowerResources.
     */
    data: XOR<invControlTowerResourcesUpdateManyMutationInput, invControlTowerResourcesUncheckedUpdateManyInput>
    /**
     * Filter which invControlTowerResources to update
     */
    where?: invControlTowerResourcesWhereInput
  }


  /**
   * invControlTowerResources upsert
   */
  export type invControlTowerResourcesUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the invControlTowerResources
     */
    select?: invControlTowerResourcesSelect<ExtArgs> | null
    /**
     * The filter to search for the invControlTowerResources to update in case it exists.
     */
    where: invControlTowerResourcesWhereUniqueInput
    /**
     * In case the invControlTowerResources found by the `where` argument doesn't exist, create a new invControlTowerResources with this data.
     */
    create: XOR<invControlTowerResourcesCreateInput, invControlTowerResourcesUncheckedCreateInput>
    /**
     * In case the invControlTowerResources was found with the provided `where` argument, update it with this data.
     */
    update: XOR<invControlTowerResourcesUpdateInput, invControlTowerResourcesUncheckedUpdateInput>
  }


  /**
   * invControlTowerResources delete
   */
  export type invControlTowerResourcesDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the invControlTowerResources
     */
    select?: invControlTowerResourcesSelect<ExtArgs> | null
    /**
     * Filter which invControlTowerResources to delete.
     */
    where: invControlTowerResourcesWhereUniqueInput
  }


  /**
   * invControlTowerResources deleteMany
   */
  export type invControlTowerResourcesDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which invControlTowerResources to delete
     */
    where?: invControlTowerResourcesWhereInput
  }


  /**
   * invControlTowerResources without action
   */
  export type invControlTowerResourcesDefaultArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the invControlTowerResources
     */
    select?: invControlTowerResourcesSelect<ExtArgs> | null
  }



  /**
   * Model invFlags
   */

  export type AggregateInvFlags = {
    _count: InvFlagsCountAggregateOutputType | null
    _avg: InvFlagsAvgAggregateOutputType | null
    _sum: InvFlagsSumAggregateOutputType | null
    _min: InvFlagsMinAggregateOutputType | null
    _max: InvFlagsMaxAggregateOutputType | null
  }

  export type InvFlagsAvgAggregateOutputType = {
    flagID: number | null
    orderID: number | null
  }

  export type InvFlagsSumAggregateOutputType = {
    flagID: number | null
    orderID: number | null
  }

  export type InvFlagsMinAggregateOutputType = {
    flagID: number | null
    flagName: string | null
    flagText: string | null
    orderID: number | null
  }

  export type InvFlagsMaxAggregateOutputType = {
    flagID: number | null
    flagName: string | null
    flagText: string | null
    orderID: number | null
  }

  export type InvFlagsCountAggregateOutputType = {
    flagID: number
    flagName: number
    flagText: number
    orderID: number
    _all: number
  }


  export type InvFlagsAvgAggregateInputType = {
    flagID?: true
    orderID?: true
  }

  export type InvFlagsSumAggregateInputType = {
    flagID?: true
    orderID?: true
  }

  export type InvFlagsMinAggregateInputType = {
    flagID?: true
    flagName?: true
    flagText?: true
    orderID?: true
  }

  export type InvFlagsMaxAggregateInputType = {
    flagID?: true
    flagName?: true
    flagText?: true
    orderID?: true
  }

  export type InvFlagsCountAggregateInputType = {
    flagID?: true
    flagName?: true
    flagText?: true
    orderID?: true
    _all?: true
  }

  export type InvFlagsAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which invFlags to aggregate.
     */
    where?: invFlagsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of invFlags to fetch.
     */
    orderBy?: invFlagsOrderByWithRelationInput | invFlagsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: invFlagsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` invFlags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` invFlags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned invFlags
    **/
    _count?: true | InvFlagsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: InvFlagsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: InvFlagsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: InvFlagsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: InvFlagsMaxAggregateInputType
  }

  export type GetInvFlagsAggregateType<T extends InvFlagsAggregateArgs> = {
        [P in keyof T & keyof AggregateInvFlags]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInvFlags[P]>
      : GetScalarType<T[P], AggregateInvFlags[P]>
  }




  export type invFlagsGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: invFlagsWhereInput
    orderBy?: invFlagsOrderByWithAggregationInput | invFlagsOrderByWithAggregationInput[]
    by: InvFlagsScalarFieldEnum[] | InvFlagsScalarFieldEnum
    having?: invFlagsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: InvFlagsCountAggregateInputType | true
    _avg?: InvFlagsAvgAggregateInputType
    _sum?: InvFlagsSumAggregateInputType
    _min?: InvFlagsMinAggregateInputType
    _max?: InvFlagsMaxAggregateInputType
  }

  export type InvFlagsGroupByOutputType = {
    flagID: number
    flagName: string | null
    flagText: string | null
    orderID: number | null
    _count: InvFlagsCountAggregateOutputType | null
    _avg: InvFlagsAvgAggregateOutputType | null
    _sum: InvFlagsSumAggregateOutputType | null
    _min: InvFlagsMinAggregateOutputType | null
    _max: InvFlagsMaxAggregateOutputType | null
  }

  type GetInvFlagsGroupByPayload<T extends invFlagsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<InvFlagsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof InvFlagsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], InvFlagsGroupByOutputType[P]>
            : GetScalarType<T[P], InvFlagsGroupByOutputType[P]>
        }
      >
    >


  export type invFlagsSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    flagID?: boolean
    flagName?: boolean
    flagText?: boolean
    orderID?: boolean
  }, ExtArgs["result"]["invFlags"]>

  export type invFlagsSelectScalar = {
    flagID?: boolean
    flagName?: boolean
    flagText?: boolean
    orderID?: boolean
  }


  export type $invFlagsPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    name: "invFlags"
    objects: {}
    scalars: $Extensions.GetResult<{
      flagID: number
      flagName: string | null
      flagText: string | null
      orderID: number | null
    }, ExtArgs["result"]["invFlags"]>
    composites: {}
  }


  type invFlagsGetPayload<S extends boolean | null | undefined | invFlagsDefaultArgs> = $Result.GetResult<Prisma.$invFlagsPayload, S>

  type invFlagsCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<invFlagsFindManyArgs, 'select' | 'include'> & {
      select?: InvFlagsCountAggregateInputType | true
    }

  export interface invFlagsDelegate<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['invFlags'], meta: { name: 'invFlags' } }
    /**
     * Find zero or one InvFlags that matches the filter.
     * @param {invFlagsFindUniqueArgs} args - Arguments to find a InvFlags
     * @example
     * // Get one InvFlags
     * const invFlags = await prisma.invFlags.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends invFlagsFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, invFlagsFindUniqueArgs<ExtArgs>>
    ): Prisma__invFlagsClient<$Result.GetResult<Prisma.$invFlagsPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one InvFlags that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {invFlagsFindUniqueOrThrowArgs} args - Arguments to find a InvFlags
     * @example
     * // Get one InvFlags
     * const invFlags = await prisma.invFlags.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends invFlagsFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, invFlagsFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__invFlagsClient<$Result.GetResult<Prisma.$invFlagsPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first InvFlags that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {invFlagsFindFirstArgs} args - Arguments to find a InvFlags
     * @example
     * // Get one InvFlags
     * const invFlags = await prisma.invFlags.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends invFlagsFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, invFlagsFindFirstArgs<ExtArgs>>
    ): Prisma__invFlagsClient<$Result.GetResult<Prisma.$invFlagsPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first InvFlags that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {invFlagsFindFirstOrThrowArgs} args - Arguments to find a InvFlags
     * @example
     * // Get one InvFlags
     * const invFlags = await prisma.invFlags.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends invFlagsFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, invFlagsFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__invFlagsClient<$Result.GetResult<Prisma.$invFlagsPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more InvFlags that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {invFlagsFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all InvFlags
     * const invFlags = await prisma.invFlags.findMany()
     * 
     * // Get first 10 InvFlags
     * const invFlags = await prisma.invFlags.findMany({ take: 10 })
     * 
     * // Only select the `flagID`
     * const invFlagsWithFlagIDOnly = await prisma.invFlags.findMany({ select: { flagID: true } })
     * 
    **/
    findMany<T extends invFlagsFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, invFlagsFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$invFlagsPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a InvFlags.
     * @param {invFlagsCreateArgs} args - Arguments to create a InvFlags.
     * @example
     * // Create one InvFlags
     * const InvFlags = await prisma.invFlags.create({
     *   data: {
     *     // ... data to create a InvFlags
     *   }
     * })
     * 
    **/
    create<T extends invFlagsCreateArgs<ExtArgs>>(
      args: SelectSubset<T, invFlagsCreateArgs<ExtArgs>>
    ): Prisma__invFlagsClient<$Result.GetResult<Prisma.$invFlagsPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many InvFlags.
     *     @param {invFlagsCreateManyArgs} args - Arguments to create many InvFlags.
     *     @example
     *     // Create many InvFlags
     *     const invFlags = await prisma.invFlags.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends invFlagsCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, invFlagsCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a InvFlags.
     * @param {invFlagsDeleteArgs} args - Arguments to delete one InvFlags.
     * @example
     * // Delete one InvFlags
     * const InvFlags = await prisma.invFlags.delete({
     *   where: {
     *     // ... filter to delete one InvFlags
     *   }
     * })
     * 
    **/
    delete<T extends invFlagsDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, invFlagsDeleteArgs<ExtArgs>>
    ): Prisma__invFlagsClient<$Result.GetResult<Prisma.$invFlagsPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one InvFlags.
     * @param {invFlagsUpdateArgs} args - Arguments to update one InvFlags.
     * @example
     * // Update one InvFlags
     * const invFlags = await prisma.invFlags.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends invFlagsUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, invFlagsUpdateArgs<ExtArgs>>
    ): Prisma__invFlagsClient<$Result.GetResult<Prisma.$invFlagsPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more InvFlags.
     * @param {invFlagsDeleteManyArgs} args - Arguments to filter InvFlags to delete.
     * @example
     * // Delete a few InvFlags
     * const { count } = await prisma.invFlags.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends invFlagsDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, invFlagsDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more InvFlags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {invFlagsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many InvFlags
     * const invFlags = await prisma.invFlags.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends invFlagsUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, invFlagsUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one InvFlags.
     * @param {invFlagsUpsertArgs} args - Arguments to update or create a InvFlags.
     * @example
     * // Update or create a InvFlags
     * const invFlags = await prisma.invFlags.upsert({
     *   create: {
     *     // ... data to create a InvFlags
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the InvFlags we want to update
     *   }
     * })
    **/
    upsert<T extends invFlagsUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, invFlagsUpsertArgs<ExtArgs>>
    ): Prisma__invFlagsClient<$Result.GetResult<Prisma.$invFlagsPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of InvFlags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {invFlagsCountArgs} args - Arguments to filter InvFlags to count.
     * @example
     * // Count the number of InvFlags
     * const count = await prisma.invFlags.count({
     *   where: {
     *     // ... the filter for the InvFlags we want to count
     *   }
     * })
    **/
    count<T extends invFlagsCountArgs>(
      args?: Subset<T, invFlagsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], InvFlagsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a InvFlags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvFlagsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends InvFlagsAggregateArgs>(args: Subset<T, InvFlagsAggregateArgs>): Prisma.PrismaPromise<GetInvFlagsAggregateType<T>>

    /**
     * Group by InvFlags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {invFlagsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends invFlagsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: invFlagsGroupByArgs['orderBy'] }
        : { orderBy?: invFlagsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, invFlagsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInvFlagsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the invFlags model
   */
  readonly fields: invFlagsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for invFlags.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__invFlagsClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';


    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the invFlags model
   */ 
  interface invFlagsFieldRefs {
    readonly flagID: FieldRef<"invFlags", 'Int'>
    readonly flagName: FieldRef<"invFlags", 'String'>
    readonly flagText: FieldRef<"invFlags", 'String'>
    readonly orderID: FieldRef<"invFlags", 'Int'>
  }
    

  // Custom InputTypes

  /**
   * invFlags findUnique
   */
  export type invFlagsFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the invFlags
     */
    select?: invFlagsSelect<ExtArgs> | null
    /**
     * Filter, which invFlags to fetch.
     */
    where: invFlagsWhereUniqueInput
  }


  /**
   * invFlags findUniqueOrThrow
   */
  export type invFlagsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the invFlags
     */
    select?: invFlagsSelect<ExtArgs> | null
    /**
     * Filter, which invFlags to fetch.
     */
    where: invFlagsWhereUniqueInput
  }


  /**
   * invFlags findFirst
   */
  export type invFlagsFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the invFlags
     */
    select?: invFlagsSelect<ExtArgs> | null
    /**
     * Filter, which invFlags to fetch.
     */
    where?: invFlagsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of invFlags to fetch.
     */
    orderBy?: invFlagsOrderByWithRelationInput | invFlagsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for invFlags.
     */
    cursor?: invFlagsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` invFlags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` invFlags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of invFlags.
     */
    distinct?: InvFlagsScalarFieldEnum | InvFlagsScalarFieldEnum[]
  }


  /**
   * invFlags findFirstOrThrow
   */
  export type invFlagsFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the invFlags
     */
    select?: invFlagsSelect<ExtArgs> | null
    /**
     * Filter, which invFlags to fetch.
     */
    where?: invFlagsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of invFlags to fetch.
     */
    orderBy?: invFlagsOrderByWithRelationInput | invFlagsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for invFlags.
     */
    cursor?: invFlagsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` invFlags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` invFlags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of invFlags.
     */
    distinct?: InvFlagsScalarFieldEnum | InvFlagsScalarFieldEnum[]
  }


  /**
   * invFlags findMany
   */
  export type invFlagsFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the invFlags
     */
    select?: invFlagsSelect<ExtArgs> | null
    /**
     * Filter, which invFlags to fetch.
     */
    where?: invFlagsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of invFlags to fetch.
     */
    orderBy?: invFlagsOrderByWithRelationInput | invFlagsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing invFlags.
     */
    cursor?: invFlagsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` invFlags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` invFlags.
     */
    skip?: number
    distinct?: InvFlagsScalarFieldEnum | InvFlagsScalarFieldEnum[]
  }


  /**
   * invFlags create
   */
  export type invFlagsCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the invFlags
     */
    select?: invFlagsSelect<ExtArgs> | null
    /**
     * The data needed to create a invFlags.
     */
    data: XOR<invFlagsCreateInput, invFlagsUncheckedCreateInput>
  }


  /**
   * invFlags createMany
   */
  export type invFlagsCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many invFlags.
     */
    data: invFlagsCreateManyInput | invFlagsCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * invFlags update
   */
  export type invFlagsUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the invFlags
     */
    select?: invFlagsSelect<ExtArgs> | null
    /**
     * The data needed to update a invFlags.
     */
    data: XOR<invFlagsUpdateInput, invFlagsUncheckedUpdateInput>
    /**
     * Choose, which invFlags to update.
     */
    where: invFlagsWhereUniqueInput
  }


  /**
   * invFlags updateMany
   */
  export type invFlagsUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update invFlags.
     */
    data: XOR<invFlagsUpdateManyMutationInput, invFlagsUncheckedUpdateManyInput>
    /**
     * Filter which invFlags to update
     */
    where?: invFlagsWhereInput
  }


  /**
   * invFlags upsert
   */
  export type invFlagsUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the invFlags
     */
    select?: invFlagsSelect<ExtArgs> | null
    /**
     * The filter to search for the invFlags to update in case it exists.
     */
    where: invFlagsWhereUniqueInput
    /**
     * In case the invFlags found by the `where` argument doesn't exist, create a new invFlags with this data.
     */
    create: XOR<invFlagsCreateInput, invFlagsUncheckedCreateInput>
    /**
     * In case the invFlags was found with the provided `where` argument, update it with this data.
     */
    update: XOR<invFlagsUpdateInput, invFlagsUncheckedUpdateInput>
  }


  /**
   * invFlags delete
   */
  export type invFlagsDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the invFlags
     */
    select?: invFlagsSelect<ExtArgs> | null
    /**
     * Filter which invFlags to delete.
     */
    where: invFlagsWhereUniqueInput
  }


  /**
   * invFlags deleteMany
   */
  export type invFlagsDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which invFlags to delete
     */
    where?: invFlagsWhereInput
  }


  /**
   * invFlags without action
   */
  export type invFlagsDefaultArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the invFlags
     */
    select?: invFlagsSelect<ExtArgs> | null
  }



  /**
   * Model invGroups
   */

  export type AggregateInvGroups = {
    _count: InvGroupsCountAggregateOutputType | null
    _avg: InvGroupsAvgAggregateOutputType | null
    _sum: InvGroupsSumAggregateOutputType | null
    _min: InvGroupsMinAggregateOutputType | null
    _max: InvGroupsMaxAggregateOutputType | null
  }

  export type InvGroupsAvgAggregateOutputType = {
    groupID: number | null
    categoryID: number | null
    iconID: number | null
  }

  export type InvGroupsSumAggregateOutputType = {
    groupID: number | null
    categoryID: number | null
    iconID: number | null
  }

  export type InvGroupsMinAggregateOutputType = {
    groupID: number | null
    categoryID: number | null
    groupName: string | null
    iconID: number | null
    useBasePrice: boolean | null
    anchored: boolean | null
    anchorable: boolean | null
    fittableNonSingleton: boolean | null
    published: boolean | null
  }

  export type InvGroupsMaxAggregateOutputType = {
    groupID: number | null
    categoryID: number | null
    groupName: string | null
    iconID: number | null
    useBasePrice: boolean | null
    anchored: boolean | null
    anchorable: boolean | null
    fittableNonSingleton: boolean | null
    published: boolean | null
  }

  export type InvGroupsCountAggregateOutputType = {
    groupID: number
    categoryID: number
    groupName: number
    iconID: number
    useBasePrice: number
    anchored: number
    anchorable: number
    fittableNonSingleton: number
    published: number
    _all: number
  }


  export type InvGroupsAvgAggregateInputType = {
    groupID?: true
    categoryID?: true
    iconID?: true
  }

  export type InvGroupsSumAggregateInputType = {
    groupID?: true
    categoryID?: true
    iconID?: true
  }

  export type InvGroupsMinAggregateInputType = {
    groupID?: true
    categoryID?: true
    groupName?: true
    iconID?: true
    useBasePrice?: true
    anchored?: true
    anchorable?: true
    fittableNonSingleton?: true
    published?: true
  }

  export type InvGroupsMaxAggregateInputType = {
    groupID?: true
    categoryID?: true
    groupName?: true
    iconID?: true
    useBasePrice?: true
    anchored?: true
    anchorable?: true
    fittableNonSingleton?: true
    published?: true
  }

  export type InvGroupsCountAggregateInputType = {
    groupID?: true
    categoryID?: true
    groupName?: true
    iconID?: true
    useBasePrice?: true
    anchored?: true
    anchorable?: true
    fittableNonSingleton?: true
    published?: true
    _all?: true
  }

  export type InvGroupsAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which invGroups to aggregate.
     */
    where?: invGroupsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of invGroups to fetch.
     */
    orderBy?: invGroupsOrderByWithRelationInput | invGroupsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: invGroupsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` invGroups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` invGroups.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned invGroups
    **/
    _count?: true | InvGroupsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: InvGroupsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: InvGroupsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: InvGroupsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: InvGroupsMaxAggregateInputType
  }

  export type GetInvGroupsAggregateType<T extends InvGroupsAggregateArgs> = {
        [P in keyof T & keyof AggregateInvGroups]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInvGroups[P]>
      : GetScalarType<T[P], AggregateInvGroups[P]>
  }




  export type invGroupsGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: invGroupsWhereInput
    orderBy?: invGroupsOrderByWithAggregationInput | invGroupsOrderByWithAggregationInput[]
    by: InvGroupsScalarFieldEnum[] | InvGroupsScalarFieldEnum
    having?: invGroupsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: InvGroupsCountAggregateInputType | true
    _avg?: InvGroupsAvgAggregateInputType
    _sum?: InvGroupsSumAggregateInputType
    _min?: InvGroupsMinAggregateInputType
    _max?: InvGroupsMaxAggregateInputType
  }

  export type InvGroupsGroupByOutputType = {
    groupID: number
    categoryID: number | null
    groupName: string | null
    iconID: number | null
    useBasePrice: boolean | null
    anchored: boolean | null
    anchorable: boolean | null
    fittableNonSingleton: boolean | null
    published: boolean | null
    _count: InvGroupsCountAggregateOutputType | null
    _avg: InvGroupsAvgAggregateOutputType | null
    _sum: InvGroupsSumAggregateOutputType | null
    _min: InvGroupsMinAggregateOutputType | null
    _max: InvGroupsMaxAggregateOutputType | null
  }

  type GetInvGroupsGroupByPayload<T extends invGroupsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<InvGroupsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof InvGroupsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], InvGroupsGroupByOutputType[P]>
            : GetScalarType<T[P], InvGroupsGroupByOutputType[P]>
        }
      >
    >


  export type invGroupsSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    groupID?: boolean
    categoryID?: boolean
    groupName?: boolean
    iconID?: boolean
    useBasePrice?: boolean
    anchored?: boolean
    anchorable?: boolean
    fittableNonSingleton?: boolean
    published?: boolean
  }, ExtArgs["result"]["invGroups"]>

  export type invGroupsSelectScalar = {
    groupID?: boolean
    categoryID?: boolean
    groupName?: boolean
    iconID?: boolean
    useBasePrice?: boolean
    anchored?: boolean
    anchorable?: boolean
    fittableNonSingleton?: boolean
    published?: boolean
  }


  export type $invGroupsPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    name: "invGroups"
    objects: {}
    scalars: $Extensions.GetResult<{
      groupID: number
      categoryID: number | null
      groupName: string | null
      iconID: number | null
      useBasePrice: boolean | null
      anchored: boolean | null
      anchorable: boolean | null
      fittableNonSingleton: boolean | null
      published: boolean | null
    }, ExtArgs["result"]["invGroups"]>
    composites: {}
  }


  type invGroupsGetPayload<S extends boolean | null | undefined | invGroupsDefaultArgs> = $Result.GetResult<Prisma.$invGroupsPayload, S>

  type invGroupsCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<invGroupsFindManyArgs, 'select' | 'include'> & {
      select?: InvGroupsCountAggregateInputType | true
    }

  export interface invGroupsDelegate<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['invGroups'], meta: { name: 'invGroups' } }
    /**
     * Find zero or one InvGroups that matches the filter.
     * @param {invGroupsFindUniqueArgs} args - Arguments to find a InvGroups
     * @example
     * // Get one InvGroups
     * const invGroups = await prisma.invGroups.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends invGroupsFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, invGroupsFindUniqueArgs<ExtArgs>>
    ): Prisma__invGroupsClient<$Result.GetResult<Prisma.$invGroupsPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one InvGroups that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {invGroupsFindUniqueOrThrowArgs} args - Arguments to find a InvGroups
     * @example
     * // Get one InvGroups
     * const invGroups = await prisma.invGroups.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends invGroupsFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, invGroupsFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__invGroupsClient<$Result.GetResult<Prisma.$invGroupsPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first InvGroups that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {invGroupsFindFirstArgs} args - Arguments to find a InvGroups
     * @example
     * // Get one InvGroups
     * const invGroups = await prisma.invGroups.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends invGroupsFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, invGroupsFindFirstArgs<ExtArgs>>
    ): Prisma__invGroupsClient<$Result.GetResult<Prisma.$invGroupsPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first InvGroups that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {invGroupsFindFirstOrThrowArgs} args - Arguments to find a InvGroups
     * @example
     * // Get one InvGroups
     * const invGroups = await prisma.invGroups.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends invGroupsFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, invGroupsFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__invGroupsClient<$Result.GetResult<Prisma.$invGroupsPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more InvGroups that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {invGroupsFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all InvGroups
     * const invGroups = await prisma.invGroups.findMany()
     * 
     * // Get first 10 InvGroups
     * const invGroups = await prisma.invGroups.findMany({ take: 10 })
     * 
     * // Only select the `groupID`
     * const invGroupsWithGroupIDOnly = await prisma.invGroups.findMany({ select: { groupID: true } })
     * 
    **/
    findMany<T extends invGroupsFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, invGroupsFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$invGroupsPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a InvGroups.
     * @param {invGroupsCreateArgs} args - Arguments to create a InvGroups.
     * @example
     * // Create one InvGroups
     * const InvGroups = await prisma.invGroups.create({
     *   data: {
     *     // ... data to create a InvGroups
     *   }
     * })
     * 
    **/
    create<T extends invGroupsCreateArgs<ExtArgs>>(
      args: SelectSubset<T, invGroupsCreateArgs<ExtArgs>>
    ): Prisma__invGroupsClient<$Result.GetResult<Prisma.$invGroupsPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many InvGroups.
     *     @param {invGroupsCreateManyArgs} args - Arguments to create many InvGroups.
     *     @example
     *     // Create many InvGroups
     *     const invGroups = await prisma.invGroups.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends invGroupsCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, invGroupsCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a InvGroups.
     * @param {invGroupsDeleteArgs} args - Arguments to delete one InvGroups.
     * @example
     * // Delete one InvGroups
     * const InvGroups = await prisma.invGroups.delete({
     *   where: {
     *     // ... filter to delete one InvGroups
     *   }
     * })
     * 
    **/
    delete<T extends invGroupsDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, invGroupsDeleteArgs<ExtArgs>>
    ): Prisma__invGroupsClient<$Result.GetResult<Prisma.$invGroupsPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one InvGroups.
     * @param {invGroupsUpdateArgs} args - Arguments to update one InvGroups.
     * @example
     * // Update one InvGroups
     * const invGroups = await prisma.invGroups.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends invGroupsUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, invGroupsUpdateArgs<ExtArgs>>
    ): Prisma__invGroupsClient<$Result.GetResult<Prisma.$invGroupsPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more InvGroups.
     * @param {invGroupsDeleteManyArgs} args - Arguments to filter InvGroups to delete.
     * @example
     * // Delete a few InvGroups
     * const { count } = await prisma.invGroups.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends invGroupsDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, invGroupsDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more InvGroups.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {invGroupsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many InvGroups
     * const invGroups = await prisma.invGroups.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends invGroupsUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, invGroupsUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one InvGroups.
     * @param {invGroupsUpsertArgs} args - Arguments to update or create a InvGroups.
     * @example
     * // Update or create a InvGroups
     * const invGroups = await prisma.invGroups.upsert({
     *   create: {
     *     // ... data to create a InvGroups
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the InvGroups we want to update
     *   }
     * })
    **/
    upsert<T extends invGroupsUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, invGroupsUpsertArgs<ExtArgs>>
    ): Prisma__invGroupsClient<$Result.GetResult<Prisma.$invGroupsPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of InvGroups.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {invGroupsCountArgs} args - Arguments to filter InvGroups to count.
     * @example
     * // Count the number of InvGroups
     * const count = await prisma.invGroups.count({
     *   where: {
     *     // ... the filter for the InvGroups we want to count
     *   }
     * })
    **/
    count<T extends invGroupsCountArgs>(
      args?: Subset<T, invGroupsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], InvGroupsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a InvGroups.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvGroupsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends InvGroupsAggregateArgs>(args: Subset<T, InvGroupsAggregateArgs>): Prisma.PrismaPromise<GetInvGroupsAggregateType<T>>

    /**
     * Group by InvGroups.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {invGroupsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends invGroupsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: invGroupsGroupByArgs['orderBy'] }
        : { orderBy?: invGroupsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, invGroupsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInvGroupsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the invGroups model
   */
  readonly fields: invGroupsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for invGroups.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__invGroupsClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';


    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the invGroups model
   */ 
  interface invGroupsFieldRefs {
    readonly groupID: FieldRef<"invGroups", 'Int'>
    readonly categoryID: FieldRef<"invGroups", 'Int'>
    readonly groupName: FieldRef<"invGroups", 'String'>
    readonly iconID: FieldRef<"invGroups", 'Int'>
    readonly useBasePrice: FieldRef<"invGroups", 'Boolean'>
    readonly anchored: FieldRef<"invGroups", 'Boolean'>
    readonly anchorable: FieldRef<"invGroups", 'Boolean'>
    readonly fittableNonSingleton: FieldRef<"invGroups", 'Boolean'>
    readonly published: FieldRef<"invGroups", 'Boolean'>
  }
    

  // Custom InputTypes

  /**
   * invGroups findUnique
   */
  export type invGroupsFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the invGroups
     */
    select?: invGroupsSelect<ExtArgs> | null
    /**
     * Filter, which invGroups to fetch.
     */
    where: invGroupsWhereUniqueInput
  }


  /**
   * invGroups findUniqueOrThrow
   */
  export type invGroupsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the invGroups
     */
    select?: invGroupsSelect<ExtArgs> | null
    /**
     * Filter, which invGroups to fetch.
     */
    where: invGroupsWhereUniqueInput
  }


  /**
   * invGroups findFirst
   */
  export type invGroupsFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the invGroups
     */
    select?: invGroupsSelect<ExtArgs> | null
    /**
     * Filter, which invGroups to fetch.
     */
    where?: invGroupsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of invGroups to fetch.
     */
    orderBy?: invGroupsOrderByWithRelationInput | invGroupsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for invGroups.
     */
    cursor?: invGroupsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` invGroups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` invGroups.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of invGroups.
     */
    distinct?: InvGroupsScalarFieldEnum | InvGroupsScalarFieldEnum[]
  }


  /**
   * invGroups findFirstOrThrow
   */
  export type invGroupsFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the invGroups
     */
    select?: invGroupsSelect<ExtArgs> | null
    /**
     * Filter, which invGroups to fetch.
     */
    where?: invGroupsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of invGroups to fetch.
     */
    orderBy?: invGroupsOrderByWithRelationInput | invGroupsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for invGroups.
     */
    cursor?: invGroupsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` invGroups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` invGroups.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of invGroups.
     */
    distinct?: InvGroupsScalarFieldEnum | InvGroupsScalarFieldEnum[]
  }


  /**
   * invGroups findMany
   */
  export type invGroupsFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the invGroups
     */
    select?: invGroupsSelect<ExtArgs> | null
    /**
     * Filter, which invGroups to fetch.
     */
    where?: invGroupsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of invGroups to fetch.
     */
    orderBy?: invGroupsOrderByWithRelationInput | invGroupsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing invGroups.
     */
    cursor?: invGroupsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` invGroups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` invGroups.
     */
    skip?: number
    distinct?: InvGroupsScalarFieldEnum | InvGroupsScalarFieldEnum[]
  }


  /**
   * invGroups create
   */
  export type invGroupsCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the invGroups
     */
    select?: invGroupsSelect<ExtArgs> | null
    /**
     * The data needed to create a invGroups.
     */
    data: XOR<invGroupsCreateInput, invGroupsUncheckedCreateInput>
  }


  /**
   * invGroups createMany
   */
  export type invGroupsCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many invGroups.
     */
    data: invGroupsCreateManyInput | invGroupsCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * invGroups update
   */
  export type invGroupsUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the invGroups
     */
    select?: invGroupsSelect<ExtArgs> | null
    /**
     * The data needed to update a invGroups.
     */
    data: XOR<invGroupsUpdateInput, invGroupsUncheckedUpdateInput>
    /**
     * Choose, which invGroups to update.
     */
    where: invGroupsWhereUniqueInput
  }


  /**
   * invGroups updateMany
   */
  export type invGroupsUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update invGroups.
     */
    data: XOR<invGroupsUpdateManyMutationInput, invGroupsUncheckedUpdateManyInput>
    /**
     * Filter which invGroups to update
     */
    where?: invGroupsWhereInput
  }


  /**
   * invGroups upsert
   */
  export type invGroupsUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the invGroups
     */
    select?: invGroupsSelect<ExtArgs> | null
    /**
     * The filter to search for the invGroups to update in case it exists.
     */
    where: invGroupsWhereUniqueInput
    /**
     * In case the invGroups found by the `where` argument doesn't exist, create a new invGroups with this data.
     */
    create: XOR<invGroupsCreateInput, invGroupsUncheckedCreateInput>
    /**
     * In case the invGroups was found with the provided `where` argument, update it with this data.
     */
    update: XOR<invGroupsUpdateInput, invGroupsUncheckedUpdateInput>
  }


  /**
   * invGroups delete
   */
  export type invGroupsDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the invGroups
     */
    select?: invGroupsSelect<ExtArgs> | null
    /**
     * Filter which invGroups to delete.
     */
    where: invGroupsWhereUniqueInput
  }


  /**
   * invGroups deleteMany
   */
  export type invGroupsDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which invGroups to delete
     */
    where?: invGroupsWhereInput
  }


  /**
   * invGroups without action
   */
  export type invGroupsDefaultArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the invGroups
     */
    select?: invGroupsSelect<ExtArgs> | null
  }



  /**
   * Model invItems
   */

  export type AggregateInvItems = {
    _count: InvItemsCountAggregateOutputType | null
    _avg: InvItemsAvgAggregateOutputType | null
    _sum: InvItemsSumAggregateOutputType | null
    _min: InvItemsMinAggregateOutputType | null
    _max: InvItemsMaxAggregateOutputType | null
  }

  export type InvItemsAvgAggregateOutputType = {
    itemID: number | null
    typeID: number | null
    ownerID: number | null
    locationID: number | null
    flagID: number | null
    quantity: number | null
  }

  export type InvItemsSumAggregateOutputType = {
    itemID: number | null
    typeID: number | null
    ownerID: number | null
    locationID: number | null
    flagID: number | null
    quantity: number | null
  }

  export type InvItemsMinAggregateOutputType = {
    itemID: number | null
    typeID: number | null
    ownerID: number | null
    locationID: number | null
    flagID: number | null
    quantity: number | null
  }

  export type InvItemsMaxAggregateOutputType = {
    itemID: number | null
    typeID: number | null
    ownerID: number | null
    locationID: number | null
    flagID: number | null
    quantity: number | null
  }

  export type InvItemsCountAggregateOutputType = {
    itemID: number
    typeID: number
    ownerID: number
    locationID: number
    flagID: number
    quantity: number
    _all: number
  }


  export type InvItemsAvgAggregateInputType = {
    itemID?: true
    typeID?: true
    ownerID?: true
    locationID?: true
    flagID?: true
    quantity?: true
  }

  export type InvItemsSumAggregateInputType = {
    itemID?: true
    typeID?: true
    ownerID?: true
    locationID?: true
    flagID?: true
    quantity?: true
  }

  export type InvItemsMinAggregateInputType = {
    itemID?: true
    typeID?: true
    ownerID?: true
    locationID?: true
    flagID?: true
    quantity?: true
  }

  export type InvItemsMaxAggregateInputType = {
    itemID?: true
    typeID?: true
    ownerID?: true
    locationID?: true
    flagID?: true
    quantity?: true
  }

  export type InvItemsCountAggregateInputType = {
    itemID?: true
    typeID?: true
    ownerID?: true
    locationID?: true
    flagID?: true
    quantity?: true
    _all?: true
  }

  export type InvItemsAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which invItems to aggregate.
     */
    where?: invItemsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of invItems to fetch.
     */
    orderBy?: invItemsOrderByWithRelationInput | invItemsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: invItemsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` invItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` invItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned invItems
    **/
    _count?: true | InvItemsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: InvItemsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: InvItemsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: InvItemsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: InvItemsMaxAggregateInputType
  }

  export type GetInvItemsAggregateType<T extends InvItemsAggregateArgs> = {
        [P in keyof T & keyof AggregateInvItems]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInvItems[P]>
      : GetScalarType<T[P], AggregateInvItems[P]>
  }




  export type invItemsGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: invItemsWhereInput
    orderBy?: invItemsOrderByWithAggregationInput | invItemsOrderByWithAggregationInput[]
    by: InvItemsScalarFieldEnum[] | InvItemsScalarFieldEnum
    having?: invItemsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: InvItemsCountAggregateInputType | true
    _avg?: InvItemsAvgAggregateInputType
    _sum?: InvItemsSumAggregateInputType
    _min?: InvItemsMinAggregateInputType
    _max?: InvItemsMaxAggregateInputType
  }

  export type InvItemsGroupByOutputType = {
    itemID: number
    typeID: number
    ownerID: number
    locationID: number
    flagID: number
    quantity: number
    _count: InvItemsCountAggregateOutputType | null
    _avg: InvItemsAvgAggregateOutputType | null
    _sum: InvItemsSumAggregateOutputType | null
    _min: InvItemsMinAggregateOutputType | null
    _max: InvItemsMaxAggregateOutputType | null
  }

  type GetInvItemsGroupByPayload<T extends invItemsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<InvItemsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof InvItemsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], InvItemsGroupByOutputType[P]>
            : GetScalarType<T[P], InvItemsGroupByOutputType[P]>
        }
      >
    >


  export type invItemsSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    itemID?: boolean
    typeID?: boolean
    ownerID?: boolean
    locationID?: boolean
    flagID?: boolean
    quantity?: boolean
  }, ExtArgs["result"]["invItems"]>

  export type invItemsSelectScalar = {
    itemID?: boolean
    typeID?: boolean
    ownerID?: boolean
    locationID?: boolean
    flagID?: boolean
    quantity?: boolean
  }


  export type $invItemsPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    name: "invItems"
    objects: {}
    scalars: $Extensions.GetResult<{
      itemID: number
      typeID: number
      ownerID: number
      locationID: number
      flagID: number
      quantity: number
    }, ExtArgs["result"]["invItems"]>
    composites: {}
  }


  type invItemsGetPayload<S extends boolean | null | undefined | invItemsDefaultArgs> = $Result.GetResult<Prisma.$invItemsPayload, S>

  type invItemsCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<invItemsFindManyArgs, 'select' | 'include'> & {
      select?: InvItemsCountAggregateInputType | true
    }

  export interface invItemsDelegate<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['invItems'], meta: { name: 'invItems' } }
    /**
     * Find zero or one InvItems that matches the filter.
     * @param {invItemsFindUniqueArgs} args - Arguments to find a InvItems
     * @example
     * // Get one InvItems
     * const invItems = await prisma.invItems.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends invItemsFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, invItemsFindUniqueArgs<ExtArgs>>
    ): Prisma__invItemsClient<$Result.GetResult<Prisma.$invItemsPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one InvItems that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {invItemsFindUniqueOrThrowArgs} args - Arguments to find a InvItems
     * @example
     * // Get one InvItems
     * const invItems = await prisma.invItems.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends invItemsFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, invItemsFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__invItemsClient<$Result.GetResult<Prisma.$invItemsPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first InvItems that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {invItemsFindFirstArgs} args - Arguments to find a InvItems
     * @example
     * // Get one InvItems
     * const invItems = await prisma.invItems.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends invItemsFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, invItemsFindFirstArgs<ExtArgs>>
    ): Prisma__invItemsClient<$Result.GetResult<Prisma.$invItemsPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first InvItems that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {invItemsFindFirstOrThrowArgs} args - Arguments to find a InvItems
     * @example
     * // Get one InvItems
     * const invItems = await prisma.invItems.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends invItemsFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, invItemsFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__invItemsClient<$Result.GetResult<Prisma.$invItemsPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more InvItems that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {invItemsFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all InvItems
     * const invItems = await prisma.invItems.findMany()
     * 
     * // Get first 10 InvItems
     * const invItems = await prisma.invItems.findMany({ take: 10 })
     * 
     * // Only select the `itemID`
     * const invItemsWithItemIDOnly = await prisma.invItems.findMany({ select: { itemID: true } })
     * 
    **/
    findMany<T extends invItemsFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, invItemsFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$invItemsPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a InvItems.
     * @param {invItemsCreateArgs} args - Arguments to create a InvItems.
     * @example
     * // Create one InvItems
     * const InvItems = await prisma.invItems.create({
     *   data: {
     *     // ... data to create a InvItems
     *   }
     * })
     * 
    **/
    create<T extends invItemsCreateArgs<ExtArgs>>(
      args: SelectSubset<T, invItemsCreateArgs<ExtArgs>>
    ): Prisma__invItemsClient<$Result.GetResult<Prisma.$invItemsPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many InvItems.
     *     @param {invItemsCreateManyArgs} args - Arguments to create many InvItems.
     *     @example
     *     // Create many InvItems
     *     const invItems = await prisma.invItems.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends invItemsCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, invItemsCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a InvItems.
     * @param {invItemsDeleteArgs} args - Arguments to delete one InvItems.
     * @example
     * // Delete one InvItems
     * const InvItems = await prisma.invItems.delete({
     *   where: {
     *     // ... filter to delete one InvItems
     *   }
     * })
     * 
    **/
    delete<T extends invItemsDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, invItemsDeleteArgs<ExtArgs>>
    ): Prisma__invItemsClient<$Result.GetResult<Prisma.$invItemsPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one InvItems.
     * @param {invItemsUpdateArgs} args - Arguments to update one InvItems.
     * @example
     * // Update one InvItems
     * const invItems = await prisma.invItems.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends invItemsUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, invItemsUpdateArgs<ExtArgs>>
    ): Prisma__invItemsClient<$Result.GetResult<Prisma.$invItemsPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more InvItems.
     * @param {invItemsDeleteManyArgs} args - Arguments to filter InvItems to delete.
     * @example
     * // Delete a few InvItems
     * const { count } = await prisma.invItems.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends invItemsDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, invItemsDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more InvItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {invItemsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many InvItems
     * const invItems = await prisma.invItems.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends invItemsUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, invItemsUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one InvItems.
     * @param {invItemsUpsertArgs} args - Arguments to update or create a InvItems.
     * @example
     * // Update or create a InvItems
     * const invItems = await prisma.invItems.upsert({
     *   create: {
     *     // ... data to create a InvItems
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the InvItems we want to update
     *   }
     * })
    **/
    upsert<T extends invItemsUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, invItemsUpsertArgs<ExtArgs>>
    ): Prisma__invItemsClient<$Result.GetResult<Prisma.$invItemsPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of InvItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {invItemsCountArgs} args - Arguments to filter InvItems to count.
     * @example
     * // Count the number of InvItems
     * const count = await prisma.invItems.count({
     *   where: {
     *     // ... the filter for the InvItems we want to count
     *   }
     * })
    **/
    count<T extends invItemsCountArgs>(
      args?: Subset<T, invItemsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], InvItemsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a InvItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvItemsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends InvItemsAggregateArgs>(args: Subset<T, InvItemsAggregateArgs>): Prisma.PrismaPromise<GetInvItemsAggregateType<T>>

    /**
     * Group by InvItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {invItemsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends invItemsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: invItemsGroupByArgs['orderBy'] }
        : { orderBy?: invItemsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, invItemsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInvItemsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the invItems model
   */
  readonly fields: invItemsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for invItems.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__invItemsClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';


    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the invItems model
   */ 
  interface invItemsFieldRefs {
    readonly itemID: FieldRef<"invItems", 'Int'>
    readonly typeID: FieldRef<"invItems", 'Int'>
    readonly ownerID: FieldRef<"invItems", 'Int'>
    readonly locationID: FieldRef<"invItems", 'Int'>
    readonly flagID: FieldRef<"invItems", 'Int'>
    readonly quantity: FieldRef<"invItems", 'Int'>
  }
    

  // Custom InputTypes

  /**
   * invItems findUnique
   */
  export type invItemsFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the invItems
     */
    select?: invItemsSelect<ExtArgs> | null
    /**
     * Filter, which invItems to fetch.
     */
    where: invItemsWhereUniqueInput
  }


  /**
   * invItems findUniqueOrThrow
   */
  export type invItemsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the invItems
     */
    select?: invItemsSelect<ExtArgs> | null
    /**
     * Filter, which invItems to fetch.
     */
    where: invItemsWhereUniqueInput
  }


  /**
   * invItems findFirst
   */
  export type invItemsFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the invItems
     */
    select?: invItemsSelect<ExtArgs> | null
    /**
     * Filter, which invItems to fetch.
     */
    where?: invItemsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of invItems to fetch.
     */
    orderBy?: invItemsOrderByWithRelationInput | invItemsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for invItems.
     */
    cursor?: invItemsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` invItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` invItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of invItems.
     */
    distinct?: InvItemsScalarFieldEnum | InvItemsScalarFieldEnum[]
  }


  /**
   * invItems findFirstOrThrow
   */
  export type invItemsFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the invItems
     */
    select?: invItemsSelect<ExtArgs> | null
    /**
     * Filter, which invItems to fetch.
     */
    where?: invItemsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of invItems to fetch.
     */
    orderBy?: invItemsOrderByWithRelationInput | invItemsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for invItems.
     */
    cursor?: invItemsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` invItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` invItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of invItems.
     */
    distinct?: InvItemsScalarFieldEnum | InvItemsScalarFieldEnum[]
  }


  /**
   * invItems findMany
   */
  export type invItemsFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the invItems
     */
    select?: invItemsSelect<ExtArgs> | null
    /**
     * Filter, which invItems to fetch.
     */
    where?: invItemsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of invItems to fetch.
     */
    orderBy?: invItemsOrderByWithRelationInput | invItemsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing invItems.
     */
    cursor?: invItemsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` invItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` invItems.
     */
    skip?: number
    distinct?: InvItemsScalarFieldEnum | InvItemsScalarFieldEnum[]
  }


  /**
   * invItems create
   */
  export type invItemsCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the invItems
     */
    select?: invItemsSelect<ExtArgs> | null
    /**
     * The data needed to create a invItems.
     */
    data: XOR<invItemsCreateInput, invItemsUncheckedCreateInput>
  }


  /**
   * invItems createMany
   */
  export type invItemsCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many invItems.
     */
    data: invItemsCreateManyInput | invItemsCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * invItems update
   */
  export type invItemsUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the invItems
     */
    select?: invItemsSelect<ExtArgs> | null
    /**
     * The data needed to update a invItems.
     */
    data: XOR<invItemsUpdateInput, invItemsUncheckedUpdateInput>
    /**
     * Choose, which invItems to update.
     */
    where: invItemsWhereUniqueInput
  }


  /**
   * invItems updateMany
   */
  export type invItemsUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update invItems.
     */
    data: XOR<invItemsUpdateManyMutationInput, invItemsUncheckedUpdateManyInput>
    /**
     * Filter which invItems to update
     */
    where?: invItemsWhereInput
  }


  /**
   * invItems upsert
   */
  export type invItemsUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the invItems
     */
    select?: invItemsSelect<ExtArgs> | null
    /**
     * The filter to search for the invItems to update in case it exists.
     */
    where: invItemsWhereUniqueInput
    /**
     * In case the invItems found by the `where` argument doesn't exist, create a new invItems with this data.
     */
    create: XOR<invItemsCreateInput, invItemsUncheckedCreateInput>
    /**
     * In case the invItems was found with the provided `where` argument, update it with this data.
     */
    update: XOR<invItemsUpdateInput, invItemsUncheckedUpdateInput>
  }


  /**
   * invItems delete
   */
  export type invItemsDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the invItems
     */
    select?: invItemsSelect<ExtArgs> | null
    /**
     * Filter which invItems to delete.
     */
    where: invItemsWhereUniqueInput
  }


  /**
   * invItems deleteMany
   */
  export type invItemsDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which invItems to delete
     */
    where?: invItemsWhereInput
  }


  /**
   * invItems without action
   */
  export type invItemsDefaultArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the invItems
     */
    select?: invItemsSelect<ExtArgs> | null
  }



  /**
   * Model invMarketGroups
   */

  export type AggregateInvMarketGroups = {
    _count: InvMarketGroupsCountAggregateOutputType | null
    _avg: InvMarketGroupsAvgAggregateOutputType | null
    _sum: InvMarketGroupsSumAggregateOutputType | null
    _min: InvMarketGroupsMinAggregateOutputType | null
    _max: InvMarketGroupsMaxAggregateOutputType | null
  }

  export type InvMarketGroupsAvgAggregateOutputType = {
    marketGroupID: number | null
    parentGroupID: number | null
    iconID: number | null
  }

  export type InvMarketGroupsSumAggregateOutputType = {
    marketGroupID: number | null
    parentGroupID: number | null
    iconID: number | null
  }

  export type InvMarketGroupsMinAggregateOutputType = {
    marketGroupID: number | null
    parentGroupID: number | null
    marketGroupName: string | null
    description: string | null
    iconID: number | null
    hasTypes: boolean | null
  }

  export type InvMarketGroupsMaxAggregateOutputType = {
    marketGroupID: number | null
    parentGroupID: number | null
    marketGroupName: string | null
    description: string | null
    iconID: number | null
    hasTypes: boolean | null
  }

  export type InvMarketGroupsCountAggregateOutputType = {
    marketGroupID: number
    parentGroupID: number
    marketGroupName: number
    description: number
    iconID: number
    hasTypes: number
    _all: number
  }


  export type InvMarketGroupsAvgAggregateInputType = {
    marketGroupID?: true
    parentGroupID?: true
    iconID?: true
  }

  export type InvMarketGroupsSumAggregateInputType = {
    marketGroupID?: true
    parentGroupID?: true
    iconID?: true
  }

  export type InvMarketGroupsMinAggregateInputType = {
    marketGroupID?: true
    parentGroupID?: true
    marketGroupName?: true
    description?: true
    iconID?: true
    hasTypes?: true
  }

  export type InvMarketGroupsMaxAggregateInputType = {
    marketGroupID?: true
    parentGroupID?: true
    marketGroupName?: true
    description?: true
    iconID?: true
    hasTypes?: true
  }

  export type InvMarketGroupsCountAggregateInputType = {
    marketGroupID?: true
    parentGroupID?: true
    marketGroupName?: true
    description?: true
    iconID?: true
    hasTypes?: true
    _all?: true
  }

  export type InvMarketGroupsAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which invMarketGroups to aggregate.
     */
    where?: invMarketGroupsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of invMarketGroups to fetch.
     */
    orderBy?: invMarketGroupsOrderByWithRelationInput | invMarketGroupsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: invMarketGroupsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` invMarketGroups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` invMarketGroups.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned invMarketGroups
    **/
    _count?: true | InvMarketGroupsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: InvMarketGroupsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: InvMarketGroupsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: InvMarketGroupsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: InvMarketGroupsMaxAggregateInputType
  }

  export type GetInvMarketGroupsAggregateType<T extends InvMarketGroupsAggregateArgs> = {
        [P in keyof T & keyof AggregateInvMarketGroups]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInvMarketGroups[P]>
      : GetScalarType<T[P], AggregateInvMarketGroups[P]>
  }




  export type invMarketGroupsGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: invMarketGroupsWhereInput
    orderBy?: invMarketGroupsOrderByWithAggregationInput | invMarketGroupsOrderByWithAggregationInput[]
    by: InvMarketGroupsScalarFieldEnum[] | InvMarketGroupsScalarFieldEnum
    having?: invMarketGroupsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: InvMarketGroupsCountAggregateInputType | true
    _avg?: InvMarketGroupsAvgAggregateInputType
    _sum?: InvMarketGroupsSumAggregateInputType
    _min?: InvMarketGroupsMinAggregateInputType
    _max?: InvMarketGroupsMaxAggregateInputType
  }

  export type InvMarketGroupsGroupByOutputType = {
    marketGroupID: number
    parentGroupID: number | null
    marketGroupName: string | null
    description: string | null
    iconID: number | null
    hasTypes: boolean | null
    _count: InvMarketGroupsCountAggregateOutputType | null
    _avg: InvMarketGroupsAvgAggregateOutputType | null
    _sum: InvMarketGroupsSumAggregateOutputType | null
    _min: InvMarketGroupsMinAggregateOutputType | null
    _max: InvMarketGroupsMaxAggregateOutputType | null
  }

  type GetInvMarketGroupsGroupByPayload<T extends invMarketGroupsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<InvMarketGroupsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof InvMarketGroupsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], InvMarketGroupsGroupByOutputType[P]>
            : GetScalarType<T[P], InvMarketGroupsGroupByOutputType[P]>
        }
      >
    >


  export type invMarketGroupsSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    marketGroupID?: boolean
    parentGroupID?: boolean
    marketGroupName?: boolean
    description?: boolean
    iconID?: boolean
    hasTypes?: boolean
  }, ExtArgs["result"]["invMarketGroups"]>

  export type invMarketGroupsSelectScalar = {
    marketGroupID?: boolean
    parentGroupID?: boolean
    marketGroupName?: boolean
    description?: boolean
    iconID?: boolean
    hasTypes?: boolean
  }


  export type $invMarketGroupsPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    name: "invMarketGroups"
    objects: {}
    scalars: $Extensions.GetResult<{
      marketGroupID: number
      parentGroupID: number | null
      marketGroupName: string | null
      description: string | null
      iconID: number | null
      hasTypes: boolean | null
    }, ExtArgs["result"]["invMarketGroups"]>
    composites: {}
  }


  type invMarketGroupsGetPayload<S extends boolean | null | undefined | invMarketGroupsDefaultArgs> = $Result.GetResult<Prisma.$invMarketGroupsPayload, S>

  type invMarketGroupsCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<invMarketGroupsFindManyArgs, 'select' | 'include'> & {
      select?: InvMarketGroupsCountAggregateInputType | true
    }

  export interface invMarketGroupsDelegate<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['invMarketGroups'], meta: { name: 'invMarketGroups' } }
    /**
     * Find zero or one InvMarketGroups that matches the filter.
     * @param {invMarketGroupsFindUniqueArgs} args - Arguments to find a InvMarketGroups
     * @example
     * // Get one InvMarketGroups
     * const invMarketGroups = await prisma.invMarketGroups.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends invMarketGroupsFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, invMarketGroupsFindUniqueArgs<ExtArgs>>
    ): Prisma__invMarketGroupsClient<$Result.GetResult<Prisma.$invMarketGroupsPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one InvMarketGroups that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {invMarketGroupsFindUniqueOrThrowArgs} args - Arguments to find a InvMarketGroups
     * @example
     * // Get one InvMarketGroups
     * const invMarketGroups = await prisma.invMarketGroups.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends invMarketGroupsFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, invMarketGroupsFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__invMarketGroupsClient<$Result.GetResult<Prisma.$invMarketGroupsPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first InvMarketGroups that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {invMarketGroupsFindFirstArgs} args - Arguments to find a InvMarketGroups
     * @example
     * // Get one InvMarketGroups
     * const invMarketGroups = await prisma.invMarketGroups.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends invMarketGroupsFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, invMarketGroupsFindFirstArgs<ExtArgs>>
    ): Prisma__invMarketGroupsClient<$Result.GetResult<Prisma.$invMarketGroupsPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first InvMarketGroups that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {invMarketGroupsFindFirstOrThrowArgs} args - Arguments to find a InvMarketGroups
     * @example
     * // Get one InvMarketGroups
     * const invMarketGroups = await prisma.invMarketGroups.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends invMarketGroupsFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, invMarketGroupsFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__invMarketGroupsClient<$Result.GetResult<Prisma.$invMarketGroupsPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more InvMarketGroups that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {invMarketGroupsFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all InvMarketGroups
     * const invMarketGroups = await prisma.invMarketGroups.findMany()
     * 
     * // Get first 10 InvMarketGroups
     * const invMarketGroups = await prisma.invMarketGroups.findMany({ take: 10 })
     * 
     * // Only select the `marketGroupID`
     * const invMarketGroupsWithMarketGroupIDOnly = await prisma.invMarketGroups.findMany({ select: { marketGroupID: true } })
     * 
    **/
    findMany<T extends invMarketGroupsFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, invMarketGroupsFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$invMarketGroupsPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a InvMarketGroups.
     * @param {invMarketGroupsCreateArgs} args - Arguments to create a InvMarketGroups.
     * @example
     * // Create one InvMarketGroups
     * const InvMarketGroups = await prisma.invMarketGroups.create({
     *   data: {
     *     // ... data to create a InvMarketGroups
     *   }
     * })
     * 
    **/
    create<T extends invMarketGroupsCreateArgs<ExtArgs>>(
      args: SelectSubset<T, invMarketGroupsCreateArgs<ExtArgs>>
    ): Prisma__invMarketGroupsClient<$Result.GetResult<Prisma.$invMarketGroupsPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many InvMarketGroups.
     *     @param {invMarketGroupsCreateManyArgs} args - Arguments to create many InvMarketGroups.
     *     @example
     *     // Create many InvMarketGroups
     *     const invMarketGroups = await prisma.invMarketGroups.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends invMarketGroupsCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, invMarketGroupsCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a InvMarketGroups.
     * @param {invMarketGroupsDeleteArgs} args - Arguments to delete one InvMarketGroups.
     * @example
     * // Delete one InvMarketGroups
     * const InvMarketGroups = await prisma.invMarketGroups.delete({
     *   where: {
     *     // ... filter to delete one InvMarketGroups
     *   }
     * })
     * 
    **/
    delete<T extends invMarketGroupsDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, invMarketGroupsDeleteArgs<ExtArgs>>
    ): Prisma__invMarketGroupsClient<$Result.GetResult<Prisma.$invMarketGroupsPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one InvMarketGroups.
     * @param {invMarketGroupsUpdateArgs} args - Arguments to update one InvMarketGroups.
     * @example
     * // Update one InvMarketGroups
     * const invMarketGroups = await prisma.invMarketGroups.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends invMarketGroupsUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, invMarketGroupsUpdateArgs<ExtArgs>>
    ): Prisma__invMarketGroupsClient<$Result.GetResult<Prisma.$invMarketGroupsPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more InvMarketGroups.
     * @param {invMarketGroupsDeleteManyArgs} args - Arguments to filter InvMarketGroups to delete.
     * @example
     * // Delete a few InvMarketGroups
     * const { count } = await prisma.invMarketGroups.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends invMarketGroupsDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, invMarketGroupsDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more InvMarketGroups.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {invMarketGroupsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many InvMarketGroups
     * const invMarketGroups = await prisma.invMarketGroups.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends invMarketGroupsUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, invMarketGroupsUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one InvMarketGroups.
     * @param {invMarketGroupsUpsertArgs} args - Arguments to update or create a InvMarketGroups.
     * @example
     * // Update or create a InvMarketGroups
     * const invMarketGroups = await prisma.invMarketGroups.upsert({
     *   create: {
     *     // ... data to create a InvMarketGroups
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the InvMarketGroups we want to update
     *   }
     * })
    **/
    upsert<T extends invMarketGroupsUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, invMarketGroupsUpsertArgs<ExtArgs>>
    ): Prisma__invMarketGroupsClient<$Result.GetResult<Prisma.$invMarketGroupsPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of InvMarketGroups.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {invMarketGroupsCountArgs} args - Arguments to filter InvMarketGroups to count.
     * @example
     * // Count the number of InvMarketGroups
     * const count = await prisma.invMarketGroups.count({
     *   where: {
     *     // ... the filter for the InvMarketGroups we want to count
     *   }
     * })
    **/
    count<T extends invMarketGroupsCountArgs>(
      args?: Subset<T, invMarketGroupsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], InvMarketGroupsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a InvMarketGroups.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvMarketGroupsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends InvMarketGroupsAggregateArgs>(args: Subset<T, InvMarketGroupsAggregateArgs>): Prisma.PrismaPromise<GetInvMarketGroupsAggregateType<T>>

    /**
     * Group by InvMarketGroups.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {invMarketGroupsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends invMarketGroupsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: invMarketGroupsGroupByArgs['orderBy'] }
        : { orderBy?: invMarketGroupsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, invMarketGroupsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInvMarketGroupsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the invMarketGroups model
   */
  readonly fields: invMarketGroupsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for invMarketGroups.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__invMarketGroupsClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';


    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the invMarketGroups model
   */ 
  interface invMarketGroupsFieldRefs {
    readonly marketGroupID: FieldRef<"invMarketGroups", 'Int'>
    readonly parentGroupID: FieldRef<"invMarketGroups", 'Int'>
    readonly marketGroupName: FieldRef<"invMarketGroups", 'String'>
    readonly description: FieldRef<"invMarketGroups", 'String'>
    readonly iconID: FieldRef<"invMarketGroups", 'Int'>
    readonly hasTypes: FieldRef<"invMarketGroups", 'Boolean'>
  }
    

  // Custom InputTypes

  /**
   * invMarketGroups findUnique
   */
  export type invMarketGroupsFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the invMarketGroups
     */
    select?: invMarketGroupsSelect<ExtArgs> | null
    /**
     * Filter, which invMarketGroups to fetch.
     */
    where: invMarketGroupsWhereUniqueInput
  }


  /**
   * invMarketGroups findUniqueOrThrow
   */
  export type invMarketGroupsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the invMarketGroups
     */
    select?: invMarketGroupsSelect<ExtArgs> | null
    /**
     * Filter, which invMarketGroups to fetch.
     */
    where: invMarketGroupsWhereUniqueInput
  }


  /**
   * invMarketGroups findFirst
   */
  export type invMarketGroupsFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the invMarketGroups
     */
    select?: invMarketGroupsSelect<ExtArgs> | null
    /**
     * Filter, which invMarketGroups to fetch.
     */
    where?: invMarketGroupsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of invMarketGroups to fetch.
     */
    orderBy?: invMarketGroupsOrderByWithRelationInput | invMarketGroupsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for invMarketGroups.
     */
    cursor?: invMarketGroupsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` invMarketGroups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` invMarketGroups.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of invMarketGroups.
     */
    distinct?: InvMarketGroupsScalarFieldEnum | InvMarketGroupsScalarFieldEnum[]
  }


  /**
   * invMarketGroups findFirstOrThrow
   */
  export type invMarketGroupsFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the invMarketGroups
     */
    select?: invMarketGroupsSelect<ExtArgs> | null
    /**
     * Filter, which invMarketGroups to fetch.
     */
    where?: invMarketGroupsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of invMarketGroups to fetch.
     */
    orderBy?: invMarketGroupsOrderByWithRelationInput | invMarketGroupsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for invMarketGroups.
     */
    cursor?: invMarketGroupsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` invMarketGroups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` invMarketGroups.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of invMarketGroups.
     */
    distinct?: InvMarketGroupsScalarFieldEnum | InvMarketGroupsScalarFieldEnum[]
  }


  /**
   * invMarketGroups findMany
   */
  export type invMarketGroupsFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the invMarketGroups
     */
    select?: invMarketGroupsSelect<ExtArgs> | null
    /**
     * Filter, which invMarketGroups to fetch.
     */
    where?: invMarketGroupsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of invMarketGroups to fetch.
     */
    orderBy?: invMarketGroupsOrderByWithRelationInput | invMarketGroupsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing invMarketGroups.
     */
    cursor?: invMarketGroupsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` invMarketGroups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` invMarketGroups.
     */
    skip?: number
    distinct?: InvMarketGroupsScalarFieldEnum | InvMarketGroupsScalarFieldEnum[]
  }


  /**
   * invMarketGroups create
   */
  export type invMarketGroupsCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the invMarketGroups
     */
    select?: invMarketGroupsSelect<ExtArgs> | null
    /**
     * The data needed to create a invMarketGroups.
     */
    data: XOR<invMarketGroupsCreateInput, invMarketGroupsUncheckedCreateInput>
  }


  /**
   * invMarketGroups createMany
   */
  export type invMarketGroupsCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many invMarketGroups.
     */
    data: invMarketGroupsCreateManyInput | invMarketGroupsCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * invMarketGroups update
   */
  export type invMarketGroupsUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the invMarketGroups
     */
    select?: invMarketGroupsSelect<ExtArgs> | null
    /**
     * The data needed to update a invMarketGroups.
     */
    data: XOR<invMarketGroupsUpdateInput, invMarketGroupsUncheckedUpdateInput>
    /**
     * Choose, which invMarketGroups to update.
     */
    where: invMarketGroupsWhereUniqueInput
  }


  /**
   * invMarketGroups updateMany
   */
  export type invMarketGroupsUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update invMarketGroups.
     */
    data: XOR<invMarketGroupsUpdateManyMutationInput, invMarketGroupsUncheckedUpdateManyInput>
    /**
     * Filter which invMarketGroups to update
     */
    where?: invMarketGroupsWhereInput
  }


  /**
   * invMarketGroups upsert
   */
  export type invMarketGroupsUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the invMarketGroups
     */
    select?: invMarketGroupsSelect<ExtArgs> | null
    /**
     * The filter to search for the invMarketGroups to update in case it exists.
     */
    where: invMarketGroupsWhereUniqueInput
    /**
     * In case the invMarketGroups found by the `where` argument doesn't exist, create a new invMarketGroups with this data.
     */
    create: XOR<invMarketGroupsCreateInput, invMarketGroupsUncheckedCreateInput>
    /**
     * In case the invMarketGroups was found with the provided `where` argument, update it with this data.
     */
    update: XOR<invMarketGroupsUpdateInput, invMarketGroupsUncheckedUpdateInput>
  }


  /**
   * invMarketGroups delete
   */
  export type invMarketGroupsDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the invMarketGroups
     */
    select?: invMarketGroupsSelect<ExtArgs> | null
    /**
     * Filter which invMarketGroups to delete.
     */
    where: invMarketGroupsWhereUniqueInput
  }


  /**
   * invMarketGroups deleteMany
   */
  export type invMarketGroupsDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which invMarketGroups to delete
     */
    where?: invMarketGroupsWhereInput
  }


  /**
   * invMarketGroups without action
   */
  export type invMarketGroupsDefaultArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the invMarketGroups
     */
    select?: invMarketGroupsSelect<ExtArgs> | null
  }



  /**
   * Model invMetaGroups
   */

  export type AggregateInvMetaGroups = {
    _count: InvMetaGroupsCountAggregateOutputType | null
    _avg: InvMetaGroupsAvgAggregateOutputType | null
    _sum: InvMetaGroupsSumAggregateOutputType | null
    _min: InvMetaGroupsMinAggregateOutputType | null
    _max: InvMetaGroupsMaxAggregateOutputType | null
  }

  export type InvMetaGroupsAvgAggregateOutputType = {
    metaGroupID: number | null
    iconID: number | null
  }

  export type InvMetaGroupsSumAggregateOutputType = {
    metaGroupID: number | null
    iconID: number | null
  }

  export type InvMetaGroupsMinAggregateOutputType = {
    metaGroupID: number | null
    metaGroupName: string | null
    description: string | null
    iconID: number | null
  }

  export type InvMetaGroupsMaxAggregateOutputType = {
    metaGroupID: number | null
    metaGroupName: string | null
    description: string | null
    iconID: number | null
  }

  export type InvMetaGroupsCountAggregateOutputType = {
    metaGroupID: number
    metaGroupName: number
    description: number
    iconID: number
    _all: number
  }


  export type InvMetaGroupsAvgAggregateInputType = {
    metaGroupID?: true
    iconID?: true
  }

  export type InvMetaGroupsSumAggregateInputType = {
    metaGroupID?: true
    iconID?: true
  }

  export type InvMetaGroupsMinAggregateInputType = {
    metaGroupID?: true
    metaGroupName?: true
    description?: true
    iconID?: true
  }

  export type InvMetaGroupsMaxAggregateInputType = {
    metaGroupID?: true
    metaGroupName?: true
    description?: true
    iconID?: true
  }

  export type InvMetaGroupsCountAggregateInputType = {
    metaGroupID?: true
    metaGroupName?: true
    description?: true
    iconID?: true
    _all?: true
  }

  export type InvMetaGroupsAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which invMetaGroups to aggregate.
     */
    where?: invMetaGroupsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of invMetaGroups to fetch.
     */
    orderBy?: invMetaGroupsOrderByWithRelationInput | invMetaGroupsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: invMetaGroupsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` invMetaGroups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` invMetaGroups.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned invMetaGroups
    **/
    _count?: true | InvMetaGroupsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: InvMetaGroupsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: InvMetaGroupsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: InvMetaGroupsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: InvMetaGroupsMaxAggregateInputType
  }

  export type GetInvMetaGroupsAggregateType<T extends InvMetaGroupsAggregateArgs> = {
        [P in keyof T & keyof AggregateInvMetaGroups]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInvMetaGroups[P]>
      : GetScalarType<T[P], AggregateInvMetaGroups[P]>
  }




  export type invMetaGroupsGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: invMetaGroupsWhereInput
    orderBy?: invMetaGroupsOrderByWithAggregationInput | invMetaGroupsOrderByWithAggregationInput[]
    by: InvMetaGroupsScalarFieldEnum[] | InvMetaGroupsScalarFieldEnum
    having?: invMetaGroupsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: InvMetaGroupsCountAggregateInputType | true
    _avg?: InvMetaGroupsAvgAggregateInputType
    _sum?: InvMetaGroupsSumAggregateInputType
    _min?: InvMetaGroupsMinAggregateInputType
    _max?: InvMetaGroupsMaxAggregateInputType
  }

  export type InvMetaGroupsGroupByOutputType = {
    metaGroupID: number
    metaGroupName: string | null
    description: string | null
    iconID: number | null
    _count: InvMetaGroupsCountAggregateOutputType | null
    _avg: InvMetaGroupsAvgAggregateOutputType | null
    _sum: InvMetaGroupsSumAggregateOutputType | null
    _min: InvMetaGroupsMinAggregateOutputType | null
    _max: InvMetaGroupsMaxAggregateOutputType | null
  }

  type GetInvMetaGroupsGroupByPayload<T extends invMetaGroupsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<InvMetaGroupsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof InvMetaGroupsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], InvMetaGroupsGroupByOutputType[P]>
            : GetScalarType<T[P], InvMetaGroupsGroupByOutputType[P]>
        }
      >
    >


  export type invMetaGroupsSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    metaGroupID?: boolean
    metaGroupName?: boolean
    description?: boolean
    iconID?: boolean
  }, ExtArgs["result"]["invMetaGroups"]>

  export type invMetaGroupsSelectScalar = {
    metaGroupID?: boolean
    metaGroupName?: boolean
    description?: boolean
    iconID?: boolean
  }


  export type $invMetaGroupsPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    name: "invMetaGroups"
    objects: {}
    scalars: $Extensions.GetResult<{
      metaGroupID: number
      metaGroupName: string | null
      description: string | null
      iconID: number | null
    }, ExtArgs["result"]["invMetaGroups"]>
    composites: {}
  }


  type invMetaGroupsGetPayload<S extends boolean | null | undefined | invMetaGroupsDefaultArgs> = $Result.GetResult<Prisma.$invMetaGroupsPayload, S>

  type invMetaGroupsCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<invMetaGroupsFindManyArgs, 'select' | 'include'> & {
      select?: InvMetaGroupsCountAggregateInputType | true
    }

  export interface invMetaGroupsDelegate<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['invMetaGroups'], meta: { name: 'invMetaGroups' } }
    /**
     * Find zero or one InvMetaGroups that matches the filter.
     * @param {invMetaGroupsFindUniqueArgs} args - Arguments to find a InvMetaGroups
     * @example
     * // Get one InvMetaGroups
     * const invMetaGroups = await prisma.invMetaGroups.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends invMetaGroupsFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, invMetaGroupsFindUniqueArgs<ExtArgs>>
    ): Prisma__invMetaGroupsClient<$Result.GetResult<Prisma.$invMetaGroupsPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one InvMetaGroups that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {invMetaGroupsFindUniqueOrThrowArgs} args - Arguments to find a InvMetaGroups
     * @example
     * // Get one InvMetaGroups
     * const invMetaGroups = await prisma.invMetaGroups.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends invMetaGroupsFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, invMetaGroupsFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__invMetaGroupsClient<$Result.GetResult<Prisma.$invMetaGroupsPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first InvMetaGroups that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {invMetaGroupsFindFirstArgs} args - Arguments to find a InvMetaGroups
     * @example
     * // Get one InvMetaGroups
     * const invMetaGroups = await prisma.invMetaGroups.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends invMetaGroupsFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, invMetaGroupsFindFirstArgs<ExtArgs>>
    ): Prisma__invMetaGroupsClient<$Result.GetResult<Prisma.$invMetaGroupsPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first InvMetaGroups that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {invMetaGroupsFindFirstOrThrowArgs} args - Arguments to find a InvMetaGroups
     * @example
     * // Get one InvMetaGroups
     * const invMetaGroups = await prisma.invMetaGroups.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends invMetaGroupsFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, invMetaGroupsFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__invMetaGroupsClient<$Result.GetResult<Prisma.$invMetaGroupsPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more InvMetaGroups that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {invMetaGroupsFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all InvMetaGroups
     * const invMetaGroups = await prisma.invMetaGroups.findMany()
     * 
     * // Get first 10 InvMetaGroups
     * const invMetaGroups = await prisma.invMetaGroups.findMany({ take: 10 })
     * 
     * // Only select the `metaGroupID`
     * const invMetaGroupsWithMetaGroupIDOnly = await prisma.invMetaGroups.findMany({ select: { metaGroupID: true } })
     * 
    **/
    findMany<T extends invMetaGroupsFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, invMetaGroupsFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$invMetaGroupsPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a InvMetaGroups.
     * @param {invMetaGroupsCreateArgs} args - Arguments to create a InvMetaGroups.
     * @example
     * // Create one InvMetaGroups
     * const InvMetaGroups = await prisma.invMetaGroups.create({
     *   data: {
     *     // ... data to create a InvMetaGroups
     *   }
     * })
     * 
    **/
    create<T extends invMetaGroupsCreateArgs<ExtArgs>>(
      args: SelectSubset<T, invMetaGroupsCreateArgs<ExtArgs>>
    ): Prisma__invMetaGroupsClient<$Result.GetResult<Prisma.$invMetaGroupsPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many InvMetaGroups.
     *     @param {invMetaGroupsCreateManyArgs} args - Arguments to create many InvMetaGroups.
     *     @example
     *     // Create many InvMetaGroups
     *     const invMetaGroups = await prisma.invMetaGroups.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends invMetaGroupsCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, invMetaGroupsCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a InvMetaGroups.
     * @param {invMetaGroupsDeleteArgs} args - Arguments to delete one InvMetaGroups.
     * @example
     * // Delete one InvMetaGroups
     * const InvMetaGroups = await prisma.invMetaGroups.delete({
     *   where: {
     *     // ... filter to delete one InvMetaGroups
     *   }
     * })
     * 
    **/
    delete<T extends invMetaGroupsDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, invMetaGroupsDeleteArgs<ExtArgs>>
    ): Prisma__invMetaGroupsClient<$Result.GetResult<Prisma.$invMetaGroupsPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one InvMetaGroups.
     * @param {invMetaGroupsUpdateArgs} args - Arguments to update one InvMetaGroups.
     * @example
     * // Update one InvMetaGroups
     * const invMetaGroups = await prisma.invMetaGroups.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends invMetaGroupsUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, invMetaGroupsUpdateArgs<ExtArgs>>
    ): Prisma__invMetaGroupsClient<$Result.GetResult<Prisma.$invMetaGroupsPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more InvMetaGroups.
     * @param {invMetaGroupsDeleteManyArgs} args - Arguments to filter InvMetaGroups to delete.
     * @example
     * // Delete a few InvMetaGroups
     * const { count } = await prisma.invMetaGroups.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends invMetaGroupsDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, invMetaGroupsDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more InvMetaGroups.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {invMetaGroupsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many InvMetaGroups
     * const invMetaGroups = await prisma.invMetaGroups.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends invMetaGroupsUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, invMetaGroupsUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one InvMetaGroups.
     * @param {invMetaGroupsUpsertArgs} args - Arguments to update or create a InvMetaGroups.
     * @example
     * // Update or create a InvMetaGroups
     * const invMetaGroups = await prisma.invMetaGroups.upsert({
     *   create: {
     *     // ... data to create a InvMetaGroups
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the InvMetaGroups we want to update
     *   }
     * })
    **/
    upsert<T extends invMetaGroupsUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, invMetaGroupsUpsertArgs<ExtArgs>>
    ): Prisma__invMetaGroupsClient<$Result.GetResult<Prisma.$invMetaGroupsPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of InvMetaGroups.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {invMetaGroupsCountArgs} args - Arguments to filter InvMetaGroups to count.
     * @example
     * // Count the number of InvMetaGroups
     * const count = await prisma.invMetaGroups.count({
     *   where: {
     *     // ... the filter for the InvMetaGroups we want to count
     *   }
     * })
    **/
    count<T extends invMetaGroupsCountArgs>(
      args?: Subset<T, invMetaGroupsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], InvMetaGroupsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a InvMetaGroups.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvMetaGroupsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends InvMetaGroupsAggregateArgs>(args: Subset<T, InvMetaGroupsAggregateArgs>): Prisma.PrismaPromise<GetInvMetaGroupsAggregateType<T>>

    /**
     * Group by InvMetaGroups.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {invMetaGroupsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends invMetaGroupsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: invMetaGroupsGroupByArgs['orderBy'] }
        : { orderBy?: invMetaGroupsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, invMetaGroupsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInvMetaGroupsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the invMetaGroups model
   */
  readonly fields: invMetaGroupsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for invMetaGroups.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__invMetaGroupsClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';


    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the invMetaGroups model
   */ 
  interface invMetaGroupsFieldRefs {
    readonly metaGroupID: FieldRef<"invMetaGroups", 'Int'>
    readonly metaGroupName: FieldRef<"invMetaGroups", 'String'>
    readonly description: FieldRef<"invMetaGroups", 'String'>
    readonly iconID: FieldRef<"invMetaGroups", 'Int'>
  }
    

  // Custom InputTypes

  /**
   * invMetaGroups findUnique
   */
  export type invMetaGroupsFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the invMetaGroups
     */
    select?: invMetaGroupsSelect<ExtArgs> | null
    /**
     * Filter, which invMetaGroups to fetch.
     */
    where: invMetaGroupsWhereUniqueInput
  }


  /**
   * invMetaGroups findUniqueOrThrow
   */
  export type invMetaGroupsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the invMetaGroups
     */
    select?: invMetaGroupsSelect<ExtArgs> | null
    /**
     * Filter, which invMetaGroups to fetch.
     */
    where: invMetaGroupsWhereUniqueInput
  }


  /**
   * invMetaGroups findFirst
   */
  export type invMetaGroupsFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the invMetaGroups
     */
    select?: invMetaGroupsSelect<ExtArgs> | null
    /**
     * Filter, which invMetaGroups to fetch.
     */
    where?: invMetaGroupsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of invMetaGroups to fetch.
     */
    orderBy?: invMetaGroupsOrderByWithRelationInput | invMetaGroupsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for invMetaGroups.
     */
    cursor?: invMetaGroupsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` invMetaGroups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` invMetaGroups.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of invMetaGroups.
     */
    distinct?: InvMetaGroupsScalarFieldEnum | InvMetaGroupsScalarFieldEnum[]
  }


  /**
   * invMetaGroups findFirstOrThrow
   */
  export type invMetaGroupsFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the invMetaGroups
     */
    select?: invMetaGroupsSelect<ExtArgs> | null
    /**
     * Filter, which invMetaGroups to fetch.
     */
    where?: invMetaGroupsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of invMetaGroups to fetch.
     */
    orderBy?: invMetaGroupsOrderByWithRelationInput | invMetaGroupsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for invMetaGroups.
     */
    cursor?: invMetaGroupsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` invMetaGroups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` invMetaGroups.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of invMetaGroups.
     */
    distinct?: InvMetaGroupsScalarFieldEnum | InvMetaGroupsScalarFieldEnum[]
  }


  /**
   * invMetaGroups findMany
   */
  export type invMetaGroupsFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the invMetaGroups
     */
    select?: invMetaGroupsSelect<ExtArgs> | null
    /**
     * Filter, which invMetaGroups to fetch.
     */
    where?: invMetaGroupsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of invMetaGroups to fetch.
     */
    orderBy?: invMetaGroupsOrderByWithRelationInput | invMetaGroupsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing invMetaGroups.
     */
    cursor?: invMetaGroupsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` invMetaGroups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` invMetaGroups.
     */
    skip?: number
    distinct?: InvMetaGroupsScalarFieldEnum | InvMetaGroupsScalarFieldEnum[]
  }


  /**
   * invMetaGroups create
   */
  export type invMetaGroupsCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the invMetaGroups
     */
    select?: invMetaGroupsSelect<ExtArgs> | null
    /**
     * The data needed to create a invMetaGroups.
     */
    data: XOR<invMetaGroupsCreateInput, invMetaGroupsUncheckedCreateInput>
  }


  /**
   * invMetaGroups createMany
   */
  export type invMetaGroupsCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many invMetaGroups.
     */
    data: invMetaGroupsCreateManyInput | invMetaGroupsCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * invMetaGroups update
   */
  export type invMetaGroupsUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the invMetaGroups
     */
    select?: invMetaGroupsSelect<ExtArgs> | null
    /**
     * The data needed to update a invMetaGroups.
     */
    data: XOR<invMetaGroupsUpdateInput, invMetaGroupsUncheckedUpdateInput>
    /**
     * Choose, which invMetaGroups to update.
     */
    where: invMetaGroupsWhereUniqueInput
  }


  /**
   * invMetaGroups updateMany
   */
  export type invMetaGroupsUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update invMetaGroups.
     */
    data: XOR<invMetaGroupsUpdateManyMutationInput, invMetaGroupsUncheckedUpdateManyInput>
    /**
     * Filter which invMetaGroups to update
     */
    where?: invMetaGroupsWhereInput
  }


  /**
   * invMetaGroups upsert
   */
  export type invMetaGroupsUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the invMetaGroups
     */
    select?: invMetaGroupsSelect<ExtArgs> | null
    /**
     * The filter to search for the invMetaGroups to update in case it exists.
     */
    where: invMetaGroupsWhereUniqueInput
    /**
     * In case the invMetaGroups found by the `where` argument doesn't exist, create a new invMetaGroups with this data.
     */
    create: XOR<invMetaGroupsCreateInput, invMetaGroupsUncheckedCreateInput>
    /**
     * In case the invMetaGroups was found with the provided `where` argument, update it with this data.
     */
    update: XOR<invMetaGroupsUpdateInput, invMetaGroupsUncheckedUpdateInput>
  }


  /**
   * invMetaGroups delete
   */
  export type invMetaGroupsDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the invMetaGroups
     */
    select?: invMetaGroupsSelect<ExtArgs> | null
    /**
     * Filter which invMetaGroups to delete.
     */
    where: invMetaGroupsWhereUniqueInput
  }


  /**
   * invMetaGroups deleteMany
   */
  export type invMetaGroupsDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which invMetaGroups to delete
     */
    where?: invMetaGroupsWhereInput
  }


  /**
   * invMetaGroups without action
   */
  export type invMetaGroupsDefaultArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the invMetaGroups
     */
    select?: invMetaGroupsSelect<ExtArgs> | null
  }



  /**
   * Model invMetaTypes
   */

  export type AggregateInvMetaTypes = {
    _count: InvMetaTypesCountAggregateOutputType | null
    _avg: InvMetaTypesAvgAggregateOutputType | null
    _sum: InvMetaTypesSumAggregateOutputType | null
    _min: InvMetaTypesMinAggregateOutputType | null
    _max: InvMetaTypesMaxAggregateOutputType | null
  }

  export type InvMetaTypesAvgAggregateOutputType = {
    typeID: number | null
    parentTypeID: number | null
    metaGroupID: number | null
  }

  export type InvMetaTypesSumAggregateOutputType = {
    typeID: number | null
    parentTypeID: number | null
    metaGroupID: number | null
  }

  export type InvMetaTypesMinAggregateOutputType = {
    typeID: number | null
    parentTypeID: number | null
    metaGroupID: number | null
  }

  export type InvMetaTypesMaxAggregateOutputType = {
    typeID: number | null
    parentTypeID: number | null
    metaGroupID: number | null
  }

  export type InvMetaTypesCountAggregateOutputType = {
    typeID: number
    parentTypeID: number
    metaGroupID: number
    _all: number
  }


  export type InvMetaTypesAvgAggregateInputType = {
    typeID?: true
    parentTypeID?: true
    metaGroupID?: true
  }

  export type InvMetaTypesSumAggregateInputType = {
    typeID?: true
    parentTypeID?: true
    metaGroupID?: true
  }

  export type InvMetaTypesMinAggregateInputType = {
    typeID?: true
    parentTypeID?: true
    metaGroupID?: true
  }

  export type InvMetaTypesMaxAggregateInputType = {
    typeID?: true
    parentTypeID?: true
    metaGroupID?: true
  }

  export type InvMetaTypesCountAggregateInputType = {
    typeID?: true
    parentTypeID?: true
    metaGroupID?: true
    _all?: true
  }

  export type InvMetaTypesAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which invMetaTypes to aggregate.
     */
    where?: invMetaTypesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of invMetaTypes to fetch.
     */
    orderBy?: invMetaTypesOrderByWithRelationInput | invMetaTypesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: invMetaTypesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` invMetaTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` invMetaTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned invMetaTypes
    **/
    _count?: true | InvMetaTypesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: InvMetaTypesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: InvMetaTypesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: InvMetaTypesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: InvMetaTypesMaxAggregateInputType
  }

  export type GetInvMetaTypesAggregateType<T extends InvMetaTypesAggregateArgs> = {
        [P in keyof T & keyof AggregateInvMetaTypes]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInvMetaTypes[P]>
      : GetScalarType<T[P], AggregateInvMetaTypes[P]>
  }




  export type invMetaTypesGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: invMetaTypesWhereInput
    orderBy?: invMetaTypesOrderByWithAggregationInput | invMetaTypesOrderByWithAggregationInput[]
    by: InvMetaTypesScalarFieldEnum[] | InvMetaTypesScalarFieldEnum
    having?: invMetaTypesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: InvMetaTypesCountAggregateInputType | true
    _avg?: InvMetaTypesAvgAggregateInputType
    _sum?: InvMetaTypesSumAggregateInputType
    _min?: InvMetaTypesMinAggregateInputType
    _max?: InvMetaTypesMaxAggregateInputType
  }

  export type InvMetaTypesGroupByOutputType = {
    typeID: number
    parentTypeID: number | null
    metaGroupID: number | null
    _count: InvMetaTypesCountAggregateOutputType | null
    _avg: InvMetaTypesAvgAggregateOutputType | null
    _sum: InvMetaTypesSumAggregateOutputType | null
    _min: InvMetaTypesMinAggregateOutputType | null
    _max: InvMetaTypesMaxAggregateOutputType | null
  }

  type GetInvMetaTypesGroupByPayload<T extends invMetaTypesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<InvMetaTypesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof InvMetaTypesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], InvMetaTypesGroupByOutputType[P]>
            : GetScalarType<T[P], InvMetaTypesGroupByOutputType[P]>
        }
      >
    >


  export type invMetaTypesSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    typeID?: boolean
    parentTypeID?: boolean
    metaGroupID?: boolean
  }, ExtArgs["result"]["invMetaTypes"]>

  export type invMetaTypesSelectScalar = {
    typeID?: boolean
    parentTypeID?: boolean
    metaGroupID?: boolean
  }


  export type $invMetaTypesPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    name: "invMetaTypes"
    objects: {}
    scalars: $Extensions.GetResult<{
      typeID: number
      parentTypeID: number | null
      metaGroupID: number | null
    }, ExtArgs["result"]["invMetaTypes"]>
    composites: {}
  }


  type invMetaTypesGetPayload<S extends boolean | null | undefined | invMetaTypesDefaultArgs> = $Result.GetResult<Prisma.$invMetaTypesPayload, S>

  type invMetaTypesCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<invMetaTypesFindManyArgs, 'select' | 'include'> & {
      select?: InvMetaTypesCountAggregateInputType | true
    }

  export interface invMetaTypesDelegate<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['invMetaTypes'], meta: { name: 'invMetaTypes' } }
    /**
     * Find zero or one InvMetaTypes that matches the filter.
     * @param {invMetaTypesFindUniqueArgs} args - Arguments to find a InvMetaTypes
     * @example
     * // Get one InvMetaTypes
     * const invMetaTypes = await prisma.invMetaTypes.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends invMetaTypesFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, invMetaTypesFindUniqueArgs<ExtArgs>>
    ): Prisma__invMetaTypesClient<$Result.GetResult<Prisma.$invMetaTypesPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one InvMetaTypes that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {invMetaTypesFindUniqueOrThrowArgs} args - Arguments to find a InvMetaTypes
     * @example
     * // Get one InvMetaTypes
     * const invMetaTypes = await prisma.invMetaTypes.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends invMetaTypesFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, invMetaTypesFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__invMetaTypesClient<$Result.GetResult<Prisma.$invMetaTypesPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first InvMetaTypes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {invMetaTypesFindFirstArgs} args - Arguments to find a InvMetaTypes
     * @example
     * // Get one InvMetaTypes
     * const invMetaTypes = await prisma.invMetaTypes.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends invMetaTypesFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, invMetaTypesFindFirstArgs<ExtArgs>>
    ): Prisma__invMetaTypesClient<$Result.GetResult<Prisma.$invMetaTypesPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first InvMetaTypes that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {invMetaTypesFindFirstOrThrowArgs} args - Arguments to find a InvMetaTypes
     * @example
     * // Get one InvMetaTypes
     * const invMetaTypes = await prisma.invMetaTypes.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends invMetaTypesFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, invMetaTypesFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__invMetaTypesClient<$Result.GetResult<Prisma.$invMetaTypesPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more InvMetaTypes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {invMetaTypesFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all InvMetaTypes
     * const invMetaTypes = await prisma.invMetaTypes.findMany()
     * 
     * // Get first 10 InvMetaTypes
     * const invMetaTypes = await prisma.invMetaTypes.findMany({ take: 10 })
     * 
     * // Only select the `typeID`
     * const invMetaTypesWithTypeIDOnly = await prisma.invMetaTypes.findMany({ select: { typeID: true } })
     * 
    **/
    findMany<T extends invMetaTypesFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, invMetaTypesFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$invMetaTypesPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a InvMetaTypes.
     * @param {invMetaTypesCreateArgs} args - Arguments to create a InvMetaTypes.
     * @example
     * // Create one InvMetaTypes
     * const InvMetaTypes = await prisma.invMetaTypes.create({
     *   data: {
     *     // ... data to create a InvMetaTypes
     *   }
     * })
     * 
    **/
    create<T extends invMetaTypesCreateArgs<ExtArgs>>(
      args: SelectSubset<T, invMetaTypesCreateArgs<ExtArgs>>
    ): Prisma__invMetaTypesClient<$Result.GetResult<Prisma.$invMetaTypesPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many InvMetaTypes.
     *     @param {invMetaTypesCreateManyArgs} args - Arguments to create many InvMetaTypes.
     *     @example
     *     // Create many InvMetaTypes
     *     const invMetaTypes = await prisma.invMetaTypes.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends invMetaTypesCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, invMetaTypesCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a InvMetaTypes.
     * @param {invMetaTypesDeleteArgs} args - Arguments to delete one InvMetaTypes.
     * @example
     * // Delete one InvMetaTypes
     * const InvMetaTypes = await prisma.invMetaTypes.delete({
     *   where: {
     *     // ... filter to delete one InvMetaTypes
     *   }
     * })
     * 
    **/
    delete<T extends invMetaTypesDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, invMetaTypesDeleteArgs<ExtArgs>>
    ): Prisma__invMetaTypesClient<$Result.GetResult<Prisma.$invMetaTypesPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one InvMetaTypes.
     * @param {invMetaTypesUpdateArgs} args - Arguments to update one InvMetaTypes.
     * @example
     * // Update one InvMetaTypes
     * const invMetaTypes = await prisma.invMetaTypes.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends invMetaTypesUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, invMetaTypesUpdateArgs<ExtArgs>>
    ): Prisma__invMetaTypesClient<$Result.GetResult<Prisma.$invMetaTypesPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more InvMetaTypes.
     * @param {invMetaTypesDeleteManyArgs} args - Arguments to filter InvMetaTypes to delete.
     * @example
     * // Delete a few InvMetaTypes
     * const { count } = await prisma.invMetaTypes.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends invMetaTypesDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, invMetaTypesDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more InvMetaTypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {invMetaTypesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many InvMetaTypes
     * const invMetaTypes = await prisma.invMetaTypes.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends invMetaTypesUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, invMetaTypesUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one InvMetaTypes.
     * @param {invMetaTypesUpsertArgs} args - Arguments to update or create a InvMetaTypes.
     * @example
     * // Update or create a InvMetaTypes
     * const invMetaTypes = await prisma.invMetaTypes.upsert({
     *   create: {
     *     // ... data to create a InvMetaTypes
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the InvMetaTypes we want to update
     *   }
     * })
    **/
    upsert<T extends invMetaTypesUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, invMetaTypesUpsertArgs<ExtArgs>>
    ): Prisma__invMetaTypesClient<$Result.GetResult<Prisma.$invMetaTypesPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of InvMetaTypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {invMetaTypesCountArgs} args - Arguments to filter InvMetaTypes to count.
     * @example
     * // Count the number of InvMetaTypes
     * const count = await prisma.invMetaTypes.count({
     *   where: {
     *     // ... the filter for the InvMetaTypes we want to count
     *   }
     * })
    **/
    count<T extends invMetaTypesCountArgs>(
      args?: Subset<T, invMetaTypesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], InvMetaTypesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a InvMetaTypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvMetaTypesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends InvMetaTypesAggregateArgs>(args: Subset<T, InvMetaTypesAggregateArgs>): Prisma.PrismaPromise<GetInvMetaTypesAggregateType<T>>

    /**
     * Group by InvMetaTypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {invMetaTypesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends invMetaTypesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: invMetaTypesGroupByArgs['orderBy'] }
        : { orderBy?: invMetaTypesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, invMetaTypesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInvMetaTypesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the invMetaTypes model
   */
  readonly fields: invMetaTypesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for invMetaTypes.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__invMetaTypesClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';


    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the invMetaTypes model
   */ 
  interface invMetaTypesFieldRefs {
    readonly typeID: FieldRef<"invMetaTypes", 'Int'>
    readonly parentTypeID: FieldRef<"invMetaTypes", 'Int'>
    readonly metaGroupID: FieldRef<"invMetaTypes", 'Int'>
  }
    

  // Custom InputTypes

  /**
   * invMetaTypes findUnique
   */
  export type invMetaTypesFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the invMetaTypes
     */
    select?: invMetaTypesSelect<ExtArgs> | null
    /**
     * Filter, which invMetaTypes to fetch.
     */
    where: invMetaTypesWhereUniqueInput
  }


  /**
   * invMetaTypes findUniqueOrThrow
   */
  export type invMetaTypesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the invMetaTypes
     */
    select?: invMetaTypesSelect<ExtArgs> | null
    /**
     * Filter, which invMetaTypes to fetch.
     */
    where: invMetaTypesWhereUniqueInput
  }


  /**
   * invMetaTypes findFirst
   */
  export type invMetaTypesFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the invMetaTypes
     */
    select?: invMetaTypesSelect<ExtArgs> | null
    /**
     * Filter, which invMetaTypes to fetch.
     */
    where?: invMetaTypesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of invMetaTypes to fetch.
     */
    orderBy?: invMetaTypesOrderByWithRelationInput | invMetaTypesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for invMetaTypes.
     */
    cursor?: invMetaTypesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` invMetaTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` invMetaTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of invMetaTypes.
     */
    distinct?: InvMetaTypesScalarFieldEnum | InvMetaTypesScalarFieldEnum[]
  }


  /**
   * invMetaTypes findFirstOrThrow
   */
  export type invMetaTypesFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the invMetaTypes
     */
    select?: invMetaTypesSelect<ExtArgs> | null
    /**
     * Filter, which invMetaTypes to fetch.
     */
    where?: invMetaTypesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of invMetaTypes to fetch.
     */
    orderBy?: invMetaTypesOrderByWithRelationInput | invMetaTypesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for invMetaTypes.
     */
    cursor?: invMetaTypesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` invMetaTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` invMetaTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of invMetaTypes.
     */
    distinct?: InvMetaTypesScalarFieldEnum | InvMetaTypesScalarFieldEnum[]
  }


  /**
   * invMetaTypes findMany
   */
  export type invMetaTypesFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the invMetaTypes
     */
    select?: invMetaTypesSelect<ExtArgs> | null
    /**
     * Filter, which invMetaTypes to fetch.
     */
    where?: invMetaTypesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of invMetaTypes to fetch.
     */
    orderBy?: invMetaTypesOrderByWithRelationInput | invMetaTypesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing invMetaTypes.
     */
    cursor?: invMetaTypesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` invMetaTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` invMetaTypes.
     */
    skip?: number
    distinct?: InvMetaTypesScalarFieldEnum | InvMetaTypesScalarFieldEnum[]
  }


  /**
   * invMetaTypes create
   */
  export type invMetaTypesCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the invMetaTypes
     */
    select?: invMetaTypesSelect<ExtArgs> | null
    /**
     * The data needed to create a invMetaTypes.
     */
    data: XOR<invMetaTypesCreateInput, invMetaTypesUncheckedCreateInput>
  }


  /**
   * invMetaTypes createMany
   */
  export type invMetaTypesCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many invMetaTypes.
     */
    data: invMetaTypesCreateManyInput | invMetaTypesCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * invMetaTypes update
   */
  export type invMetaTypesUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the invMetaTypes
     */
    select?: invMetaTypesSelect<ExtArgs> | null
    /**
     * The data needed to update a invMetaTypes.
     */
    data: XOR<invMetaTypesUpdateInput, invMetaTypesUncheckedUpdateInput>
    /**
     * Choose, which invMetaTypes to update.
     */
    where: invMetaTypesWhereUniqueInput
  }


  /**
   * invMetaTypes updateMany
   */
  export type invMetaTypesUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update invMetaTypes.
     */
    data: XOR<invMetaTypesUpdateManyMutationInput, invMetaTypesUncheckedUpdateManyInput>
    /**
     * Filter which invMetaTypes to update
     */
    where?: invMetaTypesWhereInput
  }


  /**
   * invMetaTypes upsert
   */
  export type invMetaTypesUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the invMetaTypes
     */
    select?: invMetaTypesSelect<ExtArgs> | null
    /**
     * The filter to search for the invMetaTypes to update in case it exists.
     */
    where: invMetaTypesWhereUniqueInput
    /**
     * In case the invMetaTypes found by the `where` argument doesn't exist, create a new invMetaTypes with this data.
     */
    create: XOR<invMetaTypesCreateInput, invMetaTypesUncheckedCreateInput>
    /**
     * In case the invMetaTypes was found with the provided `where` argument, update it with this data.
     */
    update: XOR<invMetaTypesUpdateInput, invMetaTypesUncheckedUpdateInput>
  }


  /**
   * invMetaTypes delete
   */
  export type invMetaTypesDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the invMetaTypes
     */
    select?: invMetaTypesSelect<ExtArgs> | null
    /**
     * Filter which invMetaTypes to delete.
     */
    where: invMetaTypesWhereUniqueInput
  }


  /**
   * invMetaTypes deleteMany
   */
  export type invMetaTypesDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which invMetaTypes to delete
     */
    where?: invMetaTypesWhereInput
  }


  /**
   * invMetaTypes without action
   */
  export type invMetaTypesDefaultArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the invMetaTypes
     */
    select?: invMetaTypesSelect<ExtArgs> | null
  }



  /**
   * Model invNames
   */

  export type AggregateInvNames = {
    _count: InvNamesCountAggregateOutputType | null
    _avg: InvNamesAvgAggregateOutputType | null
    _sum: InvNamesSumAggregateOutputType | null
    _min: InvNamesMinAggregateOutputType | null
    _max: InvNamesMaxAggregateOutputType | null
  }

  export type InvNamesAvgAggregateOutputType = {
    itemID: number | null
  }

  export type InvNamesSumAggregateOutputType = {
    itemID: number | null
  }

  export type InvNamesMinAggregateOutputType = {
    itemID: number | null
    itemName: string | null
  }

  export type InvNamesMaxAggregateOutputType = {
    itemID: number | null
    itemName: string | null
  }

  export type InvNamesCountAggregateOutputType = {
    itemID: number
    itemName: number
    _all: number
  }


  export type InvNamesAvgAggregateInputType = {
    itemID?: true
  }

  export type InvNamesSumAggregateInputType = {
    itemID?: true
  }

  export type InvNamesMinAggregateInputType = {
    itemID?: true
    itemName?: true
  }

  export type InvNamesMaxAggregateInputType = {
    itemID?: true
    itemName?: true
  }

  export type InvNamesCountAggregateInputType = {
    itemID?: true
    itemName?: true
    _all?: true
  }

  export type InvNamesAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which invNames to aggregate.
     */
    where?: invNamesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of invNames to fetch.
     */
    orderBy?: invNamesOrderByWithRelationInput | invNamesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: invNamesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` invNames from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` invNames.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned invNames
    **/
    _count?: true | InvNamesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: InvNamesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: InvNamesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: InvNamesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: InvNamesMaxAggregateInputType
  }

  export type GetInvNamesAggregateType<T extends InvNamesAggregateArgs> = {
        [P in keyof T & keyof AggregateInvNames]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInvNames[P]>
      : GetScalarType<T[P], AggregateInvNames[P]>
  }




  export type invNamesGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: invNamesWhereInput
    orderBy?: invNamesOrderByWithAggregationInput | invNamesOrderByWithAggregationInput[]
    by: InvNamesScalarFieldEnum[] | InvNamesScalarFieldEnum
    having?: invNamesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: InvNamesCountAggregateInputType | true
    _avg?: InvNamesAvgAggregateInputType
    _sum?: InvNamesSumAggregateInputType
    _min?: InvNamesMinAggregateInputType
    _max?: InvNamesMaxAggregateInputType
  }

  export type InvNamesGroupByOutputType = {
    itemID: number
    itemName: string
    _count: InvNamesCountAggregateOutputType | null
    _avg: InvNamesAvgAggregateOutputType | null
    _sum: InvNamesSumAggregateOutputType | null
    _min: InvNamesMinAggregateOutputType | null
    _max: InvNamesMaxAggregateOutputType | null
  }

  type GetInvNamesGroupByPayload<T extends invNamesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<InvNamesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof InvNamesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], InvNamesGroupByOutputType[P]>
            : GetScalarType<T[P], InvNamesGroupByOutputType[P]>
        }
      >
    >


  export type invNamesSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    itemID?: boolean
    itemName?: boolean
  }, ExtArgs["result"]["invNames"]>

  export type invNamesSelectScalar = {
    itemID?: boolean
    itemName?: boolean
  }


  export type $invNamesPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    name: "invNames"
    objects: {}
    scalars: $Extensions.GetResult<{
      itemID: number
      itemName: string
    }, ExtArgs["result"]["invNames"]>
    composites: {}
  }


  type invNamesGetPayload<S extends boolean | null | undefined | invNamesDefaultArgs> = $Result.GetResult<Prisma.$invNamesPayload, S>

  type invNamesCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<invNamesFindManyArgs, 'select' | 'include'> & {
      select?: InvNamesCountAggregateInputType | true
    }

  export interface invNamesDelegate<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['invNames'], meta: { name: 'invNames' } }
    /**
     * Find zero or one InvNames that matches the filter.
     * @param {invNamesFindUniqueArgs} args - Arguments to find a InvNames
     * @example
     * // Get one InvNames
     * const invNames = await prisma.invNames.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends invNamesFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, invNamesFindUniqueArgs<ExtArgs>>
    ): Prisma__invNamesClient<$Result.GetResult<Prisma.$invNamesPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one InvNames that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {invNamesFindUniqueOrThrowArgs} args - Arguments to find a InvNames
     * @example
     * // Get one InvNames
     * const invNames = await prisma.invNames.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends invNamesFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, invNamesFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__invNamesClient<$Result.GetResult<Prisma.$invNamesPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first InvNames that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {invNamesFindFirstArgs} args - Arguments to find a InvNames
     * @example
     * // Get one InvNames
     * const invNames = await prisma.invNames.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends invNamesFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, invNamesFindFirstArgs<ExtArgs>>
    ): Prisma__invNamesClient<$Result.GetResult<Prisma.$invNamesPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first InvNames that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {invNamesFindFirstOrThrowArgs} args - Arguments to find a InvNames
     * @example
     * // Get one InvNames
     * const invNames = await prisma.invNames.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends invNamesFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, invNamesFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__invNamesClient<$Result.GetResult<Prisma.$invNamesPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more InvNames that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {invNamesFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all InvNames
     * const invNames = await prisma.invNames.findMany()
     * 
     * // Get first 10 InvNames
     * const invNames = await prisma.invNames.findMany({ take: 10 })
     * 
     * // Only select the `itemID`
     * const invNamesWithItemIDOnly = await prisma.invNames.findMany({ select: { itemID: true } })
     * 
    **/
    findMany<T extends invNamesFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, invNamesFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$invNamesPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a InvNames.
     * @param {invNamesCreateArgs} args - Arguments to create a InvNames.
     * @example
     * // Create one InvNames
     * const InvNames = await prisma.invNames.create({
     *   data: {
     *     // ... data to create a InvNames
     *   }
     * })
     * 
    **/
    create<T extends invNamesCreateArgs<ExtArgs>>(
      args: SelectSubset<T, invNamesCreateArgs<ExtArgs>>
    ): Prisma__invNamesClient<$Result.GetResult<Prisma.$invNamesPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many InvNames.
     *     @param {invNamesCreateManyArgs} args - Arguments to create many InvNames.
     *     @example
     *     // Create many InvNames
     *     const invNames = await prisma.invNames.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends invNamesCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, invNamesCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a InvNames.
     * @param {invNamesDeleteArgs} args - Arguments to delete one InvNames.
     * @example
     * // Delete one InvNames
     * const InvNames = await prisma.invNames.delete({
     *   where: {
     *     // ... filter to delete one InvNames
     *   }
     * })
     * 
    **/
    delete<T extends invNamesDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, invNamesDeleteArgs<ExtArgs>>
    ): Prisma__invNamesClient<$Result.GetResult<Prisma.$invNamesPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one InvNames.
     * @param {invNamesUpdateArgs} args - Arguments to update one InvNames.
     * @example
     * // Update one InvNames
     * const invNames = await prisma.invNames.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends invNamesUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, invNamesUpdateArgs<ExtArgs>>
    ): Prisma__invNamesClient<$Result.GetResult<Prisma.$invNamesPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more InvNames.
     * @param {invNamesDeleteManyArgs} args - Arguments to filter InvNames to delete.
     * @example
     * // Delete a few InvNames
     * const { count } = await prisma.invNames.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends invNamesDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, invNamesDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more InvNames.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {invNamesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many InvNames
     * const invNames = await prisma.invNames.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends invNamesUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, invNamesUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one InvNames.
     * @param {invNamesUpsertArgs} args - Arguments to update or create a InvNames.
     * @example
     * // Update or create a InvNames
     * const invNames = await prisma.invNames.upsert({
     *   create: {
     *     // ... data to create a InvNames
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the InvNames we want to update
     *   }
     * })
    **/
    upsert<T extends invNamesUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, invNamesUpsertArgs<ExtArgs>>
    ): Prisma__invNamesClient<$Result.GetResult<Prisma.$invNamesPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of InvNames.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {invNamesCountArgs} args - Arguments to filter InvNames to count.
     * @example
     * // Count the number of InvNames
     * const count = await prisma.invNames.count({
     *   where: {
     *     // ... the filter for the InvNames we want to count
     *   }
     * })
    **/
    count<T extends invNamesCountArgs>(
      args?: Subset<T, invNamesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], InvNamesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a InvNames.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvNamesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends InvNamesAggregateArgs>(args: Subset<T, InvNamesAggregateArgs>): Prisma.PrismaPromise<GetInvNamesAggregateType<T>>

    /**
     * Group by InvNames.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {invNamesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends invNamesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: invNamesGroupByArgs['orderBy'] }
        : { orderBy?: invNamesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, invNamesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInvNamesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the invNames model
   */
  readonly fields: invNamesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for invNames.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__invNamesClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';


    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the invNames model
   */ 
  interface invNamesFieldRefs {
    readonly itemID: FieldRef<"invNames", 'Int'>
    readonly itemName: FieldRef<"invNames", 'String'>
  }
    

  // Custom InputTypes

  /**
   * invNames findUnique
   */
  export type invNamesFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the invNames
     */
    select?: invNamesSelect<ExtArgs> | null
    /**
     * Filter, which invNames to fetch.
     */
    where: invNamesWhereUniqueInput
  }


  /**
   * invNames findUniqueOrThrow
   */
  export type invNamesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the invNames
     */
    select?: invNamesSelect<ExtArgs> | null
    /**
     * Filter, which invNames to fetch.
     */
    where: invNamesWhereUniqueInput
  }


  /**
   * invNames findFirst
   */
  export type invNamesFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the invNames
     */
    select?: invNamesSelect<ExtArgs> | null
    /**
     * Filter, which invNames to fetch.
     */
    where?: invNamesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of invNames to fetch.
     */
    orderBy?: invNamesOrderByWithRelationInput | invNamesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for invNames.
     */
    cursor?: invNamesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` invNames from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` invNames.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of invNames.
     */
    distinct?: InvNamesScalarFieldEnum | InvNamesScalarFieldEnum[]
  }


  /**
   * invNames findFirstOrThrow
   */
  export type invNamesFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the invNames
     */
    select?: invNamesSelect<ExtArgs> | null
    /**
     * Filter, which invNames to fetch.
     */
    where?: invNamesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of invNames to fetch.
     */
    orderBy?: invNamesOrderByWithRelationInput | invNamesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for invNames.
     */
    cursor?: invNamesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` invNames from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` invNames.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of invNames.
     */
    distinct?: InvNamesScalarFieldEnum | InvNamesScalarFieldEnum[]
  }


  /**
   * invNames findMany
   */
  export type invNamesFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the invNames
     */
    select?: invNamesSelect<ExtArgs> | null
    /**
     * Filter, which invNames to fetch.
     */
    where?: invNamesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of invNames to fetch.
     */
    orderBy?: invNamesOrderByWithRelationInput | invNamesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing invNames.
     */
    cursor?: invNamesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` invNames from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` invNames.
     */
    skip?: number
    distinct?: InvNamesScalarFieldEnum | InvNamesScalarFieldEnum[]
  }


  /**
   * invNames create
   */
  export type invNamesCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the invNames
     */
    select?: invNamesSelect<ExtArgs> | null
    /**
     * The data needed to create a invNames.
     */
    data: XOR<invNamesCreateInput, invNamesUncheckedCreateInput>
  }


  /**
   * invNames createMany
   */
  export type invNamesCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many invNames.
     */
    data: invNamesCreateManyInput | invNamesCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * invNames update
   */
  export type invNamesUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the invNames
     */
    select?: invNamesSelect<ExtArgs> | null
    /**
     * The data needed to update a invNames.
     */
    data: XOR<invNamesUpdateInput, invNamesUncheckedUpdateInput>
    /**
     * Choose, which invNames to update.
     */
    where: invNamesWhereUniqueInput
  }


  /**
   * invNames updateMany
   */
  export type invNamesUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update invNames.
     */
    data: XOR<invNamesUpdateManyMutationInput, invNamesUncheckedUpdateManyInput>
    /**
     * Filter which invNames to update
     */
    where?: invNamesWhereInput
  }


  /**
   * invNames upsert
   */
  export type invNamesUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the invNames
     */
    select?: invNamesSelect<ExtArgs> | null
    /**
     * The filter to search for the invNames to update in case it exists.
     */
    where: invNamesWhereUniqueInput
    /**
     * In case the invNames found by the `where` argument doesn't exist, create a new invNames with this data.
     */
    create: XOR<invNamesCreateInput, invNamesUncheckedCreateInput>
    /**
     * In case the invNames was found with the provided `where` argument, update it with this data.
     */
    update: XOR<invNamesUpdateInput, invNamesUncheckedUpdateInput>
  }


  /**
   * invNames delete
   */
  export type invNamesDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the invNames
     */
    select?: invNamesSelect<ExtArgs> | null
    /**
     * Filter which invNames to delete.
     */
    where: invNamesWhereUniqueInput
  }


  /**
   * invNames deleteMany
   */
  export type invNamesDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which invNames to delete
     */
    where?: invNamesWhereInput
  }


  /**
   * invNames without action
   */
  export type invNamesDefaultArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the invNames
     */
    select?: invNamesSelect<ExtArgs> | null
  }



  /**
   * Model invPositions
   */

  export type AggregateInvPositions = {
    _count: InvPositionsCountAggregateOutputType | null
    _avg: InvPositionsAvgAggregateOutputType | null
    _sum: InvPositionsSumAggregateOutputType | null
    _min: InvPositionsMinAggregateOutputType | null
    _max: InvPositionsMaxAggregateOutputType | null
  }

  export type InvPositionsAvgAggregateOutputType = {
    itemID: number | null
    x: number | null
    y: number | null
    z: number | null
    yaw: number | null
    pitch: number | null
    roll: number | null
  }

  export type InvPositionsSumAggregateOutputType = {
    itemID: number | null
    x: number | null
    y: number | null
    z: number | null
    yaw: number | null
    pitch: number | null
    roll: number | null
  }

  export type InvPositionsMinAggregateOutputType = {
    itemID: number | null
    x: number | null
    y: number | null
    z: number | null
    yaw: number | null
    pitch: number | null
    roll: number | null
  }

  export type InvPositionsMaxAggregateOutputType = {
    itemID: number | null
    x: number | null
    y: number | null
    z: number | null
    yaw: number | null
    pitch: number | null
    roll: number | null
  }

  export type InvPositionsCountAggregateOutputType = {
    itemID: number
    x: number
    y: number
    z: number
    yaw: number
    pitch: number
    roll: number
    _all: number
  }


  export type InvPositionsAvgAggregateInputType = {
    itemID?: true
    x?: true
    y?: true
    z?: true
    yaw?: true
    pitch?: true
    roll?: true
  }

  export type InvPositionsSumAggregateInputType = {
    itemID?: true
    x?: true
    y?: true
    z?: true
    yaw?: true
    pitch?: true
    roll?: true
  }

  export type InvPositionsMinAggregateInputType = {
    itemID?: true
    x?: true
    y?: true
    z?: true
    yaw?: true
    pitch?: true
    roll?: true
  }

  export type InvPositionsMaxAggregateInputType = {
    itemID?: true
    x?: true
    y?: true
    z?: true
    yaw?: true
    pitch?: true
    roll?: true
  }

  export type InvPositionsCountAggregateInputType = {
    itemID?: true
    x?: true
    y?: true
    z?: true
    yaw?: true
    pitch?: true
    roll?: true
    _all?: true
  }

  export type InvPositionsAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which invPositions to aggregate.
     */
    where?: invPositionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of invPositions to fetch.
     */
    orderBy?: invPositionsOrderByWithRelationInput | invPositionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: invPositionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` invPositions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` invPositions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned invPositions
    **/
    _count?: true | InvPositionsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: InvPositionsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: InvPositionsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: InvPositionsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: InvPositionsMaxAggregateInputType
  }

  export type GetInvPositionsAggregateType<T extends InvPositionsAggregateArgs> = {
        [P in keyof T & keyof AggregateInvPositions]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInvPositions[P]>
      : GetScalarType<T[P], AggregateInvPositions[P]>
  }




  export type invPositionsGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: invPositionsWhereInput
    orderBy?: invPositionsOrderByWithAggregationInput | invPositionsOrderByWithAggregationInput[]
    by: InvPositionsScalarFieldEnum[] | InvPositionsScalarFieldEnum
    having?: invPositionsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: InvPositionsCountAggregateInputType | true
    _avg?: InvPositionsAvgAggregateInputType
    _sum?: InvPositionsSumAggregateInputType
    _min?: InvPositionsMinAggregateInputType
    _max?: InvPositionsMaxAggregateInputType
  }

  export type InvPositionsGroupByOutputType = {
    itemID: number
    x: number
    y: number
    z: number
    yaw: number | null
    pitch: number | null
    roll: number | null
    _count: InvPositionsCountAggregateOutputType | null
    _avg: InvPositionsAvgAggregateOutputType | null
    _sum: InvPositionsSumAggregateOutputType | null
    _min: InvPositionsMinAggregateOutputType | null
    _max: InvPositionsMaxAggregateOutputType | null
  }

  type GetInvPositionsGroupByPayload<T extends invPositionsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<InvPositionsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof InvPositionsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], InvPositionsGroupByOutputType[P]>
            : GetScalarType<T[P], InvPositionsGroupByOutputType[P]>
        }
      >
    >


  export type invPositionsSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    itemID?: boolean
    x?: boolean
    y?: boolean
    z?: boolean
    yaw?: boolean
    pitch?: boolean
    roll?: boolean
  }, ExtArgs["result"]["invPositions"]>

  export type invPositionsSelectScalar = {
    itemID?: boolean
    x?: boolean
    y?: boolean
    z?: boolean
    yaw?: boolean
    pitch?: boolean
    roll?: boolean
  }


  export type $invPositionsPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    name: "invPositions"
    objects: {}
    scalars: $Extensions.GetResult<{
      itemID: number
      x: number
      y: number
      z: number
      yaw: number | null
      pitch: number | null
      roll: number | null
    }, ExtArgs["result"]["invPositions"]>
    composites: {}
  }


  type invPositionsGetPayload<S extends boolean | null | undefined | invPositionsDefaultArgs> = $Result.GetResult<Prisma.$invPositionsPayload, S>

  type invPositionsCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<invPositionsFindManyArgs, 'select' | 'include'> & {
      select?: InvPositionsCountAggregateInputType | true
    }

  export interface invPositionsDelegate<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['invPositions'], meta: { name: 'invPositions' } }
    /**
     * Find zero or one InvPositions that matches the filter.
     * @param {invPositionsFindUniqueArgs} args - Arguments to find a InvPositions
     * @example
     * // Get one InvPositions
     * const invPositions = await prisma.invPositions.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends invPositionsFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, invPositionsFindUniqueArgs<ExtArgs>>
    ): Prisma__invPositionsClient<$Result.GetResult<Prisma.$invPositionsPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one InvPositions that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {invPositionsFindUniqueOrThrowArgs} args - Arguments to find a InvPositions
     * @example
     * // Get one InvPositions
     * const invPositions = await prisma.invPositions.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends invPositionsFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, invPositionsFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__invPositionsClient<$Result.GetResult<Prisma.$invPositionsPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first InvPositions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {invPositionsFindFirstArgs} args - Arguments to find a InvPositions
     * @example
     * // Get one InvPositions
     * const invPositions = await prisma.invPositions.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends invPositionsFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, invPositionsFindFirstArgs<ExtArgs>>
    ): Prisma__invPositionsClient<$Result.GetResult<Prisma.$invPositionsPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first InvPositions that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {invPositionsFindFirstOrThrowArgs} args - Arguments to find a InvPositions
     * @example
     * // Get one InvPositions
     * const invPositions = await prisma.invPositions.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends invPositionsFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, invPositionsFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__invPositionsClient<$Result.GetResult<Prisma.$invPositionsPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more InvPositions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {invPositionsFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all InvPositions
     * const invPositions = await prisma.invPositions.findMany()
     * 
     * // Get first 10 InvPositions
     * const invPositions = await prisma.invPositions.findMany({ take: 10 })
     * 
     * // Only select the `itemID`
     * const invPositionsWithItemIDOnly = await prisma.invPositions.findMany({ select: { itemID: true } })
     * 
    **/
    findMany<T extends invPositionsFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, invPositionsFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$invPositionsPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a InvPositions.
     * @param {invPositionsCreateArgs} args - Arguments to create a InvPositions.
     * @example
     * // Create one InvPositions
     * const InvPositions = await prisma.invPositions.create({
     *   data: {
     *     // ... data to create a InvPositions
     *   }
     * })
     * 
    **/
    create<T extends invPositionsCreateArgs<ExtArgs>>(
      args: SelectSubset<T, invPositionsCreateArgs<ExtArgs>>
    ): Prisma__invPositionsClient<$Result.GetResult<Prisma.$invPositionsPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many InvPositions.
     *     @param {invPositionsCreateManyArgs} args - Arguments to create many InvPositions.
     *     @example
     *     // Create many InvPositions
     *     const invPositions = await prisma.invPositions.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends invPositionsCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, invPositionsCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a InvPositions.
     * @param {invPositionsDeleteArgs} args - Arguments to delete one InvPositions.
     * @example
     * // Delete one InvPositions
     * const InvPositions = await prisma.invPositions.delete({
     *   where: {
     *     // ... filter to delete one InvPositions
     *   }
     * })
     * 
    **/
    delete<T extends invPositionsDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, invPositionsDeleteArgs<ExtArgs>>
    ): Prisma__invPositionsClient<$Result.GetResult<Prisma.$invPositionsPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one InvPositions.
     * @param {invPositionsUpdateArgs} args - Arguments to update one InvPositions.
     * @example
     * // Update one InvPositions
     * const invPositions = await prisma.invPositions.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends invPositionsUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, invPositionsUpdateArgs<ExtArgs>>
    ): Prisma__invPositionsClient<$Result.GetResult<Prisma.$invPositionsPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more InvPositions.
     * @param {invPositionsDeleteManyArgs} args - Arguments to filter InvPositions to delete.
     * @example
     * // Delete a few InvPositions
     * const { count } = await prisma.invPositions.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends invPositionsDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, invPositionsDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more InvPositions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {invPositionsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many InvPositions
     * const invPositions = await prisma.invPositions.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends invPositionsUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, invPositionsUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one InvPositions.
     * @param {invPositionsUpsertArgs} args - Arguments to update or create a InvPositions.
     * @example
     * // Update or create a InvPositions
     * const invPositions = await prisma.invPositions.upsert({
     *   create: {
     *     // ... data to create a InvPositions
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the InvPositions we want to update
     *   }
     * })
    **/
    upsert<T extends invPositionsUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, invPositionsUpsertArgs<ExtArgs>>
    ): Prisma__invPositionsClient<$Result.GetResult<Prisma.$invPositionsPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of InvPositions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {invPositionsCountArgs} args - Arguments to filter InvPositions to count.
     * @example
     * // Count the number of InvPositions
     * const count = await prisma.invPositions.count({
     *   where: {
     *     // ... the filter for the InvPositions we want to count
     *   }
     * })
    **/
    count<T extends invPositionsCountArgs>(
      args?: Subset<T, invPositionsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], InvPositionsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a InvPositions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvPositionsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends InvPositionsAggregateArgs>(args: Subset<T, InvPositionsAggregateArgs>): Prisma.PrismaPromise<GetInvPositionsAggregateType<T>>

    /**
     * Group by InvPositions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {invPositionsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends invPositionsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: invPositionsGroupByArgs['orderBy'] }
        : { orderBy?: invPositionsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, invPositionsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInvPositionsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the invPositions model
   */
  readonly fields: invPositionsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for invPositions.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__invPositionsClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';


    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the invPositions model
   */ 
  interface invPositionsFieldRefs {
    readonly itemID: FieldRef<"invPositions", 'Int'>
    readonly x: FieldRef<"invPositions", 'Float'>
    readonly y: FieldRef<"invPositions", 'Float'>
    readonly z: FieldRef<"invPositions", 'Float'>
    readonly yaw: FieldRef<"invPositions", 'Float'>
    readonly pitch: FieldRef<"invPositions", 'Float'>
    readonly roll: FieldRef<"invPositions", 'Float'>
  }
    

  // Custom InputTypes

  /**
   * invPositions findUnique
   */
  export type invPositionsFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the invPositions
     */
    select?: invPositionsSelect<ExtArgs> | null
    /**
     * Filter, which invPositions to fetch.
     */
    where: invPositionsWhereUniqueInput
  }


  /**
   * invPositions findUniqueOrThrow
   */
  export type invPositionsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the invPositions
     */
    select?: invPositionsSelect<ExtArgs> | null
    /**
     * Filter, which invPositions to fetch.
     */
    where: invPositionsWhereUniqueInput
  }


  /**
   * invPositions findFirst
   */
  export type invPositionsFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the invPositions
     */
    select?: invPositionsSelect<ExtArgs> | null
    /**
     * Filter, which invPositions to fetch.
     */
    where?: invPositionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of invPositions to fetch.
     */
    orderBy?: invPositionsOrderByWithRelationInput | invPositionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for invPositions.
     */
    cursor?: invPositionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` invPositions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` invPositions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of invPositions.
     */
    distinct?: InvPositionsScalarFieldEnum | InvPositionsScalarFieldEnum[]
  }


  /**
   * invPositions findFirstOrThrow
   */
  export type invPositionsFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the invPositions
     */
    select?: invPositionsSelect<ExtArgs> | null
    /**
     * Filter, which invPositions to fetch.
     */
    where?: invPositionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of invPositions to fetch.
     */
    orderBy?: invPositionsOrderByWithRelationInput | invPositionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for invPositions.
     */
    cursor?: invPositionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` invPositions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` invPositions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of invPositions.
     */
    distinct?: InvPositionsScalarFieldEnum | InvPositionsScalarFieldEnum[]
  }


  /**
   * invPositions findMany
   */
  export type invPositionsFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the invPositions
     */
    select?: invPositionsSelect<ExtArgs> | null
    /**
     * Filter, which invPositions to fetch.
     */
    where?: invPositionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of invPositions to fetch.
     */
    orderBy?: invPositionsOrderByWithRelationInput | invPositionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing invPositions.
     */
    cursor?: invPositionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` invPositions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` invPositions.
     */
    skip?: number
    distinct?: InvPositionsScalarFieldEnum | InvPositionsScalarFieldEnum[]
  }


  /**
   * invPositions create
   */
  export type invPositionsCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the invPositions
     */
    select?: invPositionsSelect<ExtArgs> | null
    /**
     * The data needed to create a invPositions.
     */
    data: XOR<invPositionsCreateInput, invPositionsUncheckedCreateInput>
  }


  /**
   * invPositions createMany
   */
  export type invPositionsCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many invPositions.
     */
    data: invPositionsCreateManyInput | invPositionsCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * invPositions update
   */
  export type invPositionsUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the invPositions
     */
    select?: invPositionsSelect<ExtArgs> | null
    /**
     * The data needed to update a invPositions.
     */
    data: XOR<invPositionsUpdateInput, invPositionsUncheckedUpdateInput>
    /**
     * Choose, which invPositions to update.
     */
    where: invPositionsWhereUniqueInput
  }


  /**
   * invPositions updateMany
   */
  export type invPositionsUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update invPositions.
     */
    data: XOR<invPositionsUpdateManyMutationInput, invPositionsUncheckedUpdateManyInput>
    /**
     * Filter which invPositions to update
     */
    where?: invPositionsWhereInput
  }


  /**
   * invPositions upsert
   */
  export type invPositionsUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the invPositions
     */
    select?: invPositionsSelect<ExtArgs> | null
    /**
     * The filter to search for the invPositions to update in case it exists.
     */
    where: invPositionsWhereUniqueInput
    /**
     * In case the invPositions found by the `where` argument doesn't exist, create a new invPositions with this data.
     */
    create: XOR<invPositionsCreateInput, invPositionsUncheckedCreateInput>
    /**
     * In case the invPositions was found with the provided `where` argument, update it with this data.
     */
    update: XOR<invPositionsUpdateInput, invPositionsUncheckedUpdateInput>
  }


  /**
   * invPositions delete
   */
  export type invPositionsDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the invPositions
     */
    select?: invPositionsSelect<ExtArgs> | null
    /**
     * Filter which invPositions to delete.
     */
    where: invPositionsWhereUniqueInput
  }


  /**
   * invPositions deleteMany
   */
  export type invPositionsDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which invPositions to delete
     */
    where?: invPositionsWhereInput
  }


  /**
   * invPositions without action
   */
  export type invPositionsDefaultArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the invPositions
     */
    select?: invPositionsSelect<ExtArgs> | null
  }



  /**
   * Model invTraits
   */

  export type AggregateInvTraits = {
    _count: InvTraitsCountAggregateOutputType | null
    _avg: InvTraitsAvgAggregateOutputType | null
    _sum: InvTraitsSumAggregateOutputType | null
    _min: InvTraitsMinAggregateOutputType | null
    _max: InvTraitsMaxAggregateOutputType | null
  }

  export type InvTraitsAvgAggregateOutputType = {
    traitID: number | null
    typeID: number | null
    skillID: number | null
    bonus: number | null
    unitID: number | null
  }

  export type InvTraitsSumAggregateOutputType = {
    traitID: number | null
    typeID: number | null
    skillID: number | null
    bonus: number | null
    unitID: number | null
  }

  export type InvTraitsMinAggregateOutputType = {
    traitID: number | null
    typeID: number | null
    skillID: number | null
    bonus: number | null
    bonusText: string | null
    unitID: number | null
  }

  export type InvTraitsMaxAggregateOutputType = {
    traitID: number | null
    typeID: number | null
    skillID: number | null
    bonus: number | null
    bonusText: string | null
    unitID: number | null
  }

  export type InvTraitsCountAggregateOutputType = {
    traitID: number
    typeID: number
    skillID: number
    bonus: number
    bonusText: number
    unitID: number
    _all: number
  }


  export type InvTraitsAvgAggregateInputType = {
    traitID?: true
    typeID?: true
    skillID?: true
    bonus?: true
    unitID?: true
  }

  export type InvTraitsSumAggregateInputType = {
    traitID?: true
    typeID?: true
    skillID?: true
    bonus?: true
    unitID?: true
  }

  export type InvTraitsMinAggregateInputType = {
    traitID?: true
    typeID?: true
    skillID?: true
    bonus?: true
    bonusText?: true
    unitID?: true
  }

  export type InvTraitsMaxAggregateInputType = {
    traitID?: true
    typeID?: true
    skillID?: true
    bonus?: true
    bonusText?: true
    unitID?: true
  }

  export type InvTraitsCountAggregateInputType = {
    traitID?: true
    typeID?: true
    skillID?: true
    bonus?: true
    bonusText?: true
    unitID?: true
    _all?: true
  }

  export type InvTraitsAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which invTraits to aggregate.
     */
    where?: invTraitsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of invTraits to fetch.
     */
    orderBy?: invTraitsOrderByWithRelationInput | invTraitsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: invTraitsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` invTraits from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` invTraits.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned invTraits
    **/
    _count?: true | InvTraitsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: InvTraitsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: InvTraitsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: InvTraitsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: InvTraitsMaxAggregateInputType
  }

  export type GetInvTraitsAggregateType<T extends InvTraitsAggregateArgs> = {
        [P in keyof T & keyof AggregateInvTraits]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInvTraits[P]>
      : GetScalarType<T[P], AggregateInvTraits[P]>
  }




  export type invTraitsGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: invTraitsWhereInput
    orderBy?: invTraitsOrderByWithAggregationInput | invTraitsOrderByWithAggregationInput[]
    by: InvTraitsScalarFieldEnum[] | InvTraitsScalarFieldEnum
    having?: invTraitsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: InvTraitsCountAggregateInputType | true
    _avg?: InvTraitsAvgAggregateInputType
    _sum?: InvTraitsSumAggregateInputType
    _min?: InvTraitsMinAggregateInputType
    _max?: InvTraitsMaxAggregateInputType
  }

  export type InvTraitsGroupByOutputType = {
    traitID: number
    typeID: number | null
    skillID: number | null
    bonus: number | null
    bonusText: string | null
    unitID: number | null
    _count: InvTraitsCountAggregateOutputType | null
    _avg: InvTraitsAvgAggregateOutputType | null
    _sum: InvTraitsSumAggregateOutputType | null
    _min: InvTraitsMinAggregateOutputType | null
    _max: InvTraitsMaxAggregateOutputType | null
  }

  type GetInvTraitsGroupByPayload<T extends invTraitsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<InvTraitsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof InvTraitsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], InvTraitsGroupByOutputType[P]>
            : GetScalarType<T[P], InvTraitsGroupByOutputType[P]>
        }
      >
    >


  export type invTraitsSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    traitID?: boolean
    typeID?: boolean
    skillID?: boolean
    bonus?: boolean
    bonusText?: boolean
    unitID?: boolean
  }, ExtArgs["result"]["invTraits"]>

  export type invTraitsSelectScalar = {
    traitID?: boolean
    typeID?: boolean
    skillID?: boolean
    bonus?: boolean
    bonusText?: boolean
    unitID?: boolean
  }


  export type $invTraitsPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    name: "invTraits"
    objects: {}
    scalars: $Extensions.GetResult<{
      traitID: number
      typeID: number | null
      skillID: number | null
      bonus: number | null
      bonusText: string | null
      unitID: number | null
    }, ExtArgs["result"]["invTraits"]>
    composites: {}
  }


  type invTraitsGetPayload<S extends boolean | null | undefined | invTraitsDefaultArgs> = $Result.GetResult<Prisma.$invTraitsPayload, S>

  type invTraitsCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<invTraitsFindManyArgs, 'select' | 'include'> & {
      select?: InvTraitsCountAggregateInputType | true
    }

  export interface invTraitsDelegate<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['invTraits'], meta: { name: 'invTraits' } }
    /**
     * Find zero or one InvTraits that matches the filter.
     * @param {invTraitsFindUniqueArgs} args - Arguments to find a InvTraits
     * @example
     * // Get one InvTraits
     * const invTraits = await prisma.invTraits.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends invTraitsFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, invTraitsFindUniqueArgs<ExtArgs>>
    ): Prisma__invTraitsClient<$Result.GetResult<Prisma.$invTraitsPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one InvTraits that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {invTraitsFindUniqueOrThrowArgs} args - Arguments to find a InvTraits
     * @example
     * // Get one InvTraits
     * const invTraits = await prisma.invTraits.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends invTraitsFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, invTraitsFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__invTraitsClient<$Result.GetResult<Prisma.$invTraitsPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first InvTraits that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {invTraitsFindFirstArgs} args - Arguments to find a InvTraits
     * @example
     * // Get one InvTraits
     * const invTraits = await prisma.invTraits.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends invTraitsFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, invTraitsFindFirstArgs<ExtArgs>>
    ): Prisma__invTraitsClient<$Result.GetResult<Prisma.$invTraitsPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first InvTraits that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {invTraitsFindFirstOrThrowArgs} args - Arguments to find a InvTraits
     * @example
     * // Get one InvTraits
     * const invTraits = await prisma.invTraits.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends invTraitsFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, invTraitsFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__invTraitsClient<$Result.GetResult<Prisma.$invTraitsPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more InvTraits that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {invTraitsFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all InvTraits
     * const invTraits = await prisma.invTraits.findMany()
     * 
     * // Get first 10 InvTraits
     * const invTraits = await prisma.invTraits.findMany({ take: 10 })
     * 
     * // Only select the `traitID`
     * const invTraitsWithTraitIDOnly = await prisma.invTraits.findMany({ select: { traitID: true } })
     * 
    **/
    findMany<T extends invTraitsFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, invTraitsFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$invTraitsPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a InvTraits.
     * @param {invTraitsCreateArgs} args - Arguments to create a InvTraits.
     * @example
     * // Create one InvTraits
     * const InvTraits = await prisma.invTraits.create({
     *   data: {
     *     // ... data to create a InvTraits
     *   }
     * })
     * 
    **/
    create<T extends invTraitsCreateArgs<ExtArgs>>(
      args: SelectSubset<T, invTraitsCreateArgs<ExtArgs>>
    ): Prisma__invTraitsClient<$Result.GetResult<Prisma.$invTraitsPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many InvTraits.
     *     @param {invTraitsCreateManyArgs} args - Arguments to create many InvTraits.
     *     @example
     *     // Create many InvTraits
     *     const invTraits = await prisma.invTraits.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends invTraitsCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, invTraitsCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a InvTraits.
     * @param {invTraitsDeleteArgs} args - Arguments to delete one InvTraits.
     * @example
     * // Delete one InvTraits
     * const InvTraits = await prisma.invTraits.delete({
     *   where: {
     *     // ... filter to delete one InvTraits
     *   }
     * })
     * 
    **/
    delete<T extends invTraitsDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, invTraitsDeleteArgs<ExtArgs>>
    ): Prisma__invTraitsClient<$Result.GetResult<Prisma.$invTraitsPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one InvTraits.
     * @param {invTraitsUpdateArgs} args - Arguments to update one InvTraits.
     * @example
     * // Update one InvTraits
     * const invTraits = await prisma.invTraits.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends invTraitsUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, invTraitsUpdateArgs<ExtArgs>>
    ): Prisma__invTraitsClient<$Result.GetResult<Prisma.$invTraitsPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more InvTraits.
     * @param {invTraitsDeleteManyArgs} args - Arguments to filter InvTraits to delete.
     * @example
     * // Delete a few InvTraits
     * const { count } = await prisma.invTraits.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends invTraitsDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, invTraitsDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more InvTraits.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {invTraitsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many InvTraits
     * const invTraits = await prisma.invTraits.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends invTraitsUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, invTraitsUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one InvTraits.
     * @param {invTraitsUpsertArgs} args - Arguments to update or create a InvTraits.
     * @example
     * // Update or create a InvTraits
     * const invTraits = await prisma.invTraits.upsert({
     *   create: {
     *     // ... data to create a InvTraits
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the InvTraits we want to update
     *   }
     * })
    **/
    upsert<T extends invTraitsUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, invTraitsUpsertArgs<ExtArgs>>
    ): Prisma__invTraitsClient<$Result.GetResult<Prisma.$invTraitsPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of InvTraits.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {invTraitsCountArgs} args - Arguments to filter InvTraits to count.
     * @example
     * // Count the number of InvTraits
     * const count = await prisma.invTraits.count({
     *   where: {
     *     // ... the filter for the InvTraits we want to count
     *   }
     * })
    **/
    count<T extends invTraitsCountArgs>(
      args?: Subset<T, invTraitsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], InvTraitsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a InvTraits.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvTraitsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends InvTraitsAggregateArgs>(args: Subset<T, InvTraitsAggregateArgs>): Prisma.PrismaPromise<GetInvTraitsAggregateType<T>>

    /**
     * Group by InvTraits.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {invTraitsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends invTraitsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: invTraitsGroupByArgs['orderBy'] }
        : { orderBy?: invTraitsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, invTraitsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInvTraitsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the invTraits model
   */
  readonly fields: invTraitsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for invTraits.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__invTraitsClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';


    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the invTraits model
   */ 
  interface invTraitsFieldRefs {
    readonly traitID: FieldRef<"invTraits", 'Int'>
    readonly typeID: FieldRef<"invTraits", 'Int'>
    readonly skillID: FieldRef<"invTraits", 'Int'>
    readonly bonus: FieldRef<"invTraits", 'Float'>
    readonly bonusText: FieldRef<"invTraits", 'String'>
    readonly unitID: FieldRef<"invTraits", 'Int'>
  }
    

  // Custom InputTypes

  /**
   * invTraits findUnique
   */
  export type invTraitsFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the invTraits
     */
    select?: invTraitsSelect<ExtArgs> | null
    /**
     * Filter, which invTraits to fetch.
     */
    where: invTraitsWhereUniqueInput
  }


  /**
   * invTraits findUniqueOrThrow
   */
  export type invTraitsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the invTraits
     */
    select?: invTraitsSelect<ExtArgs> | null
    /**
     * Filter, which invTraits to fetch.
     */
    where: invTraitsWhereUniqueInput
  }


  /**
   * invTraits findFirst
   */
  export type invTraitsFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the invTraits
     */
    select?: invTraitsSelect<ExtArgs> | null
    /**
     * Filter, which invTraits to fetch.
     */
    where?: invTraitsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of invTraits to fetch.
     */
    orderBy?: invTraitsOrderByWithRelationInput | invTraitsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for invTraits.
     */
    cursor?: invTraitsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` invTraits from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` invTraits.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of invTraits.
     */
    distinct?: InvTraitsScalarFieldEnum | InvTraitsScalarFieldEnum[]
  }


  /**
   * invTraits findFirstOrThrow
   */
  export type invTraitsFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the invTraits
     */
    select?: invTraitsSelect<ExtArgs> | null
    /**
     * Filter, which invTraits to fetch.
     */
    where?: invTraitsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of invTraits to fetch.
     */
    orderBy?: invTraitsOrderByWithRelationInput | invTraitsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for invTraits.
     */
    cursor?: invTraitsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` invTraits from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` invTraits.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of invTraits.
     */
    distinct?: InvTraitsScalarFieldEnum | InvTraitsScalarFieldEnum[]
  }


  /**
   * invTraits findMany
   */
  export type invTraitsFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the invTraits
     */
    select?: invTraitsSelect<ExtArgs> | null
    /**
     * Filter, which invTraits to fetch.
     */
    where?: invTraitsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of invTraits to fetch.
     */
    orderBy?: invTraitsOrderByWithRelationInput | invTraitsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing invTraits.
     */
    cursor?: invTraitsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` invTraits from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` invTraits.
     */
    skip?: number
    distinct?: InvTraitsScalarFieldEnum | InvTraitsScalarFieldEnum[]
  }


  /**
   * invTraits create
   */
  export type invTraitsCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the invTraits
     */
    select?: invTraitsSelect<ExtArgs> | null
    /**
     * The data needed to create a invTraits.
     */
    data?: XOR<invTraitsCreateInput, invTraitsUncheckedCreateInput>
  }


  /**
   * invTraits createMany
   */
  export type invTraitsCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many invTraits.
     */
    data: invTraitsCreateManyInput | invTraitsCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * invTraits update
   */
  export type invTraitsUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the invTraits
     */
    select?: invTraitsSelect<ExtArgs> | null
    /**
     * The data needed to update a invTraits.
     */
    data: XOR<invTraitsUpdateInput, invTraitsUncheckedUpdateInput>
    /**
     * Choose, which invTraits to update.
     */
    where: invTraitsWhereUniqueInput
  }


  /**
   * invTraits updateMany
   */
  export type invTraitsUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update invTraits.
     */
    data: XOR<invTraitsUpdateManyMutationInput, invTraitsUncheckedUpdateManyInput>
    /**
     * Filter which invTraits to update
     */
    where?: invTraitsWhereInput
  }


  /**
   * invTraits upsert
   */
  export type invTraitsUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the invTraits
     */
    select?: invTraitsSelect<ExtArgs> | null
    /**
     * The filter to search for the invTraits to update in case it exists.
     */
    where: invTraitsWhereUniqueInput
    /**
     * In case the invTraits found by the `where` argument doesn't exist, create a new invTraits with this data.
     */
    create: XOR<invTraitsCreateInput, invTraitsUncheckedCreateInput>
    /**
     * In case the invTraits was found with the provided `where` argument, update it with this data.
     */
    update: XOR<invTraitsUpdateInput, invTraitsUncheckedUpdateInput>
  }


  /**
   * invTraits delete
   */
  export type invTraitsDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the invTraits
     */
    select?: invTraitsSelect<ExtArgs> | null
    /**
     * Filter which invTraits to delete.
     */
    where: invTraitsWhereUniqueInput
  }


  /**
   * invTraits deleteMany
   */
  export type invTraitsDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which invTraits to delete
     */
    where?: invTraitsWhereInput
  }


  /**
   * invTraits without action
   */
  export type invTraitsDefaultArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the invTraits
     */
    select?: invTraitsSelect<ExtArgs> | null
  }



  /**
   * Model invTypeMaterials
   */

  export type AggregateInvTypeMaterials = {
    _count: InvTypeMaterialsCountAggregateOutputType | null
    _avg: InvTypeMaterialsAvgAggregateOutputType | null
    _sum: InvTypeMaterialsSumAggregateOutputType | null
    _min: InvTypeMaterialsMinAggregateOutputType | null
    _max: InvTypeMaterialsMaxAggregateOutputType | null
  }

  export type InvTypeMaterialsAvgAggregateOutputType = {
    typeID: number | null
    materialTypeID: number | null
    quantity: number | null
  }

  export type InvTypeMaterialsSumAggregateOutputType = {
    typeID: number | null
    materialTypeID: number | null
    quantity: number | null
  }

  export type InvTypeMaterialsMinAggregateOutputType = {
    typeID: number | null
    materialTypeID: number | null
    quantity: number | null
  }

  export type InvTypeMaterialsMaxAggregateOutputType = {
    typeID: number | null
    materialTypeID: number | null
    quantity: number | null
  }

  export type InvTypeMaterialsCountAggregateOutputType = {
    typeID: number
    materialTypeID: number
    quantity: number
    _all: number
  }


  export type InvTypeMaterialsAvgAggregateInputType = {
    typeID?: true
    materialTypeID?: true
    quantity?: true
  }

  export type InvTypeMaterialsSumAggregateInputType = {
    typeID?: true
    materialTypeID?: true
    quantity?: true
  }

  export type InvTypeMaterialsMinAggregateInputType = {
    typeID?: true
    materialTypeID?: true
    quantity?: true
  }

  export type InvTypeMaterialsMaxAggregateInputType = {
    typeID?: true
    materialTypeID?: true
    quantity?: true
  }

  export type InvTypeMaterialsCountAggregateInputType = {
    typeID?: true
    materialTypeID?: true
    quantity?: true
    _all?: true
  }

  export type InvTypeMaterialsAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which invTypeMaterials to aggregate.
     */
    where?: invTypeMaterialsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of invTypeMaterials to fetch.
     */
    orderBy?: invTypeMaterialsOrderByWithRelationInput | invTypeMaterialsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: invTypeMaterialsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` invTypeMaterials from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` invTypeMaterials.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned invTypeMaterials
    **/
    _count?: true | InvTypeMaterialsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: InvTypeMaterialsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: InvTypeMaterialsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: InvTypeMaterialsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: InvTypeMaterialsMaxAggregateInputType
  }

  export type GetInvTypeMaterialsAggregateType<T extends InvTypeMaterialsAggregateArgs> = {
        [P in keyof T & keyof AggregateInvTypeMaterials]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInvTypeMaterials[P]>
      : GetScalarType<T[P], AggregateInvTypeMaterials[P]>
  }




  export type invTypeMaterialsGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: invTypeMaterialsWhereInput
    orderBy?: invTypeMaterialsOrderByWithAggregationInput | invTypeMaterialsOrderByWithAggregationInput[]
    by: InvTypeMaterialsScalarFieldEnum[] | InvTypeMaterialsScalarFieldEnum
    having?: invTypeMaterialsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: InvTypeMaterialsCountAggregateInputType | true
    _avg?: InvTypeMaterialsAvgAggregateInputType
    _sum?: InvTypeMaterialsSumAggregateInputType
    _min?: InvTypeMaterialsMinAggregateInputType
    _max?: InvTypeMaterialsMaxAggregateInputType
  }

  export type InvTypeMaterialsGroupByOutputType = {
    typeID: number
    materialTypeID: number
    quantity: number
    _count: InvTypeMaterialsCountAggregateOutputType | null
    _avg: InvTypeMaterialsAvgAggregateOutputType | null
    _sum: InvTypeMaterialsSumAggregateOutputType | null
    _min: InvTypeMaterialsMinAggregateOutputType | null
    _max: InvTypeMaterialsMaxAggregateOutputType | null
  }

  type GetInvTypeMaterialsGroupByPayload<T extends invTypeMaterialsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<InvTypeMaterialsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof InvTypeMaterialsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], InvTypeMaterialsGroupByOutputType[P]>
            : GetScalarType<T[P], InvTypeMaterialsGroupByOutputType[P]>
        }
      >
    >


  export type invTypeMaterialsSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    typeID?: boolean
    materialTypeID?: boolean
    quantity?: boolean
  }, ExtArgs["result"]["invTypeMaterials"]>

  export type invTypeMaterialsSelectScalar = {
    typeID?: boolean
    materialTypeID?: boolean
    quantity?: boolean
  }


  export type $invTypeMaterialsPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    name: "invTypeMaterials"
    objects: {}
    scalars: $Extensions.GetResult<{
      typeID: number
      materialTypeID: number
      quantity: number
    }, ExtArgs["result"]["invTypeMaterials"]>
    composites: {}
  }


  type invTypeMaterialsGetPayload<S extends boolean | null | undefined | invTypeMaterialsDefaultArgs> = $Result.GetResult<Prisma.$invTypeMaterialsPayload, S>

  type invTypeMaterialsCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<invTypeMaterialsFindManyArgs, 'select' | 'include'> & {
      select?: InvTypeMaterialsCountAggregateInputType | true
    }

  export interface invTypeMaterialsDelegate<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['invTypeMaterials'], meta: { name: 'invTypeMaterials' } }
    /**
     * Find zero or one InvTypeMaterials that matches the filter.
     * @param {invTypeMaterialsFindUniqueArgs} args - Arguments to find a InvTypeMaterials
     * @example
     * // Get one InvTypeMaterials
     * const invTypeMaterials = await prisma.invTypeMaterials.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends invTypeMaterialsFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, invTypeMaterialsFindUniqueArgs<ExtArgs>>
    ): Prisma__invTypeMaterialsClient<$Result.GetResult<Prisma.$invTypeMaterialsPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one InvTypeMaterials that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {invTypeMaterialsFindUniqueOrThrowArgs} args - Arguments to find a InvTypeMaterials
     * @example
     * // Get one InvTypeMaterials
     * const invTypeMaterials = await prisma.invTypeMaterials.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends invTypeMaterialsFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, invTypeMaterialsFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__invTypeMaterialsClient<$Result.GetResult<Prisma.$invTypeMaterialsPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first InvTypeMaterials that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {invTypeMaterialsFindFirstArgs} args - Arguments to find a InvTypeMaterials
     * @example
     * // Get one InvTypeMaterials
     * const invTypeMaterials = await prisma.invTypeMaterials.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends invTypeMaterialsFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, invTypeMaterialsFindFirstArgs<ExtArgs>>
    ): Prisma__invTypeMaterialsClient<$Result.GetResult<Prisma.$invTypeMaterialsPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first InvTypeMaterials that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {invTypeMaterialsFindFirstOrThrowArgs} args - Arguments to find a InvTypeMaterials
     * @example
     * // Get one InvTypeMaterials
     * const invTypeMaterials = await prisma.invTypeMaterials.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends invTypeMaterialsFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, invTypeMaterialsFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__invTypeMaterialsClient<$Result.GetResult<Prisma.$invTypeMaterialsPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more InvTypeMaterials that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {invTypeMaterialsFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all InvTypeMaterials
     * const invTypeMaterials = await prisma.invTypeMaterials.findMany()
     * 
     * // Get first 10 InvTypeMaterials
     * const invTypeMaterials = await prisma.invTypeMaterials.findMany({ take: 10 })
     * 
     * // Only select the `typeID`
     * const invTypeMaterialsWithTypeIDOnly = await prisma.invTypeMaterials.findMany({ select: { typeID: true } })
     * 
    **/
    findMany<T extends invTypeMaterialsFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, invTypeMaterialsFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$invTypeMaterialsPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a InvTypeMaterials.
     * @param {invTypeMaterialsCreateArgs} args - Arguments to create a InvTypeMaterials.
     * @example
     * // Create one InvTypeMaterials
     * const InvTypeMaterials = await prisma.invTypeMaterials.create({
     *   data: {
     *     // ... data to create a InvTypeMaterials
     *   }
     * })
     * 
    **/
    create<T extends invTypeMaterialsCreateArgs<ExtArgs>>(
      args: SelectSubset<T, invTypeMaterialsCreateArgs<ExtArgs>>
    ): Prisma__invTypeMaterialsClient<$Result.GetResult<Prisma.$invTypeMaterialsPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many InvTypeMaterials.
     *     @param {invTypeMaterialsCreateManyArgs} args - Arguments to create many InvTypeMaterials.
     *     @example
     *     // Create many InvTypeMaterials
     *     const invTypeMaterials = await prisma.invTypeMaterials.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends invTypeMaterialsCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, invTypeMaterialsCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a InvTypeMaterials.
     * @param {invTypeMaterialsDeleteArgs} args - Arguments to delete one InvTypeMaterials.
     * @example
     * // Delete one InvTypeMaterials
     * const InvTypeMaterials = await prisma.invTypeMaterials.delete({
     *   where: {
     *     // ... filter to delete one InvTypeMaterials
     *   }
     * })
     * 
    **/
    delete<T extends invTypeMaterialsDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, invTypeMaterialsDeleteArgs<ExtArgs>>
    ): Prisma__invTypeMaterialsClient<$Result.GetResult<Prisma.$invTypeMaterialsPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one InvTypeMaterials.
     * @param {invTypeMaterialsUpdateArgs} args - Arguments to update one InvTypeMaterials.
     * @example
     * // Update one InvTypeMaterials
     * const invTypeMaterials = await prisma.invTypeMaterials.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends invTypeMaterialsUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, invTypeMaterialsUpdateArgs<ExtArgs>>
    ): Prisma__invTypeMaterialsClient<$Result.GetResult<Prisma.$invTypeMaterialsPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more InvTypeMaterials.
     * @param {invTypeMaterialsDeleteManyArgs} args - Arguments to filter InvTypeMaterials to delete.
     * @example
     * // Delete a few InvTypeMaterials
     * const { count } = await prisma.invTypeMaterials.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends invTypeMaterialsDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, invTypeMaterialsDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more InvTypeMaterials.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {invTypeMaterialsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many InvTypeMaterials
     * const invTypeMaterials = await prisma.invTypeMaterials.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends invTypeMaterialsUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, invTypeMaterialsUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one InvTypeMaterials.
     * @param {invTypeMaterialsUpsertArgs} args - Arguments to update or create a InvTypeMaterials.
     * @example
     * // Update or create a InvTypeMaterials
     * const invTypeMaterials = await prisma.invTypeMaterials.upsert({
     *   create: {
     *     // ... data to create a InvTypeMaterials
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the InvTypeMaterials we want to update
     *   }
     * })
    **/
    upsert<T extends invTypeMaterialsUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, invTypeMaterialsUpsertArgs<ExtArgs>>
    ): Prisma__invTypeMaterialsClient<$Result.GetResult<Prisma.$invTypeMaterialsPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of InvTypeMaterials.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {invTypeMaterialsCountArgs} args - Arguments to filter InvTypeMaterials to count.
     * @example
     * // Count the number of InvTypeMaterials
     * const count = await prisma.invTypeMaterials.count({
     *   where: {
     *     // ... the filter for the InvTypeMaterials we want to count
     *   }
     * })
    **/
    count<T extends invTypeMaterialsCountArgs>(
      args?: Subset<T, invTypeMaterialsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], InvTypeMaterialsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a InvTypeMaterials.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvTypeMaterialsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends InvTypeMaterialsAggregateArgs>(args: Subset<T, InvTypeMaterialsAggregateArgs>): Prisma.PrismaPromise<GetInvTypeMaterialsAggregateType<T>>

    /**
     * Group by InvTypeMaterials.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {invTypeMaterialsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends invTypeMaterialsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: invTypeMaterialsGroupByArgs['orderBy'] }
        : { orderBy?: invTypeMaterialsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, invTypeMaterialsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInvTypeMaterialsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the invTypeMaterials model
   */
  readonly fields: invTypeMaterialsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for invTypeMaterials.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__invTypeMaterialsClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';


    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the invTypeMaterials model
   */ 
  interface invTypeMaterialsFieldRefs {
    readonly typeID: FieldRef<"invTypeMaterials", 'Int'>
    readonly materialTypeID: FieldRef<"invTypeMaterials", 'Int'>
    readonly quantity: FieldRef<"invTypeMaterials", 'Int'>
  }
    

  // Custom InputTypes

  /**
   * invTypeMaterials findUnique
   */
  export type invTypeMaterialsFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the invTypeMaterials
     */
    select?: invTypeMaterialsSelect<ExtArgs> | null
    /**
     * Filter, which invTypeMaterials to fetch.
     */
    where: invTypeMaterialsWhereUniqueInput
  }


  /**
   * invTypeMaterials findUniqueOrThrow
   */
  export type invTypeMaterialsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the invTypeMaterials
     */
    select?: invTypeMaterialsSelect<ExtArgs> | null
    /**
     * Filter, which invTypeMaterials to fetch.
     */
    where: invTypeMaterialsWhereUniqueInput
  }


  /**
   * invTypeMaterials findFirst
   */
  export type invTypeMaterialsFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the invTypeMaterials
     */
    select?: invTypeMaterialsSelect<ExtArgs> | null
    /**
     * Filter, which invTypeMaterials to fetch.
     */
    where?: invTypeMaterialsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of invTypeMaterials to fetch.
     */
    orderBy?: invTypeMaterialsOrderByWithRelationInput | invTypeMaterialsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for invTypeMaterials.
     */
    cursor?: invTypeMaterialsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` invTypeMaterials from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` invTypeMaterials.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of invTypeMaterials.
     */
    distinct?: InvTypeMaterialsScalarFieldEnum | InvTypeMaterialsScalarFieldEnum[]
  }


  /**
   * invTypeMaterials findFirstOrThrow
   */
  export type invTypeMaterialsFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the invTypeMaterials
     */
    select?: invTypeMaterialsSelect<ExtArgs> | null
    /**
     * Filter, which invTypeMaterials to fetch.
     */
    where?: invTypeMaterialsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of invTypeMaterials to fetch.
     */
    orderBy?: invTypeMaterialsOrderByWithRelationInput | invTypeMaterialsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for invTypeMaterials.
     */
    cursor?: invTypeMaterialsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` invTypeMaterials from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` invTypeMaterials.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of invTypeMaterials.
     */
    distinct?: InvTypeMaterialsScalarFieldEnum | InvTypeMaterialsScalarFieldEnum[]
  }


  /**
   * invTypeMaterials findMany
   */
  export type invTypeMaterialsFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the invTypeMaterials
     */
    select?: invTypeMaterialsSelect<ExtArgs> | null
    /**
     * Filter, which invTypeMaterials to fetch.
     */
    where?: invTypeMaterialsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of invTypeMaterials to fetch.
     */
    orderBy?: invTypeMaterialsOrderByWithRelationInput | invTypeMaterialsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing invTypeMaterials.
     */
    cursor?: invTypeMaterialsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` invTypeMaterials from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` invTypeMaterials.
     */
    skip?: number
    distinct?: InvTypeMaterialsScalarFieldEnum | InvTypeMaterialsScalarFieldEnum[]
  }


  /**
   * invTypeMaterials create
   */
  export type invTypeMaterialsCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the invTypeMaterials
     */
    select?: invTypeMaterialsSelect<ExtArgs> | null
    /**
     * The data needed to create a invTypeMaterials.
     */
    data: XOR<invTypeMaterialsCreateInput, invTypeMaterialsUncheckedCreateInput>
  }


  /**
   * invTypeMaterials createMany
   */
  export type invTypeMaterialsCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many invTypeMaterials.
     */
    data: invTypeMaterialsCreateManyInput | invTypeMaterialsCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * invTypeMaterials update
   */
  export type invTypeMaterialsUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the invTypeMaterials
     */
    select?: invTypeMaterialsSelect<ExtArgs> | null
    /**
     * The data needed to update a invTypeMaterials.
     */
    data: XOR<invTypeMaterialsUpdateInput, invTypeMaterialsUncheckedUpdateInput>
    /**
     * Choose, which invTypeMaterials to update.
     */
    where: invTypeMaterialsWhereUniqueInput
  }


  /**
   * invTypeMaterials updateMany
   */
  export type invTypeMaterialsUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update invTypeMaterials.
     */
    data: XOR<invTypeMaterialsUpdateManyMutationInput, invTypeMaterialsUncheckedUpdateManyInput>
    /**
     * Filter which invTypeMaterials to update
     */
    where?: invTypeMaterialsWhereInput
  }


  /**
   * invTypeMaterials upsert
   */
  export type invTypeMaterialsUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the invTypeMaterials
     */
    select?: invTypeMaterialsSelect<ExtArgs> | null
    /**
     * The filter to search for the invTypeMaterials to update in case it exists.
     */
    where: invTypeMaterialsWhereUniqueInput
    /**
     * In case the invTypeMaterials found by the `where` argument doesn't exist, create a new invTypeMaterials with this data.
     */
    create: XOR<invTypeMaterialsCreateInput, invTypeMaterialsUncheckedCreateInput>
    /**
     * In case the invTypeMaterials was found with the provided `where` argument, update it with this data.
     */
    update: XOR<invTypeMaterialsUpdateInput, invTypeMaterialsUncheckedUpdateInput>
  }


  /**
   * invTypeMaterials delete
   */
  export type invTypeMaterialsDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the invTypeMaterials
     */
    select?: invTypeMaterialsSelect<ExtArgs> | null
    /**
     * Filter which invTypeMaterials to delete.
     */
    where: invTypeMaterialsWhereUniqueInput
  }


  /**
   * invTypeMaterials deleteMany
   */
  export type invTypeMaterialsDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which invTypeMaterials to delete
     */
    where?: invTypeMaterialsWhereInput
  }


  /**
   * invTypeMaterials without action
   */
  export type invTypeMaterialsDefaultArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the invTypeMaterials
     */
    select?: invTypeMaterialsSelect<ExtArgs> | null
  }



  /**
   * Model invTypeReactions
   */

  export type AggregateInvTypeReactions = {
    _count: InvTypeReactionsCountAggregateOutputType | null
    _avg: InvTypeReactionsAvgAggregateOutputType | null
    _sum: InvTypeReactionsSumAggregateOutputType | null
    _min: InvTypeReactionsMinAggregateOutputType | null
    _max: InvTypeReactionsMaxAggregateOutputType | null
  }

  export type InvTypeReactionsAvgAggregateOutputType = {
    reactionTypeID: number | null
    typeID: number | null
    quantity: number | null
  }

  export type InvTypeReactionsSumAggregateOutputType = {
    reactionTypeID: number | null
    typeID: number | null
    quantity: number | null
  }

  export type InvTypeReactionsMinAggregateOutputType = {
    reactionTypeID: number | null
    input: boolean | null
    typeID: number | null
    quantity: number | null
  }

  export type InvTypeReactionsMaxAggregateOutputType = {
    reactionTypeID: number | null
    input: boolean | null
    typeID: number | null
    quantity: number | null
  }

  export type InvTypeReactionsCountAggregateOutputType = {
    reactionTypeID: number
    input: number
    typeID: number
    quantity: number
    _all: number
  }


  export type InvTypeReactionsAvgAggregateInputType = {
    reactionTypeID?: true
    typeID?: true
    quantity?: true
  }

  export type InvTypeReactionsSumAggregateInputType = {
    reactionTypeID?: true
    typeID?: true
    quantity?: true
  }

  export type InvTypeReactionsMinAggregateInputType = {
    reactionTypeID?: true
    input?: true
    typeID?: true
    quantity?: true
  }

  export type InvTypeReactionsMaxAggregateInputType = {
    reactionTypeID?: true
    input?: true
    typeID?: true
    quantity?: true
  }

  export type InvTypeReactionsCountAggregateInputType = {
    reactionTypeID?: true
    input?: true
    typeID?: true
    quantity?: true
    _all?: true
  }

  export type InvTypeReactionsAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which invTypeReactions to aggregate.
     */
    where?: invTypeReactionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of invTypeReactions to fetch.
     */
    orderBy?: invTypeReactionsOrderByWithRelationInput | invTypeReactionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: invTypeReactionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` invTypeReactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` invTypeReactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned invTypeReactions
    **/
    _count?: true | InvTypeReactionsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: InvTypeReactionsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: InvTypeReactionsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: InvTypeReactionsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: InvTypeReactionsMaxAggregateInputType
  }

  export type GetInvTypeReactionsAggregateType<T extends InvTypeReactionsAggregateArgs> = {
        [P in keyof T & keyof AggregateInvTypeReactions]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInvTypeReactions[P]>
      : GetScalarType<T[P], AggregateInvTypeReactions[P]>
  }




  export type invTypeReactionsGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: invTypeReactionsWhereInput
    orderBy?: invTypeReactionsOrderByWithAggregationInput | invTypeReactionsOrderByWithAggregationInput[]
    by: InvTypeReactionsScalarFieldEnum[] | InvTypeReactionsScalarFieldEnum
    having?: invTypeReactionsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: InvTypeReactionsCountAggregateInputType | true
    _avg?: InvTypeReactionsAvgAggregateInputType
    _sum?: InvTypeReactionsSumAggregateInputType
    _min?: InvTypeReactionsMinAggregateInputType
    _max?: InvTypeReactionsMaxAggregateInputType
  }

  export type InvTypeReactionsGroupByOutputType = {
    reactionTypeID: number
    input: boolean
    typeID: number
    quantity: number | null
    _count: InvTypeReactionsCountAggregateOutputType | null
    _avg: InvTypeReactionsAvgAggregateOutputType | null
    _sum: InvTypeReactionsSumAggregateOutputType | null
    _min: InvTypeReactionsMinAggregateOutputType | null
    _max: InvTypeReactionsMaxAggregateOutputType | null
  }

  type GetInvTypeReactionsGroupByPayload<T extends invTypeReactionsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<InvTypeReactionsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof InvTypeReactionsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], InvTypeReactionsGroupByOutputType[P]>
            : GetScalarType<T[P], InvTypeReactionsGroupByOutputType[P]>
        }
      >
    >


  export type invTypeReactionsSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    reactionTypeID?: boolean
    input?: boolean
    typeID?: boolean
    quantity?: boolean
  }, ExtArgs["result"]["invTypeReactions"]>

  export type invTypeReactionsSelectScalar = {
    reactionTypeID?: boolean
    input?: boolean
    typeID?: boolean
    quantity?: boolean
  }


  export type $invTypeReactionsPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    name: "invTypeReactions"
    objects: {}
    scalars: $Extensions.GetResult<{
      reactionTypeID: number
      input: boolean
      typeID: number
      quantity: number | null
    }, ExtArgs["result"]["invTypeReactions"]>
    composites: {}
  }


  type invTypeReactionsGetPayload<S extends boolean | null | undefined | invTypeReactionsDefaultArgs> = $Result.GetResult<Prisma.$invTypeReactionsPayload, S>

  type invTypeReactionsCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<invTypeReactionsFindManyArgs, 'select' | 'include'> & {
      select?: InvTypeReactionsCountAggregateInputType | true
    }

  export interface invTypeReactionsDelegate<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['invTypeReactions'], meta: { name: 'invTypeReactions' } }
    /**
     * Find zero or one InvTypeReactions that matches the filter.
     * @param {invTypeReactionsFindUniqueArgs} args - Arguments to find a InvTypeReactions
     * @example
     * // Get one InvTypeReactions
     * const invTypeReactions = await prisma.invTypeReactions.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends invTypeReactionsFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, invTypeReactionsFindUniqueArgs<ExtArgs>>
    ): Prisma__invTypeReactionsClient<$Result.GetResult<Prisma.$invTypeReactionsPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one InvTypeReactions that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {invTypeReactionsFindUniqueOrThrowArgs} args - Arguments to find a InvTypeReactions
     * @example
     * // Get one InvTypeReactions
     * const invTypeReactions = await prisma.invTypeReactions.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends invTypeReactionsFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, invTypeReactionsFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__invTypeReactionsClient<$Result.GetResult<Prisma.$invTypeReactionsPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first InvTypeReactions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {invTypeReactionsFindFirstArgs} args - Arguments to find a InvTypeReactions
     * @example
     * // Get one InvTypeReactions
     * const invTypeReactions = await prisma.invTypeReactions.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends invTypeReactionsFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, invTypeReactionsFindFirstArgs<ExtArgs>>
    ): Prisma__invTypeReactionsClient<$Result.GetResult<Prisma.$invTypeReactionsPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first InvTypeReactions that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {invTypeReactionsFindFirstOrThrowArgs} args - Arguments to find a InvTypeReactions
     * @example
     * // Get one InvTypeReactions
     * const invTypeReactions = await prisma.invTypeReactions.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends invTypeReactionsFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, invTypeReactionsFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__invTypeReactionsClient<$Result.GetResult<Prisma.$invTypeReactionsPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more InvTypeReactions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {invTypeReactionsFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all InvTypeReactions
     * const invTypeReactions = await prisma.invTypeReactions.findMany()
     * 
     * // Get first 10 InvTypeReactions
     * const invTypeReactions = await prisma.invTypeReactions.findMany({ take: 10 })
     * 
     * // Only select the `reactionTypeID`
     * const invTypeReactionsWithReactionTypeIDOnly = await prisma.invTypeReactions.findMany({ select: { reactionTypeID: true } })
     * 
    **/
    findMany<T extends invTypeReactionsFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, invTypeReactionsFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$invTypeReactionsPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a InvTypeReactions.
     * @param {invTypeReactionsCreateArgs} args - Arguments to create a InvTypeReactions.
     * @example
     * // Create one InvTypeReactions
     * const InvTypeReactions = await prisma.invTypeReactions.create({
     *   data: {
     *     // ... data to create a InvTypeReactions
     *   }
     * })
     * 
    **/
    create<T extends invTypeReactionsCreateArgs<ExtArgs>>(
      args: SelectSubset<T, invTypeReactionsCreateArgs<ExtArgs>>
    ): Prisma__invTypeReactionsClient<$Result.GetResult<Prisma.$invTypeReactionsPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many InvTypeReactions.
     *     @param {invTypeReactionsCreateManyArgs} args - Arguments to create many InvTypeReactions.
     *     @example
     *     // Create many InvTypeReactions
     *     const invTypeReactions = await prisma.invTypeReactions.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends invTypeReactionsCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, invTypeReactionsCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a InvTypeReactions.
     * @param {invTypeReactionsDeleteArgs} args - Arguments to delete one InvTypeReactions.
     * @example
     * // Delete one InvTypeReactions
     * const InvTypeReactions = await prisma.invTypeReactions.delete({
     *   where: {
     *     // ... filter to delete one InvTypeReactions
     *   }
     * })
     * 
    **/
    delete<T extends invTypeReactionsDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, invTypeReactionsDeleteArgs<ExtArgs>>
    ): Prisma__invTypeReactionsClient<$Result.GetResult<Prisma.$invTypeReactionsPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one InvTypeReactions.
     * @param {invTypeReactionsUpdateArgs} args - Arguments to update one InvTypeReactions.
     * @example
     * // Update one InvTypeReactions
     * const invTypeReactions = await prisma.invTypeReactions.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends invTypeReactionsUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, invTypeReactionsUpdateArgs<ExtArgs>>
    ): Prisma__invTypeReactionsClient<$Result.GetResult<Prisma.$invTypeReactionsPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more InvTypeReactions.
     * @param {invTypeReactionsDeleteManyArgs} args - Arguments to filter InvTypeReactions to delete.
     * @example
     * // Delete a few InvTypeReactions
     * const { count } = await prisma.invTypeReactions.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends invTypeReactionsDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, invTypeReactionsDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more InvTypeReactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {invTypeReactionsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many InvTypeReactions
     * const invTypeReactions = await prisma.invTypeReactions.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends invTypeReactionsUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, invTypeReactionsUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one InvTypeReactions.
     * @param {invTypeReactionsUpsertArgs} args - Arguments to update or create a InvTypeReactions.
     * @example
     * // Update or create a InvTypeReactions
     * const invTypeReactions = await prisma.invTypeReactions.upsert({
     *   create: {
     *     // ... data to create a InvTypeReactions
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the InvTypeReactions we want to update
     *   }
     * })
    **/
    upsert<T extends invTypeReactionsUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, invTypeReactionsUpsertArgs<ExtArgs>>
    ): Prisma__invTypeReactionsClient<$Result.GetResult<Prisma.$invTypeReactionsPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of InvTypeReactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {invTypeReactionsCountArgs} args - Arguments to filter InvTypeReactions to count.
     * @example
     * // Count the number of InvTypeReactions
     * const count = await prisma.invTypeReactions.count({
     *   where: {
     *     // ... the filter for the InvTypeReactions we want to count
     *   }
     * })
    **/
    count<T extends invTypeReactionsCountArgs>(
      args?: Subset<T, invTypeReactionsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], InvTypeReactionsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a InvTypeReactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvTypeReactionsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends InvTypeReactionsAggregateArgs>(args: Subset<T, InvTypeReactionsAggregateArgs>): Prisma.PrismaPromise<GetInvTypeReactionsAggregateType<T>>

    /**
     * Group by InvTypeReactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {invTypeReactionsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends invTypeReactionsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: invTypeReactionsGroupByArgs['orderBy'] }
        : { orderBy?: invTypeReactionsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, invTypeReactionsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInvTypeReactionsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the invTypeReactions model
   */
  readonly fields: invTypeReactionsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for invTypeReactions.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__invTypeReactionsClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';


    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the invTypeReactions model
   */ 
  interface invTypeReactionsFieldRefs {
    readonly reactionTypeID: FieldRef<"invTypeReactions", 'Int'>
    readonly input: FieldRef<"invTypeReactions", 'Boolean'>
    readonly typeID: FieldRef<"invTypeReactions", 'Int'>
    readonly quantity: FieldRef<"invTypeReactions", 'Int'>
  }
    

  // Custom InputTypes

  /**
   * invTypeReactions findUnique
   */
  export type invTypeReactionsFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the invTypeReactions
     */
    select?: invTypeReactionsSelect<ExtArgs> | null
    /**
     * Filter, which invTypeReactions to fetch.
     */
    where: invTypeReactionsWhereUniqueInput
  }


  /**
   * invTypeReactions findUniqueOrThrow
   */
  export type invTypeReactionsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the invTypeReactions
     */
    select?: invTypeReactionsSelect<ExtArgs> | null
    /**
     * Filter, which invTypeReactions to fetch.
     */
    where: invTypeReactionsWhereUniqueInput
  }


  /**
   * invTypeReactions findFirst
   */
  export type invTypeReactionsFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the invTypeReactions
     */
    select?: invTypeReactionsSelect<ExtArgs> | null
    /**
     * Filter, which invTypeReactions to fetch.
     */
    where?: invTypeReactionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of invTypeReactions to fetch.
     */
    orderBy?: invTypeReactionsOrderByWithRelationInput | invTypeReactionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for invTypeReactions.
     */
    cursor?: invTypeReactionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` invTypeReactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` invTypeReactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of invTypeReactions.
     */
    distinct?: InvTypeReactionsScalarFieldEnum | InvTypeReactionsScalarFieldEnum[]
  }


  /**
   * invTypeReactions findFirstOrThrow
   */
  export type invTypeReactionsFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the invTypeReactions
     */
    select?: invTypeReactionsSelect<ExtArgs> | null
    /**
     * Filter, which invTypeReactions to fetch.
     */
    where?: invTypeReactionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of invTypeReactions to fetch.
     */
    orderBy?: invTypeReactionsOrderByWithRelationInput | invTypeReactionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for invTypeReactions.
     */
    cursor?: invTypeReactionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` invTypeReactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` invTypeReactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of invTypeReactions.
     */
    distinct?: InvTypeReactionsScalarFieldEnum | InvTypeReactionsScalarFieldEnum[]
  }


  /**
   * invTypeReactions findMany
   */
  export type invTypeReactionsFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the invTypeReactions
     */
    select?: invTypeReactionsSelect<ExtArgs> | null
    /**
     * Filter, which invTypeReactions to fetch.
     */
    where?: invTypeReactionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of invTypeReactions to fetch.
     */
    orderBy?: invTypeReactionsOrderByWithRelationInput | invTypeReactionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing invTypeReactions.
     */
    cursor?: invTypeReactionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` invTypeReactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` invTypeReactions.
     */
    skip?: number
    distinct?: InvTypeReactionsScalarFieldEnum | InvTypeReactionsScalarFieldEnum[]
  }


  /**
   * invTypeReactions create
   */
  export type invTypeReactionsCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the invTypeReactions
     */
    select?: invTypeReactionsSelect<ExtArgs> | null
    /**
     * The data needed to create a invTypeReactions.
     */
    data: XOR<invTypeReactionsCreateInput, invTypeReactionsUncheckedCreateInput>
  }


  /**
   * invTypeReactions createMany
   */
  export type invTypeReactionsCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many invTypeReactions.
     */
    data: invTypeReactionsCreateManyInput | invTypeReactionsCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * invTypeReactions update
   */
  export type invTypeReactionsUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the invTypeReactions
     */
    select?: invTypeReactionsSelect<ExtArgs> | null
    /**
     * The data needed to update a invTypeReactions.
     */
    data: XOR<invTypeReactionsUpdateInput, invTypeReactionsUncheckedUpdateInput>
    /**
     * Choose, which invTypeReactions to update.
     */
    where: invTypeReactionsWhereUniqueInput
  }


  /**
   * invTypeReactions updateMany
   */
  export type invTypeReactionsUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update invTypeReactions.
     */
    data: XOR<invTypeReactionsUpdateManyMutationInput, invTypeReactionsUncheckedUpdateManyInput>
    /**
     * Filter which invTypeReactions to update
     */
    where?: invTypeReactionsWhereInput
  }


  /**
   * invTypeReactions upsert
   */
  export type invTypeReactionsUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the invTypeReactions
     */
    select?: invTypeReactionsSelect<ExtArgs> | null
    /**
     * The filter to search for the invTypeReactions to update in case it exists.
     */
    where: invTypeReactionsWhereUniqueInput
    /**
     * In case the invTypeReactions found by the `where` argument doesn't exist, create a new invTypeReactions with this data.
     */
    create: XOR<invTypeReactionsCreateInput, invTypeReactionsUncheckedCreateInput>
    /**
     * In case the invTypeReactions was found with the provided `where` argument, update it with this data.
     */
    update: XOR<invTypeReactionsUpdateInput, invTypeReactionsUncheckedUpdateInput>
  }


  /**
   * invTypeReactions delete
   */
  export type invTypeReactionsDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the invTypeReactions
     */
    select?: invTypeReactionsSelect<ExtArgs> | null
    /**
     * Filter which invTypeReactions to delete.
     */
    where: invTypeReactionsWhereUniqueInput
  }


  /**
   * invTypeReactions deleteMany
   */
  export type invTypeReactionsDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which invTypeReactions to delete
     */
    where?: invTypeReactionsWhereInput
  }


  /**
   * invTypeReactions without action
   */
  export type invTypeReactionsDefaultArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the invTypeReactions
     */
    select?: invTypeReactionsSelect<ExtArgs> | null
  }



  /**
   * Model invTypes
   */

  export type AggregateInvTypes = {
    _count: InvTypesCountAggregateOutputType | null
    _avg: InvTypesAvgAggregateOutputType | null
    _sum: InvTypesSumAggregateOutputType | null
    _min: InvTypesMinAggregateOutputType | null
    _max: InvTypesMaxAggregateOutputType | null
  }

  export type InvTypesAvgAggregateOutputType = {
    typeID: number | null
    groupID: number | null
    mass: number | null
    volume: number | null
    capacity: number | null
    portionSize: number | null
    raceID: number | null
    basePrice: Decimal | null
    marketGroupID: number | null
    iconID: number | null
    soundID: number | null
    graphicID: number | null
  }

  export type InvTypesSumAggregateOutputType = {
    typeID: number | null
    groupID: number | null
    mass: number | null
    volume: number | null
    capacity: number | null
    portionSize: number | null
    raceID: number | null
    basePrice: Decimal | null
    marketGroupID: number | null
    iconID: number | null
    soundID: number | null
    graphicID: number | null
  }

  export type InvTypesMinAggregateOutputType = {
    typeID: number | null
    groupID: number | null
    typeName: string | null
    description: string | null
    mass: number | null
    volume: number | null
    capacity: number | null
    portionSize: number | null
    raceID: number | null
    basePrice: Decimal | null
    published: boolean | null
    marketGroupID: number | null
    iconID: number | null
    soundID: number | null
    graphicID: number | null
  }

  export type InvTypesMaxAggregateOutputType = {
    typeID: number | null
    groupID: number | null
    typeName: string | null
    description: string | null
    mass: number | null
    volume: number | null
    capacity: number | null
    portionSize: number | null
    raceID: number | null
    basePrice: Decimal | null
    published: boolean | null
    marketGroupID: number | null
    iconID: number | null
    soundID: number | null
    graphicID: number | null
  }

  export type InvTypesCountAggregateOutputType = {
    typeID: number
    groupID: number
    typeName: number
    description: number
    mass: number
    volume: number
    capacity: number
    portionSize: number
    raceID: number
    basePrice: number
    published: number
    marketGroupID: number
    iconID: number
    soundID: number
    graphicID: number
    _all: number
  }


  export type InvTypesAvgAggregateInputType = {
    typeID?: true
    groupID?: true
    mass?: true
    volume?: true
    capacity?: true
    portionSize?: true
    raceID?: true
    basePrice?: true
    marketGroupID?: true
    iconID?: true
    soundID?: true
    graphicID?: true
  }

  export type InvTypesSumAggregateInputType = {
    typeID?: true
    groupID?: true
    mass?: true
    volume?: true
    capacity?: true
    portionSize?: true
    raceID?: true
    basePrice?: true
    marketGroupID?: true
    iconID?: true
    soundID?: true
    graphicID?: true
  }

  export type InvTypesMinAggregateInputType = {
    typeID?: true
    groupID?: true
    typeName?: true
    description?: true
    mass?: true
    volume?: true
    capacity?: true
    portionSize?: true
    raceID?: true
    basePrice?: true
    published?: true
    marketGroupID?: true
    iconID?: true
    soundID?: true
    graphicID?: true
  }

  export type InvTypesMaxAggregateInputType = {
    typeID?: true
    groupID?: true
    typeName?: true
    description?: true
    mass?: true
    volume?: true
    capacity?: true
    portionSize?: true
    raceID?: true
    basePrice?: true
    published?: true
    marketGroupID?: true
    iconID?: true
    soundID?: true
    graphicID?: true
  }

  export type InvTypesCountAggregateInputType = {
    typeID?: true
    groupID?: true
    typeName?: true
    description?: true
    mass?: true
    volume?: true
    capacity?: true
    portionSize?: true
    raceID?: true
    basePrice?: true
    published?: true
    marketGroupID?: true
    iconID?: true
    soundID?: true
    graphicID?: true
    _all?: true
  }

  export type InvTypesAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which invTypes to aggregate.
     */
    where?: invTypesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of invTypes to fetch.
     */
    orderBy?: invTypesOrderByWithRelationInput | invTypesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: invTypesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` invTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` invTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned invTypes
    **/
    _count?: true | InvTypesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: InvTypesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: InvTypesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: InvTypesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: InvTypesMaxAggregateInputType
  }

  export type GetInvTypesAggregateType<T extends InvTypesAggregateArgs> = {
        [P in keyof T & keyof AggregateInvTypes]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInvTypes[P]>
      : GetScalarType<T[P], AggregateInvTypes[P]>
  }




  export type invTypesGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: invTypesWhereInput
    orderBy?: invTypesOrderByWithAggregationInput | invTypesOrderByWithAggregationInput[]
    by: InvTypesScalarFieldEnum[] | InvTypesScalarFieldEnum
    having?: invTypesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: InvTypesCountAggregateInputType | true
    _avg?: InvTypesAvgAggregateInputType
    _sum?: InvTypesSumAggregateInputType
    _min?: InvTypesMinAggregateInputType
    _max?: InvTypesMaxAggregateInputType
  }

  export type InvTypesGroupByOutputType = {
    typeID: number
    groupID: number | null
    typeName: string | null
    description: string | null
    mass: number | null
    volume: number | null
    capacity: number | null
    portionSize: number | null
    raceID: number | null
    basePrice: Decimal | null
    published: boolean | null
    marketGroupID: number | null
    iconID: number | null
    soundID: number | null
    graphicID: number | null
    _count: InvTypesCountAggregateOutputType | null
    _avg: InvTypesAvgAggregateOutputType | null
    _sum: InvTypesSumAggregateOutputType | null
    _min: InvTypesMinAggregateOutputType | null
    _max: InvTypesMaxAggregateOutputType | null
  }

  type GetInvTypesGroupByPayload<T extends invTypesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<InvTypesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof InvTypesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], InvTypesGroupByOutputType[P]>
            : GetScalarType<T[P], InvTypesGroupByOutputType[P]>
        }
      >
    >


  export type invTypesSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    typeID?: boolean
    groupID?: boolean
    typeName?: boolean
    description?: boolean
    mass?: boolean
    volume?: boolean
    capacity?: boolean
    portionSize?: boolean
    raceID?: boolean
    basePrice?: boolean
    published?: boolean
    marketGroupID?: boolean
    iconID?: boolean
    soundID?: boolean
    graphicID?: boolean
  }, ExtArgs["result"]["invTypes"]>

  export type invTypesSelectScalar = {
    typeID?: boolean
    groupID?: boolean
    typeName?: boolean
    description?: boolean
    mass?: boolean
    volume?: boolean
    capacity?: boolean
    portionSize?: boolean
    raceID?: boolean
    basePrice?: boolean
    published?: boolean
    marketGroupID?: boolean
    iconID?: boolean
    soundID?: boolean
    graphicID?: boolean
  }


  export type $invTypesPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    name: "invTypes"
    objects: {}
    scalars: $Extensions.GetResult<{
      typeID: number
      groupID: number | null
      typeName: string | null
      description: string | null
      mass: number | null
      volume: number | null
      capacity: number | null
      portionSize: number | null
      raceID: number | null
      basePrice: Prisma.Decimal | null
      published: boolean | null
      marketGroupID: number | null
      iconID: number | null
      soundID: number | null
      graphicID: number | null
    }, ExtArgs["result"]["invTypes"]>
    composites: {}
  }


  type invTypesGetPayload<S extends boolean | null | undefined | invTypesDefaultArgs> = $Result.GetResult<Prisma.$invTypesPayload, S>

  type invTypesCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<invTypesFindManyArgs, 'select' | 'include'> & {
      select?: InvTypesCountAggregateInputType | true
    }

  export interface invTypesDelegate<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['invTypes'], meta: { name: 'invTypes' } }
    /**
     * Find zero or one InvTypes that matches the filter.
     * @param {invTypesFindUniqueArgs} args - Arguments to find a InvTypes
     * @example
     * // Get one InvTypes
     * const invTypes = await prisma.invTypes.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends invTypesFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, invTypesFindUniqueArgs<ExtArgs>>
    ): Prisma__invTypesClient<$Result.GetResult<Prisma.$invTypesPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one InvTypes that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {invTypesFindUniqueOrThrowArgs} args - Arguments to find a InvTypes
     * @example
     * // Get one InvTypes
     * const invTypes = await prisma.invTypes.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends invTypesFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, invTypesFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__invTypesClient<$Result.GetResult<Prisma.$invTypesPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first InvTypes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {invTypesFindFirstArgs} args - Arguments to find a InvTypes
     * @example
     * // Get one InvTypes
     * const invTypes = await prisma.invTypes.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends invTypesFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, invTypesFindFirstArgs<ExtArgs>>
    ): Prisma__invTypesClient<$Result.GetResult<Prisma.$invTypesPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first InvTypes that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {invTypesFindFirstOrThrowArgs} args - Arguments to find a InvTypes
     * @example
     * // Get one InvTypes
     * const invTypes = await prisma.invTypes.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends invTypesFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, invTypesFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__invTypesClient<$Result.GetResult<Prisma.$invTypesPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more InvTypes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {invTypesFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all InvTypes
     * const invTypes = await prisma.invTypes.findMany()
     * 
     * // Get first 10 InvTypes
     * const invTypes = await prisma.invTypes.findMany({ take: 10 })
     * 
     * // Only select the `typeID`
     * const invTypesWithTypeIDOnly = await prisma.invTypes.findMany({ select: { typeID: true } })
     * 
    **/
    findMany<T extends invTypesFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, invTypesFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$invTypesPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a InvTypes.
     * @param {invTypesCreateArgs} args - Arguments to create a InvTypes.
     * @example
     * // Create one InvTypes
     * const InvTypes = await prisma.invTypes.create({
     *   data: {
     *     // ... data to create a InvTypes
     *   }
     * })
     * 
    **/
    create<T extends invTypesCreateArgs<ExtArgs>>(
      args: SelectSubset<T, invTypesCreateArgs<ExtArgs>>
    ): Prisma__invTypesClient<$Result.GetResult<Prisma.$invTypesPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many InvTypes.
     *     @param {invTypesCreateManyArgs} args - Arguments to create many InvTypes.
     *     @example
     *     // Create many InvTypes
     *     const invTypes = await prisma.invTypes.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends invTypesCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, invTypesCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a InvTypes.
     * @param {invTypesDeleteArgs} args - Arguments to delete one InvTypes.
     * @example
     * // Delete one InvTypes
     * const InvTypes = await prisma.invTypes.delete({
     *   where: {
     *     // ... filter to delete one InvTypes
     *   }
     * })
     * 
    **/
    delete<T extends invTypesDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, invTypesDeleteArgs<ExtArgs>>
    ): Prisma__invTypesClient<$Result.GetResult<Prisma.$invTypesPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one InvTypes.
     * @param {invTypesUpdateArgs} args - Arguments to update one InvTypes.
     * @example
     * // Update one InvTypes
     * const invTypes = await prisma.invTypes.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends invTypesUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, invTypesUpdateArgs<ExtArgs>>
    ): Prisma__invTypesClient<$Result.GetResult<Prisma.$invTypesPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more InvTypes.
     * @param {invTypesDeleteManyArgs} args - Arguments to filter InvTypes to delete.
     * @example
     * // Delete a few InvTypes
     * const { count } = await prisma.invTypes.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends invTypesDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, invTypesDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more InvTypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {invTypesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many InvTypes
     * const invTypes = await prisma.invTypes.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends invTypesUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, invTypesUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one InvTypes.
     * @param {invTypesUpsertArgs} args - Arguments to update or create a InvTypes.
     * @example
     * // Update or create a InvTypes
     * const invTypes = await prisma.invTypes.upsert({
     *   create: {
     *     // ... data to create a InvTypes
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the InvTypes we want to update
     *   }
     * })
    **/
    upsert<T extends invTypesUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, invTypesUpsertArgs<ExtArgs>>
    ): Prisma__invTypesClient<$Result.GetResult<Prisma.$invTypesPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of InvTypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {invTypesCountArgs} args - Arguments to filter InvTypes to count.
     * @example
     * // Count the number of InvTypes
     * const count = await prisma.invTypes.count({
     *   where: {
     *     // ... the filter for the InvTypes we want to count
     *   }
     * })
    **/
    count<T extends invTypesCountArgs>(
      args?: Subset<T, invTypesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], InvTypesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a InvTypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvTypesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends InvTypesAggregateArgs>(args: Subset<T, InvTypesAggregateArgs>): Prisma.PrismaPromise<GetInvTypesAggregateType<T>>

    /**
     * Group by InvTypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {invTypesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends invTypesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: invTypesGroupByArgs['orderBy'] }
        : { orderBy?: invTypesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, invTypesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInvTypesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the invTypes model
   */
  readonly fields: invTypesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for invTypes.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__invTypesClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';


    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the invTypes model
   */ 
  interface invTypesFieldRefs {
    readonly typeID: FieldRef<"invTypes", 'Int'>
    readonly groupID: FieldRef<"invTypes", 'Int'>
    readonly typeName: FieldRef<"invTypes", 'String'>
    readonly description: FieldRef<"invTypes", 'String'>
    readonly mass: FieldRef<"invTypes", 'Float'>
    readonly volume: FieldRef<"invTypes", 'Float'>
    readonly capacity: FieldRef<"invTypes", 'Float'>
    readonly portionSize: FieldRef<"invTypes", 'Int'>
    readonly raceID: FieldRef<"invTypes", 'Int'>
    readonly basePrice: FieldRef<"invTypes", 'Decimal'>
    readonly published: FieldRef<"invTypes", 'Boolean'>
    readonly marketGroupID: FieldRef<"invTypes", 'Int'>
    readonly iconID: FieldRef<"invTypes", 'Int'>
    readonly soundID: FieldRef<"invTypes", 'Int'>
    readonly graphicID: FieldRef<"invTypes", 'Int'>
  }
    

  // Custom InputTypes

  /**
   * invTypes findUnique
   */
  export type invTypesFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the invTypes
     */
    select?: invTypesSelect<ExtArgs> | null
    /**
     * Filter, which invTypes to fetch.
     */
    where: invTypesWhereUniqueInput
  }


  /**
   * invTypes findUniqueOrThrow
   */
  export type invTypesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the invTypes
     */
    select?: invTypesSelect<ExtArgs> | null
    /**
     * Filter, which invTypes to fetch.
     */
    where: invTypesWhereUniqueInput
  }


  /**
   * invTypes findFirst
   */
  export type invTypesFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the invTypes
     */
    select?: invTypesSelect<ExtArgs> | null
    /**
     * Filter, which invTypes to fetch.
     */
    where?: invTypesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of invTypes to fetch.
     */
    orderBy?: invTypesOrderByWithRelationInput | invTypesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for invTypes.
     */
    cursor?: invTypesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` invTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` invTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of invTypes.
     */
    distinct?: InvTypesScalarFieldEnum | InvTypesScalarFieldEnum[]
  }


  /**
   * invTypes findFirstOrThrow
   */
  export type invTypesFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the invTypes
     */
    select?: invTypesSelect<ExtArgs> | null
    /**
     * Filter, which invTypes to fetch.
     */
    where?: invTypesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of invTypes to fetch.
     */
    orderBy?: invTypesOrderByWithRelationInput | invTypesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for invTypes.
     */
    cursor?: invTypesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` invTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` invTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of invTypes.
     */
    distinct?: InvTypesScalarFieldEnum | InvTypesScalarFieldEnum[]
  }


  /**
   * invTypes findMany
   */
  export type invTypesFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the invTypes
     */
    select?: invTypesSelect<ExtArgs> | null
    /**
     * Filter, which invTypes to fetch.
     */
    where?: invTypesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of invTypes to fetch.
     */
    orderBy?: invTypesOrderByWithRelationInput | invTypesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing invTypes.
     */
    cursor?: invTypesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` invTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` invTypes.
     */
    skip?: number
    distinct?: InvTypesScalarFieldEnum | InvTypesScalarFieldEnum[]
  }


  /**
   * invTypes create
   */
  export type invTypesCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the invTypes
     */
    select?: invTypesSelect<ExtArgs> | null
    /**
     * The data needed to create a invTypes.
     */
    data: XOR<invTypesCreateInput, invTypesUncheckedCreateInput>
  }


  /**
   * invTypes createMany
   */
  export type invTypesCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many invTypes.
     */
    data: invTypesCreateManyInput | invTypesCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * invTypes update
   */
  export type invTypesUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the invTypes
     */
    select?: invTypesSelect<ExtArgs> | null
    /**
     * The data needed to update a invTypes.
     */
    data: XOR<invTypesUpdateInput, invTypesUncheckedUpdateInput>
    /**
     * Choose, which invTypes to update.
     */
    where: invTypesWhereUniqueInput
  }


  /**
   * invTypes updateMany
   */
  export type invTypesUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update invTypes.
     */
    data: XOR<invTypesUpdateManyMutationInput, invTypesUncheckedUpdateManyInput>
    /**
     * Filter which invTypes to update
     */
    where?: invTypesWhereInput
  }


  /**
   * invTypes upsert
   */
  export type invTypesUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the invTypes
     */
    select?: invTypesSelect<ExtArgs> | null
    /**
     * The filter to search for the invTypes to update in case it exists.
     */
    where: invTypesWhereUniqueInput
    /**
     * In case the invTypes found by the `where` argument doesn't exist, create a new invTypes with this data.
     */
    create: XOR<invTypesCreateInput, invTypesUncheckedCreateInput>
    /**
     * In case the invTypes was found with the provided `where` argument, update it with this data.
     */
    update: XOR<invTypesUpdateInput, invTypesUncheckedUpdateInput>
  }


  /**
   * invTypes delete
   */
  export type invTypesDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the invTypes
     */
    select?: invTypesSelect<ExtArgs> | null
    /**
     * Filter which invTypes to delete.
     */
    where: invTypesWhereUniqueInput
  }


  /**
   * invTypes deleteMany
   */
  export type invTypesDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which invTypes to delete
     */
    where?: invTypesWhereInput
  }


  /**
   * invTypes without action
   */
  export type invTypesDefaultArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the invTypes
     */
    select?: invTypesSelect<ExtArgs> | null
  }



  /**
   * Model invUniqueNames
   */

  export type AggregateInvUniqueNames = {
    _count: InvUniqueNamesCountAggregateOutputType | null
    _avg: InvUniqueNamesAvgAggregateOutputType | null
    _sum: InvUniqueNamesSumAggregateOutputType | null
    _min: InvUniqueNamesMinAggregateOutputType | null
    _max: InvUniqueNamesMaxAggregateOutputType | null
  }

  export type InvUniqueNamesAvgAggregateOutputType = {
    itemID: number | null
    groupID: number | null
  }

  export type InvUniqueNamesSumAggregateOutputType = {
    itemID: number | null
    groupID: number | null
  }

  export type InvUniqueNamesMinAggregateOutputType = {
    itemID: number | null
    itemName: string | null
    groupID: number | null
  }

  export type InvUniqueNamesMaxAggregateOutputType = {
    itemID: number | null
    itemName: string | null
    groupID: number | null
  }

  export type InvUniqueNamesCountAggregateOutputType = {
    itemID: number
    itemName: number
    groupID: number
    _all: number
  }


  export type InvUniqueNamesAvgAggregateInputType = {
    itemID?: true
    groupID?: true
  }

  export type InvUniqueNamesSumAggregateInputType = {
    itemID?: true
    groupID?: true
  }

  export type InvUniqueNamesMinAggregateInputType = {
    itemID?: true
    itemName?: true
    groupID?: true
  }

  export type InvUniqueNamesMaxAggregateInputType = {
    itemID?: true
    itemName?: true
    groupID?: true
  }

  export type InvUniqueNamesCountAggregateInputType = {
    itemID?: true
    itemName?: true
    groupID?: true
    _all?: true
  }

  export type InvUniqueNamesAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which invUniqueNames to aggregate.
     */
    where?: invUniqueNamesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of invUniqueNames to fetch.
     */
    orderBy?: invUniqueNamesOrderByWithRelationInput | invUniqueNamesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: invUniqueNamesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` invUniqueNames from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` invUniqueNames.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned invUniqueNames
    **/
    _count?: true | InvUniqueNamesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: InvUniqueNamesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: InvUniqueNamesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: InvUniqueNamesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: InvUniqueNamesMaxAggregateInputType
  }

  export type GetInvUniqueNamesAggregateType<T extends InvUniqueNamesAggregateArgs> = {
        [P in keyof T & keyof AggregateInvUniqueNames]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInvUniqueNames[P]>
      : GetScalarType<T[P], AggregateInvUniqueNames[P]>
  }




  export type invUniqueNamesGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: invUniqueNamesWhereInput
    orderBy?: invUniqueNamesOrderByWithAggregationInput | invUniqueNamesOrderByWithAggregationInput[]
    by: InvUniqueNamesScalarFieldEnum[] | InvUniqueNamesScalarFieldEnum
    having?: invUniqueNamesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: InvUniqueNamesCountAggregateInputType | true
    _avg?: InvUniqueNamesAvgAggregateInputType
    _sum?: InvUniqueNamesSumAggregateInputType
    _min?: InvUniqueNamesMinAggregateInputType
    _max?: InvUniqueNamesMaxAggregateInputType
  }

  export type InvUniqueNamesGroupByOutputType = {
    itemID: number
    itemName: string
    groupID: number | null
    _count: InvUniqueNamesCountAggregateOutputType | null
    _avg: InvUniqueNamesAvgAggregateOutputType | null
    _sum: InvUniqueNamesSumAggregateOutputType | null
    _min: InvUniqueNamesMinAggregateOutputType | null
    _max: InvUniqueNamesMaxAggregateOutputType | null
  }

  type GetInvUniqueNamesGroupByPayload<T extends invUniqueNamesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<InvUniqueNamesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof InvUniqueNamesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], InvUniqueNamesGroupByOutputType[P]>
            : GetScalarType<T[P], InvUniqueNamesGroupByOutputType[P]>
        }
      >
    >


  export type invUniqueNamesSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    itemID?: boolean
    itemName?: boolean
    groupID?: boolean
  }, ExtArgs["result"]["invUniqueNames"]>

  export type invUniqueNamesSelectScalar = {
    itemID?: boolean
    itemName?: boolean
    groupID?: boolean
  }


  export type $invUniqueNamesPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    name: "invUniqueNames"
    objects: {}
    scalars: $Extensions.GetResult<{
      itemID: number
      itemName: string
      groupID: number | null
    }, ExtArgs["result"]["invUniqueNames"]>
    composites: {}
  }


  type invUniqueNamesGetPayload<S extends boolean | null | undefined | invUniqueNamesDefaultArgs> = $Result.GetResult<Prisma.$invUniqueNamesPayload, S>

  type invUniqueNamesCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<invUniqueNamesFindManyArgs, 'select' | 'include'> & {
      select?: InvUniqueNamesCountAggregateInputType | true
    }

  export interface invUniqueNamesDelegate<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['invUniqueNames'], meta: { name: 'invUniqueNames' } }
    /**
     * Find zero or one InvUniqueNames that matches the filter.
     * @param {invUniqueNamesFindUniqueArgs} args - Arguments to find a InvUniqueNames
     * @example
     * // Get one InvUniqueNames
     * const invUniqueNames = await prisma.invUniqueNames.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends invUniqueNamesFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, invUniqueNamesFindUniqueArgs<ExtArgs>>
    ): Prisma__invUniqueNamesClient<$Result.GetResult<Prisma.$invUniqueNamesPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one InvUniqueNames that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {invUniqueNamesFindUniqueOrThrowArgs} args - Arguments to find a InvUniqueNames
     * @example
     * // Get one InvUniqueNames
     * const invUniqueNames = await prisma.invUniqueNames.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends invUniqueNamesFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, invUniqueNamesFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__invUniqueNamesClient<$Result.GetResult<Prisma.$invUniqueNamesPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first InvUniqueNames that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {invUniqueNamesFindFirstArgs} args - Arguments to find a InvUniqueNames
     * @example
     * // Get one InvUniqueNames
     * const invUniqueNames = await prisma.invUniqueNames.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends invUniqueNamesFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, invUniqueNamesFindFirstArgs<ExtArgs>>
    ): Prisma__invUniqueNamesClient<$Result.GetResult<Prisma.$invUniqueNamesPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first InvUniqueNames that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {invUniqueNamesFindFirstOrThrowArgs} args - Arguments to find a InvUniqueNames
     * @example
     * // Get one InvUniqueNames
     * const invUniqueNames = await prisma.invUniqueNames.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends invUniqueNamesFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, invUniqueNamesFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__invUniqueNamesClient<$Result.GetResult<Prisma.$invUniqueNamesPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more InvUniqueNames that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {invUniqueNamesFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all InvUniqueNames
     * const invUniqueNames = await prisma.invUniqueNames.findMany()
     * 
     * // Get first 10 InvUniqueNames
     * const invUniqueNames = await prisma.invUniqueNames.findMany({ take: 10 })
     * 
     * // Only select the `itemID`
     * const invUniqueNamesWithItemIDOnly = await prisma.invUniqueNames.findMany({ select: { itemID: true } })
     * 
    **/
    findMany<T extends invUniqueNamesFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, invUniqueNamesFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$invUniqueNamesPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a InvUniqueNames.
     * @param {invUniqueNamesCreateArgs} args - Arguments to create a InvUniqueNames.
     * @example
     * // Create one InvUniqueNames
     * const InvUniqueNames = await prisma.invUniqueNames.create({
     *   data: {
     *     // ... data to create a InvUniqueNames
     *   }
     * })
     * 
    **/
    create<T extends invUniqueNamesCreateArgs<ExtArgs>>(
      args: SelectSubset<T, invUniqueNamesCreateArgs<ExtArgs>>
    ): Prisma__invUniqueNamesClient<$Result.GetResult<Prisma.$invUniqueNamesPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many InvUniqueNames.
     *     @param {invUniqueNamesCreateManyArgs} args - Arguments to create many InvUniqueNames.
     *     @example
     *     // Create many InvUniqueNames
     *     const invUniqueNames = await prisma.invUniqueNames.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends invUniqueNamesCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, invUniqueNamesCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a InvUniqueNames.
     * @param {invUniqueNamesDeleteArgs} args - Arguments to delete one InvUniqueNames.
     * @example
     * // Delete one InvUniqueNames
     * const InvUniqueNames = await prisma.invUniqueNames.delete({
     *   where: {
     *     // ... filter to delete one InvUniqueNames
     *   }
     * })
     * 
    **/
    delete<T extends invUniqueNamesDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, invUniqueNamesDeleteArgs<ExtArgs>>
    ): Prisma__invUniqueNamesClient<$Result.GetResult<Prisma.$invUniqueNamesPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one InvUniqueNames.
     * @param {invUniqueNamesUpdateArgs} args - Arguments to update one InvUniqueNames.
     * @example
     * // Update one InvUniqueNames
     * const invUniqueNames = await prisma.invUniqueNames.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends invUniqueNamesUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, invUniqueNamesUpdateArgs<ExtArgs>>
    ): Prisma__invUniqueNamesClient<$Result.GetResult<Prisma.$invUniqueNamesPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more InvUniqueNames.
     * @param {invUniqueNamesDeleteManyArgs} args - Arguments to filter InvUniqueNames to delete.
     * @example
     * // Delete a few InvUniqueNames
     * const { count } = await prisma.invUniqueNames.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends invUniqueNamesDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, invUniqueNamesDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more InvUniqueNames.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {invUniqueNamesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many InvUniqueNames
     * const invUniqueNames = await prisma.invUniqueNames.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends invUniqueNamesUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, invUniqueNamesUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one InvUniqueNames.
     * @param {invUniqueNamesUpsertArgs} args - Arguments to update or create a InvUniqueNames.
     * @example
     * // Update or create a InvUniqueNames
     * const invUniqueNames = await prisma.invUniqueNames.upsert({
     *   create: {
     *     // ... data to create a InvUniqueNames
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the InvUniqueNames we want to update
     *   }
     * })
    **/
    upsert<T extends invUniqueNamesUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, invUniqueNamesUpsertArgs<ExtArgs>>
    ): Prisma__invUniqueNamesClient<$Result.GetResult<Prisma.$invUniqueNamesPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of InvUniqueNames.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {invUniqueNamesCountArgs} args - Arguments to filter InvUniqueNames to count.
     * @example
     * // Count the number of InvUniqueNames
     * const count = await prisma.invUniqueNames.count({
     *   where: {
     *     // ... the filter for the InvUniqueNames we want to count
     *   }
     * })
    **/
    count<T extends invUniqueNamesCountArgs>(
      args?: Subset<T, invUniqueNamesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], InvUniqueNamesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a InvUniqueNames.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvUniqueNamesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends InvUniqueNamesAggregateArgs>(args: Subset<T, InvUniqueNamesAggregateArgs>): Prisma.PrismaPromise<GetInvUniqueNamesAggregateType<T>>

    /**
     * Group by InvUniqueNames.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {invUniqueNamesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends invUniqueNamesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: invUniqueNamesGroupByArgs['orderBy'] }
        : { orderBy?: invUniqueNamesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, invUniqueNamesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInvUniqueNamesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the invUniqueNames model
   */
  readonly fields: invUniqueNamesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for invUniqueNames.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__invUniqueNamesClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';


    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the invUniqueNames model
   */ 
  interface invUniqueNamesFieldRefs {
    readonly itemID: FieldRef<"invUniqueNames", 'Int'>
    readonly itemName: FieldRef<"invUniqueNames", 'String'>
    readonly groupID: FieldRef<"invUniqueNames", 'Int'>
  }
    

  // Custom InputTypes

  /**
   * invUniqueNames findUnique
   */
  export type invUniqueNamesFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the invUniqueNames
     */
    select?: invUniqueNamesSelect<ExtArgs> | null
    /**
     * Filter, which invUniqueNames to fetch.
     */
    where: invUniqueNamesWhereUniqueInput
  }


  /**
   * invUniqueNames findUniqueOrThrow
   */
  export type invUniqueNamesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the invUniqueNames
     */
    select?: invUniqueNamesSelect<ExtArgs> | null
    /**
     * Filter, which invUniqueNames to fetch.
     */
    where: invUniqueNamesWhereUniqueInput
  }


  /**
   * invUniqueNames findFirst
   */
  export type invUniqueNamesFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the invUniqueNames
     */
    select?: invUniqueNamesSelect<ExtArgs> | null
    /**
     * Filter, which invUniqueNames to fetch.
     */
    where?: invUniqueNamesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of invUniqueNames to fetch.
     */
    orderBy?: invUniqueNamesOrderByWithRelationInput | invUniqueNamesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for invUniqueNames.
     */
    cursor?: invUniqueNamesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` invUniqueNames from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` invUniqueNames.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of invUniqueNames.
     */
    distinct?: InvUniqueNamesScalarFieldEnum | InvUniqueNamesScalarFieldEnum[]
  }


  /**
   * invUniqueNames findFirstOrThrow
   */
  export type invUniqueNamesFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the invUniqueNames
     */
    select?: invUniqueNamesSelect<ExtArgs> | null
    /**
     * Filter, which invUniqueNames to fetch.
     */
    where?: invUniqueNamesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of invUniqueNames to fetch.
     */
    orderBy?: invUniqueNamesOrderByWithRelationInput | invUniqueNamesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for invUniqueNames.
     */
    cursor?: invUniqueNamesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` invUniqueNames from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` invUniqueNames.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of invUniqueNames.
     */
    distinct?: InvUniqueNamesScalarFieldEnum | InvUniqueNamesScalarFieldEnum[]
  }


  /**
   * invUniqueNames findMany
   */
  export type invUniqueNamesFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the invUniqueNames
     */
    select?: invUniqueNamesSelect<ExtArgs> | null
    /**
     * Filter, which invUniqueNames to fetch.
     */
    where?: invUniqueNamesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of invUniqueNames to fetch.
     */
    orderBy?: invUniqueNamesOrderByWithRelationInput | invUniqueNamesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing invUniqueNames.
     */
    cursor?: invUniqueNamesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` invUniqueNames from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` invUniqueNames.
     */
    skip?: number
    distinct?: InvUniqueNamesScalarFieldEnum | InvUniqueNamesScalarFieldEnum[]
  }


  /**
   * invUniqueNames create
   */
  export type invUniqueNamesCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the invUniqueNames
     */
    select?: invUniqueNamesSelect<ExtArgs> | null
    /**
     * The data needed to create a invUniqueNames.
     */
    data: XOR<invUniqueNamesCreateInput, invUniqueNamesUncheckedCreateInput>
  }


  /**
   * invUniqueNames createMany
   */
  export type invUniqueNamesCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many invUniqueNames.
     */
    data: invUniqueNamesCreateManyInput | invUniqueNamesCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * invUniqueNames update
   */
  export type invUniqueNamesUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the invUniqueNames
     */
    select?: invUniqueNamesSelect<ExtArgs> | null
    /**
     * The data needed to update a invUniqueNames.
     */
    data: XOR<invUniqueNamesUpdateInput, invUniqueNamesUncheckedUpdateInput>
    /**
     * Choose, which invUniqueNames to update.
     */
    where: invUniqueNamesWhereUniqueInput
  }


  /**
   * invUniqueNames updateMany
   */
  export type invUniqueNamesUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update invUniqueNames.
     */
    data: XOR<invUniqueNamesUpdateManyMutationInput, invUniqueNamesUncheckedUpdateManyInput>
    /**
     * Filter which invUniqueNames to update
     */
    where?: invUniqueNamesWhereInput
  }


  /**
   * invUniqueNames upsert
   */
  export type invUniqueNamesUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the invUniqueNames
     */
    select?: invUniqueNamesSelect<ExtArgs> | null
    /**
     * The filter to search for the invUniqueNames to update in case it exists.
     */
    where: invUniqueNamesWhereUniqueInput
    /**
     * In case the invUniqueNames found by the `where` argument doesn't exist, create a new invUniqueNames with this data.
     */
    create: XOR<invUniqueNamesCreateInput, invUniqueNamesUncheckedCreateInput>
    /**
     * In case the invUniqueNames was found with the provided `where` argument, update it with this data.
     */
    update: XOR<invUniqueNamesUpdateInput, invUniqueNamesUncheckedUpdateInput>
  }


  /**
   * invUniqueNames delete
   */
  export type invUniqueNamesDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the invUniqueNames
     */
    select?: invUniqueNamesSelect<ExtArgs> | null
    /**
     * Filter which invUniqueNames to delete.
     */
    where: invUniqueNamesWhereUniqueInput
  }


  /**
   * invUniqueNames deleteMany
   */
  export type invUniqueNamesDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which invUniqueNames to delete
     */
    where?: invUniqueNamesWhereInput
  }


  /**
   * invUniqueNames without action
   */
  export type invUniqueNamesDefaultArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the invUniqueNames
     */
    select?: invUniqueNamesSelect<ExtArgs> | null
  }



  /**
   * Model invVolumes
   */

  export type AggregateInvVolumes = {
    _count: InvVolumesCountAggregateOutputType | null
    _avg: InvVolumesAvgAggregateOutputType | null
    _sum: InvVolumesSumAggregateOutputType | null
    _min: InvVolumesMinAggregateOutputType | null
    _max: InvVolumesMaxAggregateOutputType | null
  }

  export type InvVolumesAvgAggregateOutputType = {
    typeID: number | null
    volume: number | null
  }

  export type InvVolumesSumAggregateOutputType = {
    typeID: number | null
    volume: number | null
  }

  export type InvVolumesMinAggregateOutputType = {
    typeID: number | null
    volume: number | null
  }

  export type InvVolumesMaxAggregateOutputType = {
    typeID: number | null
    volume: number | null
  }

  export type InvVolumesCountAggregateOutputType = {
    typeID: number
    volume: number
    _all: number
  }


  export type InvVolumesAvgAggregateInputType = {
    typeID?: true
    volume?: true
  }

  export type InvVolumesSumAggregateInputType = {
    typeID?: true
    volume?: true
  }

  export type InvVolumesMinAggregateInputType = {
    typeID?: true
    volume?: true
  }

  export type InvVolumesMaxAggregateInputType = {
    typeID?: true
    volume?: true
  }

  export type InvVolumesCountAggregateInputType = {
    typeID?: true
    volume?: true
    _all?: true
  }

  export type InvVolumesAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which invVolumes to aggregate.
     */
    where?: invVolumesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of invVolumes to fetch.
     */
    orderBy?: invVolumesOrderByWithRelationInput | invVolumesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: invVolumesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` invVolumes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` invVolumes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned invVolumes
    **/
    _count?: true | InvVolumesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: InvVolumesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: InvVolumesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: InvVolumesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: InvVolumesMaxAggregateInputType
  }

  export type GetInvVolumesAggregateType<T extends InvVolumesAggregateArgs> = {
        [P in keyof T & keyof AggregateInvVolumes]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInvVolumes[P]>
      : GetScalarType<T[P], AggregateInvVolumes[P]>
  }




  export type invVolumesGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: invVolumesWhereInput
    orderBy?: invVolumesOrderByWithAggregationInput | invVolumesOrderByWithAggregationInput[]
    by: InvVolumesScalarFieldEnum[] | InvVolumesScalarFieldEnum
    having?: invVolumesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: InvVolumesCountAggregateInputType | true
    _avg?: InvVolumesAvgAggregateInputType
    _sum?: InvVolumesSumAggregateInputType
    _min?: InvVolumesMinAggregateInputType
    _max?: InvVolumesMaxAggregateInputType
  }

  export type InvVolumesGroupByOutputType = {
    typeID: number
    volume: number | null
    _count: InvVolumesCountAggregateOutputType | null
    _avg: InvVolumesAvgAggregateOutputType | null
    _sum: InvVolumesSumAggregateOutputType | null
    _min: InvVolumesMinAggregateOutputType | null
    _max: InvVolumesMaxAggregateOutputType | null
  }

  type GetInvVolumesGroupByPayload<T extends invVolumesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<InvVolumesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof InvVolumesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], InvVolumesGroupByOutputType[P]>
            : GetScalarType<T[P], InvVolumesGroupByOutputType[P]>
        }
      >
    >


  export type invVolumesSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    typeID?: boolean
    volume?: boolean
  }, ExtArgs["result"]["invVolumes"]>

  export type invVolumesSelectScalar = {
    typeID?: boolean
    volume?: boolean
  }


  export type $invVolumesPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    name: "invVolumes"
    objects: {}
    scalars: $Extensions.GetResult<{
      typeID: number
      volume: number | null
    }, ExtArgs["result"]["invVolumes"]>
    composites: {}
  }


  type invVolumesGetPayload<S extends boolean | null | undefined | invVolumesDefaultArgs> = $Result.GetResult<Prisma.$invVolumesPayload, S>

  type invVolumesCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<invVolumesFindManyArgs, 'select' | 'include'> & {
      select?: InvVolumesCountAggregateInputType | true
    }

  export interface invVolumesDelegate<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['invVolumes'], meta: { name: 'invVolumes' } }
    /**
     * Find zero or one InvVolumes that matches the filter.
     * @param {invVolumesFindUniqueArgs} args - Arguments to find a InvVolumes
     * @example
     * // Get one InvVolumes
     * const invVolumes = await prisma.invVolumes.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends invVolumesFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, invVolumesFindUniqueArgs<ExtArgs>>
    ): Prisma__invVolumesClient<$Result.GetResult<Prisma.$invVolumesPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one InvVolumes that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {invVolumesFindUniqueOrThrowArgs} args - Arguments to find a InvVolumes
     * @example
     * // Get one InvVolumes
     * const invVolumes = await prisma.invVolumes.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends invVolumesFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, invVolumesFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__invVolumesClient<$Result.GetResult<Prisma.$invVolumesPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first InvVolumes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {invVolumesFindFirstArgs} args - Arguments to find a InvVolumes
     * @example
     * // Get one InvVolumes
     * const invVolumes = await prisma.invVolumes.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends invVolumesFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, invVolumesFindFirstArgs<ExtArgs>>
    ): Prisma__invVolumesClient<$Result.GetResult<Prisma.$invVolumesPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first InvVolumes that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {invVolumesFindFirstOrThrowArgs} args - Arguments to find a InvVolumes
     * @example
     * // Get one InvVolumes
     * const invVolumes = await prisma.invVolumes.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends invVolumesFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, invVolumesFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__invVolumesClient<$Result.GetResult<Prisma.$invVolumesPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more InvVolumes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {invVolumesFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all InvVolumes
     * const invVolumes = await prisma.invVolumes.findMany()
     * 
     * // Get first 10 InvVolumes
     * const invVolumes = await prisma.invVolumes.findMany({ take: 10 })
     * 
     * // Only select the `typeID`
     * const invVolumesWithTypeIDOnly = await prisma.invVolumes.findMany({ select: { typeID: true } })
     * 
    **/
    findMany<T extends invVolumesFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, invVolumesFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$invVolumesPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a InvVolumes.
     * @param {invVolumesCreateArgs} args - Arguments to create a InvVolumes.
     * @example
     * // Create one InvVolumes
     * const InvVolumes = await prisma.invVolumes.create({
     *   data: {
     *     // ... data to create a InvVolumes
     *   }
     * })
     * 
    **/
    create<T extends invVolumesCreateArgs<ExtArgs>>(
      args: SelectSubset<T, invVolumesCreateArgs<ExtArgs>>
    ): Prisma__invVolumesClient<$Result.GetResult<Prisma.$invVolumesPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many InvVolumes.
     *     @param {invVolumesCreateManyArgs} args - Arguments to create many InvVolumes.
     *     @example
     *     // Create many InvVolumes
     *     const invVolumes = await prisma.invVolumes.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends invVolumesCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, invVolumesCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a InvVolumes.
     * @param {invVolumesDeleteArgs} args - Arguments to delete one InvVolumes.
     * @example
     * // Delete one InvVolumes
     * const InvVolumes = await prisma.invVolumes.delete({
     *   where: {
     *     // ... filter to delete one InvVolumes
     *   }
     * })
     * 
    **/
    delete<T extends invVolumesDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, invVolumesDeleteArgs<ExtArgs>>
    ): Prisma__invVolumesClient<$Result.GetResult<Prisma.$invVolumesPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one InvVolumes.
     * @param {invVolumesUpdateArgs} args - Arguments to update one InvVolumes.
     * @example
     * // Update one InvVolumes
     * const invVolumes = await prisma.invVolumes.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends invVolumesUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, invVolumesUpdateArgs<ExtArgs>>
    ): Prisma__invVolumesClient<$Result.GetResult<Prisma.$invVolumesPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more InvVolumes.
     * @param {invVolumesDeleteManyArgs} args - Arguments to filter InvVolumes to delete.
     * @example
     * // Delete a few InvVolumes
     * const { count } = await prisma.invVolumes.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends invVolumesDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, invVolumesDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more InvVolumes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {invVolumesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many InvVolumes
     * const invVolumes = await prisma.invVolumes.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends invVolumesUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, invVolumesUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one InvVolumes.
     * @param {invVolumesUpsertArgs} args - Arguments to update or create a InvVolumes.
     * @example
     * // Update or create a InvVolumes
     * const invVolumes = await prisma.invVolumes.upsert({
     *   create: {
     *     // ... data to create a InvVolumes
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the InvVolumes we want to update
     *   }
     * })
    **/
    upsert<T extends invVolumesUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, invVolumesUpsertArgs<ExtArgs>>
    ): Prisma__invVolumesClient<$Result.GetResult<Prisma.$invVolumesPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of InvVolumes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {invVolumesCountArgs} args - Arguments to filter InvVolumes to count.
     * @example
     * // Count the number of InvVolumes
     * const count = await prisma.invVolumes.count({
     *   where: {
     *     // ... the filter for the InvVolumes we want to count
     *   }
     * })
    **/
    count<T extends invVolumesCountArgs>(
      args?: Subset<T, invVolumesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], InvVolumesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a InvVolumes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvVolumesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends InvVolumesAggregateArgs>(args: Subset<T, InvVolumesAggregateArgs>): Prisma.PrismaPromise<GetInvVolumesAggregateType<T>>

    /**
     * Group by InvVolumes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {invVolumesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends invVolumesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: invVolumesGroupByArgs['orderBy'] }
        : { orderBy?: invVolumesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, invVolumesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInvVolumesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the invVolumes model
   */
  readonly fields: invVolumesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for invVolumes.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__invVolumesClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';


    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the invVolumes model
   */ 
  interface invVolumesFieldRefs {
    readonly typeID: FieldRef<"invVolumes", 'Int'>
    readonly volume: FieldRef<"invVolumes", 'Int'>
  }
    

  // Custom InputTypes

  /**
   * invVolumes findUnique
   */
  export type invVolumesFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the invVolumes
     */
    select?: invVolumesSelect<ExtArgs> | null
    /**
     * Filter, which invVolumes to fetch.
     */
    where: invVolumesWhereUniqueInput
  }


  /**
   * invVolumes findUniqueOrThrow
   */
  export type invVolumesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the invVolumes
     */
    select?: invVolumesSelect<ExtArgs> | null
    /**
     * Filter, which invVolumes to fetch.
     */
    where: invVolumesWhereUniqueInput
  }


  /**
   * invVolumes findFirst
   */
  export type invVolumesFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the invVolumes
     */
    select?: invVolumesSelect<ExtArgs> | null
    /**
     * Filter, which invVolumes to fetch.
     */
    where?: invVolumesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of invVolumes to fetch.
     */
    orderBy?: invVolumesOrderByWithRelationInput | invVolumesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for invVolumes.
     */
    cursor?: invVolumesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` invVolumes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` invVolumes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of invVolumes.
     */
    distinct?: InvVolumesScalarFieldEnum | InvVolumesScalarFieldEnum[]
  }


  /**
   * invVolumes findFirstOrThrow
   */
  export type invVolumesFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the invVolumes
     */
    select?: invVolumesSelect<ExtArgs> | null
    /**
     * Filter, which invVolumes to fetch.
     */
    where?: invVolumesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of invVolumes to fetch.
     */
    orderBy?: invVolumesOrderByWithRelationInput | invVolumesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for invVolumes.
     */
    cursor?: invVolumesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` invVolumes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` invVolumes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of invVolumes.
     */
    distinct?: InvVolumesScalarFieldEnum | InvVolumesScalarFieldEnum[]
  }


  /**
   * invVolumes findMany
   */
  export type invVolumesFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the invVolumes
     */
    select?: invVolumesSelect<ExtArgs> | null
    /**
     * Filter, which invVolumes to fetch.
     */
    where?: invVolumesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of invVolumes to fetch.
     */
    orderBy?: invVolumesOrderByWithRelationInput | invVolumesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing invVolumes.
     */
    cursor?: invVolumesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` invVolumes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` invVolumes.
     */
    skip?: number
    distinct?: InvVolumesScalarFieldEnum | InvVolumesScalarFieldEnum[]
  }


  /**
   * invVolumes create
   */
  export type invVolumesCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the invVolumes
     */
    select?: invVolumesSelect<ExtArgs> | null
    /**
     * The data needed to create a invVolumes.
     */
    data: XOR<invVolumesCreateInput, invVolumesUncheckedCreateInput>
  }


  /**
   * invVolumes createMany
   */
  export type invVolumesCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many invVolumes.
     */
    data: invVolumesCreateManyInput | invVolumesCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * invVolumes update
   */
  export type invVolumesUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the invVolumes
     */
    select?: invVolumesSelect<ExtArgs> | null
    /**
     * The data needed to update a invVolumes.
     */
    data: XOR<invVolumesUpdateInput, invVolumesUncheckedUpdateInput>
    /**
     * Choose, which invVolumes to update.
     */
    where: invVolumesWhereUniqueInput
  }


  /**
   * invVolumes updateMany
   */
  export type invVolumesUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update invVolumes.
     */
    data: XOR<invVolumesUpdateManyMutationInput, invVolumesUncheckedUpdateManyInput>
    /**
     * Filter which invVolumes to update
     */
    where?: invVolumesWhereInput
  }


  /**
   * invVolumes upsert
   */
  export type invVolumesUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the invVolumes
     */
    select?: invVolumesSelect<ExtArgs> | null
    /**
     * The filter to search for the invVolumes to update in case it exists.
     */
    where: invVolumesWhereUniqueInput
    /**
     * In case the invVolumes found by the `where` argument doesn't exist, create a new invVolumes with this data.
     */
    create: XOR<invVolumesCreateInput, invVolumesUncheckedCreateInput>
    /**
     * In case the invVolumes was found with the provided `where` argument, update it with this data.
     */
    update: XOR<invVolumesUpdateInput, invVolumesUncheckedUpdateInput>
  }


  /**
   * invVolumes delete
   */
  export type invVolumesDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the invVolumes
     */
    select?: invVolumesSelect<ExtArgs> | null
    /**
     * Filter which invVolumes to delete.
     */
    where: invVolumesWhereUniqueInput
  }


  /**
   * invVolumes deleteMany
   */
  export type invVolumesDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which invVolumes to delete
     */
    where?: invVolumesWhereInput
  }


  /**
   * invVolumes without action
   */
  export type invVolumesDefaultArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the invVolumes
     */
    select?: invVolumesSelect<ExtArgs> | null
  }



  /**
   * Model mapCelestialGraphics
   */

  export type AggregateMapCelestialGraphics = {
    _count: MapCelestialGraphicsCountAggregateOutputType | null
    _avg: MapCelestialGraphicsAvgAggregateOutputType | null
    _sum: MapCelestialGraphicsSumAggregateOutputType | null
    _min: MapCelestialGraphicsMinAggregateOutputType | null
    _max: MapCelestialGraphicsMaxAggregateOutputType | null
  }

  export type MapCelestialGraphicsAvgAggregateOutputType = {
    celestialID: number | null
    heightMap1: number | null
    heightMap2: number | null
    shaderPreset: number | null
  }

  export type MapCelestialGraphicsSumAggregateOutputType = {
    celestialID: number | null
    heightMap1: number | null
    heightMap2: number | null
    shaderPreset: number | null
  }

  export type MapCelestialGraphicsMinAggregateOutputType = {
    celestialID: number | null
    heightMap1: number | null
    heightMap2: number | null
    shaderPreset: number | null
    population: boolean | null
  }

  export type MapCelestialGraphicsMaxAggregateOutputType = {
    celestialID: number | null
    heightMap1: number | null
    heightMap2: number | null
    shaderPreset: number | null
    population: boolean | null
  }

  export type MapCelestialGraphicsCountAggregateOutputType = {
    celestialID: number
    heightMap1: number
    heightMap2: number
    shaderPreset: number
    population: number
    _all: number
  }


  export type MapCelestialGraphicsAvgAggregateInputType = {
    celestialID?: true
    heightMap1?: true
    heightMap2?: true
    shaderPreset?: true
  }

  export type MapCelestialGraphicsSumAggregateInputType = {
    celestialID?: true
    heightMap1?: true
    heightMap2?: true
    shaderPreset?: true
  }

  export type MapCelestialGraphicsMinAggregateInputType = {
    celestialID?: true
    heightMap1?: true
    heightMap2?: true
    shaderPreset?: true
    population?: true
  }

  export type MapCelestialGraphicsMaxAggregateInputType = {
    celestialID?: true
    heightMap1?: true
    heightMap2?: true
    shaderPreset?: true
    population?: true
  }

  export type MapCelestialGraphicsCountAggregateInputType = {
    celestialID?: true
    heightMap1?: true
    heightMap2?: true
    shaderPreset?: true
    population?: true
    _all?: true
  }

  export type MapCelestialGraphicsAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which mapCelestialGraphics to aggregate.
     */
    where?: mapCelestialGraphicsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of mapCelestialGraphics to fetch.
     */
    orderBy?: mapCelestialGraphicsOrderByWithRelationInput | mapCelestialGraphicsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: mapCelestialGraphicsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` mapCelestialGraphics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` mapCelestialGraphics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned mapCelestialGraphics
    **/
    _count?: true | MapCelestialGraphicsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MapCelestialGraphicsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MapCelestialGraphicsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MapCelestialGraphicsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MapCelestialGraphicsMaxAggregateInputType
  }

  export type GetMapCelestialGraphicsAggregateType<T extends MapCelestialGraphicsAggregateArgs> = {
        [P in keyof T & keyof AggregateMapCelestialGraphics]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMapCelestialGraphics[P]>
      : GetScalarType<T[P], AggregateMapCelestialGraphics[P]>
  }




  export type mapCelestialGraphicsGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: mapCelestialGraphicsWhereInput
    orderBy?: mapCelestialGraphicsOrderByWithAggregationInput | mapCelestialGraphicsOrderByWithAggregationInput[]
    by: MapCelestialGraphicsScalarFieldEnum[] | MapCelestialGraphicsScalarFieldEnum
    having?: mapCelestialGraphicsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MapCelestialGraphicsCountAggregateInputType | true
    _avg?: MapCelestialGraphicsAvgAggregateInputType
    _sum?: MapCelestialGraphicsSumAggregateInputType
    _min?: MapCelestialGraphicsMinAggregateInputType
    _max?: MapCelestialGraphicsMaxAggregateInputType
  }

  export type MapCelestialGraphicsGroupByOutputType = {
    celestialID: number
    heightMap1: number | null
    heightMap2: number | null
    shaderPreset: number | null
    population: boolean | null
    _count: MapCelestialGraphicsCountAggregateOutputType | null
    _avg: MapCelestialGraphicsAvgAggregateOutputType | null
    _sum: MapCelestialGraphicsSumAggregateOutputType | null
    _min: MapCelestialGraphicsMinAggregateOutputType | null
    _max: MapCelestialGraphicsMaxAggregateOutputType | null
  }

  type GetMapCelestialGraphicsGroupByPayload<T extends mapCelestialGraphicsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MapCelestialGraphicsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MapCelestialGraphicsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MapCelestialGraphicsGroupByOutputType[P]>
            : GetScalarType<T[P], MapCelestialGraphicsGroupByOutputType[P]>
        }
      >
    >


  export type mapCelestialGraphicsSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    celestialID?: boolean
    heightMap1?: boolean
    heightMap2?: boolean
    shaderPreset?: boolean
    population?: boolean
  }, ExtArgs["result"]["mapCelestialGraphics"]>

  export type mapCelestialGraphicsSelectScalar = {
    celestialID?: boolean
    heightMap1?: boolean
    heightMap2?: boolean
    shaderPreset?: boolean
    population?: boolean
  }


  export type $mapCelestialGraphicsPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    name: "mapCelestialGraphics"
    objects: {}
    scalars: $Extensions.GetResult<{
      celestialID: number
      heightMap1: number | null
      heightMap2: number | null
      shaderPreset: number | null
      population: boolean | null
    }, ExtArgs["result"]["mapCelestialGraphics"]>
    composites: {}
  }


  type mapCelestialGraphicsGetPayload<S extends boolean | null | undefined | mapCelestialGraphicsDefaultArgs> = $Result.GetResult<Prisma.$mapCelestialGraphicsPayload, S>

  type mapCelestialGraphicsCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<mapCelestialGraphicsFindManyArgs, 'select' | 'include'> & {
      select?: MapCelestialGraphicsCountAggregateInputType | true
    }

  export interface mapCelestialGraphicsDelegate<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['mapCelestialGraphics'], meta: { name: 'mapCelestialGraphics' } }
    /**
     * Find zero or one MapCelestialGraphics that matches the filter.
     * @param {mapCelestialGraphicsFindUniqueArgs} args - Arguments to find a MapCelestialGraphics
     * @example
     * // Get one MapCelestialGraphics
     * const mapCelestialGraphics = await prisma.mapCelestialGraphics.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends mapCelestialGraphicsFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, mapCelestialGraphicsFindUniqueArgs<ExtArgs>>
    ): Prisma__mapCelestialGraphicsClient<$Result.GetResult<Prisma.$mapCelestialGraphicsPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one MapCelestialGraphics that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {mapCelestialGraphicsFindUniqueOrThrowArgs} args - Arguments to find a MapCelestialGraphics
     * @example
     * // Get one MapCelestialGraphics
     * const mapCelestialGraphics = await prisma.mapCelestialGraphics.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends mapCelestialGraphicsFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, mapCelestialGraphicsFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__mapCelestialGraphicsClient<$Result.GetResult<Prisma.$mapCelestialGraphicsPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first MapCelestialGraphics that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {mapCelestialGraphicsFindFirstArgs} args - Arguments to find a MapCelestialGraphics
     * @example
     * // Get one MapCelestialGraphics
     * const mapCelestialGraphics = await prisma.mapCelestialGraphics.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends mapCelestialGraphicsFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, mapCelestialGraphicsFindFirstArgs<ExtArgs>>
    ): Prisma__mapCelestialGraphicsClient<$Result.GetResult<Prisma.$mapCelestialGraphicsPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first MapCelestialGraphics that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {mapCelestialGraphicsFindFirstOrThrowArgs} args - Arguments to find a MapCelestialGraphics
     * @example
     * // Get one MapCelestialGraphics
     * const mapCelestialGraphics = await prisma.mapCelestialGraphics.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends mapCelestialGraphicsFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, mapCelestialGraphicsFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__mapCelestialGraphicsClient<$Result.GetResult<Prisma.$mapCelestialGraphicsPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more MapCelestialGraphics that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {mapCelestialGraphicsFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MapCelestialGraphics
     * const mapCelestialGraphics = await prisma.mapCelestialGraphics.findMany()
     * 
     * // Get first 10 MapCelestialGraphics
     * const mapCelestialGraphics = await prisma.mapCelestialGraphics.findMany({ take: 10 })
     * 
     * // Only select the `celestialID`
     * const mapCelestialGraphicsWithCelestialIDOnly = await prisma.mapCelestialGraphics.findMany({ select: { celestialID: true } })
     * 
    **/
    findMany<T extends mapCelestialGraphicsFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, mapCelestialGraphicsFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$mapCelestialGraphicsPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a MapCelestialGraphics.
     * @param {mapCelestialGraphicsCreateArgs} args - Arguments to create a MapCelestialGraphics.
     * @example
     * // Create one MapCelestialGraphics
     * const MapCelestialGraphics = await prisma.mapCelestialGraphics.create({
     *   data: {
     *     // ... data to create a MapCelestialGraphics
     *   }
     * })
     * 
    **/
    create<T extends mapCelestialGraphicsCreateArgs<ExtArgs>>(
      args: SelectSubset<T, mapCelestialGraphicsCreateArgs<ExtArgs>>
    ): Prisma__mapCelestialGraphicsClient<$Result.GetResult<Prisma.$mapCelestialGraphicsPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many MapCelestialGraphics.
     *     @param {mapCelestialGraphicsCreateManyArgs} args - Arguments to create many MapCelestialGraphics.
     *     @example
     *     // Create many MapCelestialGraphics
     *     const mapCelestialGraphics = await prisma.mapCelestialGraphics.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends mapCelestialGraphicsCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, mapCelestialGraphicsCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a MapCelestialGraphics.
     * @param {mapCelestialGraphicsDeleteArgs} args - Arguments to delete one MapCelestialGraphics.
     * @example
     * // Delete one MapCelestialGraphics
     * const MapCelestialGraphics = await prisma.mapCelestialGraphics.delete({
     *   where: {
     *     // ... filter to delete one MapCelestialGraphics
     *   }
     * })
     * 
    **/
    delete<T extends mapCelestialGraphicsDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, mapCelestialGraphicsDeleteArgs<ExtArgs>>
    ): Prisma__mapCelestialGraphicsClient<$Result.GetResult<Prisma.$mapCelestialGraphicsPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one MapCelestialGraphics.
     * @param {mapCelestialGraphicsUpdateArgs} args - Arguments to update one MapCelestialGraphics.
     * @example
     * // Update one MapCelestialGraphics
     * const mapCelestialGraphics = await prisma.mapCelestialGraphics.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends mapCelestialGraphicsUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, mapCelestialGraphicsUpdateArgs<ExtArgs>>
    ): Prisma__mapCelestialGraphicsClient<$Result.GetResult<Prisma.$mapCelestialGraphicsPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more MapCelestialGraphics.
     * @param {mapCelestialGraphicsDeleteManyArgs} args - Arguments to filter MapCelestialGraphics to delete.
     * @example
     * // Delete a few MapCelestialGraphics
     * const { count } = await prisma.mapCelestialGraphics.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends mapCelestialGraphicsDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, mapCelestialGraphicsDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MapCelestialGraphics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {mapCelestialGraphicsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MapCelestialGraphics
     * const mapCelestialGraphics = await prisma.mapCelestialGraphics.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends mapCelestialGraphicsUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, mapCelestialGraphicsUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one MapCelestialGraphics.
     * @param {mapCelestialGraphicsUpsertArgs} args - Arguments to update or create a MapCelestialGraphics.
     * @example
     * // Update or create a MapCelestialGraphics
     * const mapCelestialGraphics = await prisma.mapCelestialGraphics.upsert({
     *   create: {
     *     // ... data to create a MapCelestialGraphics
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MapCelestialGraphics we want to update
     *   }
     * })
    **/
    upsert<T extends mapCelestialGraphicsUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, mapCelestialGraphicsUpsertArgs<ExtArgs>>
    ): Prisma__mapCelestialGraphicsClient<$Result.GetResult<Prisma.$mapCelestialGraphicsPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of MapCelestialGraphics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {mapCelestialGraphicsCountArgs} args - Arguments to filter MapCelestialGraphics to count.
     * @example
     * // Count the number of MapCelestialGraphics
     * const count = await prisma.mapCelestialGraphics.count({
     *   where: {
     *     // ... the filter for the MapCelestialGraphics we want to count
     *   }
     * })
    **/
    count<T extends mapCelestialGraphicsCountArgs>(
      args?: Subset<T, mapCelestialGraphicsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MapCelestialGraphicsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MapCelestialGraphics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MapCelestialGraphicsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MapCelestialGraphicsAggregateArgs>(args: Subset<T, MapCelestialGraphicsAggregateArgs>): Prisma.PrismaPromise<GetMapCelestialGraphicsAggregateType<T>>

    /**
     * Group by MapCelestialGraphics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {mapCelestialGraphicsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends mapCelestialGraphicsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: mapCelestialGraphicsGroupByArgs['orderBy'] }
        : { orderBy?: mapCelestialGraphicsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, mapCelestialGraphicsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMapCelestialGraphicsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the mapCelestialGraphics model
   */
  readonly fields: mapCelestialGraphicsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for mapCelestialGraphics.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__mapCelestialGraphicsClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';


    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the mapCelestialGraphics model
   */ 
  interface mapCelestialGraphicsFieldRefs {
    readonly celestialID: FieldRef<"mapCelestialGraphics", 'Int'>
    readonly heightMap1: FieldRef<"mapCelestialGraphics", 'Int'>
    readonly heightMap2: FieldRef<"mapCelestialGraphics", 'Int'>
    readonly shaderPreset: FieldRef<"mapCelestialGraphics", 'Int'>
    readonly population: FieldRef<"mapCelestialGraphics", 'Boolean'>
  }
    

  // Custom InputTypes

  /**
   * mapCelestialGraphics findUnique
   */
  export type mapCelestialGraphicsFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the mapCelestialGraphics
     */
    select?: mapCelestialGraphicsSelect<ExtArgs> | null
    /**
     * Filter, which mapCelestialGraphics to fetch.
     */
    where: mapCelestialGraphicsWhereUniqueInput
  }


  /**
   * mapCelestialGraphics findUniqueOrThrow
   */
  export type mapCelestialGraphicsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the mapCelestialGraphics
     */
    select?: mapCelestialGraphicsSelect<ExtArgs> | null
    /**
     * Filter, which mapCelestialGraphics to fetch.
     */
    where: mapCelestialGraphicsWhereUniqueInput
  }


  /**
   * mapCelestialGraphics findFirst
   */
  export type mapCelestialGraphicsFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the mapCelestialGraphics
     */
    select?: mapCelestialGraphicsSelect<ExtArgs> | null
    /**
     * Filter, which mapCelestialGraphics to fetch.
     */
    where?: mapCelestialGraphicsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of mapCelestialGraphics to fetch.
     */
    orderBy?: mapCelestialGraphicsOrderByWithRelationInput | mapCelestialGraphicsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for mapCelestialGraphics.
     */
    cursor?: mapCelestialGraphicsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` mapCelestialGraphics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` mapCelestialGraphics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of mapCelestialGraphics.
     */
    distinct?: MapCelestialGraphicsScalarFieldEnum | MapCelestialGraphicsScalarFieldEnum[]
  }


  /**
   * mapCelestialGraphics findFirstOrThrow
   */
  export type mapCelestialGraphicsFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the mapCelestialGraphics
     */
    select?: mapCelestialGraphicsSelect<ExtArgs> | null
    /**
     * Filter, which mapCelestialGraphics to fetch.
     */
    where?: mapCelestialGraphicsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of mapCelestialGraphics to fetch.
     */
    orderBy?: mapCelestialGraphicsOrderByWithRelationInput | mapCelestialGraphicsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for mapCelestialGraphics.
     */
    cursor?: mapCelestialGraphicsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` mapCelestialGraphics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` mapCelestialGraphics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of mapCelestialGraphics.
     */
    distinct?: MapCelestialGraphicsScalarFieldEnum | MapCelestialGraphicsScalarFieldEnum[]
  }


  /**
   * mapCelestialGraphics findMany
   */
  export type mapCelestialGraphicsFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the mapCelestialGraphics
     */
    select?: mapCelestialGraphicsSelect<ExtArgs> | null
    /**
     * Filter, which mapCelestialGraphics to fetch.
     */
    where?: mapCelestialGraphicsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of mapCelestialGraphics to fetch.
     */
    orderBy?: mapCelestialGraphicsOrderByWithRelationInput | mapCelestialGraphicsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing mapCelestialGraphics.
     */
    cursor?: mapCelestialGraphicsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` mapCelestialGraphics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` mapCelestialGraphics.
     */
    skip?: number
    distinct?: MapCelestialGraphicsScalarFieldEnum | MapCelestialGraphicsScalarFieldEnum[]
  }


  /**
   * mapCelestialGraphics create
   */
  export type mapCelestialGraphicsCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the mapCelestialGraphics
     */
    select?: mapCelestialGraphicsSelect<ExtArgs> | null
    /**
     * The data needed to create a mapCelestialGraphics.
     */
    data: XOR<mapCelestialGraphicsCreateInput, mapCelestialGraphicsUncheckedCreateInput>
  }


  /**
   * mapCelestialGraphics createMany
   */
  export type mapCelestialGraphicsCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many mapCelestialGraphics.
     */
    data: mapCelestialGraphicsCreateManyInput | mapCelestialGraphicsCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * mapCelestialGraphics update
   */
  export type mapCelestialGraphicsUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the mapCelestialGraphics
     */
    select?: mapCelestialGraphicsSelect<ExtArgs> | null
    /**
     * The data needed to update a mapCelestialGraphics.
     */
    data: XOR<mapCelestialGraphicsUpdateInput, mapCelestialGraphicsUncheckedUpdateInput>
    /**
     * Choose, which mapCelestialGraphics to update.
     */
    where: mapCelestialGraphicsWhereUniqueInput
  }


  /**
   * mapCelestialGraphics updateMany
   */
  export type mapCelestialGraphicsUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update mapCelestialGraphics.
     */
    data: XOR<mapCelestialGraphicsUpdateManyMutationInput, mapCelestialGraphicsUncheckedUpdateManyInput>
    /**
     * Filter which mapCelestialGraphics to update
     */
    where?: mapCelestialGraphicsWhereInput
  }


  /**
   * mapCelestialGraphics upsert
   */
  export type mapCelestialGraphicsUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the mapCelestialGraphics
     */
    select?: mapCelestialGraphicsSelect<ExtArgs> | null
    /**
     * The filter to search for the mapCelestialGraphics to update in case it exists.
     */
    where: mapCelestialGraphicsWhereUniqueInput
    /**
     * In case the mapCelestialGraphics found by the `where` argument doesn't exist, create a new mapCelestialGraphics with this data.
     */
    create: XOR<mapCelestialGraphicsCreateInput, mapCelestialGraphicsUncheckedCreateInput>
    /**
     * In case the mapCelestialGraphics was found with the provided `where` argument, update it with this data.
     */
    update: XOR<mapCelestialGraphicsUpdateInput, mapCelestialGraphicsUncheckedUpdateInput>
  }


  /**
   * mapCelestialGraphics delete
   */
  export type mapCelestialGraphicsDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the mapCelestialGraphics
     */
    select?: mapCelestialGraphicsSelect<ExtArgs> | null
    /**
     * Filter which mapCelestialGraphics to delete.
     */
    where: mapCelestialGraphicsWhereUniqueInput
  }


  /**
   * mapCelestialGraphics deleteMany
   */
  export type mapCelestialGraphicsDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which mapCelestialGraphics to delete
     */
    where?: mapCelestialGraphicsWhereInput
  }


  /**
   * mapCelestialGraphics without action
   */
  export type mapCelestialGraphicsDefaultArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the mapCelestialGraphics
     */
    select?: mapCelestialGraphicsSelect<ExtArgs> | null
  }



  /**
   * Model mapCelestialStatistics
   */

  export type AggregateMapCelestialStatistics = {
    _count: MapCelestialStatisticsCountAggregateOutputType | null
    _avg: MapCelestialStatisticsAvgAggregateOutputType | null
    _sum: MapCelestialStatisticsSumAggregateOutputType | null
    _min: MapCelestialStatisticsMinAggregateOutputType | null
    _max: MapCelestialStatisticsMaxAggregateOutputType | null
  }

  export type MapCelestialStatisticsAvgAggregateOutputType = {
    celestialID: number | null
    temperature: number | null
    luminosity: number | null
    age: number | null
    life: number | null
    orbitRadius: number | null
    eccentricity: number | null
    massDust: number | null
    massGas: number | null
    density: number | null
    surfaceGravity: number | null
    escapeVelocity: number | null
    orbitPeriod: number | null
    rotationRate: number | null
    pressure: number | null
    radius: number | null
    mass: number | null
  }

  export type MapCelestialStatisticsSumAggregateOutputType = {
    celestialID: number | null
    temperature: number | null
    luminosity: number | null
    age: number | null
    life: number | null
    orbitRadius: number | null
    eccentricity: number | null
    massDust: number | null
    massGas: number | null
    density: number | null
    surfaceGravity: number | null
    escapeVelocity: number | null
    orbitPeriod: number | null
    rotationRate: number | null
    pressure: number | null
    radius: number | null
    mass: number | null
  }

  export type MapCelestialStatisticsMinAggregateOutputType = {
    celestialID: number | null
    temperature: number | null
    spectralClass: string | null
    luminosity: number | null
    age: number | null
    life: number | null
    orbitRadius: number | null
    eccentricity: number | null
    massDust: number | null
    massGas: number | null
    fragmented: boolean | null
    density: number | null
    surfaceGravity: number | null
    escapeVelocity: number | null
    orbitPeriod: number | null
    rotationRate: number | null
    locked: boolean | null
    pressure: number | null
    radius: number | null
    mass: number | null
  }

  export type MapCelestialStatisticsMaxAggregateOutputType = {
    celestialID: number | null
    temperature: number | null
    spectralClass: string | null
    luminosity: number | null
    age: number | null
    life: number | null
    orbitRadius: number | null
    eccentricity: number | null
    massDust: number | null
    massGas: number | null
    fragmented: boolean | null
    density: number | null
    surfaceGravity: number | null
    escapeVelocity: number | null
    orbitPeriod: number | null
    rotationRate: number | null
    locked: boolean | null
    pressure: number | null
    radius: number | null
    mass: number | null
  }

  export type MapCelestialStatisticsCountAggregateOutputType = {
    celestialID: number
    temperature: number
    spectralClass: number
    luminosity: number
    age: number
    life: number
    orbitRadius: number
    eccentricity: number
    massDust: number
    massGas: number
    fragmented: number
    density: number
    surfaceGravity: number
    escapeVelocity: number
    orbitPeriod: number
    rotationRate: number
    locked: number
    pressure: number
    radius: number
    mass: number
    _all: number
  }


  export type MapCelestialStatisticsAvgAggregateInputType = {
    celestialID?: true
    temperature?: true
    luminosity?: true
    age?: true
    life?: true
    orbitRadius?: true
    eccentricity?: true
    massDust?: true
    massGas?: true
    density?: true
    surfaceGravity?: true
    escapeVelocity?: true
    orbitPeriod?: true
    rotationRate?: true
    pressure?: true
    radius?: true
    mass?: true
  }

  export type MapCelestialStatisticsSumAggregateInputType = {
    celestialID?: true
    temperature?: true
    luminosity?: true
    age?: true
    life?: true
    orbitRadius?: true
    eccentricity?: true
    massDust?: true
    massGas?: true
    density?: true
    surfaceGravity?: true
    escapeVelocity?: true
    orbitPeriod?: true
    rotationRate?: true
    pressure?: true
    radius?: true
    mass?: true
  }

  export type MapCelestialStatisticsMinAggregateInputType = {
    celestialID?: true
    temperature?: true
    spectralClass?: true
    luminosity?: true
    age?: true
    life?: true
    orbitRadius?: true
    eccentricity?: true
    massDust?: true
    massGas?: true
    fragmented?: true
    density?: true
    surfaceGravity?: true
    escapeVelocity?: true
    orbitPeriod?: true
    rotationRate?: true
    locked?: true
    pressure?: true
    radius?: true
    mass?: true
  }

  export type MapCelestialStatisticsMaxAggregateInputType = {
    celestialID?: true
    temperature?: true
    spectralClass?: true
    luminosity?: true
    age?: true
    life?: true
    orbitRadius?: true
    eccentricity?: true
    massDust?: true
    massGas?: true
    fragmented?: true
    density?: true
    surfaceGravity?: true
    escapeVelocity?: true
    orbitPeriod?: true
    rotationRate?: true
    locked?: true
    pressure?: true
    radius?: true
    mass?: true
  }

  export type MapCelestialStatisticsCountAggregateInputType = {
    celestialID?: true
    temperature?: true
    spectralClass?: true
    luminosity?: true
    age?: true
    life?: true
    orbitRadius?: true
    eccentricity?: true
    massDust?: true
    massGas?: true
    fragmented?: true
    density?: true
    surfaceGravity?: true
    escapeVelocity?: true
    orbitPeriod?: true
    rotationRate?: true
    locked?: true
    pressure?: true
    radius?: true
    mass?: true
    _all?: true
  }

  export type MapCelestialStatisticsAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which mapCelestialStatistics to aggregate.
     */
    where?: mapCelestialStatisticsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of mapCelestialStatistics to fetch.
     */
    orderBy?: mapCelestialStatisticsOrderByWithRelationInput | mapCelestialStatisticsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: mapCelestialStatisticsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` mapCelestialStatistics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` mapCelestialStatistics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned mapCelestialStatistics
    **/
    _count?: true | MapCelestialStatisticsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MapCelestialStatisticsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MapCelestialStatisticsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MapCelestialStatisticsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MapCelestialStatisticsMaxAggregateInputType
  }

  export type GetMapCelestialStatisticsAggregateType<T extends MapCelestialStatisticsAggregateArgs> = {
        [P in keyof T & keyof AggregateMapCelestialStatistics]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMapCelestialStatistics[P]>
      : GetScalarType<T[P], AggregateMapCelestialStatistics[P]>
  }




  export type mapCelestialStatisticsGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: mapCelestialStatisticsWhereInput
    orderBy?: mapCelestialStatisticsOrderByWithAggregationInput | mapCelestialStatisticsOrderByWithAggregationInput[]
    by: MapCelestialStatisticsScalarFieldEnum[] | MapCelestialStatisticsScalarFieldEnum
    having?: mapCelestialStatisticsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MapCelestialStatisticsCountAggregateInputType | true
    _avg?: MapCelestialStatisticsAvgAggregateInputType
    _sum?: MapCelestialStatisticsSumAggregateInputType
    _min?: MapCelestialStatisticsMinAggregateInputType
    _max?: MapCelestialStatisticsMaxAggregateInputType
  }

  export type MapCelestialStatisticsGroupByOutputType = {
    celestialID: number
    temperature: number | null
    spectralClass: string | null
    luminosity: number | null
    age: number | null
    life: number | null
    orbitRadius: number | null
    eccentricity: number | null
    massDust: number | null
    massGas: number | null
    fragmented: boolean | null
    density: number | null
    surfaceGravity: number | null
    escapeVelocity: number | null
    orbitPeriod: number | null
    rotationRate: number | null
    locked: boolean | null
    pressure: number | null
    radius: number | null
    mass: number | null
    _count: MapCelestialStatisticsCountAggregateOutputType | null
    _avg: MapCelestialStatisticsAvgAggregateOutputType | null
    _sum: MapCelestialStatisticsSumAggregateOutputType | null
    _min: MapCelestialStatisticsMinAggregateOutputType | null
    _max: MapCelestialStatisticsMaxAggregateOutputType | null
  }

  type GetMapCelestialStatisticsGroupByPayload<T extends mapCelestialStatisticsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MapCelestialStatisticsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MapCelestialStatisticsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MapCelestialStatisticsGroupByOutputType[P]>
            : GetScalarType<T[P], MapCelestialStatisticsGroupByOutputType[P]>
        }
      >
    >


  export type mapCelestialStatisticsSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    celestialID?: boolean
    temperature?: boolean
    spectralClass?: boolean
    luminosity?: boolean
    age?: boolean
    life?: boolean
    orbitRadius?: boolean
    eccentricity?: boolean
    massDust?: boolean
    massGas?: boolean
    fragmented?: boolean
    density?: boolean
    surfaceGravity?: boolean
    escapeVelocity?: boolean
    orbitPeriod?: boolean
    rotationRate?: boolean
    locked?: boolean
    pressure?: boolean
    radius?: boolean
    mass?: boolean
  }, ExtArgs["result"]["mapCelestialStatistics"]>

  export type mapCelestialStatisticsSelectScalar = {
    celestialID?: boolean
    temperature?: boolean
    spectralClass?: boolean
    luminosity?: boolean
    age?: boolean
    life?: boolean
    orbitRadius?: boolean
    eccentricity?: boolean
    massDust?: boolean
    massGas?: boolean
    fragmented?: boolean
    density?: boolean
    surfaceGravity?: boolean
    escapeVelocity?: boolean
    orbitPeriod?: boolean
    rotationRate?: boolean
    locked?: boolean
    pressure?: boolean
    radius?: boolean
    mass?: boolean
  }


  export type $mapCelestialStatisticsPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    name: "mapCelestialStatistics"
    objects: {}
    scalars: $Extensions.GetResult<{
      celestialID: number
      temperature: number | null
      spectralClass: string | null
      luminosity: number | null
      age: number | null
      life: number | null
      orbitRadius: number | null
      eccentricity: number | null
      massDust: number | null
      massGas: number | null
      fragmented: boolean | null
      density: number | null
      surfaceGravity: number | null
      escapeVelocity: number | null
      orbitPeriod: number | null
      rotationRate: number | null
      locked: boolean | null
      pressure: number | null
      radius: number | null
      mass: number | null
    }, ExtArgs["result"]["mapCelestialStatistics"]>
    composites: {}
  }


  type mapCelestialStatisticsGetPayload<S extends boolean | null | undefined | mapCelestialStatisticsDefaultArgs> = $Result.GetResult<Prisma.$mapCelestialStatisticsPayload, S>

  type mapCelestialStatisticsCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<mapCelestialStatisticsFindManyArgs, 'select' | 'include'> & {
      select?: MapCelestialStatisticsCountAggregateInputType | true
    }

  export interface mapCelestialStatisticsDelegate<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['mapCelestialStatistics'], meta: { name: 'mapCelestialStatistics' } }
    /**
     * Find zero or one MapCelestialStatistics that matches the filter.
     * @param {mapCelestialStatisticsFindUniqueArgs} args - Arguments to find a MapCelestialStatistics
     * @example
     * // Get one MapCelestialStatistics
     * const mapCelestialStatistics = await prisma.mapCelestialStatistics.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends mapCelestialStatisticsFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, mapCelestialStatisticsFindUniqueArgs<ExtArgs>>
    ): Prisma__mapCelestialStatisticsClient<$Result.GetResult<Prisma.$mapCelestialStatisticsPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one MapCelestialStatistics that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {mapCelestialStatisticsFindUniqueOrThrowArgs} args - Arguments to find a MapCelestialStatistics
     * @example
     * // Get one MapCelestialStatistics
     * const mapCelestialStatistics = await prisma.mapCelestialStatistics.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends mapCelestialStatisticsFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, mapCelestialStatisticsFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__mapCelestialStatisticsClient<$Result.GetResult<Prisma.$mapCelestialStatisticsPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first MapCelestialStatistics that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {mapCelestialStatisticsFindFirstArgs} args - Arguments to find a MapCelestialStatistics
     * @example
     * // Get one MapCelestialStatistics
     * const mapCelestialStatistics = await prisma.mapCelestialStatistics.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends mapCelestialStatisticsFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, mapCelestialStatisticsFindFirstArgs<ExtArgs>>
    ): Prisma__mapCelestialStatisticsClient<$Result.GetResult<Prisma.$mapCelestialStatisticsPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first MapCelestialStatistics that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {mapCelestialStatisticsFindFirstOrThrowArgs} args - Arguments to find a MapCelestialStatistics
     * @example
     * // Get one MapCelestialStatistics
     * const mapCelestialStatistics = await prisma.mapCelestialStatistics.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends mapCelestialStatisticsFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, mapCelestialStatisticsFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__mapCelestialStatisticsClient<$Result.GetResult<Prisma.$mapCelestialStatisticsPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more MapCelestialStatistics that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {mapCelestialStatisticsFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MapCelestialStatistics
     * const mapCelestialStatistics = await prisma.mapCelestialStatistics.findMany()
     * 
     * // Get first 10 MapCelestialStatistics
     * const mapCelestialStatistics = await prisma.mapCelestialStatistics.findMany({ take: 10 })
     * 
     * // Only select the `celestialID`
     * const mapCelestialStatisticsWithCelestialIDOnly = await prisma.mapCelestialStatistics.findMany({ select: { celestialID: true } })
     * 
    **/
    findMany<T extends mapCelestialStatisticsFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, mapCelestialStatisticsFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$mapCelestialStatisticsPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a MapCelestialStatistics.
     * @param {mapCelestialStatisticsCreateArgs} args - Arguments to create a MapCelestialStatistics.
     * @example
     * // Create one MapCelestialStatistics
     * const MapCelestialStatistics = await prisma.mapCelestialStatistics.create({
     *   data: {
     *     // ... data to create a MapCelestialStatistics
     *   }
     * })
     * 
    **/
    create<T extends mapCelestialStatisticsCreateArgs<ExtArgs>>(
      args: SelectSubset<T, mapCelestialStatisticsCreateArgs<ExtArgs>>
    ): Prisma__mapCelestialStatisticsClient<$Result.GetResult<Prisma.$mapCelestialStatisticsPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many MapCelestialStatistics.
     *     @param {mapCelestialStatisticsCreateManyArgs} args - Arguments to create many MapCelestialStatistics.
     *     @example
     *     // Create many MapCelestialStatistics
     *     const mapCelestialStatistics = await prisma.mapCelestialStatistics.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends mapCelestialStatisticsCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, mapCelestialStatisticsCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a MapCelestialStatistics.
     * @param {mapCelestialStatisticsDeleteArgs} args - Arguments to delete one MapCelestialStatistics.
     * @example
     * // Delete one MapCelestialStatistics
     * const MapCelestialStatistics = await prisma.mapCelestialStatistics.delete({
     *   where: {
     *     // ... filter to delete one MapCelestialStatistics
     *   }
     * })
     * 
    **/
    delete<T extends mapCelestialStatisticsDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, mapCelestialStatisticsDeleteArgs<ExtArgs>>
    ): Prisma__mapCelestialStatisticsClient<$Result.GetResult<Prisma.$mapCelestialStatisticsPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one MapCelestialStatistics.
     * @param {mapCelestialStatisticsUpdateArgs} args - Arguments to update one MapCelestialStatistics.
     * @example
     * // Update one MapCelestialStatistics
     * const mapCelestialStatistics = await prisma.mapCelestialStatistics.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends mapCelestialStatisticsUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, mapCelestialStatisticsUpdateArgs<ExtArgs>>
    ): Prisma__mapCelestialStatisticsClient<$Result.GetResult<Prisma.$mapCelestialStatisticsPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more MapCelestialStatistics.
     * @param {mapCelestialStatisticsDeleteManyArgs} args - Arguments to filter MapCelestialStatistics to delete.
     * @example
     * // Delete a few MapCelestialStatistics
     * const { count } = await prisma.mapCelestialStatistics.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends mapCelestialStatisticsDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, mapCelestialStatisticsDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MapCelestialStatistics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {mapCelestialStatisticsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MapCelestialStatistics
     * const mapCelestialStatistics = await prisma.mapCelestialStatistics.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends mapCelestialStatisticsUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, mapCelestialStatisticsUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one MapCelestialStatistics.
     * @param {mapCelestialStatisticsUpsertArgs} args - Arguments to update or create a MapCelestialStatistics.
     * @example
     * // Update or create a MapCelestialStatistics
     * const mapCelestialStatistics = await prisma.mapCelestialStatistics.upsert({
     *   create: {
     *     // ... data to create a MapCelestialStatistics
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MapCelestialStatistics we want to update
     *   }
     * })
    **/
    upsert<T extends mapCelestialStatisticsUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, mapCelestialStatisticsUpsertArgs<ExtArgs>>
    ): Prisma__mapCelestialStatisticsClient<$Result.GetResult<Prisma.$mapCelestialStatisticsPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of MapCelestialStatistics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {mapCelestialStatisticsCountArgs} args - Arguments to filter MapCelestialStatistics to count.
     * @example
     * // Count the number of MapCelestialStatistics
     * const count = await prisma.mapCelestialStatistics.count({
     *   where: {
     *     // ... the filter for the MapCelestialStatistics we want to count
     *   }
     * })
    **/
    count<T extends mapCelestialStatisticsCountArgs>(
      args?: Subset<T, mapCelestialStatisticsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MapCelestialStatisticsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MapCelestialStatistics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MapCelestialStatisticsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MapCelestialStatisticsAggregateArgs>(args: Subset<T, MapCelestialStatisticsAggregateArgs>): Prisma.PrismaPromise<GetMapCelestialStatisticsAggregateType<T>>

    /**
     * Group by MapCelestialStatistics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {mapCelestialStatisticsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends mapCelestialStatisticsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: mapCelestialStatisticsGroupByArgs['orderBy'] }
        : { orderBy?: mapCelestialStatisticsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, mapCelestialStatisticsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMapCelestialStatisticsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the mapCelestialStatistics model
   */
  readonly fields: mapCelestialStatisticsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for mapCelestialStatistics.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__mapCelestialStatisticsClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';


    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the mapCelestialStatistics model
   */ 
  interface mapCelestialStatisticsFieldRefs {
    readonly celestialID: FieldRef<"mapCelestialStatistics", 'Int'>
    readonly temperature: FieldRef<"mapCelestialStatistics", 'Float'>
    readonly spectralClass: FieldRef<"mapCelestialStatistics", 'String'>
    readonly luminosity: FieldRef<"mapCelestialStatistics", 'Float'>
    readonly age: FieldRef<"mapCelestialStatistics", 'Float'>
    readonly life: FieldRef<"mapCelestialStatistics", 'Float'>
    readonly orbitRadius: FieldRef<"mapCelestialStatistics", 'Float'>
    readonly eccentricity: FieldRef<"mapCelestialStatistics", 'Float'>
    readonly massDust: FieldRef<"mapCelestialStatistics", 'Float'>
    readonly massGas: FieldRef<"mapCelestialStatistics", 'Float'>
    readonly fragmented: FieldRef<"mapCelestialStatistics", 'Boolean'>
    readonly density: FieldRef<"mapCelestialStatistics", 'Float'>
    readonly surfaceGravity: FieldRef<"mapCelestialStatistics", 'Float'>
    readonly escapeVelocity: FieldRef<"mapCelestialStatistics", 'Float'>
    readonly orbitPeriod: FieldRef<"mapCelestialStatistics", 'Float'>
    readonly rotationRate: FieldRef<"mapCelestialStatistics", 'Float'>
    readonly locked: FieldRef<"mapCelestialStatistics", 'Boolean'>
    readonly pressure: FieldRef<"mapCelestialStatistics", 'Float'>
    readonly radius: FieldRef<"mapCelestialStatistics", 'Float'>
    readonly mass: FieldRef<"mapCelestialStatistics", 'Int'>
  }
    

  // Custom InputTypes

  /**
   * mapCelestialStatistics findUnique
   */
  export type mapCelestialStatisticsFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the mapCelestialStatistics
     */
    select?: mapCelestialStatisticsSelect<ExtArgs> | null
    /**
     * Filter, which mapCelestialStatistics to fetch.
     */
    where: mapCelestialStatisticsWhereUniqueInput
  }


  /**
   * mapCelestialStatistics findUniqueOrThrow
   */
  export type mapCelestialStatisticsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the mapCelestialStatistics
     */
    select?: mapCelestialStatisticsSelect<ExtArgs> | null
    /**
     * Filter, which mapCelestialStatistics to fetch.
     */
    where: mapCelestialStatisticsWhereUniqueInput
  }


  /**
   * mapCelestialStatistics findFirst
   */
  export type mapCelestialStatisticsFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the mapCelestialStatistics
     */
    select?: mapCelestialStatisticsSelect<ExtArgs> | null
    /**
     * Filter, which mapCelestialStatistics to fetch.
     */
    where?: mapCelestialStatisticsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of mapCelestialStatistics to fetch.
     */
    orderBy?: mapCelestialStatisticsOrderByWithRelationInput | mapCelestialStatisticsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for mapCelestialStatistics.
     */
    cursor?: mapCelestialStatisticsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` mapCelestialStatistics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` mapCelestialStatistics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of mapCelestialStatistics.
     */
    distinct?: MapCelestialStatisticsScalarFieldEnum | MapCelestialStatisticsScalarFieldEnum[]
  }


  /**
   * mapCelestialStatistics findFirstOrThrow
   */
  export type mapCelestialStatisticsFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the mapCelestialStatistics
     */
    select?: mapCelestialStatisticsSelect<ExtArgs> | null
    /**
     * Filter, which mapCelestialStatistics to fetch.
     */
    where?: mapCelestialStatisticsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of mapCelestialStatistics to fetch.
     */
    orderBy?: mapCelestialStatisticsOrderByWithRelationInput | mapCelestialStatisticsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for mapCelestialStatistics.
     */
    cursor?: mapCelestialStatisticsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` mapCelestialStatistics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` mapCelestialStatistics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of mapCelestialStatistics.
     */
    distinct?: MapCelestialStatisticsScalarFieldEnum | MapCelestialStatisticsScalarFieldEnum[]
  }


  /**
   * mapCelestialStatistics findMany
   */
  export type mapCelestialStatisticsFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the mapCelestialStatistics
     */
    select?: mapCelestialStatisticsSelect<ExtArgs> | null
    /**
     * Filter, which mapCelestialStatistics to fetch.
     */
    where?: mapCelestialStatisticsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of mapCelestialStatistics to fetch.
     */
    orderBy?: mapCelestialStatisticsOrderByWithRelationInput | mapCelestialStatisticsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing mapCelestialStatistics.
     */
    cursor?: mapCelestialStatisticsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` mapCelestialStatistics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` mapCelestialStatistics.
     */
    skip?: number
    distinct?: MapCelestialStatisticsScalarFieldEnum | MapCelestialStatisticsScalarFieldEnum[]
  }


  /**
   * mapCelestialStatistics create
   */
  export type mapCelestialStatisticsCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the mapCelestialStatistics
     */
    select?: mapCelestialStatisticsSelect<ExtArgs> | null
    /**
     * The data needed to create a mapCelestialStatistics.
     */
    data: XOR<mapCelestialStatisticsCreateInput, mapCelestialStatisticsUncheckedCreateInput>
  }


  /**
   * mapCelestialStatistics createMany
   */
  export type mapCelestialStatisticsCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many mapCelestialStatistics.
     */
    data: mapCelestialStatisticsCreateManyInput | mapCelestialStatisticsCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * mapCelestialStatistics update
   */
  export type mapCelestialStatisticsUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the mapCelestialStatistics
     */
    select?: mapCelestialStatisticsSelect<ExtArgs> | null
    /**
     * The data needed to update a mapCelestialStatistics.
     */
    data: XOR<mapCelestialStatisticsUpdateInput, mapCelestialStatisticsUncheckedUpdateInput>
    /**
     * Choose, which mapCelestialStatistics to update.
     */
    where: mapCelestialStatisticsWhereUniqueInput
  }


  /**
   * mapCelestialStatistics updateMany
   */
  export type mapCelestialStatisticsUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update mapCelestialStatistics.
     */
    data: XOR<mapCelestialStatisticsUpdateManyMutationInput, mapCelestialStatisticsUncheckedUpdateManyInput>
    /**
     * Filter which mapCelestialStatistics to update
     */
    where?: mapCelestialStatisticsWhereInput
  }


  /**
   * mapCelestialStatistics upsert
   */
  export type mapCelestialStatisticsUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the mapCelestialStatistics
     */
    select?: mapCelestialStatisticsSelect<ExtArgs> | null
    /**
     * The filter to search for the mapCelestialStatistics to update in case it exists.
     */
    where: mapCelestialStatisticsWhereUniqueInput
    /**
     * In case the mapCelestialStatistics found by the `where` argument doesn't exist, create a new mapCelestialStatistics with this data.
     */
    create: XOR<mapCelestialStatisticsCreateInput, mapCelestialStatisticsUncheckedCreateInput>
    /**
     * In case the mapCelestialStatistics was found with the provided `where` argument, update it with this data.
     */
    update: XOR<mapCelestialStatisticsUpdateInput, mapCelestialStatisticsUncheckedUpdateInput>
  }


  /**
   * mapCelestialStatistics delete
   */
  export type mapCelestialStatisticsDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the mapCelestialStatistics
     */
    select?: mapCelestialStatisticsSelect<ExtArgs> | null
    /**
     * Filter which mapCelestialStatistics to delete.
     */
    where: mapCelestialStatisticsWhereUniqueInput
  }


  /**
   * mapCelestialStatistics deleteMany
   */
  export type mapCelestialStatisticsDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which mapCelestialStatistics to delete
     */
    where?: mapCelestialStatisticsWhereInput
  }


  /**
   * mapCelestialStatistics without action
   */
  export type mapCelestialStatisticsDefaultArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the mapCelestialStatistics
     */
    select?: mapCelestialStatisticsSelect<ExtArgs> | null
  }



  /**
   * Model mapConstellationJumps
   */

  export type AggregateMapConstellationJumps = {
    _count: MapConstellationJumpsCountAggregateOutputType | null
    _avg: MapConstellationJumpsAvgAggregateOutputType | null
    _sum: MapConstellationJumpsSumAggregateOutputType | null
    _min: MapConstellationJumpsMinAggregateOutputType | null
    _max: MapConstellationJumpsMaxAggregateOutputType | null
  }

  export type MapConstellationJumpsAvgAggregateOutputType = {
    fromRegionID: number | null
    fromConstellationID: number | null
    toConstellationID: number | null
    toRegionID: number | null
  }

  export type MapConstellationJumpsSumAggregateOutputType = {
    fromRegionID: number | null
    fromConstellationID: number | null
    toConstellationID: number | null
    toRegionID: number | null
  }

  export type MapConstellationJumpsMinAggregateOutputType = {
    fromRegionID: number | null
    fromConstellationID: number | null
    toConstellationID: number | null
    toRegionID: number | null
  }

  export type MapConstellationJumpsMaxAggregateOutputType = {
    fromRegionID: number | null
    fromConstellationID: number | null
    toConstellationID: number | null
    toRegionID: number | null
  }

  export type MapConstellationJumpsCountAggregateOutputType = {
    fromRegionID: number
    fromConstellationID: number
    toConstellationID: number
    toRegionID: number
    _all: number
  }


  export type MapConstellationJumpsAvgAggregateInputType = {
    fromRegionID?: true
    fromConstellationID?: true
    toConstellationID?: true
    toRegionID?: true
  }

  export type MapConstellationJumpsSumAggregateInputType = {
    fromRegionID?: true
    fromConstellationID?: true
    toConstellationID?: true
    toRegionID?: true
  }

  export type MapConstellationJumpsMinAggregateInputType = {
    fromRegionID?: true
    fromConstellationID?: true
    toConstellationID?: true
    toRegionID?: true
  }

  export type MapConstellationJumpsMaxAggregateInputType = {
    fromRegionID?: true
    fromConstellationID?: true
    toConstellationID?: true
    toRegionID?: true
  }

  export type MapConstellationJumpsCountAggregateInputType = {
    fromRegionID?: true
    fromConstellationID?: true
    toConstellationID?: true
    toRegionID?: true
    _all?: true
  }

  export type MapConstellationJumpsAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which mapConstellationJumps to aggregate.
     */
    where?: mapConstellationJumpsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of mapConstellationJumps to fetch.
     */
    orderBy?: mapConstellationJumpsOrderByWithRelationInput | mapConstellationJumpsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: mapConstellationJumpsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` mapConstellationJumps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` mapConstellationJumps.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned mapConstellationJumps
    **/
    _count?: true | MapConstellationJumpsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MapConstellationJumpsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MapConstellationJumpsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MapConstellationJumpsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MapConstellationJumpsMaxAggregateInputType
  }

  export type GetMapConstellationJumpsAggregateType<T extends MapConstellationJumpsAggregateArgs> = {
        [P in keyof T & keyof AggregateMapConstellationJumps]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMapConstellationJumps[P]>
      : GetScalarType<T[P], AggregateMapConstellationJumps[P]>
  }




  export type mapConstellationJumpsGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: mapConstellationJumpsWhereInput
    orderBy?: mapConstellationJumpsOrderByWithAggregationInput | mapConstellationJumpsOrderByWithAggregationInput[]
    by: MapConstellationJumpsScalarFieldEnum[] | MapConstellationJumpsScalarFieldEnum
    having?: mapConstellationJumpsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MapConstellationJumpsCountAggregateInputType | true
    _avg?: MapConstellationJumpsAvgAggregateInputType
    _sum?: MapConstellationJumpsSumAggregateInputType
    _min?: MapConstellationJumpsMinAggregateInputType
    _max?: MapConstellationJumpsMaxAggregateInputType
  }

  export type MapConstellationJumpsGroupByOutputType = {
    fromRegionID: number | null
    fromConstellationID: number
    toConstellationID: number
    toRegionID: number | null
    _count: MapConstellationJumpsCountAggregateOutputType | null
    _avg: MapConstellationJumpsAvgAggregateOutputType | null
    _sum: MapConstellationJumpsSumAggregateOutputType | null
    _min: MapConstellationJumpsMinAggregateOutputType | null
    _max: MapConstellationJumpsMaxAggregateOutputType | null
  }

  type GetMapConstellationJumpsGroupByPayload<T extends mapConstellationJumpsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MapConstellationJumpsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MapConstellationJumpsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MapConstellationJumpsGroupByOutputType[P]>
            : GetScalarType<T[P], MapConstellationJumpsGroupByOutputType[P]>
        }
      >
    >


  export type mapConstellationJumpsSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    fromRegionID?: boolean
    fromConstellationID?: boolean
    toConstellationID?: boolean
    toRegionID?: boolean
  }, ExtArgs["result"]["mapConstellationJumps"]>

  export type mapConstellationJumpsSelectScalar = {
    fromRegionID?: boolean
    fromConstellationID?: boolean
    toConstellationID?: boolean
    toRegionID?: boolean
  }


  export type $mapConstellationJumpsPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    name: "mapConstellationJumps"
    objects: {}
    scalars: $Extensions.GetResult<{
      fromRegionID: number | null
      fromConstellationID: number
      toConstellationID: number
      toRegionID: number | null
    }, ExtArgs["result"]["mapConstellationJumps"]>
    composites: {}
  }


  type mapConstellationJumpsGetPayload<S extends boolean | null | undefined | mapConstellationJumpsDefaultArgs> = $Result.GetResult<Prisma.$mapConstellationJumpsPayload, S>

  type mapConstellationJumpsCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<mapConstellationJumpsFindManyArgs, 'select' | 'include'> & {
      select?: MapConstellationJumpsCountAggregateInputType | true
    }

  export interface mapConstellationJumpsDelegate<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['mapConstellationJumps'], meta: { name: 'mapConstellationJumps' } }
    /**
     * Find zero or one MapConstellationJumps that matches the filter.
     * @param {mapConstellationJumpsFindUniqueArgs} args - Arguments to find a MapConstellationJumps
     * @example
     * // Get one MapConstellationJumps
     * const mapConstellationJumps = await prisma.mapConstellationJumps.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends mapConstellationJumpsFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, mapConstellationJumpsFindUniqueArgs<ExtArgs>>
    ): Prisma__mapConstellationJumpsClient<$Result.GetResult<Prisma.$mapConstellationJumpsPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one MapConstellationJumps that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {mapConstellationJumpsFindUniqueOrThrowArgs} args - Arguments to find a MapConstellationJumps
     * @example
     * // Get one MapConstellationJumps
     * const mapConstellationJumps = await prisma.mapConstellationJumps.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends mapConstellationJumpsFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, mapConstellationJumpsFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__mapConstellationJumpsClient<$Result.GetResult<Prisma.$mapConstellationJumpsPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first MapConstellationJumps that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {mapConstellationJumpsFindFirstArgs} args - Arguments to find a MapConstellationJumps
     * @example
     * // Get one MapConstellationJumps
     * const mapConstellationJumps = await prisma.mapConstellationJumps.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends mapConstellationJumpsFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, mapConstellationJumpsFindFirstArgs<ExtArgs>>
    ): Prisma__mapConstellationJumpsClient<$Result.GetResult<Prisma.$mapConstellationJumpsPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first MapConstellationJumps that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {mapConstellationJumpsFindFirstOrThrowArgs} args - Arguments to find a MapConstellationJumps
     * @example
     * // Get one MapConstellationJumps
     * const mapConstellationJumps = await prisma.mapConstellationJumps.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends mapConstellationJumpsFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, mapConstellationJumpsFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__mapConstellationJumpsClient<$Result.GetResult<Prisma.$mapConstellationJumpsPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more MapConstellationJumps that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {mapConstellationJumpsFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MapConstellationJumps
     * const mapConstellationJumps = await prisma.mapConstellationJumps.findMany()
     * 
     * // Get first 10 MapConstellationJumps
     * const mapConstellationJumps = await prisma.mapConstellationJumps.findMany({ take: 10 })
     * 
     * // Only select the `fromRegionID`
     * const mapConstellationJumpsWithFromRegionIDOnly = await prisma.mapConstellationJumps.findMany({ select: { fromRegionID: true } })
     * 
    **/
    findMany<T extends mapConstellationJumpsFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, mapConstellationJumpsFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$mapConstellationJumpsPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a MapConstellationJumps.
     * @param {mapConstellationJumpsCreateArgs} args - Arguments to create a MapConstellationJumps.
     * @example
     * // Create one MapConstellationJumps
     * const MapConstellationJumps = await prisma.mapConstellationJumps.create({
     *   data: {
     *     // ... data to create a MapConstellationJumps
     *   }
     * })
     * 
    **/
    create<T extends mapConstellationJumpsCreateArgs<ExtArgs>>(
      args: SelectSubset<T, mapConstellationJumpsCreateArgs<ExtArgs>>
    ): Prisma__mapConstellationJumpsClient<$Result.GetResult<Prisma.$mapConstellationJumpsPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many MapConstellationJumps.
     *     @param {mapConstellationJumpsCreateManyArgs} args - Arguments to create many MapConstellationJumps.
     *     @example
     *     // Create many MapConstellationJumps
     *     const mapConstellationJumps = await prisma.mapConstellationJumps.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends mapConstellationJumpsCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, mapConstellationJumpsCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a MapConstellationJumps.
     * @param {mapConstellationJumpsDeleteArgs} args - Arguments to delete one MapConstellationJumps.
     * @example
     * // Delete one MapConstellationJumps
     * const MapConstellationJumps = await prisma.mapConstellationJumps.delete({
     *   where: {
     *     // ... filter to delete one MapConstellationJumps
     *   }
     * })
     * 
    **/
    delete<T extends mapConstellationJumpsDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, mapConstellationJumpsDeleteArgs<ExtArgs>>
    ): Prisma__mapConstellationJumpsClient<$Result.GetResult<Prisma.$mapConstellationJumpsPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one MapConstellationJumps.
     * @param {mapConstellationJumpsUpdateArgs} args - Arguments to update one MapConstellationJumps.
     * @example
     * // Update one MapConstellationJumps
     * const mapConstellationJumps = await prisma.mapConstellationJumps.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends mapConstellationJumpsUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, mapConstellationJumpsUpdateArgs<ExtArgs>>
    ): Prisma__mapConstellationJumpsClient<$Result.GetResult<Prisma.$mapConstellationJumpsPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more MapConstellationJumps.
     * @param {mapConstellationJumpsDeleteManyArgs} args - Arguments to filter MapConstellationJumps to delete.
     * @example
     * // Delete a few MapConstellationJumps
     * const { count } = await prisma.mapConstellationJumps.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends mapConstellationJumpsDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, mapConstellationJumpsDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MapConstellationJumps.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {mapConstellationJumpsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MapConstellationJumps
     * const mapConstellationJumps = await prisma.mapConstellationJumps.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends mapConstellationJumpsUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, mapConstellationJumpsUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one MapConstellationJumps.
     * @param {mapConstellationJumpsUpsertArgs} args - Arguments to update or create a MapConstellationJumps.
     * @example
     * // Update or create a MapConstellationJumps
     * const mapConstellationJumps = await prisma.mapConstellationJumps.upsert({
     *   create: {
     *     // ... data to create a MapConstellationJumps
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MapConstellationJumps we want to update
     *   }
     * })
    **/
    upsert<T extends mapConstellationJumpsUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, mapConstellationJumpsUpsertArgs<ExtArgs>>
    ): Prisma__mapConstellationJumpsClient<$Result.GetResult<Prisma.$mapConstellationJumpsPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of MapConstellationJumps.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {mapConstellationJumpsCountArgs} args - Arguments to filter MapConstellationJumps to count.
     * @example
     * // Count the number of MapConstellationJumps
     * const count = await prisma.mapConstellationJumps.count({
     *   where: {
     *     // ... the filter for the MapConstellationJumps we want to count
     *   }
     * })
    **/
    count<T extends mapConstellationJumpsCountArgs>(
      args?: Subset<T, mapConstellationJumpsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MapConstellationJumpsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MapConstellationJumps.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MapConstellationJumpsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MapConstellationJumpsAggregateArgs>(args: Subset<T, MapConstellationJumpsAggregateArgs>): Prisma.PrismaPromise<GetMapConstellationJumpsAggregateType<T>>

    /**
     * Group by MapConstellationJumps.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {mapConstellationJumpsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends mapConstellationJumpsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: mapConstellationJumpsGroupByArgs['orderBy'] }
        : { orderBy?: mapConstellationJumpsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, mapConstellationJumpsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMapConstellationJumpsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the mapConstellationJumps model
   */
  readonly fields: mapConstellationJumpsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for mapConstellationJumps.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__mapConstellationJumpsClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';


    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the mapConstellationJumps model
   */ 
  interface mapConstellationJumpsFieldRefs {
    readonly fromRegionID: FieldRef<"mapConstellationJumps", 'Int'>
    readonly fromConstellationID: FieldRef<"mapConstellationJumps", 'Int'>
    readonly toConstellationID: FieldRef<"mapConstellationJumps", 'Int'>
    readonly toRegionID: FieldRef<"mapConstellationJumps", 'Int'>
  }
    

  // Custom InputTypes

  /**
   * mapConstellationJumps findUnique
   */
  export type mapConstellationJumpsFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the mapConstellationJumps
     */
    select?: mapConstellationJumpsSelect<ExtArgs> | null
    /**
     * Filter, which mapConstellationJumps to fetch.
     */
    where: mapConstellationJumpsWhereUniqueInput
  }


  /**
   * mapConstellationJumps findUniqueOrThrow
   */
  export type mapConstellationJumpsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the mapConstellationJumps
     */
    select?: mapConstellationJumpsSelect<ExtArgs> | null
    /**
     * Filter, which mapConstellationJumps to fetch.
     */
    where: mapConstellationJumpsWhereUniqueInput
  }


  /**
   * mapConstellationJumps findFirst
   */
  export type mapConstellationJumpsFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the mapConstellationJumps
     */
    select?: mapConstellationJumpsSelect<ExtArgs> | null
    /**
     * Filter, which mapConstellationJumps to fetch.
     */
    where?: mapConstellationJumpsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of mapConstellationJumps to fetch.
     */
    orderBy?: mapConstellationJumpsOrderByWithRelationInput | mapConstellationJumpsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for mapConstellationJumps.
     */
    cursor?: mapConstellationJumpsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` mapConstellationJumps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` mapConstellationJumps.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of mapConstellationJumps.
     */
    distinct?: MapConstellationJumpsScalarFieldEnum | MapConstellationJumpsScalarFieldEnum[]
  }


  /**
   * mapConstellationJumps findFirstOrThrow
   */
  export type mapConstellationJumpsFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the mapConstellationJumps
     */
    select?: mapConstellationJumpsSelect<ExtArgs> | null
    /**
     * Filter, which mapConstellationJumps to fetch.
     */
    where?: mapConstellationJumpsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of mapConstellationJumps to fetch.
     */
    orderBy?: mapConstellationJumpsOrderByWithRelationInput | mapConstellationJumpsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for mapConstellationJumps.
     */
    cursor?: mapConstellationJumpsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` mapConstellationJumps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` mapConstellationJumps.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of mapConstellationJumps.
     */
    distinct?: MapConstellationJumpsScalarFieldEnum | MapConstellationJumpsScalarFieldEnum[]
  }


  /**
   * mapConstellationJumps findMany
   */
  export type mapConstellationJumpsFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the mapConstellationJumps
     */
    select?: mapConstellationJumpsSelect<ExtArgs> | null
    /**
     * Filter, which mapConstellationJumps to fetch.
     */
    where?: mapConstellationJumpsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of mapConstellationJumps to fetch.
     */
    orderBy?: mapConstellationJumpsOrderByWithRelationInput | mapConstellationJumpsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing mapConstellationJumps.
     */
    cursor?: mapConstellationJumpsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` mapConstellationJumps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` mapConstellationJumps.
     */
    skip?: number
    distinct?: MapConstellationJumpsScalarFieldEnum | MapConstellationJumpsScalarFieldEnum[]
  }


  /**
   * mapConstellationJumps create
   */
  export type mapConstellationJumpsCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the mapConstellationJumps
     */
    select?: mapConstellationJumpsSelect<ExtArgs> | null
    /**
     * The data needed to create a mapConstellationJumps.
     */
    data: XOR<mapConstellationJumpsCreateInput, mapConstellationJumpsUncheckedCreateInput>
  }


  /**
   * mapConstellationJumps createMany
   */
  export type mapConstellationJumpsCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many mapConstellationJumps.
     */
    data: mapConstellationJumpsCreateManyInput | mapConstellationJumpsCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * mapConstellationJumps update
   */
  export type mapConstellationJumpsUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the mapConstellationJumps
     */
    select?: mapConstellationJumpsSelect<ExtArgs> | null
    /**
     * The data needed to update a mapConstellationJumps.
     */
    data: XOR<mapConstellationJumpsUpdateInput, mapConstellationJumpsUncheckedUpdateInput>
    /**
     * Choose, which mapConstellationJumps to update.
     */
    where: mapConstellationJumpsWhereUniqueInput
  }


  /**
   * mapConstellationJumps updateMany
   */
  export type mapConstellationJumpsUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update mapConstellationJumps.
     */
    data: XOR<mapConstellationJumpsUpdateManyMutationInput, mapConstellationJumpsUncheckedUpdateManyInput>
    /**
     * Filter which mapConstellationJumps to update
     */
    where?: mapConstellationJumpsWhereInput
  }


  /**
   * mapConstellationJumps upsert
   */
  export type mapConstellationJumpsUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the mapConstellationJumps
     */
    select?: mapConstellationJumpsSelect<ExtArgs> | null
    /**
     * The filter to search for the mapConstellationJumps to update in case it exists.
     */
    where: mapConstellationJumpsWhereUniqueInput
    /**
     * In case the mapConstellationJumps found by the `where` argument doesn't exist, create a new mapConstellationJumps with this data.
     */
    create: XOR<mapConstellationJumpsCreateInput, mapConstellationJumpsUncheckedCreateInput>
    /**
     * In case the mapConstellationJumps was found with the provided `where` argument, update it with this data.
     */
    update: XOR<mapConstellationJumpsUpdateInput, mapConstellationJumpsUncheckedUpdateInput>
  }


  /**
   * mapConstellationJumps delete
   */
  export type mapConstellationJumpsDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the mapConstellationJumps
     */
    select?: mapConstellationJumpsSelect<ExtArgs> | null
    /**
     * Filter which mapConstellationJumps to delete.
     */
    where: mapConstellationJumpsWhereUniqueInput
  }


  /**
   * mapConstellationJumps deleteMany
   */
  export type mapConstellationJumpsDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which mapConstellationJumps to delete
     */
    where?: mapConstellationJumpsWhereInput
  }


  /**
   * mapConstellationJumps without action
   */
  export type mapConstellationJumpsDefaultArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the mapConstellationJumps
     */
    select?: mapConstellationJumpsSelect<ExtArgs> | null
  }



  /**
   * Model mapConstellations
   */

  export type AggregateMapConstellations = {
    _count: MapConstellationsCountAggregateOutputType | null
    _avg: MapConstellationsAvgAggregateOutputType | null
    _sum: MapConstellationsSumAggregateOutputType | null
    _min: MapConstellationsMinAggregateOutputType | null
    _max: MapConstellationsMaxAggregateOutputType | null
  }

  export type MapConstellationsAvgAggregateOutputType = {
    regionID: number | null
    constellationID: number | null
    x: number | null
    y: number | null
    z: number | null
    xMin: number | null
    xMax: number | null
    yMin: number | null
    yMax: number | null
    zMin: number | null
    zMax: number | null
    factionID: number | null
    radius: number | null
  }

  export type MapConstellationsSumAggregateOutputType = {
    regionID: number | null
    constellationID: number | null
    x: number | null
    y: number | null
    z: number | null
    xMin: number | null
    xMax: number | null
    yMin: number | null
    yMax: number | null
    zMin: number | null
    zMax: number | null
    factionID: number | null
    radius: number | null
  }

  export type MapConstellationsMinAggregateOutputType = {
    regionID: number | null
    constellationID: number | null
    constellationName: string | null
    x: number | null
    y: number | null
    z: number | null
    xMin: number | null
    xMax: number | null
    yMin: number | null
    yMax: number | null
    zMin: number | null
    zMax: number | null
    factionID: number | null
    radius: number | null
  }

  export type MapConstellationsMaxAggregateOutputType = {
    regionID: number | null
    constellationID: number | null
    constellationName: string | null
    x: number | null
    y: number | null
    z: number | null
    xMin: number | null
    xMax: number | null
    yMin: number | null
    yMax: number | null
    zMin: number | null
    zMax: number | null
    factionID: number | null
    radius: number | null
  }

  export type MapConstellationsCountAggregateOutputType = {
    regionID: number
    constellationID: number
    constellationName: number
    x: number
    y: number
    z: number
    xMin: number
    xMax: number
    yMin: number
    yMax: number
    zMin: number
    zMax: number
    factionID: number
    radius: number
    _all: number
  }


  export type MapConstellationsAvgAggregateInputType = {
    regionID?: true
    constellationID?: true
    x?: true
    y?: true
    z?: true
    xMin?: true
    xMax?: true
    yMin?: true
    yMax?: true
    zMin?: true
    zMax?: true
    factionID?: true
    radius?: true
  }

  export type MapConstellationsSumAggregateInputType = {
    regionID?: true
    constellationID?: true
    x?: true
    y?: true
    z?: true
    xMin?: true
    xMax?: true
    yMin?: true
    yMax?: true
    zMin?: true
    zMax?: true
    factionID?: true
    radius?: true
  }

  export type MapConstellationsMinAggregateInputType = {
    regionID?: true
    constellationID?: true
    constellationName?: true
    x?: true
    y?: true
    z?: true
    xMin?: true
    xMax?: true
    yMin?: true
    yMax?: true
    zMin?: true
    zMax?: true
    factionID?: true
    radius?: true
  }

  export type MapConstellationsMaxAggregateInputType = {
    regionID?: true
    constellationID?: true
    constellationName?: true
    x?: true
    y?: true
    z?: true
    xMin?: true
    xMax?: true
    yMin?: true
    yMax?: true
    zMin?: true
    zMax?: true
    factionID?: true
    radius?: true
  }

  export type MapConstellationsCountAggregateInputType = {
    regionID?: true
    constellationID?: true
    constellationName?: true
    x?: true
    y?: true
    z?: true
    xMin?: true
    xMax?: true
    yMin?: true
    yMax?: true
    zMin?: true
    zMax?: true
    factionID?: true
    radius?: true
    _all?: true
  }

  export type MapConstellationsAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which mapConstellations to aggregate.
     */
    where?: mapConstellationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of mapConstellations to fetch.
     */
    orderBy?: mapConstellationsOrderByWithRelationInput | mapConstellationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: mapConstellationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` mapConstellations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` mapConstellations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned mapConstellations
    **/
    _count?: true | MapConstellationsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MapConstellationsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MapConstellationsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MapConstellationsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MapConstellationsMaxAggregateInputType
  }

  export type GetMapConstellationsAggregateType<T extends MapConstellationsAggregateArgs> = {
        [P in keyof T & keyof AggregateMapConstellations]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMapConstellations[P]>
      : GetScalarType<T[P], AggregateMapConstellations[P]>
  }




  export type mapConstellationsGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: mapConstellationsWhereInput
    orderBy?: mapConstellationsOrderByWithAggregationInput | mapConstellationsOrderByWithAggregationInput[]
    by: MapConstellationsScalarFieldEnum[] | MapConstellationsScalarFieldEnum
    having?: mapConstellationsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MapConstellationsCountAggregateInputType | true
    _avg?: MapConstellationsAvgAggregateInputType
    _sum?: MapConstellationsSumAggregateInputType
    _min?: MapConstellationsMinAggregateInputType
    _max?: MapConstellationsMaxAggregateInputType
  }

  export type MapConstellationsGroupByOutputType = {
    regionID: number | null
    constellationID: number
    constellationName: string | null
    x: number | null
    y: number | null
    z: number | null
    xMin: number | null
    xMax: number | null
    yMin: number | null
    yMax: number | null
    zMin: number | null
    zMax: number | null
    factionID: number | null
    radius: number | null
    _count: MapConstellationsCountAggregateOutputType | null
    _avg: MapConstellationsAvgAggregateOutputType | null
    _sum: MapConstellationsSumAggregateOutputType | null
    _min: MapConstellationsMinAggregateOutputType | null
    _max: MapConstellationsMaxAggregateOutputType | null
  }

  type GetMapConstellationsGroupByPayload<T extends mapConstellationsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MapConstellationsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MapConstellationsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MapConstellationsGroupByOutputType[P]>
            : GetScalarType<T[P], MapConstellationsGroupByOutputType[P]>
        }
      >
    >


  export type mapConstellationsSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    regionID?: boolean
    constellationID?: boolean
    constellationName?: boolean
    x?: boolean
    y?: boolean
    z?: boolean
    xMin?: boolean
    xMax?: boolean
    yMin?: boolean
    yMax?: boolean
    zMin?: boolean
    zMax?: boolean
    factionID?: boolean
    radius?: boolean
  }, ExtArgs["result"]["mapConstellations"]>

  export type mapConstellationsSelectScalar = {
    regionID?: boolean
    constellationID?: boolean
    constellationName?: boolean
    x?: boolean
    y?: boolean
    z?: boolean
    xMin?: boolean
    xMax?: boolean
    yMin?: boolean
    yMax?: boolean
    zMin?: boolean
    zMax?: boolean
    factionID?: boolean
    radius?: boolean
  }


  export type $mapConstellationsPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    name: "mapConstellations"
    objects: {}
    scalars: $Extensions.GetResult<{
      regionID: number | null
      constellationID: number
      constellationName: string | null
      x: number | null
      y: number | null
      z: number | null
      xMin: number | null
      xMax: number | null
      yMin: number | null
      yMax: number | null
      zMin: number | null
      zMax: number | null
      factionID: number | null
      radius: number | null
    }, ExtArgs["result"]["mapConstellations"]>
    composites: {}
  }


  type mapConstellationsGetPayload<S extends boolean | null | undefined | mapConstellationsDefaultArgs> = $Result.GetResult<Prisma.$mapConstellationsPayload, S>

  type mapConstellationsCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<mapConstellationsFindManyArgs, 'select' | 'include'> & {
      select?: MapConstellationsCountAggregateInputType | true
    }

  export interface mapConstellationsDelegate<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['mapConstellations'], meta: { name: 'mapConstellations' } }
    /**
     * Find zero or one MapConstellations that matches the filter.
     * @param {mapConstellationsFindUniqueArgs} args - Arguments to find a MapConstellations
     * @example
     * // Get one MapConstellations
     * const mapConstellations = await prisma.mapConstellations.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends mapConstellationsFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, mapConstellationsFindUniqueArgs<ExtArgs>>
    ): Prisma__mapConstellationsClient<$Result.GetResult<Prisma.$mapConstellationsPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one MapConstellations that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {mapConstellationsFindUniqueOrThrowArgs} args - Arguments to find a MapConstellations
     * @example
     * // Get one MapConstellations
     * const mapConstellations = await prisma.mapConstellations.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends mapConstellationsFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, mapConstellationsFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__mapConstellationsClient<$Result.GetResult<Prisma.$mapConstellationsPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first MapConstellations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {mapConstellationsFindFirstArgs} args - Arguments to find a MapConstellations
     * @example
     * // Get one MapConstellations
     * const mapConstellations = await prisma.mapConstellations.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends mapConstellationsFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, mapConstellationsFindFirstArgs<ExtArgs>>
    ): Prisma__mapConstellationsClient<$Result.GetResult<Prisma.$mapConstellationsPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first MapConstellations that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {mapConstellationsFindFirstOrThrowArgs} args - Arguments to find a MapConstellations
     * @example
     * // Get one MapConstellations
     * const mapConstellations = await prisma.mapConstellations.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends mapConstellationsFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, mapConstellationsFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__mapConstellationsClient<$Result.GetResult<Prisma.$mapConstellationsPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more MapConstellations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {mapConstellationsFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MapConstellations
     * const mapConstellations = await prisma.mapConstellations.findMany()
     * 
     * // Get first 10 MapConstellations
     * const mapConstellations = await prisma.mapConstellations.findMany({ take: 10 })
     * 
     * // Only select the `regionID`
     * const mapConstellationsWithRegionIDOnly = await prisma.mapConstellations.findMany({ select: { regionID: true } })
     * 
    **/
    findMany<T extends mapConstellationsFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, mapConstellationsFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$mapConstellationsPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a MapConstellations.
     * @param {mapConstellationsCreateArgs} args - Arguments to create a MapConstellations.
     * @example
     * // Create one MapConstellations
     * const MapConstellations = await prisma.mapConstellations.create({
     *   data: {
     *     // ... data to create a MapConstellations
     *   }
     * })
     * 
    **/
    create<T extends mapConstellationsCreateArgs<ExtArgs>>(
      args: SelectSubset<T, mapConstellationsCreateArgs<ExtArgs>>
    ): Prisma__mapConstellationsClient<$Result.GetResult<Prisma.$mapConstellationsPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many MapConstellations.
     *     @param {mapConstellationsCreateManyArgs} args - Arguments to create many MapConstellations.
     *     @example
     *     // Create many MapConstellations
     *     const mapConstellations = await prisma.mapConstellations.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends mapConstellationsCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, mapConstellationsCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a MapConstellations.
     * @param {mapConstellationsDeleteArgs} args - Arguments to delete one MapConstellations.
     * @example
     * // Delete one MapConstellations
     * const MapConstellations = await prisma.mapConstellations.delete({
     *   where: {
     *     // ... filter to delete one MapConstellations
     *   }
     * })
     * 
    **/
    delete<T extends mapConstellationsDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, mapConstellationsDeleteArgs<ExtArgs>>
    ): Prisma__mapConstellationsClient<$Result.GetResult<Prisma.$mapConstellationsPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one MapConstellations.
     * @param {mapConstellationsUpdateArgs} args - Arguments to update one MapConstellations.
     * @example
     * // Update one MapConstellations
     * const mapConstellations = await prisma.mapConstellations.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends mapConstellationsUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, mapConstellationsUpdateArgs<ExtArgs>>
    ): Prisma__mapConstellationsClient<$Result.GetResult<Prisma.$mapConstellationsPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more MapConstellations.
     * @param {mapConstellationsDeleteManyArgs} args - Arguments to filter MapConstellations to delete.
     * @example
     * // Delete a few MapConstellations
     * const { count } = await prisma.mapConstellations.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends mapConstellationsDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, mapConstellationsDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MapConstellations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {mapConstellationsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MapConstellations
     * const mapConstellations = await prisma.mapConstellations.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends mapConstellationsUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, mapConstellationsUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one MapConstellations.
     * @param {mapConstellationsUpsertArgs} args - Arguments to update or create a MapConstellations.
     * @example
     * // Update or create a MapConstellations
     * const mapConstellations = await prisma.mapConstellations.upsert({
     *   create: {
     *     // ... data to create a MapConstellations
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MapConstellations we want to update
     *   }
     * })
    **/
    upsert<T extends mapConstellationsUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, mapConstellationsUpsertArgs<ExtArgs>>
    ): Prisma__mapConstellationsClient<$Result.GetResult<Prisma.$mapConstellationsPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of MapConstellations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {mapConstellationsCountArgs} args - Arguments to filter MapConstellations to count.
     * @example
     * // Count the number of MapConstellations
     * const count = await prisma.mapConstellations.count({
     *   where: {
     *     // ... the filter for the MapConstellations we want to count
     *   }
     * })
    **/
    count<T extends mapConstellationsCountArgs>(
      args?: Subset<T, mapConstellationsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MapConstellationsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MapConstellations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MapConstellationsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MapConstellationsAggregateArgs>(args: Subset<T, MapConstellationsAggregateArgs>): Prisma.PrismaPromise<GetMapConstellationsAggregateType<T>>

    /**
     * Group by MapConstellations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {mapConstellationsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends mapConstellationsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: mapConstellationsGroupByArgs['orderBy'] }
        : { orderBy?: mapConstellationsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, mapConstellationsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMapConstellationsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the mapConstellations model
   */
  readonly fields: mapConstellationsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for mapConstellations.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__mapConstellationsClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';


    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the mapConstellations model
   */ 
  interface mapConstellationsFieldRefs {
    readonly regionID: FieldRef<"mapConstellations", 'Int'>
    readonly constellationID: FieldRef<"mapConstellations", 'Int'>
    readonly constellationName: FieldRef<"mapConstellations", 'String'>
    readonly x: FieldRef<"mapConstellations", 'Float'>
    readonly y: FieldRef<"mapConstellations", 'Float'>
    readonly z: FieldRef<"mapConstellations", 'Float'>
    readonly xMin: FieldRef<"mapConstellations", 'Float'>
    readonly xMax: FieldRef<"mapConstellations", 'Float'>
    readonly yMin: FieldRef<"mapConstellations", 'Float'>
    readonly yMax: FieldRef<"mapConstellations", 'Float'>
    readonly zMin: FieldRef<"mapConstellations", 'Float'>
    readonly zMax: FieldRef<"mapConstellations", 'Float'>
    readonly factionID: FieldRef<"mapConstellations", 'Int'>
    readonly radius: FieldRef<"mapConstellations", 'Float'>
  }
    

  // Custom InputTypes

  /**
   * mapConstellations findUnique
   */
  export type mapConstellationsFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the mapConstellations
     */
    select?: mapConstellationsSelect<ExtArgs> | null
    /**
     * Filter, which mapConstellations to fetch.
     */
    where: mapConstellationsWhereUniqueInput
  }


  /**
   * mapConstellations findUniqueOrThrow
   */
  export type mapConstellationsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the mapConstellations
     */
    select?: mapConstellationsSelect<ExtArgs> | null
    /**
     * Filter, which mapConstellations to fetch.
     */
    where: mapConstellationsWhereUniqueInput
  }


  /**
   * mapConstellations findFirst
   */
  export type mapConstellationsFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the mapConstellations
     */
    select?: mapConstellationsSelect<ExtArgs> | null
    /**
     * Filter, which mapConstellations to fetch.
     */
    where?: mapConstellationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of mapConstellations to fetch.
     */
    orderBy?: mapConstellationsOrderByWithRelationInput | mapConstellationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for mapConstellations.
     */
    cursor?: mapConstellationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` mapConstellations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` mapConstellations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of mapConstellations.
     */
    distinct?: MapConstellationsScalarFieldEnum | MapConstellationsScalarFieldEnum[]
  }


  /**
   * mapConstellations findFirstOrThrow
   */
  export type mapConstellationsFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the mapConstellations
     */
    select?: mapConstellationsSelect<ExtArgs> | null
    /**
     * Filter, which mapConstellations to fetch.
     */
    where?: mapConstellationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of mapConstellations to fetch.
     */
    orderBy?: mapConstellationsOrderByWithRelationInput | mapConstellationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for mapConstellations.
     */
    cursor?: mapConstellationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` mapConstellations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` mapConstellations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of mapConstellations.
     */
    distinct?: MapConstellationsScalarFieldEnum | MapConstellationsScalarFieldEnum[]
  }


  /**
   * mapConstellations findMany
   */
  export type mapConstellationsFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the mapConstellations
     */
    select?: mapConstellationsSelect<ExtArgs> | null
    /**
     * Filter, which mapConstellations to fetch.
     */
    where?: mapConstellationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of mapConstellations to fetch.
     */
    orderBy?: mapConstellationsOrderByWithRelationInput | mapConstellationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing mapConstellations.
     */
    cursor?: mapConstellationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` mapConstellations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` mapConstellations.
     */
    skip?: number
    distinct?: MapConstellationsScalarFieldEnum | MapConstellationsScalarFieldEnum[]
  }


  /**
   * mapConstellations create
   */
  export type mapConstellationsCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the mapConstellations
     */
    select?: mapConstellationsSelect<ExtArgs> | null
    /**
     * The data needed to create a mapConstellations.
     */
    data: XOR<mapConstellationsCreateInput, mapConstellationsUncheckedCreateInput>
  }


  /**
   * mapConstellations createMany
   */
  export type mapConstellationsCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many mapConstellations.
     */
    data: mapConstellationsCreateManyInput | mapConstellationsCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * mapConstellations update
   */
  export type mapConstellationsUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the mapConstellations
     */
    select?: mapConstellationsSelect<ExtArgs> | null
    /**
     * The data needed to update a mapConstellations.
     */
    data: XOR<mapConstellationsUpdateInput, mapConstellationsUncheckedUpdateInput>
    /**
     * Choose, which mapConstellations to update.
     */
    where: mapConstellationsWhereUniqueInput
  }


  /**
   * mapConstellations updateMany
   */
  export type mapConstellationsUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update mapConstellations.
     */
    data: XOR<mapConstellationsUpdateManyMutationInput, mapConstellationsUncheckedUpdateManyInput>
    /**
     * Filter which mapConstellations to update
     */
    where?: mapConstellationsWhereInput
  }


  /**
   * mapConstellations upsert
   */
  export type mapConstellationsUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the mapConstellations
     */
    select?: mapConstellationsSelect<ExtArgs> | null
    /**
     * The filter to search for the mapConstellations to update in case it exists.
     */
    where: mapConstellationsWhereUniqueInput
    /**
     * In case the mapConstellations found by the `where` argument doesn't exist, create a new mapConstellations with this data.
     */
    create: XOR<mapConstellationsCreateInput, mapConstellationsUncheckedCreateInput>
    /**
     * In case the mapConstellations was found with the provided `where` argument, update it with this data.
     */
    update: XOR<mapConstellationsUpdateInput, mapConstellationsUncheckedUpdateInput>
  }


  /**
   * mapConstellations delete
   */
  export type mapConstellationsDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the mapConstellations
     */
    select?: mapConstellationsSelect<ExtArgs> | null
    /**
     * Filter which mapConstellations to delete.
     */
    where: mapConstellationsWhereUniqueInput
  }


  /**
   * mapConstellations deleteMany
   */
  export type mapConstellationsDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which mapConstellations to delete
     */
    where?: mapConstellationsWhereInput
  }


  /**
   * mapConstellations without action
   */
  export type mapConstellationsDefaultArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the mapConstellations
     */
    select?: mapConstellationsSelect<ExtArgs> | null
  }



  /**
   * Model mapDenormalize
   */

  export type AggregateMapDenormalize = {
    _count: MapDenormalizeCountAggregateOutputType | null
    _avg: MapDenormalizeAvgAggregateOutputType | null
    _sum: MapDenormalizeSumAggregateOutputType | null
    _min: MapDenormalizeMinAggregateOutputType | null
    _max: MapDenormalizeMaxAggregateOutputType | null
  }

  export type MapDenormalizeAvgAggregateOutputType = {
    itemID: number | null
    typeID: number | null
    groupID: number | null
    solarSystemID: number | null
    constellationID: number | null
    regionID: number | null
    orbitID: number | null
    x: number | null
    y: number | null
    z: number | null
    radius: number | null
    security: number | null
    celestialIndex: number | null
    orbitIndex: number | null
  }

  export type MapDenormalizeSumAggregateOutputType = {
    itemID: number | null
    typeID: number | null
    groupID: number | null
    solarSystemID: number | null
    constellationID: number | null
    regionID: number | null
    orbitID: number | null
    x: number | null
    y: number | null
    z: number | null
    radius: number | null
    security: number | null
    celestialIndex: number | null
    orbitIndex: number | null
  }

  export type MapDenormalizeMinAggregateOutputType = {
    itemID: number | null
    typeID: number | null
    groupID: number | null
    solarSystemID: number | null
    constellationID: number | null
    regionID: number | null
    orbitID: number | null
    x: number | null
    y: number | null
    z: number | null
    radius: number | null
    itemName: string | null
    security: number | null
    celestialIndex: number | null
    orbitIndex: number | null
  }

  export type MapDenormalizeMaxAggregateOutputType = {
    itemID: number | null
    typeID: number | null
    groupID: number | null
    solarSystemID: number | null
    constellationID: number | null
    regionID: number | null
    orbitID: number | null
    x: number | null
    y: number | null
    z: number | null
    radius: number | null
    itemName: string | null
    security: number | null
    celestialIndex: number | null
    orbitIndex: number | null
  }

  export type MapDenormalizeCountAggregateOutputType = {
    itemID: number
    typeID: number
    groupID: number
    solarSystemID: number
    constellationID: number
    regionID: number
    orbitID: number
    x: number
    y: number
    z: number
    radius: number
    itemName: number
    security: number
    celestialIndex: number
    orbitIndex: number
    _all: number
  }


  export type MapDenormalizeAvgAggregateInputType = {
    itemID?: true
    typeID?: true
    groupID?: true
    solarSystemID?: true
    constellationID?: true
    regionID?: true
    orbitID?: true
    x?: true
    y?: true
    z?: true
    radius?: true
    security?: true
    celestialIndex?: true
    orbitIndex?: true
  }

  export type MapDenormalizeSumAggregateInputType = {
    itemID?: true
    typeID?: true
    groupID?: true
    solarSystemID?: true
    constellationID?: true
    regionID?: true
    orbitID?: true
    x?: true
    y?: true
    z?: true
    radius?: true
    security?: true
    celestialIndex?: true
    orbitIndex?: true
  }

  export type MapDenormalizeMinAggregateInputType = {
    itemID?: true
    typeID?: true
    groupID?: true
    solarSystemID?: true
    constellationID?: true
    regionID?: true
    orbitID?: true
    x?: true
    y?: true
    z?: true
    radius?: true
    itemName?: true
    security?: true
    celestialIndex?: true
    orbitIndex?: true
  }

  export type MapDenormalizeMaxAggregateInputType = {
    itemID?: true
    typeID?: true
    groupID?: true
    solarSystemID?: true
    constellationID?: true
    regionID?: true
    orbitID?: true
    x?: true
    y?: true
    z?: true
    radius?: true
    itemName?: true
    security?: true
    celestialIndex?: true
    orbitIndex?: true
  }

  export type MapDenormalizeCountAggregateInputType = {
    itemID?: true
    typeID?: true
    groupID?: true
    solarSystemID?: true
    constellationID?: true
    regionID?: true
    orbitID?: true
    x?: true
    y?: true
    z?: true
    radius?: true
    itemName?: true
    security?: true
    celestialIndex?: true
    orbitIndex?: true
    _all?: true
  }

  export type MapDenormalizeAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which mapDenormalize to aggregate.
     */
    where?: mapDenormalizeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of mapDenormalizes to fetch.
     */
    orderBy?: mapDenormalizeOrderByWithRelationInput | mapDenormalizeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: mapDenormalizeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` mapDenormalizes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` mapDenormalizes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned mapDenormalizes
    **/
    _count?: true | MapDenormalizeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MapDenormalizeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MapDenormalizeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MapDenormalizeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MapDenormalizeMaxAggregateInputType
  }

  export type GetMapDenormalizeAggregateType<T extends MapDenormalizeAggregateArgs> = {
        [P in keyof T & keyof AggregateMapDenormalize]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMapDenormalize[P]>
      : GetScalarType<T[P], AggregateMapDenormalize[P]>
  }




  export type mapDenormalizeGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: mapDenormalizeWhereInput
    orderBy?: mapDenormalizeOrderByWithAggregationInput | mapDenormalizeOrderByWithAggregationInput[]
    by: MapDenormalizeScalarFieldEnum[] | MapDenormalizeScalarFieldEnum
    having?: mapDenormalizeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MapDenormalizeCountAggregateInputType | true
    _avg?: MapDenormalizeAvgAggregateInputType
    _sum?: MapDenormalizeSumAggregateInputType
    _min?: MapDenormalizeMinAggregateInputType
    _max?: MapDenormalizeMaxAggregateInputType
  }

  export type MapDenormalizeGroupByOutputType = {
    itemID: number
    typeID: number | null
    groupID: number | null
    solarSystemID: number | null
    constellationID: number | null
    regionID: number | null
    orbitID: number | null
    x: number | null
    y: number | null
    z: number | null
    radius: number | null
    itemName: string | null
    security: number | null
    celestialIndex: number | null
    orbitIndex: number | null
    _count: MapDenormalizeCountAggregateOutputType | null
    _avg: MapDenormalizeAvgAggregateOutputType | null
    _sum: MapDenormalizeSumAggregateOutputType | null
    _min: MapDenormalizeMinAggregateOutputType | null
    _max: MapDenormalizeMaxAggregateOutputType | null
  }

  type GetMapDenormalizeGroupByPayload<T extends mapDenormalizeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MapDenormalizeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MapDenormalizeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MapDenormalizeGroupByOutputType[P]>
            : GetScalarType<T[P], MapDenormalizeGroupByOutputType[P]>
        }
      >
    >


  export type mapDenormalizeSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    itemID?: boolean
    typeID?: boolean
    groupID?: boolean
    solarSystemID?: boolean
    constellationID?: boolean
    regionID?: boolean
    orbitID?: boolean
    x?: boolean
    y?: boolean
    z?: boolean
    radius?: boolean
    itemName?: boolean
    security?: boolean
    celestialIndex?: boolean
    orbitIndex?: boolean
  }, ExtArgs["result"]["mapDenormalize"]>

  export type mapDenormalizeSelectScalar = {
    itemID?: boolean
    typeID?: boolean
    groupID?: boolean
    solarSystemID?: boolean
    constellationID?: boolean
    regionID?: boolean
    orbitID?: boolean
    x?: boolean
    y?: boolean
    z?: boolean
    radius?: boolean
    itemName?: boolean
    security?: boolean
    celestialIndex?: boolean
    orbitIndex?: boolean
  }


  export type $mapDenormalizePayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    name: "mapDenormalize"
    objects: {}
    scalars: $Extensions.GetResult<{
      itemID: number
      typeID: number | null
      groupID: number | null
      solarSystemID: number | null
      constellationID: number | null
      regionID: number | null
      orbitID: number | null
      x: number | null
      y: number | null
      z: number | null
      radius: number | null
      itemName: string | null
      security: number | null
      celestialIndex: number | null
      orbitIndex: number | null
    }, ExtArgs["result"]["mapDenormalize"]>
    composites: {}
  }


  type mapDenormalizeGetPayload<S extends boolean | null | undefined | mapDenormalizeDefaultArgs> = $Result.GetResult<Prisma.$mapDenormalizePayload, S>

  type mapDenormalizeCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<mapDenormalizeFindManyArgs, 'select' | 'include'> & {
      select?: MapDenormalizeCountAggregateInputType | true
    }

  export interface mapDenormalizeDelegate<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['mapDenormalize'], meta: { name: 'mapDenormalize' } }
    /**
     * Find zero or one MapDenormalize that matches the filter.
     * @param {mapDenormalizeFindUniqueArgs} args - Arguments to find a MapDenormalize
     * @example
     * // Get one MapDenormalize
     * const mapDenormalize = await prisma.mapDenormalize.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends mapDenormalizeFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, mapDenormalizeFindUniqueArgs<ExtArgs>>
    ): Prisma__mapDenormalizeClient<$Result.GetResult<Prisma.$mapDenormalizePayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one MapDenormalize that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {mapDenormalizeFindUniqueOrThrowArgs} args - Arguments to find a MapDenormalize
     * @example
     * // Get one MapDenormalize
     * const mapDenormalize = await prisma.mapDenormalize.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends mapDenormalizeFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, mapDenormalizeFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__mapDenormalizeClient<$Result.GetResult<Prisma.$mapDenormalizePayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first MapDenormalize that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {mapDenormalizeFindFirstArgs} args - Arguments to find a MapDenormalize
     * @example
     * // Get one MapDenormalize
     * const mapDenormalize = await prisma.mapDenormalize.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends mapDenormalizeFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, mapDenormalizeFindFirstArgs<ExtArgs>>
    ): Prisma__mapDenormalizeClient<$Result.GetResult<Prisma.$mapDenormalizePayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first MapDenormalize that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {mapDenormalizeFindFirstOrThrowArgs} args - Arguments to find a MapDenormalize
     * @example
     * // Get one MapDenormalize
     * const mapDenormalize = await prisma.mapDenormalize.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends mapDenormalizeFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, mapDenormalizeFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__mapDenormalizeClient<$Result.GetResult<Prisma.$mapDenormalizePayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more MapDenormalizes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {mapDenormalizeFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MapDenormalizes
     * const mapDenormalizes = await prisma.mapDenormalize.findMany()
     * 
     * // Get first 10 MapDenormalizes
     * const mapDenormalizes = await prisma.mapDenormalize.findMany({ take: 10 })
     * 
     * // Only select the `itemID`
     * const mapDenormalizeWithItemIDOnly = await prisma.mapDenormalize.findMany({ select: { itemID: true } })
     * 
    **/
    findMany<T extends mapDenormalizeFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, mapDenormalizeFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$mapDenormalizePayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a MapDenormalize.
     * @param {mapDenormalizeCreateArgs} args - Arguments to create a MapDenormalize.
     * @example
     * // Create one MapDenormalize
     * const MapDenormalize = await prisma.mapDenormalize.create({
     *   data: {
     *     // ... data to create a MapDenormalize
     *   }
     * })
     * 
    **/
    create<T extends mapDenormalizeCreateArgs<ExtArgs>>(
      args: SelectSubset<T, mapDenormalizeCreateArgs<ExtArgs>>
    ): Prisma__mapDenormalizeClient<$Result.GetResult<Prisma.$mapDenormalizePayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many MapDenormalizes.
     *     @param {mapDenormalizeCreateManyArgs} args - Arguments to create many MapDenormalizes.
     *     @example
     *     // Create many MapDenormalizes
     *     const mapDenormalize = await prisma.mapDenormalize.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends mapDenormalizeCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, mapDenormalizeCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a MapDenormalize.
     * @param {mapDenormalizeDeleteArgs} args - Arguments to delete one MapDenormalize.
     * @example
     * // Delete one MapDenormalize
     * const MapDenormalize = await prisma.mapDenormalize.delete({
     *   where: {
     *     // ... filter to delete one MapDenormalize
     *   }
     * })
     * 
    **/
    delete<T extends mapDenormalizeDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, mapDenormalizeDeleteArgs<ExtArgs>>
    ): Prisma__mapDenormalizeClient<$Result.GetResult<Prisma.$mapDenormalizePayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one MapDenormalize.
     * @param {mapDenormalizeUpdateArgs} args - Arguments to update one MapDenormalize.
     * @example
     * // Update one MapDenormalize
     * const mapDenormalize = await prisma.mapDenormalize.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends mapDenormalizeUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, mapDenormalizeUpdateArgs<ExtArgs>>
    ): Prisma__mapDenormalizeClient<$Result.GetResult<Prisma.$mapDenormalizePayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more MapDenormalizes.
     * @param {mapDenormalizeDeleteManyArgs} args - Arguments to filter MapDenormalizes to delete.
     * @example
     * // Delete a few MapDenormalizes
     * const { count } = await prisma.mapDenormalize.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends mapDenormalizeDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, mapDenormalizeDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MapDenormalizes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {mapDenormalizeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MapDenormalizes
     * const mapDenormalize = await prisma.mapDenormalize.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends mapDenormalizeUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, mapDenormalizeUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one MapDenormalize.
     * @param {mapDenormalizeUpsertArgs} args - Arguments to update or create a MapDenormalize.
     * @example
     * // Update or create a MapDenormalize
     * const mapDenormalize = await prisma.mapDenormalize.upsert({
     *   create: {
     *     // ... data to create a MapDenormalize
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MapDenormalize we want to update
     *   }
     * })
    **/
    upsert<T extends mapDenormalizeUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, mapDenormalizeUpsertArgs<ExtArgs>>
    ): Prisma__mapDenormalizeClient<$Result.GetResult<Prisma.$mapDenormalizePayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of MapDenormalizes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {mapDenormalizeCountArgs} args - Arguments to filter MapDenormalizes to count.
     * @example
     * // Count the number of MapDenormalizes
     * const count = await prisma.mapDenormalize.count({
     *   where: {
     *     // ... the filter for the MapDenormalizes we want to count
     *   }
     * })
    **/
    count<T extends mapDenormalizeCountArgs>(
      args?: Subset<T, mapDenormalizeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MapDenormalizeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MapDenormalize.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MapDenormalizeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MapDenormalizeAggregateArgs>(args: Subset<T, MapDenormalizeAggregateArgs>): Prisma.PrismaPromise<GetMapDenormalizeAggregateType<T>>

    /**
     * Group by MapDenormalize.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {mapDenormalizeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends mapDenormalizeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: mapDenormalizeGroupByArgs['orderBy'] }
        : { orderBy?: mapDenormalizeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, mapDenormalizeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMapDenormalizeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the mapDenormalize model
   */
  readonly fields: mapDenormalizeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for mapDenormalize.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__mapDenormalizeClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';


    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the mapDenormalize model
   */ 
  interface mapDenormalizeFieldRefs {
    readonly itemID: FieldRef<"mapDenormalize", 'Int'>
    readonly typeID: FieldRef<"mapDenormalize", 'Int'>
    readonly groupID: FieldRef<"mapDenormalize", 'Int'>
    readonly solarSystemID: FieldRef<"mapDenormalize", 'Int'>
    readonly constellationID: FieldRef<"mapDenormalize", 'Int'>
    readonly regionID: FieldRef<"mapDenormalize", 'Int'>
    readonly orbitID: FieldRef<"mapDenormalize", 'Int'>
    readonly x: FieldRef<"mapDenormalize", 'Float'>
    readonly y: FieldRef<"mapDenormalize", 'Float'>
    readonly z: FieldRef<"mapDenormalize", 'Float'>
    readonly radius: FieldRef<"mapDenormalize", 'Float'>
    readonly itemName: FieldRef<"mapDenormalize", 'String'>
    readonly security: FieldRef<"mapDenormalize", 'Float'>
    readonly celestialIndex: FieldRef<"mapDenormalize", 'Int'>
    readonly orbitIndex: FieldRef<"mapDenormalize", 'Int'>
  }
    

  // Custom InputTypes

  /**
   * mapDenormalize findUnique
   */
  export type mapDenormalizeFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the mapDenormalize
     */
    select?: mapDenormalizeSelect<ExtArgs> | null
    /**
     * Filter, which mapDenormalize to fetch.
     */
    where: mapDenormalizeWhereUniqueInput
  }


  /**
   * mapDenormalize findUniqueOrThrow
   */
  export type mapDenormalizeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the mapDenormalize
     */
    select?: mapDenormalizeSelect<ExtArgs> | null
    /**
     * Filter, which mapDenormalize to fetch.
     */
    where: mapDenormalizeWhereUniqueInput
  }


  /**
   * mapDenormalize findFirst
   */
  export type mapDenormalizeFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the mapDenormalize
     */
    select?: mapDenormalizeSelect<ExtArgs> | null
    /**
     * Filter, which mapDenormalize to fetch.
     */
    where?: mapDenormalizeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of mapDenormalizes to fetch.
     */
    orderBy?: mapDenormalizeOrderByWithRelationInput | mapDenormalizeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for mapDenormalizes.
     */
    cursor?: mapDenormalizeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` mapDenormalizes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` mapDenormalizes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of mapDenormalizes.
     */
    distinct?: MapDenormalizeScalarFieldEnum | MapDenormalizeScalarFieldEnum[]
  }


  /**
   * mapDenormalize findFirstOrThrow
   */
  export type mapDenormalizeFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the mapDenormalize
     */
    select?: mapDenormalizeSelect<ExtArgs> | null
    /**
     * Filter, which mapDenormalize to fetch.
     */
    where?: mapDenormalizeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of mapDenormalizes to fetch.
     */
    orderBy?: mapDenormalizeOrderByWithRelationInput | mapDenormalizeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for mapDenormalizes.
     */
    cursor?: mapDenormalizeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` mapDenormalizes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` mapDenormalizes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of mapDenormalizes.
     */
    distinct?: MapDenormalizeScalarFieldEnum | MapDenormalizeScalarFieldEnum[]
  }


  /**
   * mapDenormalize findMany
   */
  export type mapDenormalizeFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the mapDenormalize
     */
    select?: mapDenormalizeSelect<ExtArgs> | null
    /**
     * Filter, which mapDenormalizes to fetch.
     */
    where?: mapDenormalizeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of mapDenormalizes to fetch.
     */
    orderBy?: mapDenormalizeOrderByWithRelationInput | mapDenormalizeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing mapDenormalizes.
     */
    cursor?: mapDenormalizeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` mapDenormalizes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` mapDenormalizes.
     */
    skip?: number
    distinct?: MapDenormalizeScalarFieldEnum | MapDenormalizeScalarFieldEnum[]
  }


  /**
   * mapDenormalize create
   */
  export type mapDenormalizeCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the mapDenormalize
     */
    select?: mapDenormalizeSelect<ExtArgs> | null
    /**
     * The data needed to create a mapDenormalize.
     */
    data: XOR<mapDenormalizeCreateInput, mapDenormalizeUncheckedCreateInput>
  }


  /**
   * mapDenormalize createMany
   */
  export type mapDenormalizeCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many mapDenormalizes.
     */
    data: mapDenormalizeCreateManyInput | mapDenormalizeCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * mapDenormalize update
   */
  export type mapDenormalizeUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the mapDenormalize
     */
    select?: mapDenormalizeSelect<ExtArgs> | null
    /**
     * The data needed to update a mapDenormalize.
     */
    data: XOR<mapDenormalizeUpdateInput, mapDenormalizeUncheckedUpdateInput>
    /**
     * Choose, which mapDenormalize to update.
     */
    where: mapDenormalizeWhereUniqueInput
  }


  /**
   * mapDenormalize updateMany
   */
  export type mapDenormalizeUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update mapDenormalizes.
     */
    data: XOR<mapDenormalizeUpdateManyMutationInput, mapDenormalizeUncheckedUpdateManyInput>
    /**
     * Filter which mapDenormalizes to update
     */
    where?: mapDenormalizeWhereInput
  }


  /**
   * mapDenormalize upsert
   */
  export type mapDenormalizeUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the mapDenormalize
     */
    select?: mapDenormalizeSelect<ExtArgs> | null
    /**
     * The filter to search for the mapDenormalize to update in case it exists.
     */
    where: mapDenormalizeWhereUniqueInput
    /**
     * In case the mapDenormalize found by the `where` argument doesn't exist, create a new mapDenormalize with this data.
     */
    create: XOR<mapDenormalizeCreateInput, mapDenormalizeUncheckedCreateInput>
    /**
     * In case the mapDenormalize was found with the provided `where` argument, update it with this data.
     */
    update: XOR<mapDenormalizeUpdateInput, mapDenormalizeUncheckedUpdateInput>
  }


  /**
   * mapDenormalize delete
   */
  export type mapDenormalizeDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the mapDenormalize
     */
    select?: mapDenormalizeSelect<ExtArgs> | null
    /**
     * Filter which mapDenormalize to delete.
     */
    where: mapDenormalizeWhereUniqueInput
  }


  /**
   * mapDenormalize deleteMany
   */
  export type mapDenormalizeDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which mapDenormalizes to delete
     */
    where?: mapDenormalizeWhereInput
  }


  /**
   * mapDenormalize without action
   */
  export type mapDenormalizeDefaultArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the mapDenormalize
     */
    select?: mapDenormalizeSelect<ExtArgs> | null
  }



  /**
   * Model mapJumps
   */

  export type AggregateMapJumps = {
    _count: MapJumpsCountAggregateOutputType | null
    _avg: MapJumpsAvgAggregateOutputType | null
    _sum: MapJumpsSumAggregateOutputType | null
    _min: MapJumpsMinAggregateOutputType | null
    _max: MapJumpsMaxAggregateOutputType | null
  }

  export type MapJumpsAvgAggregateOutputType = {
    stargateID: number | null
    destinationID: number | null
  }

  export type MapJumpsSumAggregateOutputType = {
    stargateID: number | null
    destinationID: number | null
  }

  export type MapJumpsMinAggregateOutputType = {
    stargateID: number | null
    destinationID: number | null
  }

  export type MapJumpsMaxAggregateOutputType = {
    stargateID: number | null
    destinationID: number | null
  }

  export type MapJumpsCountAggregateOutputType = {
    stargateID: number
    destinationID: number
    _all: number
  }


  export type MapJumpsAvgAggregateInputType = {
    stargateID?: true
    destinationID?: true
  }

  export type MapJumpsSumAggregateInputType = {
    stargateID?: true
    destinationID?: true
  }

  export type MapJumpsMinAggregateInputType = {
    stargateID?: true
    destinationID?: true
  }

  export type MapJumpsMaxAggregateInputType = {
    stargateID?: true
    destinationID?: true
  }

  export type MapJumpsCountAggregateInputType = {
    stargateID?: true
    destinationID?: true
    _all?: true
  }

  export type MapJumpsAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which mapJumps to aggregate.
     */
    where?: mapJumpsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of mapJumps to fetch.
     */
    orderBy?: mapJumpsOrderByWithRelationInput | mapJumpsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: mapJumpsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` mapJumps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` mapJumps.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned mapJumps
    **/
    _count?: true | MapJumpsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MapJumpsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MapJumpsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MapJumpsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MapJumpsMaxAggregateInputType
  }

  export type GetMapJumpsAggregateType<T extends MapJumpsAggregateArgs> = {
        [P in keyof T & keyof AggregateMapJumps]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMapJumps[P]>
      : GetScalarType<T[P], AggregateMapJumps[P]>
  }




  export type mapJumpsGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: mapJumpsWhereInput
    orderBy?: mapJumpsOrderByWithAggregationInput | mapJumpsOrderByWithAggregationInput[]
    by: MapJumpsScalarFieldEnum[] | MapJumpsScalarFieldEnum
    having?: mapJumpsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MapJumpsCountAggregateInputType | true
    _avg?: MapJumpsAvgAggregateInputType
    _sum?: MapJumpsSumAggregateInputType
    _min?: MapJumpsMinAggregateInputType
    _max?: MapJumpsMaxAggregateInputType
  }

  export type MapJumpsGroupByOutputType = {
    stargateID: number
    destinationID: number | null
    _count: MapJumpsCountAggregateOutputType | null
    _avg: MapJumpsAvgAggregateOutputType | null
    _sum: MapJumpsSumAggregateOutputType | null
    _min: MapJumpsMinAggregateOutputType | null
    _max: MapJumpsMaxAggregateOutputType | null
  }

  type GetMapJumpsGroupByPayload<T extends mapJumpsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MapJumpsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MapJumpsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MapJumpsGroupByOutputType[P]>
            : GetScalarType<T[P], MapJumpsGroupByOutputType[P]>
        }
      >
    >


  export type mapJumpsSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    stargateID?: boolean
    destinationID?: boolean
  }, ExtArgs["result"]["mapJumps"]>

  export type mapJumpsSelectScalar = {
    stargateID?: boolean
    destinationID?: boolean
  }


  export type $mapJumpsPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    name: "mapJumps"
    objects: {}
    scalars: $Extensions.GetResult<{
      stargateID: number
      destinationID: number | null
    }, ExtArgs["result"]["mapJumps"]>
    composites: {}
  }


  type mapJumpsGetPayload<S extends boolean | null | undefined | mapJumpsDefaultArgs> = $Result.GetResult<Prisma.$mapJumpsPayload, S>

  type mapJumpsCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<mapJumpsFindManyArgs, 'select' | 'include'> & {
      select?: MapJumpsCountAggregateInputType | true
    }

  export interface mapJumpsDelegate<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['mapJumps'], meta: { name: 'mapJumps' } }
    /**
     * Find zero or one MapJumps that matches the filter.
     * @param {mapJumpsFindUniqueArgs} args - Arguments to find a MapJumps
     * @example
     * // Get one MapJumps
     * const mapJumps = await prisma.mapJumps.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends mapJumpsFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, mapJumpsFindUniqueArgs<ExtArgs>>
    ): Prisma__mapJumpsClient<$Result.GetResult<Prisma.$mapJumpsPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one MapJumps that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {mapJumpsFindUniqueOrThrowArgs} args - Arguments to find a MapJumps
     * @example
     * // Get one MapJumps
     * const mapJumps = await prisma.mapJumps.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends mapJumpsFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, mapJumpsFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__mapJumpsClient<$Result.GetResult<Prisma.$mapJumpsPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first MapJumps that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {mapJumpsFindFirstArgs} args - Arguments to find a MapJumps
     * @example
     * // Get one MapJumps
     * const mapJumps = await prisma.mapJumps.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends mapJumpsFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, mapJumpsFindFirstArgs<ExtArgs>>
    ): Prisma__mapJumpsClient<$Result.GetResult<Prisma.$mapJumpsPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first MapJumps that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {mapJumpsFindFirstOrThrowArgs} args - Arguments to find a MapJumps
     * @example
     * // Get one MapJumps
     * const mapJumps = await prisma.mapJumps.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends mapJumpsFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, mapJumpsFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__mapJumpsClient<$Result.GetResult<Prisma.$mapJumpsPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more MapJumps that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {mapJumpsFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MapJumps
     * const mapJumps = await prisma.mapJumps.findMany()
     * 
     * // Get first 10 MapJumps
     * const mapJumps = await prisma.mapJumps.findMany({ take: 10 })
     * 
     * // Only select the `stargateID`
     * const mapJumpsWithStargateIDOnly = await prisma.mapJumps.findMany({ select: { stargateID: true } })
     * 
    **/
    findMany<T extends mapJumpsFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, mapJumpsFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$mapJumpsPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a MapJumps.
     * @param {mapJumpsCreateArgs} args - Arguments to create a MapJumps.
     * @example
     * // Create one MapJumps
     * const MapJumps = await prisma.mapJumps.create({
     *   data: {
     *     // ... data to create a MapJumps
     *   }
     * })
     * 
    **/
    create<T extends mapJumpsCreateArgs<ExtArgs>>(
      args: SelectSubset<T, mapJumpsCreateArgs<ExtArgs>>
    ): Prisma__mapJumpsClient<$Result.GetResult<Prisma.$mapJumpsPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many MapJumps.
     *     @param {mapJumpsCreateManyArgs} args - Arguments to create many MapJumps.
     *     @example
     *     // Create many MapJumps
     *     const mapJumps = await prisma.mapJumps.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends mapJumpsCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, mapJumpsCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a MapJumps.
     * @param {mapJumpsDeleteArgs} args - Arguments to delete one MapJumps.
     * @example
     * // Delete one MapJumps
     * const MapJumps = await prisma.mapJumps.delete({
     *   where: {
     *     // ... filter to delete one MapJumps
     *   }
     * })
     * 
    **/
    delete<T extends mapJumpsDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, mapJumpsDeleteArgs<ExtArgs>>
    ): Prisma__mapJumpsClient<$Result.GetResult<Prisma.$mapJumpsPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one MapJumps.
     * @param {mapJumpsUpdateArgs} args - Arguments to update one MapJumps.
     * @example
     * // Update one MapJumps
     * const mapJumps = await prisma.mapJumps.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends mapJumpsUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, mapJumpsUpdateArgs<ExtArgs>>
    ): Prisma__mapJumpsClient<$Result.GetResult<Prisma.$mapJumpsPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more MapJumps.
     * @param {mapJumpsDeleteManyArgs} args - Arguments to filter MapJumps to delete.
     * @example
     * // Delete a few MapJumps
     * const { count } = await prisma.mapJumps.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends mapJumpsDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, mapJumpsDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MapJumps.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {mapJumpsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MapJumps
     * const mapJumps = await prisma.mapJumps.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends mapJumpsUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, mapJumpsUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one MapJumps.
     * @param {mapJumpsUpsertArgs} args - Arguments to update or create a MapJumps.
     * @example
     * // Update or create a MapJumps
     * const mapJumps = await prisma.mapJumps.upsert({
     *   create: {
     *     // ... data to create a MapJumps
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MapJumps we want to update
     *   }
     * })
    **/
    upsert<T extends mapJumpsUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, mapJumpsUpsertArgs<ExtArgs>>
    ): Prisma__mapJumpsClient<$Result.GetResult<Prisma.$mapJumpsPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of MapJumps.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {mapJumpsCountArgs} args - Arguments to filter MapJumps to count.
     * @example
     * // Count the number of MapJumps
     * const count = await prisma.mapJumps.count({
     *   where: {
     *     // ... the filter for the MapJumps we want to count
     *   }
     * })
    **/
    count<T extends mapJumpsCountArgs>(
      args?: Subset<T, mapJumpsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MapJumpsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MapJumps.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MapJumpsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MapJumpsAggregateArgs>(args: Subset<T, MapJumpsAggregateArgs>): Prisma.PrismaPromise<GetMapJumpsAggregateType<T>>

    /**
     * Group by MapJumps.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {mapJumpsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends mapJumpsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: mapJumpsGroupByArgs['orderBy'] }
        : { orderBy?: mapJumpsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, mapJumpsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMapJumpsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the mapJumps model
   */
  readonly fields: mapJumpsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for mapJumps.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__mapJumpsClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';


    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the mapJumps model
   */ 
  interface mapJumpsFieldRefs {
    readonly stargateID: FieldRef<"mapJumps", 'Int'>
    readonly destinationID: FieldRef<"mapJumps", 'Int'>
  }
    

  // Custom InputTypes

  /**
   * mapJumps findUnique
   */
  export type mapJumpsFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the mapJumps
     */
    select?: mapJumpsSelect<ExtArgs> | null
    /**
     * Filter, which mapJumps to fetch.
     */
    where: mapJumpsWhereUniqueInput
  }


  /**
   * mapJumps findUniqueOrThrow
   */
  export type mapJumpsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the mapJumps
     */
    select?: mapJumpsSelect<ExtArgs> | null
    /**
     * Filter, which mapJumps to fetch.
     */
    where: mapJumpsWhereUniqueInput
  }


  /**
   * mapJumps findFirst
   */
  export type mapJumpsFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the mapJumps
     */
    select?: mapJumpsSelect<ExtArgs> | null
    /**
     * Filter, which mapJumps to fetch.
     */
    where?: mapJumpsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of mapJumps to fetch.
     */
    orderBy?: mapJumpsOrderByWithRelationInput | mapJumpsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for mapJumps.
     */
    cursor?: mapJumpsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` mapJumps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` mapJumps.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of mapJumps.
     */
    distinct?: MapJumpsScalarFieldEnum | MapJumpsScalarFieldEnum[]
  }


  /**
   * mapJumps findFirstOrThrow
   */
  export type mapJumpsFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the mapJumps
     */
    select?: mapJumpsSelect<ExtArgs> | null
    /**
     * Filter, which mapJumps to fetch.
     */
    where?: mapJumpsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of mapJumps to fetch.
     */
    orderBy?: mapJumpsOrderByWithRelationInput | mapJumpsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for mapJumps.
     */
    cursor?: mapJumpsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` mapJumps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` mapJumps.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of mapJumps.
     */
    distinct?: MapJumpsScalarFieldEnum | MapJumpsScalarFieldEnum[]
  }


  /**
   * mapJumps findMany
   */
  export type mapJumpsFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the mapJumps
     */
    select?: mapJumpsSelect<ExtArgs> | null
    /**
     * Filter, which mapJumps to fetch.
     */
    where?: mapJumpsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of mapJumps to fetch.
     */
    orderBy?: mapJumpsOrderByWithRelationInput | mapJumpsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing mapJumps.
     */
    cursor?: mapJumpsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` mapJumps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` mapJumps.
     */
    skip?: number
    distinct?: MapJumpsScalarFieldEnum | MapJumpsScalarFieldEnum[]
  }


  /**
   * mapJumps create
   */
  export type mapJumpsCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the mapJumps
     */
    select?: mapJumpsSelect<ExtArgs> | null
    /**
     * The data needed to create a mapJumps.
     */
    data: XOR<mapJumpsCreateInput, mapJumpsUncheckedCreateInput>
  }


  /**
   * mapJumps createMany
   */
  export type mapJumpsCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many mapJumps.
     */
    data: mapJumpsCreateManyInput | mapJumpsCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * mapJumps update
   */
  export type mapJumpsUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the mapJumps
     */
    select?: mapJumpsSelect<ExtArgs> | null
    /**
     * The data needed to update a mapJumps.
     */
    data: XOR<mapJumpsUpdateInput, mapJumpsUncheckedUpdateInput>
    /**
     * Choose, which mapJumps to update.
     */
    where: mapJumpsWhereUniqueInput
  }


  /**
   * mapJumps updateMany
   */
  export type mapJumpsUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update mapJumps.
     */
    data: XOR<mapJumpsUpdateManyMutationInput, mapJumpsUncheckedUpdateManyInput>
    /**
     * Filter which mapJumps to update
     */
    where?: mapJumpsWhereInput
  }


  /**
   * mapJumps upsert
   */
  export type mapJumpsUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the mapJumps
     */
    select?: mapJumpsSelect<ExtArgs> | null
    /**
     * The filter to search for the mapJumps to update in case it exists.
     */
    where: mapJumpsWhereUniqueInput
    /**
     * In case the mapJumps found by the `where` argument doesn't exist, create a new mapJumps with this data.
     */
    create: XOR<mapJumpsCreateInput, mapJumpsUncheckedCreateInput>
    /**
     * In case the mapJumps was found with the provided `where` argument, update it with this data.
     */
    update: XOR<mapJumpsUpdateInput, mapJumpsUncheckedUpdateInput>
  }


  /**
   * mapJumps delete
   */
  export type mapJumpsDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the mapJumps
     */
    select?: mapJumpsSelect<ExtArgs> | null
    /**
     * Filter which mapJumps to delete.
     */
    where: mapJumpsWhereUniqueInput
  }


  /**
   * mapJumps deleteMany
   */
  export type mapJumpsDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which mapJumps to delete
     */
    where?: mapJumpsWhereInput
  }


  /**
   * mapJumps without action
   */
  export type mapJumpsDefaultArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the mapJumps
     */
    select?: mapJumpsSelect<ExtArgs> | null
  }



  /**
   * Model mapLandmarks
   */

  export type AggregateMapLandmarks = {
    _count: MapLandmarksCountAggregateOutputType | null
    _avg: MapLandmarksAvgAggregateOutputType | null
    _sum: MapLandmarksSumAggregateOutputType | null
    _min: MapLandmarksMinAggregateOutputType | null
    _max: MapLandmarksMaxAggregateOutputType | null
  }

  export type MapLandmarksAvgAggregateOutputType = {
    landmarkID: number | null
    locationID: number | null
    x: number | null
    y: number | null
    z: number | null
    iconID: number | null
  }

  export type MapLandmarksSumAggregateOutputType = {
    landmarkID: number | null
    locationID: number | null
    x: number | null
    y: number | null
    z: number | null
    iconID: number | null
  }

  export type MapLandmarksMinAggregateOutputType = {
    landmarkID: number | null
    landmarkName: string | null
    description: string | null
    locationID: number | null
    x: number | null
    y: number | null
    z: number | null
    iconID: number | null
  }

  export type MapLandmarksMaxAggregateOutputType = {
    landmarkID: number | null
    landmarkName: string | null
    description: string | null
    locationID: number | null
    x: number | null
    y: number | null
    z: number | null
    iconID: number | null
  }

  export type MapLandmarksCountAggregateOutputType = {
    landmarkID: number
    landmarkName: number
    description: number
    locationID: number
    x: number
    y: number
    z: number
    iconID: number
    _all: number
  }


  export type MapLandmarksAvgAggregateInputType = {
    landmarkID?: true
    locationID?: true
    x?: true
    y?: true
    z?: true
    iconID?: true
  }

  export type MapLandmarksSumAggregateInputType = {
    landmarkID?: true
    locationID?: true
    x?: true
    y?: true
    z?: true
    iconID?: true
  }

  export type MapLandmarksMinAggregateInputType = {
    landmarkID?: true
    landmarkName?: true
    description?: true
    locationID?: true
    x?: true
    y?: true
    z?: true
    iconID?: true
  }

  export type MapLandmarksMaxAggregateInputType = {
    landmarkID?: true
    landmarkName?: true
    description?: true
    locationID?: true
    x?: true
    y?: true
    z?: true
    iconID?: true
  }

  export type MapLandmarksCountAggregateInputType = {
    landmarkID?: true
    landmarkName?: true
    description?: true
    locationID?: true
    x?: true
    y?: true
    z?: true
    iconID?: true
    _all?: true
  }

  export type MapLandmarksAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which mapLandmarks to aggregate.
     */
    where?: mapLandmarksWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of mapLandmarks to fetch.
     */
    orderBy?: mapLandmarksOrderByWithRelationInput | mapLandmarksOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: mapLandmarksWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` mapLandmarks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` mapLandmarks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned mapLandmarks
    **/
    _count?: true | MapLandmarksCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MapLandmarksAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MapLandmarksSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MapLandmarksMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MapLandmarksMaxAggregateInputType
  }

  export type GetMapLandmarksAggregateType<T extends MapLandmarksAggregateArgs> = {
        [P in keyof T & keyof AggregateMapLandmarks]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMapLandmarks[P]>
      : GetScalarType<T[P], AggregateMapLandmarks[P]>
  }




  export type mapLandmarksGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: mapLandmarksWhereInput
    orderBy?: mapLandmarksOrderByWithAggregationInput | mapLandmarksOrderByWithAggregationInput[]
    by: MapLandmarksScalarFieldEnum[] | MapLandmarksScalarFieldEnum
    having?: mapLandmarksScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MapLandmarksCountAggregateInputType | true
    _avg?: MapLandmarksAvgAggregateInputType
    _sum?: MapLandmarksSumAggregateInputType
    _min?: MapLandmarksMinAggregateInputType
    _max?: MapLandmarksMaxAggregateInputType
  }

  export type MapLandmarksGroupByOutputType = {
    landmarkID: number
    landmarkName: string | null
    description: string | null
    locationID: number | null
    x: number | null
    y: number | null
    z: number | null
    iconID: number | null
    _count: MapLandmarksCountAggregateOutputType | null
    _avg: MapLandmarksAvgAggregateOutputType | null
    _sum: MapLandmarksSumAggregateOutputType | null
    _min: MapLandmarksMinAggregateOutputType | null
    _max: MapLandmarksMaxAggregateOutputType | null
  }

  type GetMapLandmarksGroupByPayload<T extends mapLandmarksGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MapLandmarksGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MapLandmarksGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MapLandmarksGroupByOutputType[P]>
            : GetScalarType<T[P], MapLandmarksGroupByOutputType[P]>
        }
      >
    >


  export type mapLandmarksSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    landmarkID?: boolean
    landmarkName?: boolean
    description?: boolean
    locationID?: boolean
    x?: boolean
    y?: boolean
    z?: boolean
    iconID?: boolean
  }, ExtArgs["result"]["mapLandmarks"]>

  export type mapLandmarksSelectScalar = {
    landmarkID?: boolean
    landmarkName?: boolean
    description?: boolean
    locationID?: boolean
    x?: boolean
    y?: boolean
    z?: boolean
    iconID?: boolean
  }


  export type $mapLandmarksPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    name: "mapLandmarks"
    objects: {}
    scalars: $Extensions.GetResult<{
      landmarkID: number
      landmarkName: string | null
      description: string | null
      locationID: number | null
      x: number | null
      y: number | null
      z: number | null
      iconID: number | null
    }, ExtArgs["result"]["mapLandmarks"]>
    composites: {}
  }


  type mapLandmarksGetPayload<S extends boolean | null | undefined | mapLandmarksDefaultArgs> = $Result.GetResult<Prisma.$mapLandmarksPayload, S>

  type mapLandmarksCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<mapLandmarksFindManyArgs, 'select' | 'include'> & {
      select?: MapLandmarksCountAggregateInputType | true
    }

  export interface mapLandmarksDelegate<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['mapLandmarks'], meta: { name: 'mapLandmarks' } }
    /**
     * Find zero or one MapLandmarks that matches the filter.
     * @param {mapLandmarksFindUniqueArgs} args - Arguments to find a MapLandmarks
     * @example
     * // Get one MapLandmarks
     * const mapLandmarks = await prisma.mapLandmarks.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends mapLandmarksFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, mapLandmarksFindUniqueArgs<ExtArgs>>
    ): Prisma__mapLandmarksClient<$Result.GetResult<Prisma.$mapLandmarksPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one MapLandmarks that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {mapLandmarksFindUniqueOrThrowArgs} args - Arguments to find a MapLandmarks
     * @example
     * // Get one MapLandmarks
     * const mapLandmarks = await prisma.mapLandmarks.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends mapLandmarksFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, mapLandmarksFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__mapLandmarksClient<$Result.GetResult<Prisma.$mapLandmarksPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first MapLandmarks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {mapLandmarksFindFirstArgs} args - Arguments to find a MapLandmarks
     * @example
     * // Get one MapLandmarks
     * const mapLandmarks = await prisma.mapLandmarks.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends mapLandmarksFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, mapLandmarksFindFirstArgs<ExtArgs>>
    ): Prisma__mapLandmarksClient<$Result.GetResult<Prisma.$mapLandmarksPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first MapLandmarks that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {mapLandmarksFindFirstOrThrowArgs} args - Arguments to find a MapLandmarks
     * @example
     * // Get one MapLandmarks
     * const mapLandmarks = await prisma.mapLandmarks.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends mapLandmarksFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, mapLandmarksFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__mapLandmarksClient<$Result.GetResult<Prisma.$mapLandmarksPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more MapLandmarks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {mapLandmarksFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MapLandmarks
     * const mapLandmarks = await prisma.mapLandmarks.findMany()
     * 
     * // Get first 10 MapLandmarks
     * const mapLandmarks = await prisma.mapLandmarks.findMany({ take: 10 })
     * 
     * // Only select the `landmarkID`
     * const mapLandmarksWithLandmarkIDOnly = await prisma.mapLandmarks.findMany({ select: { landmarkID: true } })
     * 
    **/
    findMany<T extends mapLandmarksFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, mapLandmarksFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$mapLandmarksPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a MapLandmarks.
     * @param {mapLandmarksCreateArgs} args - Arguments to create a MapLandmarks.
     * @example
     * // Create one MapLandmarks
     * const MapLandmarks = await prisma.mapLandmarks.create({
     *   data: {
     *     // ... data to create a MapLandmarks
     *   }
     * })
     * 
    **/
    create<T extends mapLandmarksCreateArgs<ExtArgs>>(
      args: SelectSubset<T, mapLandmarksCreateArgs<ExtArgs>>
    ): Prisma__mapLandmarksClient<$Result.GetResult<Prisma.$mapLandmarksPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many MapLandmarks.
     *     @param {mapLandmarksCreateManyArgs} args - Arguments to create many MapLandmarks.
     *     @example
     *     // Create many MapLandmarks
     *     const mapLandmarks = await prisma.mapLandmarks.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends mapLandmarksCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, mapLandmarksCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a MapLandmarks.
     * @param {mapLandmarksDeleteArgs} args - Arguments to delete one MapLandmarks.
     * @example
     * // Delete one MapLandmarks
     * const MapLandmarks = await prisma.mapLandmarks.delete({
     *   where: {
     *     // ... filter to delete one MapLandmarks
     *   }
     * })
     * 
    **/
    delete<T extends mapLandmarksDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, mapLandmarksDeleteArgs<ExtArgs>>
    ): Prisma__mapLandmarksClient<$Result.GetResult<Prisma.$mapLandmarksPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one MapLandmarks.
     * @param {mapLandmarksUpdateArgs} args - Arguments to update one MapLandmarks.
     * @example
     * // Update one MapLandmarks
     * const mapLandmarks = await prisma.mapLandmarks.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends mapLandmarksUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, mapLandmarksUpdateArgs<ExtArgs>>
    ): Prisma__mapLandmarksClient<$Result.GetResult<Prisma.$mapLandmarksPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more MapLandmarks.
     * @param {mapLandmarksDeleteManyArgs} args - Arguments to filter MapLandmarks to delete.
     * @example
     * // Delete a few MapLandmarks
     * const { count } = await prisma.mapLandmarks.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends mapLandmarksDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, mapLandmarksDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MapLandmarks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {mapLandmarksUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MapLandmarks
     * const mapLandmarks = await prisma.mapLandmarks.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends mapLandmarksUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, mapLandmarksUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one MapLandmarks.
     * @param {mapLandmarksUpsertArgs} args - Arguments to update or create a MapLandmarks.
     * @example
     * // Update or create a MapLandmarks
     * const mapLandmarks = await prisma.mapLandmarks.upsert({
     *   create: {
     *     // ... data to create a MapLandmarks
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MapLandmarks we want to update
     *   }
     * })
    **/
    upsert<T extends mapLandmarksUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, mapLandmarksUpsertArgs<ExtArgs>>
    ): Prisma__mapLandmarksClient<$Result.GetResult<Prisma.$mapLandmarksPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of MapLandmarks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {mapLandmarksCountArgs} args - Arguments to filter MapLandmarks to count.
     * @example
     * // Count the number of MapLandmarks
     * const count = await prisma.mapLandmarks.count({
     *   where: {
     *     // ... the filter for the MapLandmarks we want to count
     *   }
     * })
    **/
    count<T extends mapLandmarksCountArgs>(
      args?: Subset<T, mapLandmarksCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MapLandmarksCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MapLandmarks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MapLandmarksAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MapLandmarksAggregateArgs>(args: Subset<T, MapLandmarksAggregateArgs>): Prisma.PrismaPromise<GetMapLandmarksAggregateType<T>>

    /**
     * Group by MapLandmarks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {mapLandmarksGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends mapLandmarksGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: mapLandmarksGroupByArgs['orderBy'] }
        : { orderBy?: mapLandmarksGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, mapLandmarksGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMapLandmarksGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the mapLandmarks model
   */
  readonly fields: mapLandmarksFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for mapLandmarks.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__mapLandmarksClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';


    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the mapLandmarks model
   */ 
  interface mapLandmarksFieldRefs {
    readonly landmarkID: FieldRef<"mapLandmarks", 'Int'>
    readonly landmarkName: FieldRef<"mapLandmarks", 'String'>
    readonly description: FieldRef<"mapLandmarks", 'String'>
    readonly locationID: FieldRef<"mapLandmarks", 'Int'>
    readonly x: FieldRef<"mapLandmarks", 'Float'>
    readonly y: FieldRef<"mapLandmarks", 'Float'>
    readonly z: FieldRef<"mapLandmarks", 'Float'>
    readonly iconID: FieldRef<"mapLandmarks", 'Int'>
  }
    

  // Custom InputTypes

  /**
   * mapLandmarks findUnique
   */
  export type mapLandmarksFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the mapLandmarks
     */
    select?: mapLandmarksSelect<ExtArgs> | null
    /**
     * Filter, which mapLandmarks to fetch.
     */
    where: mapLandmarksWhereUniqueInput
  }


  /**
   * mapLandmarks findUniqueOrThrow
   */
  export type mapLandmarksFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the mapLandmarks
     */
    select?: mapLandmarksSelect<ExtArgs> | null
    /**
     * Filter, which mapLandmarks to fetch.
     */
    where: mapLandmarksWhereUniqueInput
  }


  /**
   * mapLandmarks findFirst
   */
  export type mapLandmarksFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the mapLandmarks
     */
    select?: mapLandmarksSelect<ExtArgs> | null
    /**
     * Filter, which mapLandmarks to fetch.
     */
    where?: mapLandmarksWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of mapLandmarks to fetch.
     */
    orderBy?: mapLandmarksOrderByWithRelationInput | mapLandmarksOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for mapLandmarks.
     */
    cursor?: mapLandmarksWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` mapLandmarks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` mapLandmarks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of mapLandmarks.
     */
    distinct?: MapLandmarksScalarFieldEnum | MapLandmarksScalarFieldEnum[]
  }


  /**
   * mapLandmarks findFirstOrThrow
   */
  export type mapLandmarksFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the mapLandmarks
     */
    select?: mapLandmarksSelect<ExtArgs> | null
    /**
     * Filter, which mapLandmarks to fetch.
     */
    where?: mapLandmarksWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of mapLandmarks to fetch.
     */
    orderBy?: mapLandmarksOrderByWithRelationInput | mapLandmarksOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for mapLandmarks.
     */
    cursor?: mapLandmarksWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` mapLandmarks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` mapLandmarks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of mapLandmarks.
     */
    distinct?: MapLandmarksScalarFieldEnum | MapLandmarksScalarFieldEnum[]
  }


  /**
   * mapLandmarks findMany
   */
  export type mapLandmarksFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the mapLandmarks
     */
    select?: mapLandmarksSelect<ExtArgs> | null
    /**
     * Filter, which mapLandmarks to fetch.
     */
    where?: mapLandmarksWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of mapLandmarks to fetch.
     */
    orderBy?: mapLandmarksOrderByWithRelationInput | mapLandmarksOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing mapLandmarks.
     */
    cursor?: mapLandmarksWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` mapLandmarks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` mapLandmarks.
     */
    skip?: number
    distinct?: MapLandmarksScalarFieldEnum | MapLandmarksScalarFieldEnum[]
  }


  /**
   * mapLandmarks create
   */
  export type mapLandmarksCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the mapLandmarks
     */
    select?: mapLandmarksSelect<ExtArgs> | null
    /**
     * The data needed to create a mapLandmarks.
     */
    data: XOR<mapLandmarksCreateInput, mapLandmarksUncheckedCreateInput>
  }


  /**
   * mapLandmarks createMany
   */
  export type mapLandmarksCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many mapLandmarks.
     */
    data: mapLandmarksCreateManyInput | mapLandmarksCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * mapLandmarks update
   */
  export type mapLandmarksUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the mapLandmarks
     */
    select?: mapLandmarksSelect<ExtArgs> | null
    /**
     * The data needed to update a mapLandmarks.
     */
    data: XOR<mapLandmarksUpdateInput, mapLandmarksUncheckedUpdateInput>
    /**
     * Choose, which mapLandmarks to update.
     */
    where: mapLandmarksWhereUniqueInput
  }


  /**
   * mapLandmarks updateMany
   */
  export type mapLandmarksUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update mapLandmarks.
     */
    data: XOR<mapLandmarksUpdateManyMutationInput, mapLandmarksUncheckedUpdateManyInput>
    /**
     * Filter which mapLandmarks to update
     */
    where?: mapLandmarksWhereInput
  }


  /**
   * mapLandmarks upsert
   */
  export type mapLandmarksUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the mapLandmarks
     */
    select?: mapLandmarksSelect<ExtArgs> | null
    /**
     * The filter to search for the mapLandmarks to update in case it exists.
     */
    where: mapLandmarksWhereUniqueInput
    /**
     * In case the mapLandmarks found by the `where` argument doesn't exist, create a new mapLandmarks with this data.
     */
    create: XOR<mapLandmarksCreateInput, mapLandmarksUncheckedCreateInput>
    /**
     * In case the mapLandmarks was found with the provided `where` argument, update it with this data.
     */
    update: XOR<mapLandmarksUpdateInput, mapLandmarksUncheckedUpdateInput>
  }


  /**
   * mapLandmarks delete
   */
  export type mapLandmarksDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the mapLandmarks
     */
    select?: mapLandmarksSelect<ExtArgs> | null
    /**
     * Filter which mapLandmarks to delete.
     */
    where: mapLandmarksWhereUniqueInput
  }


  /**
   * mapLandmarks deleteMany
   */
  export type mapLandmarksDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which mapLandmarks to delete
     */
    where?: mapLandmarksWhereInput
  }


  /**
   * mapLandmarks without action
   */
  export type mapLandmarksDefaultArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the mapLandmarks
     */
    select?: mapLandmarksSelect<ExtArgs> | null
  }



  /**
   * Model mapLocationScenes
   */

  export type AggregateMapLocationScenes = {
    _count: MapLocationScenesCountAggregateOutputType | null
    _avg: MapLocationScenesAvgAggregateOutputType | null
    _sum: MapLocationScenesSumAggregateOutputType | null
    _min: MapLocationScenesMinAggregateOutputType | null
    _max: MapLocationScenesMaxAggregateOutputType | null
  }

  export type MapLocationScenesAvgAggregateOutputType = {
    locationID: number | null
    graphicID: number | null
  }

  export type MapLocationScenesSumAggregateOutputType = {
    locationID: number | null
    graphicID: number | null
  }

  export type MapLocationScenesMinAggregateOutputType = {
    locationID: number | null
    graphicID: number | null
  }

  export type MapLocationScenesMaxAggregateOutputType = {
    locationID: number | null
    graphicID: number | null
  }

  export type MapLocationScenesCountAggregateOutputType = {
    locationID: number
    graphicID: number
    _all: number
  }


  export type MapLocationScenesAvgAggregateInputType = {
    locationID?: true
    graphicID?: true
  }

  export type MapLocationScenesSumAggregateInputType = {
    locationID?: true
    graphicID?: true
  }

  export type MapLocationScenesMinAggregateInputType = {
    locationID?: true
    graphicID?: true
  }

  export type MapLocationScenesMaxAggregateInputType = {
    locationID?: true
    graphicID?: true
  }

  export type MapLocationScenesCountAggregateInputType = {
    locationID?: true
    graphicID?: true
    _all?: true
  }

  export type MapLocationScenesAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which mapLocationScenes to aggregate.
     */
    where?: mapLocationScenesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of mapLocationScenes to fetch.
     */
    orderBy?: mapLocationScenesOrderByWithRelationInput | mapLocationScenesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: mapLocationScenesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` mapLocationScenes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` mapLocationScenes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned mapLocationScenes
    **/
    _count?: true | MapLocationScenesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MapLocationScenesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MapLocationScenesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MapLocationScenesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MapLocationScenesMaxAggregateInputType
  }

  export type GetMapLocationScenesAggregateType<T extends MapLocationScenesAggregateArgs> = {
        [P in keyof T & keyof AggregateMapLocationScenes]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMapLocationScenes[P]>
      : GetScalarType<T[P], AggregateMapLocationScenes[P]>
  }




  export type mapLocationScenesGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: mapLocationScenesWhereInput
    orderBy?: mapLocationScenesOrderByWithAggregationInput | mapLocationScenesOrderByWithAggregationInput[]
    by: MapLocationScenesScalarFieldEnum[] | MapLocationScenesScalarFieldEnum
    having?: mapLocationScenesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MapLocationScenesCountAggregateInputType | true
    _avg?: MapLocationScenesAvgAggregateInputType
    _sum?: MapLocationScenesSumAggregateInputType
    _min?: MapLocationScenesMinAggregateInputType
    _max?: MapLocationScenesMaxAggregateInputType
  }

  export type MapLocationScenesGroupByOutputType = {
    locationID: number
    graphicID: number | null
    _count: MapLocationScenesCountAggregateOutputType | null
    _avg: MapLocationScenesAvgAggregateOutputType | null
    _sum: MapLocationScenesSumAggregateOutputType | null
    _min: MapLocationScenesMinAggregateOutputType | null
    _max: MapLocationScenesMaxAggregateOutputType | null
  }

  type GetMapLocationScenesGroupByPayload<T extends mapLocationScenesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MapLocationScenesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MapLocationScenesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MapLocationScenesGroupByOutputType[P]>
            : GetScalarType<T[P], MapLocationScenesGroupByOutputType[P]>
        }
      >
    >


  export type mapLocationScenesSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    locationID?: boolean
    graphicID?: boolean
  }, ExtArgs["result"]["mapLocationScenes"]>

  export type mapLocationScenesSelectScalar = {
    locationID?: boolean
    graphicID?: boolean
  }


  export type $mapLocationScenesPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    name: "mapLocationScenes"
    objects: {}
    scalars: $Extensions.GetResult<{
      locationID: number
      graphicID: number | null
    }, ExtArgs["result"]["mapLocationScenes"]>
    composites: {}
  }


  type mapLocationScenesGetPayload<S extends boolean | null | undefined | mapLocationScenesDefaultArgs> = $Result.GetResult<Prisma.$mapLocationScenesPayload, S>

  type mapLocationScenesCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<mapLocationScenesFindManyArgs, 'select' | 'include'> & {
      select?: MapLocationScenesCountAggregateInputType | true
    }

  export interface mapLocationScenesDelegate<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['mapLocationScenes'], meta: { name: 'mapLocationScenes' } }
    /**
     * Find zero or one MapLocationScenes that matches the filter.
     * @param {mapLocationScenesFindUniqueArgs} args - Arguments to find a MapLocationScenes
     * @example
     * // Get one MapLocationScenes
     * const mapLocationScenes = await prisma.mapLocationScenes.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends mapLocationScenesFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, mapLocationScenesFindUniqueArgs<ExtArgs>>
    ): Prisma__mapLocationScenesClient<$Result.GetResult<Prisma.$mapLocationScenesPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one MapLocationScenes that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {mapLocationScenesFindUniqueOrThrowArgs} args - Arguments to find a MapLocationScenes
     * @example
     * // Get one MapLocationScenes
     * const mapLocationScenes = await prisma.mapLocationScenes.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends mapLocationScenesFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, mapLocationScenesFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__mapLocationScenesClient<$Result.GetResult<Prisma.$mapLocationScenesPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first MapLocationScenes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {mapLocationScenesFindFirstArgs} args - Arguments to find a MapLocationScenes
     * @example
     * // Get one MapLocationScenes
     * const mapLocationScenes = await prisma.mapLocationScenes.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends mapLocationScenesFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, mapLocationScenesFindFirstArgs<ExtArgs>>
    ): Prisma__mapLocationScenesClient<$Result.GetResult<Prisma.$mapLocationScenesPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first MapLocationScenes that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {mapLocationScenesFindFirstOrThrowArgs} args - Arguments to find a MapLocationScenes
     * @example
     * // Get one MapLocationScenes
     * const mapLocationScenes = await prisma.mapLocationScenes.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends mapLocationScenesFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, mapLocationScenesFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__mapLocationScenesClient<$Result.GetResult<Prisma.$mapLocationScenesPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more MapLocationScenes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {mapLocationScenesFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MapLocationScenes
     * const mapLocationScenes = await prisma.mapLocationScenes.findMany()
     * 
     * // Get first 10 MapLocationScenes
     * const mapLocationScenes = await prisma.mapLocationScenes.findMany({ take: 10 })
     * 
     * // Only select the `locationID`
     * const mapLocationScenesWithLocationIDOnly = await prisma.mapLocationScenes.findMany({ select: { locationID: true } })
     * 
    **/
    findMany<T extends mapLocationScenesFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, mapLocationScenesFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$mapLocationScenesPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a MapLocationScenes.
     * @param {mapLocationScenesCreateArgs} args - Arguments to create a MapLocationScenes.
     * @example
     * // Create one MapLocationScenes
     * const MapLocationScenes = await prisma.mapLocationScenes.create({
     *   data: {
     *     // ... data to create a MapLocationScenes
     *   }
     * })
     * 
    **/
    create<T extends mapLocationScenesCreateArgs<ExtArgs>>(
      args: SelectSubset<T, mapLocationScenesCreateArgs<ExtArgs>>
    ): Prisma__mapLocationScenesClient<$Result.GetResult<Prisma.$mapLocationScenesPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many MapLocationScenes.
     *     @param {mapLocationScenesCreateManyArgs} args - Arguments to create many MapLocationScenes.
     *     @example
     *     // Create many MapLocationScenes
     *     const mapLocationScenes = await prisma.mapLocationScenes.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends mapLocationScenesCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, mapLocationScenesCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a MapLocationScenes.
     * @param {mapLocationScenesDeleteArgs} args - Arguments to delete one MapLocationScenes.
     * @example
     * // Delete one MapLocationScenes
     * const MapLocationScenes = await prisma.mapLocationScenes.delete({
     *   where: {
     *     // ... filter to delete one MapLocationScenes
     *   }
     * })
     * 
    **/
    delete<T extends mapLocationScenesDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, mapLocationScenesDeleteArgs<ExtArgs>>
    ): Prisma__mapLocationScenesClient<$Result.GetResult<Prisma.$mapLocationScenesPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one MapLocationScenes.
     * @param {mapLocationScenesUpdateArgs} args - Arguments to update one MapLocationScenes.
     * @example
     * // Update one MapLocationScenes
     * const mapLocationScenes = await prisma.mapLocationScenes.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends mapLocationScenesUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, mapLocationScenesUpdateArgs<ExtArgs>>
    ): Prisma__mapLocationScenesClient<$Result.GetResult<Prisma.$mapLocationScenesPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more MapLocationScenes.
     * @param {mapLocationScenesDeleteManyArgs} args - Arguments to filter MapLocationScenes to delete.
     * @example
     * // Delete a few MapLocationScenes
     * const { count } = await prisma.mapLocationScenes.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends mapLocationScenesDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, mapLocationScenesDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MapLocationScenes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {mapLocationScenesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MapLocationScenes
     * const mapLocationScenes = await prisma.mapLocationScenes.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends mapLocationScenesUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, mapLocationScenesUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one MapLocationScenes.
     * @param {mapLocationScenesUpsertArgs} args - Arguments to update or create a MapLocationScenes.
     * @example
     * // Update or create a MapLocationScenes
     * const mapLocationScenes = await prisma.mapLocationScenes.upsert({
     *   create: {
     *     // ... data to create a MapLocationScenes
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MapLocationScenes we want to update
     *   }
     * })
    **/
    upsert<T extends mapLocationScenesUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, mapLocationScenesUpsertArgs<ExtArgs>>
    ): Prisma__mapLocationScenesClient<$Result.GetResult<Prisma.$mapLocationScenesPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of MapLocationScenes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {mapLocationScenesCountArgs} args - Arguments to filter MapLocationScenes to count.
     * @example
     * // Count the number of MapLocationScenes
     * const count = await prisma.mapLocationScenes.count({
     *   where: {
     *     // ... the filter for the MapLocationScenes we want to count
     *   }
     * })
    **/
    count<T extends mapLocationScenesCountArgs>(
      args?: Subset<T, mapLocationScenesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MapLocationScenesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MapLocationScenes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MapLocationScenesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MapLocationScenesAggregateArgs>(args: Subset<T, MapLocationScenesAggregateArgs>): Prisma.PrismaPromise<GetMapLocationScenesAggregateType<T>>

    /**
     * Group by MapLocationScenes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {mapLocationScenesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends mapLocationScenesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: mapLocationScenesGroupByArgs['orderBy'] }
        : { orderBy?: mapLocationScenesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, mapLocationScenesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMapLocationScenesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the mapLocationScenes model
   */
  readonly fields: mapLocationScenesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for mapLocationScenes.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__mapLocationScenesClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';


    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the mapLocationScenes model
   */ 
  interface mapLocationScenesFieldRefs {
    readonly locationID: FieldRef<"mapLocationScenes", 'Int'>
    readonly graphicID: FieldRef<"mapLocationScenes", 'Int'>
  }
    

  // Custom InputTypes

  /**
   * mapLocationScenes findUnique
   */
  export type mapLocationScenesFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the mapLocationScenes
     */
    select?: mapLocationScenesSelect<ExtArgs> | null
    /**
     * Filter, which mapLocationScenes to fetch.
     */
    where: mapLocationScenesWhereUniqueInput
  }


  /**
   * mapLocationScenes findUniqueOrThrow
   */
  export type mapLocationScenesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the mapLocationScenes
     */
    select?: mapLocationScenesSelect<ExtArgs> | null
    /**
     * Filter, which mapLocationScenes to fetch.
     */
    where: mapLocationScenesWhereUniqueInput
  }


  /**
   * mapLocationScenes findFirst
   */
  export type mapLocationScenesFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the mapLocationScenes
     */
    select?: mapLocationScenesSelect<ExtArgs> | null
    /**
     * Filter, which mapLocationScenes to fetch.
     */
    where?: mapLocationScenesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of mapLocationScenes to fetch.
     */
    orderBy?: mapLocationScenesOrderByWithRelationInput | mapLocationScenesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for mapLocationScenes.
     */
    cursor?: mapLocationScenesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` mapLocationScenes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` mapLocationScenes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of mapLocationScenes.
     */
    distinct?: MapLocationScenesScalarFieldEnum | MapLocationScenesScalarFieldEnum[]
  }


  /**
   * mapLocationScenes findFirstOrThrow
   */
  export type mapLocationScenesFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the mapLocationScenes
     */
    select?: mapLocationScenesSelect<ExtArgs> | null
    /**
     * Filter, which mapLocationScenes to fetch.
     */
    where?: mapLocationScenesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of mapLocationScenes to fetch.
     */
    orderBy?: mapLocationScenesOrderByWithRelationInput | mapLocationScenesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for mapLocationScenes.
     */
    cursor?: mapLocationScenesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` mapLocationScenes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` mapLocationScenes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of mapLocationScenes.
     */
    distinct?: MapLocationScenesScalarFieldEnum | MapLocationScenesScalarFieldEnum[]
  }


  /**
   * mapLocationScenes findMany
   */
  export type mapLocationScenesFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the mapLocationScenes
     */
    select?: mapLocationScenesSelect<ExtArgs> | null
    /**
     * Filter, which mapLocationScenes to fetch.
     */
    where?: mapLocationScenesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of mapLocationScenes to fetch.
     */
    orderBy?: mapLocationScenesOrderByWithRelationInput | mapLocationScenesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing mapLocationScenes.
     */
    cursor?: mapLocationScenesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` mapLocationScenes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` mapLocationScenes.
     */
    skip?: number
    distinct?: MapLocationScenesScalarFieldEnum | MapLocationScenesScalarFieldEnum[]
  }


  /**
   * mapLocationScenes create
   */
  export type mapLocationScenesCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the mapLocationScenes
     */
    select?: mapLocationScenesSelect<ExtArgs> | null
    /**
     * The data needed to create a mapLocationScenes.
     */
    data: XOR<mapLocationScenesCreateInput, mapLocationScenesUncheckedCreateInput>
  }


  /**
   * mapLocationScenes createMany
   */
  export type mapLocationScenesCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many mapLocationScenes.
     */
    data: mapLocationScenesCreateManyInput | mapLocationScenesCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * mapLocationScenes update
   */
  export type mapLocationScenesUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the mapLocationScenes
     */
    select?: mapLocationScenesSelect<ExtArgs> | null
    /**
     * The data needed to update a mapLocationScenes.
     */
    data: XOR<mapLocationScenesUpdateInput, mapLocationScenesUncheckedUpdateInput>
    /**
     * Choose, which mapLocationScenes to update.
     */
    where: mapLocationScenesWhereUniqueInput
  }


  /**
   * mapLocationScenes updateMany
   */
  export type mapLocationScenesUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update mapLocationScenes.
     */
    data: XOR<mapLocationScenesUpdateManyMutationInput, mapLocationScenesUncheckedUpdateManyInput>
    /**
     * Filter which mapLocationScenes to update
     */
    where?: mapLocationScenesWhereInput
  }


  /**
   * mapLocationScenes upsert
   */
  export type mapLocationScenesUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the mapLocationScenes
     */
    select?: mapLocationScenesSelect<ExtArgs> | null
    /**
     * The filter to search for the mapLocationScenes to update in case it exists.
     */
    where: mapLocationScenesWhereUniqueInput
    /**
     * In case the mapLocationScenes found by the `where` argument doesn't exist, create a new mapLocationScenes with this data.
     */
    create: XOR<mapLocationScenesCreateInput, mapLocationScenesUncheckedCreateInput>
    /**
     * In case the mapLocationScenes was found with the provided `where` argument, update it with this data.
     */
    update: XOR<mapLocationScenesUpdateInput, mapLocationScenesUncheckedUpdateInput>
  }


  /**
   * mapLocationScenes delete
   */
  export type mapLocationScenesDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the mapLocationScenes
     */
    select?: mapLocationScenesSelect<ExtArgs> | null
    /**
     * Filter which mapLocationScenes to delete.
     */
    where: mapLocationScenesWhereUniqueInput
  }


  /**
   * mapLocationScenes deleteMany
   */
  export type mapLocationScenesDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which mapLocationScenes to delete
     */
    where?: mapLocationScenesWhereInput
  }


  /**
   * mapLocationScenes without action
   */
  export type mapLocationScenesDefaultArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the mapLocationScenes
     */
    select?: mapLocationScenesSelect<ExtArgs> | null
  }



  /**
   * Model mapLocationWormholeClasses
   */

  export type AggregateMapLocationWormholeClasses = {
    _count: MapLocationWormholeClassesCountAggregateOutputType | null
    _avg: MapLocationWormholeClassesAvgAggregateOutputType | null
    _sum: MapLocationWormholeClassesSumAggregateOutputType | null
    _min: MapLocationWormholeClassesMinAggregateOutputType | null
    _max: MapLocationWormholeClassesMaxAggregateOutputType | null
  }

  export type MapLocationWormholeClassesAvgAggregateOutputType = {
    locationID: number | null
    wormholeClassID: number | null
  }

  export type MapLocationWormholeClassesSumAggregateOutputType = {
    locationID: number | null
    wormholeClassID: number | null
  }

  export type MapLocationWormholeClassesMinAggregateOutputType = {
    locationID: number | null
    wormholeClassID: number | null
  }

  export type MapLocationWormholeClassesMaxAggregateOutputType = {
    locationID: number | null
    wormholeClassID: number | null
  }

  export type MapLocationWormholeClassesCountAggregateOutputType = {
    locationID: number
    wormholeClassID: number
    _all: number
  }


  export type MapLocationWormholeClassesAvgAggregateInputType = {
    locationID?: true
    wormholeClassID?: true
  }

  export type MapLocationWormholeClassesSumAggregateInputType = {
    locationID?: true
    wormholeClassID?: true
  }

  export type MapLocationWormholeClassesMinAggregateInputType = {
    locationID?: true
    wormholeClassID?: true
  }

  export type MapLocationWormholeClassesMaxAggregateInputType = {
    locationID?: true
    wormholeClassID?: true
  }

  export type MapLocationWormholeClassesCountAggregateInputType = {
    locationID?: true
    wormholeClassID?: true
    _all?: true
  }

  export type MapLocationWormholeClassesAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which mapLocationWormholeClasses to aggregate.
     */
    where?: mapLocationWormholeClassesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of mapLocationWormholeClasses to fetch.
     */
    orderBy?: mapLocationWormholeClassesOrderByWithRelationInput | mapLocationWormholeClassesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: mapLocationWormholeClassesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` mapLocationWormholeClasses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` mapLocationWormholeClasses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned mapLocationWormholeClasses
    **/
    _count?: true | MapLocationWormholeClassesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MapLocationWormholeClassesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MapLocationWormholeClassesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MapLocationWormholeClassesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MapLocationWormholeClassesMaxAggregateInputType
  }

  export type GetMapLocationWormholeClassesAggregateType<T extends MapLocationWormholeClassesAggregateArgs> = {
        [P in keyof T & keyof AggregateMapLocationWormholeClasses]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMapLocationWormholeClasses[P]>
      : GetScalarType<T[P], AggregateMapLocationWormholeClasses[P]>
  }




  export type mapLocationWormholeClassesGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: mapLocationWormholeClassesWhereInput
    orderBy?: mapLocationWormholeClassesOrderByWithAggregationInput | mapLocationWormholeClassesOrderByWithAggregationInput[]
    by: MapLocationWormholeClassesScalarFieldEnum[] | MapLocationWormholeClassesScalarFieldEnum
    having?: mapLocationWormholeClassesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MapLocationWormholeClassesCountAggregateInputType | true
    _avg?: MapLocationWormholeClassesAvgAggregateInputType
    _sum?: MapLocationWormholeClassesSumAggregateInputType
    _min?: MapLocationWormholeClassesMinAggregateInputType
    _max?: MapLocationWormholeClassesMaxAggregateInputType
  }

  export type MapLocationWormholeClassesGroupByOutputType = {
    locationID: number
    wormholeClassID: number | null
    _count: MapLocationWormholeClassesCountAggregateOutputType | null
    _avg: MapLocationWormholeClassesAvgAggregateOutputType | null
    _sum: MapLocationWormholeClassesSumAggregateOutputType | null
    _min: MapLocationWormholeClassesMinAggregateOutputType | null
    _max: MapLocationWormholeClassesMaxAggregateOutputType | null
  }

  type GetMapLocationWormholeClassesGroupByPayload<T extends mapLocationWormholeClassesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MapLocationWormholeClassesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MapLocationWormholeClassesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MapLocationWormholeClassesGroupByOutputType[P]>
            : GetScalarType<T[P], MapLocationWormholeClassesGroupByOutputType[P]>
        }
      >
    >


  export type mapLocationWormholeClassesSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    locationID?: boolean
    wormholeClassID?: boolean
  }, ExtArgs["result"]["mapLocationWormholeClasses"]>

  export type mapLocationWormholeClassesSelectScalar = {
    locationID?: boolean
    wormholeClassID?: boolean
  }


  export type $mapLocationWormholeClassesPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    name: "mapLocationWormholeClasses"
    objects: {}
    scalars: $Extensions.GetResult<{
      locationID: number
      wormholeClassID: number | null
    }, ExtArgs["result"]["mapLocationWormholeClasses"]>
    composites: {}
  }


  type mapLocationWormholeClassesGetPayload<S extends boolean | null | undefined | mapLocationWormholeClassesDefaultArgs> = $Result.GetResult<Prisma.$mapLocationWormholeClassesPayload, S>

  type mapLocationWormholeClassesCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<mapLocationWormholeClassesFindManyArgs, 'select' | 'include'> & {
      select?: MapLocationWormholeClassesCountAggregateInputType | true
    }

  export interface mapLocationWormholeClassesDelegate<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['mapLocationWormholeClasses'], meta: { name: 'mapLocationWormholeClasses' } }
    /**
     * Find zero or one MapLocationWormholeClasses that matches the filter.
     * @param {mapLocationWormholeClassesFindUniqueArgs} args - Arguments to find a MapLocationWormholeClasses
     * @example
     * // Get one MapLocationWormholeClasses
     * const mapLocationWormholeClasses = await prisma.mapLocationWormholeClasses.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends mapLocationWormholeClassesFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, mapLocationWormholeClassesFindUniqueArgs<ExtArgs>>
    ): Prisma__mapLocationWormholeClassesClient<$Result.GetResult<Prisma.$mapLocationWormholeClassesPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one MapLocationWormholeClasses that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {mapLocationWormholeClassesFindUniqueOrThrowArgs} args - Arguments to find a MapLocationWormholeClasses
     * @example
     * // Get one MapLocationWormholeClasses
     * const mapLocationWormholeClasses = await prisma.mapLocationWormholeClasses.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends mapLocationWormholeClassesFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, mapLocationWormholeClassesFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__mapLocationWormholeClassesClient<$Result.GetResult<Prisma.$mapLocationWormholeClassesPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first MapLocationWormholeClasses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {mapLocationWormholeClassesFindFirstArgs} args - Arguments to find a MapLocationWormholeClasses
     * @example
     * // Get one MapLocationWormholeClasses
     * const mapLocationWormholeClasses = await prisma.mapLocationWormholeClasses.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends mapLocationWormholeClassesFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, mapLocationWormholeClassesFindFirstArgs<ExtArgs>>
    ): Prisma__mapLocationWormholeClassesClient<$Result.GetResult<Prisma.$mapLocationWormholeClassesPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first MapLocationWormholeClasses that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {mapLocationWormholeClassesFindFirstOrThrowArgs} args - Arguments to find a MapLocationWormholeClasses
     * @example
     * // Get one MapLocationWormholeClasses
     * const mapLocationWormholeClasses = await prisma.mapLocationWormholeClasses.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends mapLocationWormholeClassesFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, mapLocationWormholeClassesFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__mapLocationWormholeClassesClient<$Result.GetResult<Prisma.$mapLocationWormholeClassesPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more MapLocationWormholeClasses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {mapLocationWormholeClassesFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MapLocationWormholeClasses
     * const mapLocationWormholeClasses = await prisma.mapLocationWormholeClasses.findMany()
     * 
     * // Get first 10 MapLocationWormholeClasses
     * const mapLocationWormholeClasses = await prisma.mapLocationWormholeClasses.findMany({ take: 10 })
     * 
     * // Only select the `locationID`
     * const mapLocationWormholeClassesWithLocationIDOnly = await prisma.mapLocationWormholeClasses.findMany({ select: { locationID: true } })
     * 
    **/
    findMany<T extends mapLocationWormholeClassesFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, mapLocationWormholeClassesFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$mapLocationWormholeClassesPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a MapLocationWormholeClasses.
     * @param {mapLocationWormholeClassesCreateArgs} args - Arguments to create a MapLocationWormholeClasses.
     * @example
     * // Create one MapLocationWormholeClasses
     * const MapLocationWormholeClasses = await prisma.mapLocationWormholeClasses.create({
     *   data: {
     *     // ... data to create a MapLocationWormholeClasses
     *   }
     * })
     * 
    **/
    create<T extends mapLocationWormholeClassesCreateArgs<ExtArgs>>(
      args: SelectSubset<T, mapLocationWormholeClassesCreateArgs<ExtArgs>>
    ): Prisma__mapLocationWormholeClassesClient<$Result.GetResult<Prisma.$mapLocationWormholeClassesPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many MapLocationWormholeClasses.
     *     @param {mapLocationWormholeClassesCreateManyArgs} args - Arguments to create many MapLocationWormholeClasses.
     *     @example
     *     // Create many MapLocationWormholeClasses
     *     const mapLocationWormholeClasses = await prisma.mapLocationWormholeClasses.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends mapLocationWormholeClassesCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, mapLocationWormholeClassesCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a MapLocationWormholeClasses.
     * @param {mapLocationWormholeClassesDeleteArgs} args - Arguments to delete one MapLocationWormholeClasses.
     * @example
     * // Delete one MapLocationWormholeClasses
     * const MapLocationWormholeClasses = await prisma.mapLocationWormholeClasses.delete({
     *   where: {
     *     // ... filter to delete one MapLocationWormholeClasses
     *   }
     * })
     * 
    **/
    delete<T extends mapLocationWormholeClassesDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, mapLocationWormholeClassesDeleteArgs<ExtArgs>>
    ): Prisma__mapLocationWormholeClassesClient<$Result.GetResult<Prisma.$mapLocationWormholeClassesPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one MapLocationWormholeClasses.
     * @param {mapLocationWormholeClassesUpdateArgs} args - Arguments to update one MapLocationWormholeClasses.
     * @example
     * // Update one MapLocationWormholeClasses
     * const mapLocationWormholeClasses = await prisma.mapLocationWormholeClasses.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends mapLocationWormholeClassesUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, mapLocationWormholeClassesUpdateArgs<ExtArgs>>
    ): Prisma__mapLocationWormholeClassesClient<$Result.GetResult<Prisma.$mapLocationWormholeClassesPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more MapLocationWormholeClasses.
     * @param {mapLocationWormholeClassesDeleteManyArgs} args - Arguments to filter MapLocationWormholeClasses to delete.
     * @example
     * // Delete a few MapLocationWormholeClasses
     * const { count } = await prisma.mapLocationWormholeClasses.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends mapLocationWormholeClassesDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, mapLocationWormholeClassesDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MapLocationWormholeClasses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {mapLocationWormholeClassesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MapLocationWormholeClasses
     * const mapLocationWormholeClasses = await prisma.mapLocationWormholeClasses.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends mapLocationWormholeClassesUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, mapLocationWormholeClassesUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one MapLocationWormholeClasses.
     * @param {mapLocationWormholeClassesUpsertArgs} args - Arguments to update or create a MapLocationWormholeClasses.
     * @example
     * // Update or create a MapLocationWormholeClasses
     * const mapLocationWormholeClasses = await prisma.mapLocationWormholeClasses.upsert({
     *   create: {
     *     // ... data to create a MapLocationWormholeClasses
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MapLocationWormholeClasses we want to update
     *   }
     * })
    **/
    upsert<T extends mapLocationWormholeClassesUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, mapLocationWormholeClassesUpsertArgs<ExtArgs>>
    ): Prisma__mapLocationWormholeClassesClient<$Result.GetResult<Prisma.$mapLocationWormholeClassesPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of MapLocationWormholeClasses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {mapLocationWormholeClassesCountArgs} args - Arguments to filter MapLocationWormholeClasses to count.
     * @example
     * // Count the number of MapLocationWormholeClasses
     * const count = await prisma.mapLocationWormholeClasses.count({
     *   where: {
     *     // ... the filter for the MapLocationWormholeClasses we want to count
     *   }
     * })
    **/
    count<T extends mapLocationWormholeClassesCountArgs>(
      args?: Subset<T, mapLocationWormholeClassesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MapLocationWormholeClassesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MapLocationWormholeClasses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MapLocationWormholeClassesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MapLocationWormholeClassesAggregateArgs>(args: Subset<T, MapLocationWormholeClassesAggregateArgs>): Prisma.PrismaPromise<GetMapLocationWormholeClassesAggregateType<T>>

    /**
     * Group by MapLocationWormholeClasses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {mapLocationWormholeClassesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends mapLocationWormholeClassesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: mapLocationWormholeClassesGroupByArgs['orderBy'] }
        : { orderBy?: mapLocationWormholeClassesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, mapLocationWormholeClassesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMapLocationWormholeClassesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the mapLocationWormholeClasses model
   */
  readonly fields: mapLocationWormholeClassesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for mapLocationWormholeClasses.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__mapLocationWormholeClassesClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';


    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the mapLocationWormholeClasses model
   */ 
  interface mapLocationWormholeClassesFieldRefs {
    readonly locationID: FieldRef<"mapLocationWormholeClasses", 'Int'>
    readonly wormholeClassID: FieldRef<"mapLocationWormholeClasses", 'Int'>
  }
    

  // Custom InputTypes

  /**
   * mapLocationWormholeClasses findUnique
   */
  export type mapLocationWormholeClassesFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the mapLocationWormholeClasses
     */
    select?: mapLocationWormholeClassesSelect<ExtArgs> | null
    /**
     * Filter, which mapLocationWormholeClasses to fetch.
     */
    where: mapLocationWormholeClassesWhereUniqueInput
  }


  /**
   * mapLocationWormholeClasses findUniqueOrThrow
   */
  export type mapLocationWormholeClassesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the mapLocationWormholeClasses
     */
    select?: mapLocationWormholeClassesSelect<ExtArgs> | null
    /**
     * Filter, which mapLocationWormholeClasses to fetch.
     */
    where: mapLocationWormholeClassesWhereUniqueInput
  }


  /**
   * mapLocationWormholeClasses findFirst
   */
  export type mapLocationWormholeClassesFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the mapLocationWormholeClasses
     */
    select?: mapLocationWormholeClassesSelect<ExtArgs> | null
    /**
     * Filter, which mapLocationWormholeClasses to fetch.
     */
    where?: mapLocationWormholeClassesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of mapLocationWormholeClasses to fetch.
     */
    orderBy?: mapLocationWormholeClassesOrderByWithRelationInput | mapLocationWormholeClassesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for mapLocationWormholeClasses.
     */
    cursor?: mapLocationWormholeClassesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` mapLocationWormholeClasses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` mapLocationWormholeClasses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of mapLocationWormholeClasses.
     */
    distinct?: MapLocationWormholeClassesScalarFieldEnum | MapLocationWormholeClassesScalarFieldEnum[]
  }


  /**
   * mapLocationWormholeClasses findFirstOrThrow
   */
  export type mapLocationWormholeClassesFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the mapLocationWormholeClasses
     */
    select?: mapLocationWormholeClassesSelect<ExtArgs> | null
    /**
     * Filter, which mapLocationWormholeClasses to fetch.
     */
    where?: mapLocationWormholeClassesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of mapLocationWormholeClasses to fetch.
     */
    orderBy?: mapLocationWormholeClassesOrderByWithRelationInput | mapLocationWormholeClassesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for mapLocationWormholeClasses.
     */
    cursor?: mapLocationWormholeClassesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` mapLocationWormholeClasses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` mapLocationWormholeClasses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of mapLocationWormholeClasses.
     */
    distinct?: MapLocationWormholeClassesScalarFieldEnum | MapLocationWormholeClassesScalarFieldEnum[]
  }


  /**
   * mapLocationWormholeClasses findMany
   */
  export type mapLocationWormholeClassesFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the mapLocationWormholeClasses
     */
    select?: mapLocationWormholeClassesSelect<ExtArgs> | null
    /**
     * Filter, which mapLocationWormholeClasses to fetch.
     */
    where?: mapLocationWormholeClassesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of mapLocationWormholeClasses to fetch.
     */
    orderBy?: mapLocationWormholeClassesOrderByWithRelationInput | mapLocationWormholeClassesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing mapLocationWormholeClasses.
     */
    cursor?: mapLocationWormholeClassesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` mapLocationWormholeClasses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` mapLocationWormholeClasses.
     */
    skip?: number
    distinct?: MapLocationWormholeClassesScalarFieldEnum | MapLocationWormholeClassesScalarFieldEnum[]
  }


  /**
   * mapLocationWormholeClasses create
   */
  export type mapLocationWormholeClassesCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the mapLocationWormholeClasses
     */
    select?: mapLocationWormholeClassesSelect<ExtArgs> | null
    /**
     * The data needed to create a mapLocationWormholeClasses.
     */
    data: XOR<mapLocationWormholeClassesCreateInput, mapLocationWormholeClassesUncheckedCreateInput>
  }


  /**
   * mapLocationWormholeClasses createMany
   */
  export type mapLocationWormholeClassesCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many mapLocationWormholeClasses.
     */
    data: mapLocationWormholeClassesCreateManyInput | mapLocationWormholeClassesCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * mapLocationWormholeClasses update
   */
  export type mapLocationWormholeClassesUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the mapLocationWormholeClasses
     */
    select?: mapLocationWormholeClassesSelect<ExtArgs> | null
    /**
     * The data needed to update a mapLocationWormholeClasses.
     */
    data: XOR<mapLocationWormholeClassesUpdateInput, mapLocationWormholeClassesUncheckedUpdateInput>
    /**
     * Choose, which mapLocationWormholeClasses to update.
     */
    where: mapLocationWormholeClassesWhereUniqueInput
  }


  /**
   * mapLocationWormholeClasses updateMany
   */
  export type mapLocationWormholeClassesUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update mapLocationWormholeClasses.
     */
    data: XOR<mapLocationWormholeClassesUpdateManyMutationInput, mapLocationWormholeClassesUncheckedUpdateManyInput>
    /**
     * Filter which mapLocationWormholeClasses to update
     */
    where?: mapLocationWormholeClassesWhereInput
  }


  /**
   * mapLocationWormholeClasses upsert
   */
  export type mapLocationWormholeClassesUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the mapLocationWormholeClasses
     */
    select?: mapLocationWormholeClassesSelect<ExtArgs> | null
    /**
     * The filter to search for the mapLocationWormholeClasses to update in case it exists.
     */
    where: mapLocationWormholeClassesWhereUniqueInput
    /**
     * In case the mapLocationWormholeClasses found by the `where` argument doesn't exist, create a new mapLocationWormholeClasses with this data.
     */
    create: XOR<mapLocationWormholeClassesCreateInput, mapLocationWormholeClassesUncheckedCreateInput>
    /**
     * In case the mapLocationWormholeClasses was found with the provided `where` argument, update it with this data.
     */
    update: XOR<mapLocationWormholeClassesUpdateInput, mapLocationWormholeClassesUncheckedUpdateInput>
  }


  /**
   * mapLocationWormholeClasses delete
   */
  export type mapLocationWormholeClassesDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the mapLocationWormholeClasses
     */
    select?: mapLocationWormholeClassesSelect<ExtArgs> | null
    /**
     * Filter which mapLocationWormholeClasses to delete.
     */
    where: mapLocationWormholeClassesWhereUniqueInput
  }


  /**
   * mapLocationWormholeClasses deleteMany
   */
  export type mapLocationWormholeClassesDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which mapLocationWormholeClasses to delete
     */
    where?: mapLocationWormholeClassesWhereInput
  }


  /**
   * mapLocationWormholeClasses without action
   */
  export type mapLocationWormholeClassesDefaultArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the mapLocationWormholeClasses
     */
    select?: mapLocationWormholeClassesSelect<ExtArgs> | null
  }



  /**
   * Model mapRegionJumps
   */

  export type AggregateMapRegionJumps = {
    _count: MapRegionJumpsCountAggregateOutputType | null
    _avg: MapRegionJumpsAvgAggregateOutputType | null
    _sum: MapRegionJumpsSumAggregateOutputType | null
    _min: MapRegionJumpsMinAggregateOutputType | null
    _max: MapRegionJumpsMaxAggregateOutputType | null
  }

  export type MapRegionJumpsAvgAggregateOutputType = {
    fromRegionID: number | null
    toRegionID: number | null
  }

  export type MapRegionJumpsSumAggregateOutputType = {
    fromRegionID: number | null
    toRegionID: number | null
  }

  export type MapRegionJumpsMinAggregateOutputType = {
    fromRegionID: number | null
    toRegionID: number | null
  }

  export type MapRegionJumpsMaxAggregateOutputType = {
    fromRegionID: number | null
    toRegionID: number | null
  }

  export type MapRegionJumpsCountAggregateOutputType = {
    fromRegionID: number
    toRegionID: number
    _all: number
  }


  export type MapRegionJumpsAvgAggregateInputType = {
    fromRegionID?: true
    toRegionID?: true
  }

  export type MapRegionJumpsSumAggregateInputType = {
    fromRegionID?: true
    toRegionID?: true
  }

  export type MapRegionJumpsMinAggregateInputType = {
    fromRegionID?: true
    toRegionID?: true
  }

  export type MapRegionJumpsMaxAggregateInputType = {
    fromRegionID?: true
    toRegionID?: true
  }

  export type MapRegionJumpsCountAggregateInputType = {
    fromRegionID?: true
    toRegionID?: true
    _all?: true
  }

  export type MapRegionJumpsAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which mapRegionJumps to aggregate.
     */
    where?: mapRegionJumpsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of mapRegionJumps to fetch.
     */
    orderBy?: mapRegionJumpsOrderByWithRelationInput | mapRegionJumpsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: mapRegionJumpsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` mapRegionJumps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` mapRegionJumps.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned mapRegionJumps
    **/
    _count?: true | MapRegionJumpsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MapRegionJumpsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MapRegionJumpsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MapRegionJumpsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MapRegionJumpsMaxAggregateInputType
  }

  export type GetMapRegionJumpsAggregateType<T extends MapRegionJumpsAggregateArgs> = {
        [P in keyof T & keyof AggregateMapRegionJumps]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMapRegionJumps[P]>
      : GetScalarType<T[P], AggregateMapRegionJumps[P]>
  }




  export type mapRegionJumpsGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: mapRegionJumpsWhereInput
    orderBy?: mapRegionJumpsOrderByWithAggregationInput | mapRegionJumpsOrderByWithAggregationInput[]
    by: MapRegionJumpsScalarFieldEnum[] | MapRegionJumpsScalarFieldEnum
    having?: mapRegionJumpsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MapRegionJumpsCountAggregateInputType | true
    _avg?: MapRegionJumpsAvgAggregateInputType
    _sum?: MapRegionJumpsSumAggregateInputType
    _min?: MapRegionJumpsMinAggregateInputType
    _max?: MapRegionJumpsMaxAggregateInputType
  }

  export type MapRegionJumpsGroupByOutputType = {
    fromRegionID: number
    toRegionID: number
    _count: MapRegionJumpsCountAggregateOutputType | null
    _avg: MapRegionJumpsAvgAggregateOutputType | null
    _sum: MapRegionJumpsSumAggregateOutputType | null
    _min: MapRegionJumpsMinAggregateOutputType | null
    _max: MapRegionJumpsMaxAggregateOutputType | null
  }

  type GetMapRegionJumpsGroupByPayload<T extends mapRegionJumpsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MapRegionJumpsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MapRegionJumpsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MapRegionJumpsGroupByOutputType[P]>
            : GetScalarType<T[P], MapRegionJumpsGroupByOutputType[P]>
        }
      >
    >


  export type mapRegionJumpsSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    fromRegionID?: boolean
    toRegionID?: boolean
  }, ExtArgs["result"]["mapRegionJumps"]>

  export type mapRegionJumpsSelectScalar = {
    fromRegionID?: boolean
    toRegionID?: boolean
  }


  export type $mapRegionJumpsPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    name: "mapRegionJumps"
    objects: {}
    scalars: $Extensions.GetResult<{
      fromRegionID: number
      toRegionID: number
    }, ExtArgs["result"]["mapRegionJumps"]>
    composites: {}
  }


  type mapRegionJumpsGetPayload<S extends boolean | null | undefined | mapRegionJumpsDefaultArgs> = $Result.GetResult<Prisma.$mapRegionJumpsPayload, S>

  type mapRegionJumpsCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<mapRegionJumpsFindManyArgs, 'select' | 'include'> & {
      select?: MapRegionJumpsCountAggregateInputType | true
    }

  export interface mapRegionJumpsDelegate<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['mapRegionJumps'], meta: { name: 'mapRegionJumps' } }
    /**
     * Find zero or one MapRegionJumps that matches the filter.
     * @param {mapRegionJumpsFindUniqueArgs} args - Arguments to find a MapRegionJumps
     * @example
     * // Get one MapRegionJumps
     * const mapRegionJumps = await prisma.mapRegionJumps.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends mapRegionJumpsFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, mapRegionJumpsFindUniqueArgs<ExtArgs>>
    ): Prisma__mapRegionJumpsClient<$Result.GetResult<Prisma.$mapRegionJumpsPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one MapRegionJumps that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {mapRegionJumpsFindUniqueOrThrowArgs} args - Arguments to find a MapRegionJumps
     * @example
     * // Get one MapRegionJumps
     * const mapRegionJumps = await prisma.mapRegionJumps.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends mapRegionJumpsFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, mapRegionJumpsFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__mapRegionJumpsClient<$Result.GetResult<Prisma.$mapRegionJumpsPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first MapRegionJumps that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {mapRegionJumpsFindFirstArgs} args - Arguments to find a MapRegionJumps
     * @example
     * // Get one MapRegionJumps
     * const mapRegionJumps = await prisma.mapRegionJumps.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends mapRegionJumpsFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, mapRegionJumpsFindFirstArgs<ExtArgs>>
    ): Prisma__mapRegionJumpsClient<$Result.GetResult<Prisma.$mapRegionJumpsPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first MapRegionJumps that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {mapRegionJumpsFindFirstOrThrowArgs} args - Arguments to find a MapRegionJumps
     * @example
     * // Get one MapRegionJumps
     * const mapRegionJumps = await prisma.mapRegionJumps.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends mapRegionJumpsFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, mapRegionJumpsFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__mapRegionJumpsClient<$Result.GetResult<Prisma.$mapRegionJumpsPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more MapRegionJumps that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {mapRegionJumpsFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MapRegionJumps
     * const mapRegionJumps = await prisma.mapRegionJumps.findMany()
     * 
     * // Get first 10 MapRegionJumps
     * const mapRegionJumps = await prisma.mapRegionJumps.findMany({ take: 10 })
     * 
     * // Only select the `fromRegionID`
     * const mapRegionJumpsWithFromRegionIDOnly = await prisma.mapRegionJumps.findMany({ select: { fromRegionID: true } })
     * 
    **/
    findMany<T extends mapRegionJumpsFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, mapRegionJumpsFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$mapRegionJumpsPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a MapRegionJumps.
     * @param {mapRegionJumpsCreateArgs} args - Arguments to create a MapRegionJumps.
     * @example
     * // Create one MapRegionJumps
     * const MapRegionJumps = await prisma.mapRegionJumps.create({
     *   data: {
     *     // ... data to create a MapRegionJumps
     *   }
     * })
     * 
    **/
    create<T extends mapRegionJumpsCreateArgs<ExtArgs>>(
      args: SelectSubset<T, mapRegionJumpsCreateArgs<ExtArgs>>
    ): Prisma__mapRegionJumpsClient<$Result.GetResult<Prisma.$mapRegionJumpsPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many MapRegionJumps.
     *     @param {mapRegionJumpsCreateManyArgs} args - Arguments to create many MapRegionJumps.
     *     @example
     *     // Create many MapRegionJumps
     *     const mapRegionJumps = await prisma.mapRegionJumps.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends mapRegionJumpsCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, mapRegionJumpsCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a MapRegionJumps.
     * @param {mapRegionJumpsDeleteArgs} args - Arguments to delete one MapRegionJumps.
     * @example
     * // Delete one MapRegionJumps
     * const MapRegionJumps = await prisma.mapRegionJumps.delete({
     *   where: {
     *     // ... filter to delete one MapRegionJumps
     *   }
     * })
     * 
    **/
    delete<T extends mapRegionJumpsDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, mapRegionJumpsDeleteArgs<ExtArgs>>
    ): Prisma__mapRegionJumpsClient<$Result.GetResult<Prisma.$mapRegionJumpsPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one MapRegionJumps.
     * @param {mapRegionJumpsUpdateArgs} args - Arguments to update one MapRegionJumps.
     * @example
     * // Update one MapRegionJumps
     * const mapRegionJumps = await prisma.mapRegionJumps.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends mapRegionJumpsUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, mapRegionJumpsUpdateArgs<ExtArgs>>
    ): Prisma__mapRegionJumpsClient<$Result.GetResult<Prisma.$mapRegionJumpsPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more MapRegionJumps.
     * @param {mapRegionJumpsDeleteManyArgs} args - Arguments to filter MapRegionJumps to delete.
     * @example
     * // Delete a few MapRegionJumps
     * const { count } = await prisma.mapRegionJumps.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends mapRegionJumpsDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, mapRegionJumpsDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MapRegionJumps.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {mapRegionJumpsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MapRegionJumps
     * const mapRegionJumps = await prisma.mapRegionJumps.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends mapRegionJumpsUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, mapRegionJumpsUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one MapRegionJumps.
     * @param {mapRegionJumpsUpsertArgs} args - Arguments to update or create a MapRegionJumps.
     * @example
     * // Update or create a MapRegionJumps
     * const mapRegionJumps = await prisma.mapRegionJumps.upsert({
     *   create: {
     *     // ... data to create a MapRegionJumps
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MapRegionJumps we want to update
     *   }
     * })
    **/
    upsert<T extends mapRegionJumpsUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, mapRegionJumpsUpsertArgs<ExtArgs>>
    ): Prisma__mapRegionJumpsClient<$Result.GetResult<Prisma.$mapRegionJumpsPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of MapRegionJumps.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {mapRegionJumpsCountArgs} args - Arguments to filter MapRegionJumps to count.
     * @example
     * // Count the number of MapRegionJumps
     * const count = await prisma.mapRegionJumps.count({
     *   where: {
     *     // ... the filter for the MapRegionJumps we want to count
     *   }
     * })
    **/
    count<T extends mapRegionJumpsCountArgs>(
      args?: Subset<T, mapRegionJumpsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MapRegionJumpsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MapRegionJumps.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MapRegionJumpsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MapRegionJumpsAggregateArgs>(args: Subset<T, MapRegionJumpsAggregateArgs>): Prisma.PrismaPromise<GetMapRegionJumpsAggregateType<T>>

    /**
     * Group by MapRegionJumps.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {mapRegionJumpsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends mapRegionJumpsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: mapRegionJumpsGroupByArgs['orderBy'] }
        : { orderBy?: mapRegionJumpsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, mapRegionJumpsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMapRegionJumpsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the mapRegionJumps model
   */
  readonly fields: mapRegionJumpsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for mapRegionJumps.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__mapRegionJumpsClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';


    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the mapRegionJumps model
   */ 
  interface mapRegionJumpsFieldRefs {
    readonly fromRegionID: FieldRef<"mapRegionJumps", 'Int'>
    readonly toRegionID: FieldRef<"mapRegionJumps", 'Int'>
  }
    

  // Custom InputTypes

  /**
   * mapRegionJumps findUnique
   */
  export type mapRegionJumpsFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the mapRegionJumps
     */
    select?: mapRegionJumpsSelect<ExtArgs> | null
    /**
     * Filter, which mapRegionJumps to fetch.
     */
    where: mapRegionJumpsWhereUniqueInput
  }


  /**
   * mapRegionJumps findUniqueOrThrow
   */
  export type mapRegionJumpsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the mapRegionJumps
     */
    select?: mapRegionJumpsSelect<ExtArgs> | null
    /**
     * Filter, which mapRegionJumps to fetch.
     */
    where: mapRegionJumpsWhereUniqueInput
  }


  /**
   * mapRegionJumps findFirst
   */
  export type mapRegionJumpsFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the mapRegionJumps
     */
    select?: mapRegionJumpsSelect<ExtArgs> | null
    /**
     * Filter, which mapRegionJumps to fetch.
     */
    where?: mapRegionJumpsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of mapRegionJumps to fetch.
     */
    orderBy?: mapRegionJumpsOrderByWithRelationInput | mapRegionJumpsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for mapRegionJumps.
     */
    cursor?: mapRegionJumpsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` mapRegionJumps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` mapRegionJumps.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of mapRegionJumps.
     */
    distinct?: MapRegionJumpsScalarFieldEnum | MapRegionJumpsScalarFieldEnum[]
  }


  /**
   * mapRegionJumps findFirstOrThrow
   */
  export type mapRegionJumpsFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the mapRegionJumps
     */
    select?: mapRegionJumpsSelect<ExtArgs> | null
    /**
     * Filter, which mapRegionJumps to fetch.
     */
    where?: mapRegionJumpsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of mapRegionJumps to fetch.
     */
    orderBy?: mapRegionJumpsOrderByWithRelationInput | mapRegionJumpsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for mapRegionJumps.
     */
    cursor?: mapRegionJumpsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` mapRegionJumps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` mapRegionJumps.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of mapRegionJumps.
     */
    distinct?: MapRegionJumpsScalarFieldEnum | MapRegionJumpsScalarFieldEnum[]
  }


  /**
   * mapRegionJumps findMany
   */
  export type mapRegionJumpsFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the mapRegionJumps
     */
    select?: mapRegionJumpsSelect<ExtArgs> | null
    /**
     * Filter, which mapRegionJumps to fetch.
     */
    where?: mapRegionJumpsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of mapRegionJumps to fetch.
     */
    orderBy?: mapRegionJumpsOrderByWithRelationInput | mapRegionJumpsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing mapRegionJumps.
     */
    cursor?: mapRegionJumpsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` mapRegionJumps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` mapRegionJumps.
     */
    skip?: number
    distinct?: MapRegionJumpsScalarFieldEnum | MapRegionJumpsScalarFieldEnum[]
  }


  /**
   * mapRegionJumps create
   */
  export type mapRegionJumpsCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the mapRegionJumps
     */
    select?: mapRegionJumpsSelect<ExtArgs> | null
    /**
     * The data needed to create a mapRegionJumps.
     */
    data: XOR<mapRegionJumpsCreateInput, mapRegionJumpsUncheckedCreateInput>
  }


  /**
   * mapRegionJumps createMany
   */
  export type mapRegionJumpsCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many mapRegionJumps.
     */
    data: mapRegionJumpsCreateManyInput | mapRegionJumpsCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * mapRegionJumps update
   */
  export type mapRegionJumpsUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the mapRegionJumps
     */
    select?: mapRegionJumpsSelect<ExtArgs> | null
    /**
     * The data needed to update a mapRegionJumps.
     */
    data: XOR<mapRegionJumpsUpdateInput, mapRegionJumpsUncheckedUpdateInput>
    /**
     * Choose, which mapRegionJumps to update.
     */
    where: mapRegionJumpsWhereUniqueInput
  }


  /**
   * mapRegionJumps updateMany
   */
  export type mapRegionJumpsUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update mapRegionJumps.
     */
    data: XOR<mapRegionJumpsUpdateManyMutationInput, mapRegionJumpsUncheckedUpdateManyInput>
    /**
     * Filter which mapRegionJumps to update
     */
    where?: mapRegionJumpsWhereInput
  }


  /**
   * mapRegionJumps upsert
   */
  export type mapRegionJumpsUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the mapRegionJumps
     */
    select?: mapRegionJumpsSelect<ExtArgs> | null
    /**
     * The filter to search for the mapRegionJumps to update in case it exists.
     */
    where: mapRegionJumpsWhereUniqueInput
    /**
     * In case the mapRegionJumps found by the `where` argument doesn't exist, create a new mapRegionJumps with this data.
     */
    create: XOR<mapRegionJumpsCreateInput, mapRegionJumpsUncheckedCreateInput>
    /**
     * In case the mapRegionJumps was found with the provided `where` argument, update it with this data.
     */
    update: XOR<mapRegionJumpsUpdateInput, mapRegionJumpsUncheckedUpdateInput>
  }


  /**
   * mapRegionJumps delete
   */
  export type mapRegionJumpsDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the mapRegionJumps
     */
    select?: mapRegionJumpsSelect<ExtArgs> | null
    /**
     * Filter which mapRegionJumps to delete.
     */
    where: mapRegionJumpsWhereUniqueInput
  }


  /**
   * mapRegionJumps deleteMany
   */
  export type mapRegionJumpsDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which mapRegionJumps to delete
     */
    where?: mapRegionJumpsWhereInput
  }


  /**
   * mapRegionJumps without action
   */
  export type mapRegionJumpsDefaultArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the mapRegionJumps
     */
    select?: mapRegionJumpsSelect<ExtArgs> | null
  }



  /**
   * Model mapRegions
   */

  export type AggregateMapRegions = {
    _count: MapRegionsCountAggregateOutputType | null
    _avg: MapRegionsAvgAggregateOutputType | null
    _sum: MapRegionsSumAggregateOutputType | null
    _min: MapRegionsMinAggregateOutputType | null
    _max: MapRegionsMaxAggregateOutputType | null
  }

  export type MapRegionsAvgAggregateOutputType = {
    regionID: number | null
    x: number | null
    y: number | null
    z: number | null
    xMin: number | null
    xMax: number | null
    yMin: number | null
    yMax: number | null
    zMin: number | null
    zMax: number | null
    factionID: number | null
    nebula: number | null
    radius: number | null
  }

  export type MapRegionsSumAggregateOutputType = {
    regionID: number | null
    x: number | null
    y: number | null
    z: number | null
    xMin: number | null
    xMax: number | null
    yMin: number | null
    yMax: number | null
    zMin: number | null
    zMax: number | null
    factionID: number | null
    nebula: number | null
    radius: number | null
  }

  export type MapRegionsMinAggregateOutputType = {
    regionID: number | null
    regionName: string | null
    x: number | null
    y: number | null
    z: number | null
    xMin: number | null
    xMax: number | null
    yMin: number | null
    yMax: number | null
    zMin: number | null
    zMax: number | null
    factionID: number | null
    nebula: number | null
    radius: number | null
  }

  export type MapRegionsMaxAggregateOutputType = {
    regionID: number | null
    regionName: string | null
    x: number | null
    y: number | null
    z: number | null
    xMin: number | null
    xMax: number | null
    yMin: number | null
    yMax: number | null
    zMin: number | null
    zMax: number | null
    factionID: number | null
    nebula: number | null
    radius: number | null
  }

  export type MapRegionsCountAggregateOutputType = {
    regionID: number
    regionName: number
    x: number
    y: number
    z: number
    xMin: number
    xMax: number
    yMin: number
    yMax: number
    zMin: number
    zMax: number
    factionID: number
    nebula: number
    radius: number
    _all: number
  }


  export type MapRegionsAvgAggregateInputType = {
    regionID?: true
    x?: true
    y?: true
    z?: true
    xMin?: true
    xMax?: true
    yMin?: true
    yMax?: true
    zMin?: true
    zMax?: true
    factionID?: true
    nebula?: true
    radius?: true
  }

  export type MapRegionsSumAggregateInputType = {
    regionID?: true
    x?: true
    y?: true
    z?: true
    xMin?: true
    xMax?: true
    yMin?: true
    yMax?: true
    zMin?: true
    zMax?: true
    factionID?: true
    nebula?: true
    radius?: true
  }

  export type MapRegionsMinAggregateInputType = {
    regionID?: true
    regionName?: true
    x?: true
    y?: true
    z?: true
    xMin?: true
    xMax?: true
    yMin?: true
    yMax?: true
    zMin?: true
    zMax?: true
    factionID?: true
    nebula?: true
    radius?: true
  }

  export type MapRegionsMaxAggregateInputType = {
    regionID?: true
    regionName?: true
    x?: true
    y?: true
    z?: true
    xMin?: true
    xMax?: true
    yMin?: true
    yMax?: true
    zMin?: true
    zMax?: true
    factionID?: true
    nebula?: true
    radius?: true
  }

  export type MapRegionsCountAggregateInputType = {
    regionID?: true
    regionName?: true
    x?: true
    y?: true
    z?: true
    xMin?: true
    xMax?: true
    yMin?: true
    yMax?: true
    zMin?: true
    zMax?: true
    factionID?: true
    nebula?: true
    radius?: true
    _all?: true
  }

  export type MapRegionsAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which mapRegions to aggregate.
     */
    where?: mapRegionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of mapRegions to fetch.
     */
    orderBy?: mapRegionsOrderByWithRelationInput | mapRegionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: mapRegionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` mapRegions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` mapRegions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned mapRegions
    **/
    _count?: true | MapRegionsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MapRegionsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MapRegionsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MapRegionsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MapRegionsMaxAggregateInputType
  }

  export type GetMapRegionsAggregateType<T extends MapRegionsAggregateArgs> = {
        [P in keyof T & keyof AggregateMapRegions]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMapRegions[P]>
      : GetScalarType<T[P], AggregateMapRegions[P]>
  }




  export type mapRegionsGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: mapRegionsWhereInput
    orderBy?: mapRegionsOrderByWithAggregationInput | mapRegionsOrderByWithAggregationInput[]
    by: MapRegionsScalarFieldEnum[] | MapRegionsScalarFieldEnum
    having?: mapRegionsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MapRegionsCountAggregateInputType | true
    _avg?: MapRegionsAvgAggregateInputType
    _sum?: MapRegionsSumAggregateInputType
    _min?: MapRegionsMinAggregateInputType
    _max?: MapRegionsMaxAggregateInputType
  }

  export type MapRegionsGroupByOutputType = {
    regionID: number
    regionName: string | null
    x: number | null
    y: number | null
    z: number | null
    xMin: number | null
    xMax: number | null
    yMin: number | null
    yMax: number | null
    zMin: number | null
    zMax: number | null
    factionID: number | null
    nebula: number | null
    radius: number | null
    _count: MapRegionsCountAggregateOutputType | null
    _avg: MapRegionsAvgAggregateOutputType | null
    _sum: MapRegionsSumAggregateOutputType | null
    _min: MapRegionsMinAggregateOutputType | null
    _max: MapRegionsMaxAggregateOutputType | null
  }

  type GetMapRegionsGroupByPayload<T extends mapRegionsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MapRegionsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MapRegionsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MapRegionsGroupByOutputType[P]>
            : GetScalarType<T[P], MapRegionsGroupByOutputType[P]>
        }
      >
    >


  export type mapRegionsSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    regionID?: boolean
    regionName?: boolean
    x?: boolean
    y?: boolean
    z?: boolean
    xMin?: boolean
    xMax?: boolean
    yMin?: boolean
    yMax?: boolean
    zMin?: boolean
    zMax?: boolean
    factionID?: boolean
    nebula?: boolean
    radius?: boolean
  }, ExtArgs["result"]["mapRegions"]>

  export type mapRegionsSelectScalar = {
    regionID?: boolean
    regionName?: boolean
    x?: boolean
    y?: boolean
    z?: boolean
    xMin?: boolean
    xMax?: boolean
    yMin?: boolean
    yMax?: boolean
    zMin?: boolean
    zMax?: boolean
    factionID?: boolean
    nebula?: boolean
    radius?: boolean
  }


  export type $mapRegionsPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    name: "mapRegions"
    objects: {}
    scalars: $Extensions.GetResult<{
      regionID: number
      regionName: string | null
      x: number | null
      y: number | null
      z: number | null
      xMin: number | null
      xMax: number | null
      yMin: number | null
      yMax: number | null
      zMin: number | null
      zMax: number | null
      factionID: number | null
      nebula: number | null
      radius: number | null
    }, ExtArgs["result"]["mapRegions"]>
    composites: {}
  }


  type mapRegionsGetPayload<S extends boolean | null | undefined | mapRegionsDefaultArgs> = $Result.GetResult<Prisma.$mapRegionsPayload, S>

  type mapRegionsCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<mapRegionsFindManyArgs, 'select' | 'include'> & {
      select?: MapRegionsCountAggregateInputType | true
    }

  export interface mapRegionsDelegate<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['mapRegions'], meta: { name: 'mapRegions' } }
    /**
     * Find zero or one MapRegions that matches the filter.
     * @param {mapRegionsFindUniqueArgs} args - Arguments to find a MapRegions
     * @example
     * // Get one MapRegions
     * const mapRegions = await prisma.mapRegions.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends mapRegionsFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, mapRegionsFindUniqueArgs<ExtArgs>>
    ): Prisma__mapRegionsClient<$Result.GetResult<Prisma.$mapRegionsPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one MapRegions that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {mapRegionsFindUniqueOrThrowArgs} args - Arguments to find a MapRegions
     * @example
     * // Get one MapRegions
     * const mapRegions = await prisma.mapRegions.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends mapRegionsFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, mapRegionsFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__mapRegionsClient<$Result.GetResult<Prisma.$mapRegionsPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first MapRegions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {mapRegionsFindFirstArgs} args - Arguments to find a MapRegions
     * @example
     * // Get one MapRegions
     * const mapRegions = await prisma.mapRegions.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends mapRegionsFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, mapRegionsFindFirstArgs<ExtArgs>>
    ): Prisma__mapRegionsClient<$Result.GetResult<Prisma.$mapRegionsPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first MapRegions that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {mapRegionsFindFirstOrThrowArgs} args - Arguments to find a MapRegions
     * @example
     * // Get one MapRegions
     * const mapRegions = await prisma.mapRegions.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends mapRegionsFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, mapRegionsFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__mapRegionsClient<$Result.GetResult<Prisma.$mapRegionsPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more MapRegions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {mapRegionsFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MapRegions
     * const mapRegions = await prisma.mapRegions.findMany()
     * 
     * // Get first 10 MapRegions
     * const mapRegions = await prisma.mapRegions.findMany({ take: 10 })
     * 
     * // Only select the `regionID`
     * const mapRegionsWithRegionIDOnly = await prisma.mapRegions.findMany({ select: { regionID: true } })
     * 
    **/
    findMany<T extends mapRegionsFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, mapRegionsFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$mapRegionsPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a MapRegions.
     * @param {mapRegionsCreateArgs} args - Arguments to create a MapRegions.
     * @example
     * // Create one MapRegions
     * const MapRegions = await prisma.mapRegions.create({
     *   data: {
     *     // ... data to create a MapRegions
     *   }
     * })
     * 
    **/
    create<T extends mapRegionsCreateArgs<ExtArgs>>(
      args: SelectSubset<T, mapRegionsCreateArgs<ExtArgs>>
    ): Prisma__mapRegionsClient<$Result.GetResult<Prisma.$mapRegionsPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many MapRegions.
     *     @param {mapRegionsCreateManyArgs} args - Arguments to create many MapRegions.
     *     @example
     *     // Create many MapRegions
     *     const mapRegions = await prisma.mapRegions.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends mapRegionsCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, mapRegionsCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a MapRegions.
     * @param {mapRegionsDeleteArgs} args - Arguments to delete one MapRegions.
     * @example
     * // Delete one MapRegions
     * const MapRegions = await prisma.mapRegions.delete({
     *   where: {
     *     // ... filter to delete one MapRegions
     *   }
     * })
     * 
    **/
    delete<T extends mapRegionsDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, mapRegionsDeleteArgs<ExtArgs>>
    ): Prisma__mapRegionsClient<$Result.GetResult<Prisma.$mapRegionsPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one MapRegions.
     * @param {mapRegionsUpdateArgs} args - Arguments to update one MapRegions.
     * @example
     * // Update one MapRegions
     * const mapRegions = await prisma.mapRegions.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends mapRegionsUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, mapRegionsUpdateArgs<ExtArgs>>
    ): Prisma__mapRegionsClient<$Result.GetResult<Prisma.$mapRegionsPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more MapRegions.
     * @param {mapRegionsDeleteManyArgs} args - Arguments to filter MapRegions to delete.
     * @example
     * // Delete a few MapRegions
     * const { count } = await prisma.mapRegions.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends mapRegionsDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, mapRegionsDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MapRegions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {mapRegionsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MapRegions
     * const mapRegions = await prisma.mapRegions.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends mapRegionsUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, mapRegionsUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one MapRegions.
     * @param {mapRegionsUpsertArgs} args - Arguments to update or create a MapRegions.
     * @example
     * // Update or create a MapRegions
     * const mapRegions = await prisma.mapRegions.upsert({
     *   create: {
     *     // ... data to create a MapRegions
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MapRegions we want to update
     *   }
     * })
    **/
    upsert<T extends mapRegionsUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, mapRegionsUpsertArgs<ExtArgs>>
    ): Prisma__mapRegionsClient<$Result.GetResult<Prisma.$mapRegionsPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of MapRegions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {mapRegionsCountArgs} args - Arguments to filter MapRegions to count.
     * @example
     * // Count the number of MapRegions
     * const count = await prisma.mapRegions.count({
     *   where: {
     *     // ... the filter for the MapRegions we want to count
     *   }
     * })
    **/
    count<T extends mapRegionsCountArgs>(
      args?: Subset<T, mapRegionsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MapRegionsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MapRegions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MapRegionsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MapRegionsAggregateArgs>(args: Subset<T, MapRegionsAggregateArgs>): Prisma.PrismaPromise<GetMapRegionsAggregateType<T>>

    /**
     * Group by MapRegions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {mapRegionsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends mapRegionsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: mapRegionsGroupByArgs['orderBy'] }
        : { orderBy?: mapRegionsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, mapRegionsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMapRegionsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the mapRegions model
   */
  readonly fields: mapRegionsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for mapRegions.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__mapRegionsClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';


    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the mapRegions model
   */ 
  interface mapRegionsFieldRefs {
    readonly regionID: FieldRef<"mapRegions", 'Int'>
    readonly regionName: FieldRef<"mapRegions", 'String'>
    readonly x: FieldRef<"mapRegions", 'Float'>
    readonly y: FieldRef<"mapRegions", 'Float'>
    readonly z: FieldRef<"mapRegions", 'Float'>
    readonly xMin: FieldRef<"mapRegions", 'Float'>
    readonly xMax: FieldRef<"mapRegions", 'Float'>
    readonly yMin: FieldRef<"mapRegions", 'Float'>
    readonly yMax: FieldRef<"mapRegions", 'Float'>
    readonly zMin: FieldRef<"mapRegions", 'Float'>
    readonly zMax: FieldRef<"mapRegions", 'Float'>
    readonly factionID: FieldRef<"mapRegions", 'Int'>
    readonly nebula: FieldRef<"mapRegions", 'Int'>
    readonly radius: FieldRef<"mapRegions", 'Float'>
  }
    

  // Custom InputTypes

  /**
   * mapRegions findUnique
   */
  export type mapRegionsFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the mapRegions
     */
    select?: mapRegionsSelect<ExtArgs> | null
    /**
     * Filter, which mapRegions to fetch.
     */
    where: mapRegionsWhereUniqueInput
  }


  /**
   * mapRegions findUniqueOrThrow
   */
  export type mapRegionsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the mapRegions
     */
    select?: mapRegionsSelect<ExtArgs> | null
    /**
     * Filter, which mapRegions to fetch.
     */
    where: mapRegionsWhereUniqueInput
  }


  /**
   * mapRegions findFirst
   */
  export type mapRegionsFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the mapRegions
     */
    select?: mapRegionsSelect<ExtArgs> | null
    /**
     * Filter, which mapRegions to fetch.
     */
    where?: mapRegionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of mapRegions to fetch.
     */
    orderBy?: mapRegionsOrderByWithRelationInput | mapRegionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for mapRegions.
     */
    cursor?: mapRegionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` mapRegions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` mapRegions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of mapRegions.
     */
    distinct?: MapRegionsScalarFieldEnum | MapRegionsScalarFieldEnum[]
  }


  /**
   * mapRegions findFirstOrThrow
   */
  export type mapRegionsFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the mapRegions
     */
    select?: mapRegionsSelect<ExtArgs> | null
    /**
     * Filter, which mapRegions to fetch.
     */
    where?: mapRegionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of mapRegions to fetch.
     */
    orderBy?: mapRegionsOrderByWithRelationInput | mapRegionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for mapRegions.
     */
    cursor?: mapRegionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` mapRegions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` mapRegions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of mapRegions.
     */
    distinct?: MapRegionsScalarFieldEnum | MapRegionsScalarFieldEnum[]
  }


  /**
   * mapRegions findMany
   */
  export type mapRegionsFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the mapRegions
     */
    select?: mapRegionsSelect<ExtArgs> | null
    /**
     * Filter, which mapRegions to fetch.
     */
    where?: mapRegionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of mapRegions to fetch.
     */
    orderBy?: mapRegionsOrderByWithRelationInput | mapRegionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing mapRegions.
     */
    cursor?: mapRegionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` mapRegions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` mapRegions.
     */
    skip?: number
    distinct?: MapRegionsScalarFieldEnum | MapRegionsScalarFieldEnum[]
  }


  /**
   * mapRegions create
   */
  export type mapRegionsCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the mapRegions
     */
    select?: mapRegionsSelect<ExtArgs> | null
    /**
     * The data needed to create a mapRegions.
     */
    data: XOR<mapRegionsCreateInput, mapRegionsUncheckedCreateInput>
  }


  /**
   * mapRegions createMany
   */
  export type mapRegionsCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many mapRegions.
     */
    data: mapRegionsCreateManyInput | mapRegionsCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * mapRegions update
   */
  export type mapRegionsUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the mapRegions
     */
    select?: mapRegionsSelect<ExtArgs> | null
    /**
     * The data needed to update a mapRegions.
     */
    data: XOR<mapRegionsUpdateInput, mapRegionsUncheckedUpdateInput>
    /**
     * Choose, which mapRegions to update.
     */
    where: mapRegionsWhereUniqueInput
  }


  /**
   * mapRegions updateMany
   */
  export type mapRegionsUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update mapRegions.
     */
    data: XOR<mapRegionsUpdateManyMutationInput, mapRegionsUncheckedUpdateManyInput>
    /**
     * Filter which mapRegions to update
     */
    where?: mapRegionsWhereInput
  }


  /**
   * mapRegions upsert
   */
  export type mapRegionsUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the mapRegions
     */
    select?: mapRegionsSelect<ExtArgs> | null
    /**
     * The filter to search for the mapRegions to update in case it exists.
     */
    where: mapRegionsWhereUniqueInput
    /**
     * In case the mapRegions found by the `where` argument doesn't exist, create a new mapRegions with this data.
     */
    create: XOR<mapRegionsCreateInput, mapRegionsUncheckedCreateInput>
    /**
     * In case the mapRegions was found with the provided `where` argument, update it with this data.
     */
    update: XOR<mapRegionsUpdateInput, mapRegionsUncheckedUpdateInput>
  }


  /**
   * mapRegions delete
   */
  export type mapRegionsDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the mapRegions
     */
    select?: mapRegionsSelect<ExtArgs> | null
    /**
     * Filter which mapRegions to delete.
     */
    where: mapRegionsWhereUniqueInput
  }


  /**
   * mapRegions deleteMany
   */
  export type mapRegionsDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which mapRegions to delete
     */
    where?: mapRegionsWhereInput
  }


  /**
   * mapRegions without action
   */
  export type mapRegionsDefaultArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the mapRegions
     */
    select?: mapRegionsSelect<ExtArgs> | null
  }



  /**
   * Model mapSolarSystemJumps
   */

  export type AggregateMapSolarSystemJumps = {
    _count: MapSolarSystemJumpsCountAggregateOutputType | null
    _avg: MapSolarSystemJumpsAvgAggregateOutputType | null
    _sum: MapSolarSystemJumpsSumAggregateOutputType | null
    _min: MapSolarSystemJumpsMinAggregateOutputType | null
    _max: MapSolarSystemJumpsMaxAggregateOutputType | null
  }

  export type MapSolarSystemJumpsAvgAggregateOutputType = {
    fromRegionID: number | null
    fromConstellationID: number | null
    fromSolarSystemID: number | null
    toSolarSystemID: number | null
    toConstellationID: number | null
    toRegionID: number | null
  }

  export type MapSolarSystemJumpsSumAggregateOutputType = {
    fromRegionID: number | null
    fromConstellationID: number | null
    fromSolarSystemID: number | null
    toSolarSystemID: number | null
    toConstellationID: number | null
    toRegionID: number | null
  }

  export type MapSolarSystemJumpsMinAggregateOutputType = {
    fromRegionID: number | null
    fromConstellationID: number | null
    fromSolarSystemID: number | null
    toSolarSystemID: number | null
    toConstellationID: number | null
    toRegionID: number | null
  }

  export type MapSolarSystemJumpsMaxAggregateOutputType = {
    fromRegionID: number | null
    fromConstellationID: number | null
    fromSolarSystemID: number | null
    toSolarSystemID: number | null
    toConstellationID: number | null
    toRegionID: number | null
  }

  export type MapSolarSystemJumpsCountAggregateOutputType = {
    fromRegionID: number
    fromConstellationID: number
    fromSolarSystemID: number
    toSolarSystemID: number
    toConstellationID: number
    toRegionID: number
    _all: number
  }


  export type MapSolarSystemJumpsAvgAggregateInputType = {
    fromRegionID?: true
    fromConstellationID?: true
    fromSolarSystemID?: true
    toSolarSystemID?: true
    toConstellationID?: true
    toRegionID?: true
  }

  export type MapSolarSystemJumpsSumAggregateInputType = {
    fromRegionID?: true
    fromConstellationID?: true
    fromSolarSystemID?: true
    toSolarSystemID?: true
    toConstellationID?: true
    toRegionID?: true
  }

  export type MapSolarSystemJumpsMinAggregateInputType = {
    fromRegionID?: true
    fromConstellationID?: true
    fromSolarSystemID?: true
    toSolarSystemID?: true
    toConstellationID?: true
    toRegionID?: true
  }

  export type MapSolarSystemJumpsMaxAggregateInputType = {
    fromRegionID?: true
    fromConstellationID?: true
    fromSolarSystemID?: true
    toSolarSystemID?: true
    toConstellationID?: true
    toRegionID?: true
  }

  export type MapSolarSystemJumpsCountAggregateInputType = {
    fromRegionID?: true
    fromConstellationID?: true
    fromSolarSystemID?: true
    toSolarSystemID?: true
    toConstellationID?: true
    toRegionID?: true
    _all?: true
  }

  export type MapSolarSystemJumpsAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which mapSolarSystemJumps to aggregate.
     */
    where?: mapSolarSystemJumpsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of mapSolarSystemJumps to fetch.
     */
    orderBy?: mapSolarSystemJumpsOrderByWithRelationInput | mapSolarSystemJumpsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: mapSolarSystemJumpsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` mapSolarSystemJumps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` mapSolarSystemJumps.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned mapSolarSystemJumps
    **/
    _count?: true | MapSolarSystemJumpsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MapSolarSystemJumpsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MapSolarSystemJumpsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MapSolarSystemJumpsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MapSolarSystemJumpsMaxAggregateInputType
  }

  export type GetMapSolarSystemJumpsAggregateType<T extends MapSolarSystemJumpsAggregateArgs> = {
        [P in keyof T & keyof AggregateMapSolarSystemJumps]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMapSolarSystemJumps[P]>
      : GetScalarType<T[P], AggregateMapSolarSystemJumps[P]>
  }




  export type mapSolarSystemJumpsGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: mapSolarSystemJumpsWhereInput
    orderBy?: mapSolarSystemJumpsOrderByWithAggregationInput | mapSolarSystemJumpsOrderByWithAggregationInput[]
    by: MapSolarSystemJumpsScalarFieldEnum[] | MapSolarSystemJumpsScalarFieldEnum
    having?: mapSolarSystemJumpsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MapSolarSystemJumpsCountAggregateInputType | true
    _avg?: MapSolarSystemJumpsAvgAggregateInputType
    _sum?: MapSolarSystemJumpsSumAggregateInputType
    _min?: MapSolarSystemJumpsMinAggregateInputType
    _max?: MapSolarSystemJumpsMaxAggregateInputType
  }

  export type MapSolarSystemJumpsGroupByOutputType = {
    fromRegionID: number | null
    fromConstellationID: number | null
    fromSolarSystemID: number
    toSolarSystemID: number
    toConstellationID: number | null
    toRegionID: number | null
    _count: MapSolarSystemJumpsCountAggregateOutputType | null
    _avg: MapSolarSystemJumpsAvgAggregateOutputType | null
    _sum: MapSolarSystemJumpsSumAggregateOutputType | null
    _min: MapSolarSystemJumpsMinAggregateOutputType | null
    _max: MapSolarSystemJumpsMaxAggregateOutputType | null
  }

  type GetMapSolarSystemJumpsGroupByPayload<T extends mapSolarSystemJumpsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MapSolarSystemJumpsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MapSolarSystemJumpsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MapSolarSystemJumpsGroupByOutputType[P]>
            : GetScalarType<T[P], MapSolarSystemJumpsGroupByOutputType[P]>
        }
      >
    >


  export type mapSolarSystemJumpsSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    fromRegionID?: boolean
    fromConstellationID?: boolean
    fromSolarSystemID?: boolean
    toSolarSystemID?: boolean
    toConstellationID?: boolean
    toRegionID?: boolean
  }, ExtArgs["result"]["mapSolarSystemJumps"]>

  export type mapSolarSystemJumpsSelectScalar = {
    fromRegionID?: boolean
    fromConstellationID?: boolean
    fromSolarSystemID?: boolean
    toSolarSystemID?: boolean
    toConstellationID?: boolean
    toRegionID?: boolean
  }


  export type $mapSolarSystemJumpsPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    name: "mapSolarSystemJumps"
    objects: {}
    scalars: $Extensions.GetResult<{
      fromRegionID: number | null
      fromConstellationID: number | null
      fromSolarSystemID: number
      toSolarSystemID: number
      toConstellationID: number | null
      toRegionID: number | null
    }, ExtArgs["result"]["mapSolarSystemJumps"]>
    composites: {}
  }


  type mapSolarSystemJumpsGetPayload<S extends boolean | null | undefined | mapSolarSystemJumpsDefaultArgs> = $Result.GetResult<Prisma.$mapSolarSystemJumpsPayload, S>

  type mapSolarSystemJumpsCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<mapSolarSystemJumpsFindManyArgs, 'select' | 'include'> & {
      select?: MapSolarSystemJumpsCountAggregateInputType | true
    }

  export interface mapSolarSystemJumpsDelegate<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['mapSolarSystemJumps'], meta: { name: 'mapSolarSystemJumps' } }
    /**
     * Find zero or one MapSolarSystemJumps that matches the filter.
     * @param {mapSolarSystemJumpsFindUniqueArgs} args - Arguments to find a MapSolarSystemJumps
     * @example
     * // Get one MapSolarSystemJumps
     * const mapSolarSystemJumps = await prisma.mapSolarSystemJumps.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends mapSolarSystemJumpsFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, mapSolarSystemJumpsFindUniqueArgs<ExtArgs>>
    ): Prisma__mapSolarSystemJumpsClient<$Result.GetResult<Prisma.$mapSolarSystemJumpsPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one MapSolarSystemJumps that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {mapSolarSystemJumpsFindUniqueOrThrowArgs} args - Arguments to find a MapSolarSystemJumps
     * @example
     * // Get one MapSolarSystemJumps
     * const mapSolarSystemJumps = await prisma.mapSolarSystemJumps.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends mapSolarSystemJumpsFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, mapSolarSystemJumpsFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__mapSolarSystemJumpsClient<$Result.GetResult<Prisma.$mapSolarSystemJumpsPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first MapSolarSystemJumps that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {mapSolarSystemJumpsFindFirstArgs} args - Arguments to find a MapSolarSystemJumps
     * @example
     * // Get one MapSolarSystemJumps
     * const mapSolarSystemJumps = await prisma.mapSolarSystemJumps.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends mapSolarSystemJumpsFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, mapSolarSystemJumpsFindFirstArgs<ExtArgs>>
    ): Prisma__mapSolarSystemJumpsClient<$Result.GetResult<Prisma.$mapSolarSystemJumpsPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first MapSolarSystemJumps that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {mapSolarSystemJumpsFindFirstOrThrowArgs} args - Arguments to find a MapSolarSystemJumps
     * @example
     * // Get one MapSolarSystemJumps
     * const mapSolarSystemJumps = await prisma.mapSolarSystemJumps.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends mapSolarSystemJumpsFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, mapSolarSystemJumpsFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__mapSolarSystemJumpsClient<$Result.GetResult<Prisma.$mapSolarSystemJumpsPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more MapSolarSystemJumps that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {mapSolarSystemJumpsFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MapSolarSystemJumps
     * const mapSolarSystemJumps = await prisma.mapSolarSystemJumps.findMany()
     * 
     * // Get first 10 MapSolarSystemJumps
     * const mapSolarSystemJumps = await prisma.mapSolarSystemJumps.findMany({ take: 10 })
     * 
     * // Only select the `fromRegionID`
     * const mapSolarSystemJumpsWithFromRegionIDOnly = await prisma.mapSolarSystemJumps.findMany({ select: { fromRegionID: true } })
     * 
    **/
    findMany<T extends mapSolarSystemJumpsFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, mapSolarSystemJumpsFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$mapSolarSystemJumpsPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a MapSolarSystemJumps.
     * @param {mapSolarSystemJumpsCreateArgs} args - Arguments to create a MapSolarSystemJumps.
     * @example
     * // Create one MapSolarSystemJumps
     * const MapSolarSystemJumps = await prisma.mapSolarSystemJumps.create({
     *   data: {
     *     // ... data to create a MapSolarSystemJumps
     *   }
     * })
     * 
    **/
    create<T extends mapSolarSystemJumpsCreateArgs<ExtArgs>>(
      args: SelectSubset<T, mapSolarSystemJumpsCreateArgs<ExtArgs>>
    ): Prisma__mapSolarSystemJumpsClient<$Result.GetResult<Prisma.$mapSolarSystemJumpsPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many MapSolarSystemJumps.
     *     @param {mapSolarSystemJumpsCreateManyArgs} args - Arguments to create many MapSolarSystemJumps.
     *     @example
     *     // Create many MapSolarSystemJumps
     *     const mapSolarSystemJumps = await prisma.mapSolarSystemJumps.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends mapSolarSystemJumpsCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, mapSolarSystemJumpsCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a MapSolarSystemJumps.
     * @param {mapSolarSystemJumpsDeleteArgs} args - Arguments to delete one MapSolarSystemJumps.
     * @example
     * // Delete one MapSolarSystemJumps
     * const MapSolarSystemJumps = await prisma.mapSolarSystemJumps.delete({
     *   where: {
     *     // ... filter to delete one MapSolarSystemJumps
     *   }
     * })
     * 
    **/
    delete<T extends mapSolarSystemJumpsDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, mapSolarSystemJumpsDeleteArgs<ExtArgs>>
    ): Prisma__mapSolarSystemJumpsClient<$Result.GetResult<Prisma.$mapSolarSystemJumpsPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one MapSolarSystemJumps.
     * @param {mapSolarSystemJumpsUpdateArgs} args - Arguments to update one MapSolarSystemJumps.
     * @example
     * // Update one MapSolarSystemJumps
     * const mapSolarSystemJumps = await prisma.mapSolarSystemJumps.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends mapSolarSystemJumpsUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, mapSolarSystemJumpsUpdateArgs<ExtArgs>>
    ): Prisma__mapSolarSystemJumpsClient<$Result.GetResult<Prisma.$mapSolarSystemJumpsPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more MapSolarSystemJumps.
     * @param {mapSolarSystemJumpsDeleteManyArgs} args - Arguments to filter MapSolarSystemJumps to delete.
     * @example
     * // Delete a few MapSolarSystemJumps
     * const { count } = await prisma.mapSolarSystemJumps.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends mapSolarSystemJumpsDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, mapSolarSystemJumpsDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MapSolarSystemJumps.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {mapSolarSystemJumpsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MapSolarSystemJumps
     * const mapSolarSystemJumps = await prisma.mapSolarSystemJumps.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends mapSolarSystemJumpsUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, mapSolarSystemJumpsUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one MapSolarSystemJumps.
     * @param {mapSolarSystemJumpsUpsertArgs} args - Arguments to update or create a MapSolarSystemJumps.
     * @example
     * // Update or create a MapSolarSystemJumps
     * const mapSolarSystemJumps = await prisma.mapSolarSystemJumps.upsert({
     *   create: {
     *     // ... data to create a MapSolarSystemJumps
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MapSolarSystemJumps we want to update
     *   }
     * })
    **/
    upsert<T extends mapSolarSystemJumpsUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, mapSolarSystemJumpsUpsertArgs<ExtArgs>>
    ): Prisma__mapSolarSystemJumpsClient<$Result.GetResult<Prisma.$mapSolarSystemJumpsPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of MapSolarSystemJumps.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {mapSolarSystemJumpsCountArgs} args - Arguments to filter MapSolarSystemJumps to count.
     * @example
     * // Count the number of MapSolarSystemJumps
     * const count = await prisma.mapSolarSystemJumps.count({
     *   where: {
     *     // ... the filter for the MapSolarSystemJumps we want to count
     *   }
     * })
    **/
    count<T extends mapSolarSystemJumpsCountArgs>(
      args?: Subset<T, mapSolarSystemJumpsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MapSolarSystemJumpsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MapSolarSystemJumps.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MapSolarSystemJumpsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MapSolarSystemJumpsAggregateArgs>(args: Subset<T, MapSolarSystemJumpsAggregateArgs>): Prisma.PrismaPromise<GetMapSolarSystemJumpsAggregateType<T>>

    /**
     * Group by MapSolarSystemJumps.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {mapSolarSystemJumpsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends mapSolarSystemJumpsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: mapSolarSystemJumpsGroupByArgs['orderBy'] }
        : { orderBy?: mapSolarSystemJumpsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, mapSolarSystemJumpsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMapSolarSystemJumpsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the mapSolarSystemJumps model
   */
  readonly fields: mapSolarSystemJumpsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for mapSolarSystemJumps.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__mapSolarSystemJumpsClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';


    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the mapSolarSystemJumps model
   */ 
  interface mapSolarSystemJumpsFieldRefs {
    readonly fromRegionID: FieldRef<"mapSolarSystemJumps", 'Int'>
    readonly fromConstellationID: FieldRef<"mapSolarSystemJumps", 'Int'>
    readonly fromSolarSystemID: FieldRef<"mapSolarSystemJumps", 'Int'>
    readonly toSolarSystemID: FieldRef<"mapSolarSystemJumps", 'Int'>
    readonly toConstellationID: FieldRef<"mapSolarSystemJumps", 'Int'>
    readonly toRegionID: FieldRef<"mapSolarSystemJumps", 'Int'>
  }
    

  // Custom InputTypes

  /**
   * mapSolarSystemJumps findUnique
   */
  export type mapSolarSystemJumpsFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the mapSolarSystemJumps
     */
    select?: mapSolarSystemJumpsSelect<ExtArgs> | null
    /**
     * Filter, which mapSolarSystemJumps to fetch.
     */
    where: mapSolarSystemJumpsWhereUniqueInput
  }


  /**
   * mapSolarSystemJumps findUniqueOrThrow
   */
  export type mapSolarSystemJumpsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the mapSolarSystemJumps
     */
    select?: mapSolarSystemJumpsSelect<ExtArgs> | null
    /**
     * Filter, which mapSolarSystemJumps to fetch.
     */
    where: mapSolarSystemJumpsWhereUniqueInput
  }


  /**
   * mapSolarSystemJumps findFirst
   */
  export type mapSolarSystemJumpsFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the mapSolarSystemJumps
     */
    select?: mapSolarSystemJumpsSelect<ExtArgs> | null
    /**
     * Filter, which mapSolarSystemJumps to fetch.
     */
    where?: mapSolarSystemJumpsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of mapSolarSystemJumps to fetch.
     */
    orderBy?: mapSolarSystemJumpsOrderByWithRelationInput | mapSolarSystemJumpsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for mapSolarSystemJumps.
     */
    cursor?: mapSolarSystemJumpsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` mapSolarSystemJumps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` mapSolarSystemJumps.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of mapSolarSystemJumps.
     */
    distinct?: MapSolarSystemJumpsScalarFieldEnum | MapSolarSystemJumpsScalarFieldEnum[]
  }


  /**
   * mapSolarSystemJumps findFirstOrThrow
   */
  export type mapSolarSystemJumpsFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the mapSolarSystemJumps
     */
    select?: mapSolarSystemJumpsSelect<ExtArgs> | null
    /**
     * Filter, which mapSolarSystemJumps to fetch.
     */
    where?: mapSolarSystemJumpsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of mapSolarSystemJumps to fetch.
     */
    orderBy?: mapSolarSystemJumpsOrderByWithRelationInput | mapSolarSystemJumpsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for mapSolarSystemJumps.
     */
    cursor?: mapSolarSystemJumpsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` mapSolarSystemJumps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` mapSolarSystemJumps.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of mapSolarSystemJumps.
     */
    distinct?: MapSolarSystemJumpsScalarFieldEnum | MapSolarSystemJumpsScalarFieldEnum[]
  }


  /**
   * mapSolarSystemJumps findMany
   */
  export type mapSolarSystemJumpsFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the mapSolarSystemJumps
     */
    select?: mapSolarSystemJumpsSelect<ExtArgs> | null
    /**
     * Filter, which mapSolarSystemJumps to fetch.
     */
    where?: mapSolarSystemJumpsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of mapSolarSystemJumps to fetch.
     */
    orderBy?: mapSolarSystemJumpsOrderByWithRelationInput | mapSolarSystemJumpsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing mapSolarSystemJumps.
     */
    cursor?: mapSolarSystemJumpsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` mapSolarSystemJumps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` mapSolarSystemJumps.
     */
    skip?: number
    distinct?: MapSolarSystemJumpsScalarFieldEnum | MapSolarSystemJumpsScalarFieldEnum[]
  }


  /**
   * mapSolarSystemJumps create
   */
  export type mapSolarSystemJumpsCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the mapSolarSystemJumps
     */
    select?: mapSolarSystemJumpsSelect<ExtArgs> | null
    /**
     * The data needed to create a mapSolarSystemJumps.
     */
    data: XOR<mapSolarSystemJumpsCreateInput, mapSolarSystemJumpsUncheckedCreateInput>
  }


  /**
   * mapSolarSystemJumps createMany
   */
  export type mapSolarSystemJumpsCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many mapSolarSystemJumps.
     */
    data: mapSolarSystemJumpsCreateManyInput | mapSolarSystemJumpsCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * mapSolarSystemJumps update
   */
  export type mapSolarSystemJumpsUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the mapSolarSystemJumps
     */
    select?: mapSolarSystemJumpsSelect<ExtArgs> | null
    /**
     * The data needed to update a mapSolarSystemJumps.
     */
    data: XOR<mapSolarSystemJumpsUpdateInput, mapSolarSystemJumpsUncheckedUpdateInput>
    /**
     * Choose, which mapSolarSystemJumps to update.
     */
    where: mapSolarSystemJumpsWhereUniqueInput
  }


  /**
   * mapSolarSystemJumps updateMany
   */
  export type mapSolarSystemJumpsUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update mapSolarSystemJumps.
     */
    data: XOR<mapSolarSystemJumpsUpdateManyMutationInput, mapSolarSystemJumpsUncheckedUpdateManyInput>
    /**
     * Filter which mapSolarSystemJumps to update
     */
    where?: mapSolarSystemJumpsWhereInput
  }


  /**
   * mapSolarSystemJumps upsert
   */
  export type mapSolarSystemJumpsUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the mapSolarSystemJumps
     */
    select?: mapSolarSystemJumpsSelect<ExtArgs> | null
    /**
     * The filter to search for the mapSolarSystemJumps to update in case it exists.
     */
    where: mapSolarSystemJumpsWhereUniqueInput
    /**
     * In case the mapSolarSystemJumps found by the `where` argument doesn't exist, create a new mapSolarSystemJumps with this data.
     */
    create: XOR<mapSolarSystemJumpsCreateInput, mapSolarSystemJumpsUncheckedCreateInput>
    /**
     * In case the mapSolarSystemJumps was found with the provided `where` argument, update it with this data.
     */
    update: XOR<mapSolarSystemJumpsUpdateInput, mapSolarSystemJumpsUncheckedUpdateInput>
  }


  /**
   * mapSolarSystemJumps delete
   */
  export type mapSolarSystemJumpsDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the mapSolarSystemJumps
     */
    select?: mapSolarSystemJumpsSelect<ExtArgs> | null
    /**
     * Filter which mapSolarSystemJumps to delete.
     */
    where: mapSolarSystemJumpsWhereUniqueInput
  }


  /**
   * mapSolarSystemJumps deleteMany
   */
  export type mapSolarSystemJumpsDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which mapSolarSystemJumps to delete
     */
    where?: mapSolarSystemJumpsWhereInput
  }


  /**
   * mapSolarSystemJumps without action
   */
  export type mapSolarSystemJumpsDefaultArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the mapSolarSystemJumps
     */
    select?: mapSolarSystemJumpsSelect<ExtArgs> | null
  }



  /**
   * Model mapSolarSystems
   */

  export type AggregateMapSolarSystems = {
    _count: MapSolarSystemsCountAggregateOutputType | null
    _avg: MapSolarSystemsAvgAggregateOutputType | null
    _sum: MapSolarSystemsSumAggregateOutputType | null
    _min: MapSolarSystemsMinAggregateOutputType | null
    _max: MapSolarSystemsMaxAggregateOutputType | null
  }

  export type MapSolarSystemsAvgAggregateOutputType = {
    regionID: number | null
    constellationID: number | null
    solarSystemID: number | null
    x: number | null
    y: number | null
    z: number | null
    xMin: number | null
    xMax: number | null
    yMin: number | null
    yMax: number | null
    zMin: number | null
    zMax: number | null
    luminosity: number | null
    security: number | null
    factionID: number | null
    radius: number | null
    sunTypeID: number | null
  }

  export type MapSolarSystemsSumAggregateOutputType = {
    regionID: number | null
    constellationID: number | null
    solarSystemID: number | null
    x: number | null
    y: number | null
    z: number | null
    xMin: number | null
    xMax: number | null
    yMin: number | null
    yMax: number | null
    zMin: number | null
    zMax: number | null
    luminosity: number | null
    security: number | null
    factionID: number | null
    radius: number | null
    sunTypeID: number | null
  }

  export type MapSolarSystemsMinAggregateOutputType = {
    regionID: number | null
    constellationID: number | null
    solarSystemID: number | null
    solarSystemName: string | null
    x: number | null
    y: number | null
    z: number | null
    xMin: number | null
    xMax: number | null
    yMin: number | null
    yMax: number | null
    zMin: number | null
    zMax: number | null
    luminosity: number | null
    border: boolean | null
    fringe: boolean | null
    corridor: boolean | null
    hub: boolean | null
    international: boolean | null
    regional: boolean | null
    constellation: boolean | null
    security: number | null
    factionID: number | null
    radius: number | null
    sunTypeID: number | null
    securityClass: string | null
  }

  export type MapSolarSystemsMaxAggregateOutputType = {
    regionID: number | null
    constellationID: number | null
    solarSystemID: number | null
    solarSystemName: string | null
    x: number | null
    y: number | null
    z: number | null
    xMin: number | null
    xMax: number | null
    yMin: number | null
    yMax: number | null
    zMin: number | null
    zMax: number | null
    luminosity: number | null
    border: boolean | null
    fringe: boolean | null
    corridor: boolean | null
    hub: boolean | null
    international: boolean | null
    regional: boolean | null
    constellation: boolean | null
    security: number | null
    factionID: number | null
    radius: number | null
    sunTypeID: number | null
    securityClass: string | null
  }

  export type MapSolarSystemsCountAggregateOutputType = {
    regionID: number
    constellationID: number
    solarSystemID: number
    solarSystemName: number
    x: number
    y: number
    z: number
    xMin: number
    xMax: number
    yMin: number
    yMax: number
    zMin: number
    zMax: number
    luminosity: number
    border: number
    fringe: number
    corridor: number
    hub: number
    international: number
    regional: number
    constellation: number
    security: number
    factionID: number
    radius: number
    sunTypeID: number
    securityClass: number
    _all: number
  }


  export type MapSolarSystemsAvgAggregateInputType = {
    regionID?: true
    constellationID?: true
    solarSystemID?: true
    x?: true
    y?: true
    z?: true
    xMin?: true
    xMax?: true
    yMin?: true
    yMax?: true
    zMin?: true
    zMax?: true
    luminosity?: true
    security?: true
    factionID?: true
    radius?: true
    sunTypeID?: true
  }

  export type MapSolarSystemsSumAggregateInputType = {
    regionID?: true
    constellationID?: true
    solarSystemID?: true
    x?: true
    y?: true
    z?: true
    xMin?: true
    xMax?: true
    yMin?: true
    yMax?: true
    zMin?: true
    zMax?: true
    luminosity?: true
    security?: true
    factionID?: true
    radius?: true
    sunTypeID?: true
  }

  export type MapSolarSystemsMinAggregateInputType = {
    regionID?: true
    constellationID?: true
    solarSystemID?: true
    solarSystemName?: true
    x?: true
    y?: true
    z?: true
    xMin?: true
    xMax?: true
    yMin?: true
    yMax?: true
    zMin?: true
    zMax?: true
    luminosity?: true
    border?: true
    fringe?: true
    corridor?: true
    hub?: true
    international?: true
    regional?: true
    constellation?: true
    security?: true
    factionID?: true
    radius?: true
    sunTypeID?: true
    securityClass?: true
  }

  export type MapSolarSystemsMaxAggregateInputType = {
    regionID?: true
    constellationID?: true
    solarSystemID?: true
    solarSystemName?: true
    x?: true
    y?: true
    z?: true
    xMin?: true
    xMax?: true
    yMin?: true
    yMax?: true
    zMin?: true
    zMax?: true
    luminosity?: true
    border?: true
    fringe?: true
    corridor?: true
    hub?: true
    international?: true
    regional?: true
    constellation?: true
    security?: true
    factionID?: true
    radius?: true
    sunTypeID?: true
    securityClass?: true
  }

  export type MapSolarSystemsCountAggregateInputType = {
    regionID?: true
    constellationID?: true
    solarSystemID?: true
    solarSystemName?: true
    x?: true
    y?: true
    z?: true
    xMin?: true
    xMax?: true
    yMin?: true
    yMax?: true
    zMin?: true
    zMax?: true
    luminosity?: true
    border?: true
    fringe?: true
    corridor?: true
    hub?: true
    international?: true
    regional?: true
    constellation?: true
    security?: true
    factionID?: true
    radius?: true
    sunTypeID?: true
    securityClass?: true
    _all?: true
  }

  export type MapSolarSystemsAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which mapSolarSystems to aggregate.
     */
    where?: mapSolarSystemsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of mapSolarSystems to fetch.
     */
    orderBy?: mapSolarSystemsOrderByWithRelationInput | mapSolarSystemsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: mapSolarSystemsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` mapSolarSystems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` mapSolarSystems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned mapSolarSystems
    **/
    _count?: true | MapSolarSystemsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MapSolarSystemsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MapSolarSystemsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MapSolarSystemsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MapSolarSystemsMaxAggregateInputType
  }

  export type GetMapSolarSystemsAggregateType<T extends MapSolarSystemsAggregateArgs> = {
        [P in keyof T & keyof AggregateMapSolarSystems]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMapSolarSystems[P]>
      : GetScalarType<T[P], AggregateMapSolarSystems[P]>
  }




  export type mapSolarSystemsGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: mapSolarSystemsWhereInput
    orderBy?: mapSolarSystemsOrderByWithAggregationInput | mapSolarSystemsOrderByWithAggregationInput[]
    by: MapSolarSystemsScalarFieldEnum[] | MapSolarSystemsScalarFieldEnum
    having?: mapSolarSystemsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MapSolarSystemsCountAggregateInputType | true
    _avg?: MapSolarSystemsAvgAggregateInputType
    _sum?: MapSolarSystemsSumAggregateInputType
    _min?: MapSolarSystemsMinAggregateInputType
    _max?: MapSolarSystemsMaxAggregateInputType
  }

  export type MapSolarSystemsGroupByOutputType = {
    regionID: number | null
    constellationID: number | null
    solarSystemID: number
    solarSystemName: string | null
    x: number | null
    y: number | null
    z: number | null
    xMin: number | null
    xMax: number | null
    yMin: number | null
    yMax: number | null
    zMin: number | null
    zMax: number | null
    luminosity: number | null
    border: boolean | null
    fringe: boolean | null
    corridor: boolean | null
    hub: boolean | null
    international: boolean | null
    regional: boolean | null
    constellation: boolean | null
    security: number | null
    factionID: number | null
    radius: number | null
    sunTypeID: number | null
    securityClass: string | null
    _count: MapSolarSystemsCountAggregateOutputType | null
    _avg: MapSolarSystemsAvgAggregateOutputType | null
    _sum: MapSolarSystemsSumAggregateOutputType | null
    _min: MapSolarSystemsMinAggregateOutputType | null
    _max: MapSolarSystemsMaxAggregateOutputType | null
  }

  type GetMapSolarSystemsGroupByPayload<T extends mapSolarSystemsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MapSolarSystemsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MapSolarSystemsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MapSolarSystemsGroupByOutputType[P]>
            : GetScalarType<T[P], MapSolarSystemsGroupByOutputType[P]>
        }
      >
    >


  export type mapSolarSystemsSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    regionID?: boolean
    constellationID?: boolean
    solarSystemID?: boolean
    solarSystemName?: boolean
    x?: boolean
    y?: boolean
    z?: boolean
    xMin?: boolean
    xMax?: boolean
    yMin?: boolean
    yMax?: boolean
    zMin?: boolean
    zMax?: boolean
    luminosity?: boolean
    border?: boolean
    fringe?: boolean
    corridor?: boolean
    hub?: boolean
    international?: boolean
    regional?: boolean
    constellation?: boolean
    security?: boolean
    factionID?: boolean
    radius?: boolean
    sunTypeID?: boolean
    securityClass?: boolean
  }, ExtArgs["result"]["mapSolarSystems"]>

  export type mapSolarSystemsSelectScalar = {
    regionID?: boolean
    constellationID?: boolean
    solarSystemID?: boolean
    solarSystemName?: boolean
    x?: boolean
    y?: boolean
    z?: boolean
    xMin?: boolean
    xMax?: boolean
    yMin?: boolean
    yMax?: boolean
    zMin?: boolean
    zMax?: boolean
    luminosity?: boolean
    border?: boolean
    fringe?: boolean
    corridor?: boolean
    hub?: boolean
    international?: boolean
    regional?: boolean
    constellation?: boolean
    security?: boolean
    factionID?: boolean
    radius?: boolean
    sunTypeID?: boolean
    securityClass?: boolean
  }


  export type $mapSolarSystemsPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    name: "mapSolarSystems"
    objects: {}
    scalars: $Extensions.GetResult<{
      regionID: number | null
      constellationID: number | null
      solarSystemID: number
      solarSystemName: string | null
      x: number | null
      y: number | null
      z: number | null
      xMin: number | null
      xMax: number | null
      yMin: number | null
      yMax: number | null
      zMin: number | null
      zMax: number | null
      luminosity: number | null
      border: boolean | null
      fringe: boolean | null
      corridor: boolean | null
      hub: boolean | null
      international: boolean | null
      regional: boolean | null
      constellation: boolean | null
      security: number | null
      factionID: number | null
      radius: number | null
      sunTypeID: number | null
      securityClass: string | null
    }, ExtArgs["result"]["mapSolarSystems"]>
    composites: {}
  }


  type mapSolarSystemsGetPayload<S extends boolean | null | undefined | mapSolarSystemsDefaultArgs> = $Result.GetResult<Prisma.$mapSolarSystemsPayload, S>

  type mapSolarSystemsCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<mapSolarSystemsFindManyArgs, 'select' | 'include'> & {
      select?: MapSolarSystemsCountAggregateInputType | true
    }

  export interface mapSolarSystemsDelegate<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['mapSolarSystems'], meta: { name: 'mapSolarSystems' } }
    /**
     * Find zero or one MapSolarSystems that matches the filter.
     * @param {mapSolarSystemsFindUniqueArgs} args - Arguments to find a MapSolarSystems
     * @example
     * // Get one MapSolarSystems
     * const mapSolarSystems = await prisma.mapSolarSystems.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends mapSolarSystemsFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, mapSolarSystemsFindUniqueArgs<ExtArgs>>
    ): Prisma__mapSolarSystemsClient<$Result.GetResult<Prisma.$mapSolarSystemsPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one MapSolarSystems that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {mapSolarSystemsFindUniqueOrThrowArgs} args - Arguments to find a MapSolarSystems
     * @example
     * // Get one MapSolarSystems
     * const mapSolarSystems = await prisma.mapSolarSystems.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends mapSolarSystemsFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, mapSolarSystemsFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__mapSolarSystemsClient<$Result.GetResult<Prisma.$mapSolarSystemsPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first MapSolarSystems that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {mapSolarSystemsFindFirstArgs} args - Arguments to find a MapSolarSystems
     * @example
     * // Get one MapSolarSystems
     * const mapSolarSystems = await prisma.mapSolarSystems.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends mapSolarSystemsFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, mapSolarSystemsFindFirstArgs<ExtArgs>>
    ): Prisma__mapSolarSystemsClient<$Result.GetResult<Prisma.$mapSolarSystemsPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first MapSolarSystems that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {mapSolarSystemsFindFirstOrThrowArgs} args - Arguments to find a MapSolarSystems
     * @example
     * // Get one MapSolarSystems
     * const mapSolarSystems = await prisma.mapSolarSystems.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends mapSolarSystemsFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, mapSolarSystemsFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__mapSolarSystemsClient<$Result.GetResult<Prisma.$mapSolarSystemsPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more MapSolarSystems that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {mapSolarSystemsFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MapSolarSystems
     * const mapSolarSystems = await prisma.mapSolarSystems.findMany()
     * 
     * // Get first 10 MapSolarSystems
     * const mapSolarSystems = await prisma.mapSolarSystems.findMany({ take: 10 })
     * 
     * // Only select the `regionID`
     * const mapSolarSystemsWithRegionIDOnly = await prisma.mapSolarSystems.findMany({ select: { regionID: true } })
     * 
    **/
    findMany<T extends mapSolarSystemsFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, mapSolarSystemsFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$mapSolarSystemsPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a MapSolarSystems.
     * @param {mapSolarSystemsCreateArgs} args - Arguments to create a MapSolarSystems.
     * @example
     * // Create one MapSolarSystems
     * const MapSolarSystems = await prisma.mapSolarSystems.create({
     *   data: {
     *     // ... data to create a MapSolarSystems
     *   }
     * })
     * 
    **/
    create<T extends mapSolarSystemsCreateArgs<ExtArgs>>(
      args: SelectSubset<T, mapSolarSystemsCreateArgs<ExtArgs>>
    ): Prisma__mapSolarSystemsClient<$Result.GetResult<Prisma.$mapSolarSystemsPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many MapSolarSystems.
     *     @param {mapSolarSystemsCreateManyArgs} args - Arguments to create many MapSolarSystems.
     *     @example
     *     // Create many MapSolarSystems
     *     const mapSolarSystems = await prisma.mapSolarSystems.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends mapSolarSystemsCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, mapSolarSystemsCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a MapSolarSystems.
     * @param {mapSolarSystemsDeleteArgs} args - Arguments to delete one MapSolarSystems.
     * @example
     * // Delete one MapSolarSystems
     * const MapSolarSystems = await prisma.mapSolarSystems.delete({
     *   where: {
     *     // ... filter to delete one MapSolarSystems
     *   }
     * })
     * 
    **/
    delete<T extends mapSolarSystemsDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, mapSolarSystemsDeleteArgs<ExtArgs>>
    ): Prisma__mapSolarSystemsClient<$Result.GetResult<Prisma.$mapSolarSystemsPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one MapSolarSystems.
     * @param {mapSolarSystemsUpdateArgs} args - Arguments to update one MapSolarSystems.
     * @example
     * // Update one MapSolarSystems
     * const mapSolarSystems = await prisma.mapSolarSystems.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends mapSolarSystemsUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, mapSolarSystemsUpdateArgs<ExtArgs>>
    ): Prisma__mapSolarSystemsClient<$Result.GetResult<Prisma.$mapSolarSystemsPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more MapSolarSystems.
     * @param {mapSolarSystemsDeleteManyArgs} args - Arguments to filter MapSolarSystems to delete.
     * @example
     * // Delete a few MapSolarSystems
     * const { count } = await prisma.mapSolarSystems.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends mapSolarSystemsDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, mapSolarSystemsDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MapSolarSystems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {mapSolarSystemsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MapSolarSystems
     * const mapSolarSystems = await prisma.mapSolarSystems.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends mapSolarSystemsUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, mapSolarSystemsUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one MapSolarSystems.
     * @param {mapSolarSystemsUpsertArgs} args - Arguments to update or create a MapSolarSystems.
     * @example
     * // Update or create a MapSolarSystems
     * const mapSolarSystems = await prisma.mapSolarSystems.upsert({
     *   create: {
     *     // ... data to create a MapSolarSystems
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MapSolarSystems we want to update
     *   }
     * })
    **/
    upsert<T extends mapSolarSystemsUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, mapSolarSystemsUpsertArgs<ExtArgs>>
    ): Prisma__mapSolarSystemsClient<$Result.GetResult<Prisma.$mapSolarSystemsPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of MapSolarSystems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {mapSolarSystemsCountArgs} args - Arguments to filter MapSolarSystems to count.
     * @example
     * // Count the number of MapSolarSystems
     * const count = await prisma.mapSolarSystems.count({
     *   where: {
     *     // ... the filter for the MapSolarSystems we want to count
     *   }
     * })
    **/
    count<T extends mapSolarSystemsCountArgs>(
      args?: Subset<T, mapSolarSystemsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MapSolarSystemsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MapSolarSystems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MapSolarSystemsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MapSolarSystemsAggregateArgs>(args: Subset<T, MapSolarSystemsAggregateArgs>): Prisma.PrismaPromise<GetMapSolarSystemsAggregateType<T>>

    /**
     * Group by MapSolarSystems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {mapSolarSystemsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends mapSolarSystemsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: mapSolarSystemsGroupByArgs['orderBy'] }
        : { orderBy?: mapSolarSystemsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, mapSolarSystemsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMapSolarSystemsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the mapSolarSystems model
   */
  readonly fields: mapSolarSystemsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for mapSolarSystems.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__mapSolarSystemsClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';


    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the mapSolarSystems model
   */ 
  interface mapSolarSystemsFieldRefs {
    readonly regionID: FieldRef<"mapSolarSystems", 'Int'>
    readonly constellationID: FieldRef<"mapSolarSystems", 'Int'>
    readonly solarSystemID: FieldRef<"mapSolarSystems", 'Int'>
    readonly solarSystemName: FieldRef<"mapSolarSystems", 'String'>
    readonly x: FieldRef<"mapSolarSystems", 'Float'>
    readonly y: FieldRef<"mapSolarSystems", 'Float'>
    readonly z: FieldRef<"mapSolarSystems", 'Float'>
    readonly xMin: FieldRef<"mapSolarSystems", 'Float'>
    readonly xMax: FieldRef<"mapSolarSystems", 'Float'>
    readonly yMin: FieldRef<"mapSolarSystems", 'Float'>
    readonly yMax: FieldRef<"mapSolarSystems", 'Float'>
    readonly zMin: FieldRef<"mapSolarSystems", 'Float'>
    readonly zMax: FieldRef<"mapSolarSystems", 'Float'>
    readonly luminosity: FieldRef<"mapSolarSystems", 'Float'>
    readonly border: FieldRef<"mapSolarSystems", 'Boolean'>
    readonly fringe: FieldRef<"mapSolarSystems", 'Boolean'>
    readonly corridor: FieldRef<"mapSolarSystems", 'Boolean'>
    readonly hub: FieldRef<"mapSolarSystems", 'Boolean'>
    readonly international: FieldRef<"mapSolarSystems", 'Boolean'>
    readonly regional: FieldRef<"mapSolarSystems", 'Boolean'>
    readonly constellation: FieldRef<"mapSolarSystems", 'Boolean'>
    readonly security: FieldRef<"mapSolarSystems", 'Float'>
    readonly factionID: FieldRef<"mapSolarSystems", 'Int'>
    readonly radius: FieldRef<"mapSolarSystems", 'Float'>
    readonly sunTypeID: FieldRef<"mapSolarSystems", 'Int'>
    readonly securityClass: FieldRef<"mapSolarSystems", 'String'>
  }
    

  // Custom InputTypes

  /**
   * mapSolarSystems findUnique
   */
  export type mapSolarSystemsFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the mapSolarSystems
     */
    select?: mapSolarSystemsSelect<ExtArgs> | null
    /**
     * Filter, which mapSolarSystems to fetch.
     */
    where: mapSolarSystemsWhereUniqueInput
  }


  /**
   * mapSolarSystems findUniqueOrThrow
   */
  export type mapSolarSystemsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the mapSolarSystems
     */
    select?: mapSolarSystemsSelect<ExtArgs> | null
    /**
     * Filter, which mapSolarSystems to fetch.
     */
    where: mapSolarSystemsWhereUniqueInput
  }


  /**
   * mapSolarSystems findFirst
   */
  export type mapSolarSystemsFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the mapSolarSystems
     */
    select?: mapSolarSystemsSelect<ExtArgs> | null
    /**
     * Filter, which mapSolarSystems to fetch.
     */
    where?: mapSolarSystemsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of mapSolarSystems to fetch.
     */
    orderBy?: mapSolarSystemsOrderByWithRelationInput | mapSolarSystemsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for mapSolarSystems.
     */
    cursor?: mapSolarSystemsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` mapSolarSystems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` mapSolarSystems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of mapSolarSystems.
     */
    distinct?: MapSolarSystemsScalarFieldEnum | MapSolarSystemsScalarFieldEnum[]
  }


  /**
   * mapSolarSystems findFirstOrThrow
   */
  export type mapSolarSystemsFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the mapSolarSystems
     */
    select?: mapSolarSystemsSelect<ExtArgs> | null
    /**
     * Filter, which mapSolarSystems to fetch.
     */
    where?: mapSolarSystemsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of mapSolarSystems to fetch.
     */
    orderBy?: mapSolarSystemsOrderByWithRelationInput | mapSolarSystemsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for mapSolarSystems.
     */
    cursor?: mapSolarSystemsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` mapSolarSystems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` mapSolarSystems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of mapSolarSystems.
     */
    distinct?: MapSolarSystemsScalarFieldEnum | MapSolarSystemsScalarFieldEnum[]
  }


  /**
   * mapSolarSystems findMany
   */
  export type mapSolarSystemsFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the mapSolarSystems
     */
    select?: mapSolarSystemsSelect<ExtArgs> | null
    /**
     * Filter, which mapSolarSystems to fetch.
     */
    where?: mapSolarSystemsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of mapSolarSystems to fetch.
     */
    orderBy?: mapSolarSystemsOrderByWithRelationInput | mapSolarSystemsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing mapSolarSystems.
     */
    cursor?: mapSolarSystemsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` mapSolarSystems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` mapSolarSystems.
     */
    skip?: number
    distinct?: MapSolarSystemsScalarFieldEnum | MapSolarSystemsScalarFieldEnum[]
  }


  /**
   * mapSolarSystems create
   */
  export type mapSolarSystemsCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the mapSolarSystems
     */
    select?: mapSolarSystemsSelect<ExtArgs> | null
    /**
     * The data needed to create a mapSolarSystems.
     */
    data: XOR<mapSolarSystemsCreateInput, mapSolarSystemsUncheckedCreateInput>
  }


  /**
   * mapSolarSystems createMany
   */
  export type mapSolarSystemsCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many mapSolarSystems.
     */
    data: mapSolarSystemsCreateManyInput | mapSolarSystemsCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * mapSolarSystems update
   */
  export type mapSolarSystemsUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the mapSolarSystems
     */
    select?: mapSolarSystemsSelect<ExtArgs> | null
    /**
     * The data needed to update a mapSolarSystems.
     */
    data: XOR<mapSolarSystemsUpdateInput, mapSolarSystemsUncheckedUpdateInput>
    /**
     * Choose, which mapSolarSystems to update.
     */
    where: mapSolarSystemsWhereUniqueInput
  }


  /**
   * mapSolarSystems updateMany
   */
  export type mapSolarSystemsUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update mapSolarSystems.
     */
    data: XOR<mapSolarSystemsUpdateManyMutationInput, mapSolarSystemsUncheckedUpdateManyInput>
    /**
     * Filter which mapSolarSystems to update
     */
    where?: mapSolarSystemsWhereInput
  }


  /**
   * mapSolarSystems upsert
   */
  export type mapSolarSystemsUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the mapSolarSystems
     */
    select?: mapSolarSystemsSelect<ExtArgs> | null
    /**
     * The filter to search for the mapSolarSystems to update in case it exists.
     */
    where: mapSolarSystemsWhereUniqueInput
    /**
     * In case the mapSolarSystems found by the `where` argument doesn't exist, create a new mapSolarSystems with this data.
     */
    create: XOR<mapSolarSystemsCreateInput, mapSolarSystemsUncheckedCreateInput>
    /**
     * In case the mapSolarSystems was found with the provided `where` argument, update it with this data.
     */
    update: XOR<mapSolarSystemsUpdateInput, mapSolarSystemsUncheckedUpdateInput>
  }


  /**
   * mapSolarSystems delete
   */
  export type mapSolarSystemsDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the mapSolarSystems
     */
    select?: mapSolarSystemsSelect<ExtArgs> | null
    /**
     * Filter which mapSolarSystems to delete.
     */
    where: mapSolarSystemsWhereUniqueInput
  }


  /**
   * mapSolarSystems deleteMany
   */
  export type mapSolarSystemsDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which mapSolarSystems to delete
     */
    where?: mapSolarSystemsWhereInput
  }


  /**
   * mapSolarSystems without action
   */
  export type mapSolarSystemsDefaultArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the mapSolarSystems
     */
    select?: mapSolarSystemsSelect<ExtArgs> | null
  }



  /**
   * Model mapUniverse
   */

  export type AggregateMapUniverse = {
    _count: MapUniverseCountAggregateOutputType | null
    _avg: MapUniverseAvgAggregateOutputType | null
    _sum: MapUniverseSumAggregateOutputType | null
    _min: MapUniverseMinAggregateOutputType | null
    _max: MapUniverseMaxAggregateOutputType | null
  }

  export type MapUniverseAvgAggregateOutputType = {
    universeID: number | null
    x: number | null
    y: number | null
    z: number | null
    xMin: number | null
    xMax: number | null
    yMin: number | null
    yMax: number | null
    zMin: number | null
    zMax: number | null
    radius: number | null
  }

  export type MapUniverseSumAggregateOutputType = {
    universeID: number | null
    x: number | null
    y: number | null
    z: number | null
    xMin: number | null
    xMax: number | null
    yMin: number | null
    yMax: number | null
    zMin: number | null
    zMax: number | null
    radius: number | null
  }

  export type MapUniverseMinAggregateOutputType = {
    universeID: number | null
    universeName: string | null
    x: number | null
    y: number | null
    z: number | null
    xMin: number | null
    xMax: number | null
    yMin: number | null
    yMax: number | null
    zMin: number | null
    zMax: number | null
    radius: number | null
  }

  export type MapUniverseMaxAggregateOutputType = {
    universeID: number | null
    universeName: string | null
    x: number | null
    y: number | null
    z: number | null
    xMin: number | null
    xMax: number | null
    yMin: number | null
    yMax: number | null
    zMin: number | null
    zMax: number | null
    radius: number | null
  }

  export type MapUniverseCountAggregateOutputType = {
    universeID: number
    universeName: number
    x: number
    y: number
    z: number
    xMin: number
    xMax: number
    yMin: number
    yMax: number
    zMin: number
    zMax: number
    radius: number
    _all: number
  }


  export type MapUniverseAvgAggregateInputType = {
    universeID?: true
    x?: true
    y?: true
    z?: true
    xMin?: true
    xMax?: true
    yMin?: true
    yMax?: true
    zMin?: true
    zMax?: true
    radius?: true
  }

  export type MapUniverseSumAggregateInputType = {
    universeID?: true
    x?: true
    y?: true
    z?: true
    xMin?: true
    xMax?: true
    yMin?: true
    yMax?: true
    zMin?: true
    zMax?: true
    radius?: true
  }

  export type MapUniverseMinAggregateInputType = {
    universeID?: true
    universeName?: true
    x?: true
    y?: true
    z?: true
    xMin?: true
    xMax?: true
    yMin?: true
    yMax?: true
    zMin?: true
    zMax?: true
    radius?: true
  }

  export type MapUniverseMaxAggregateInputType = {
    universeID?: true
    universeName?: true
    x?: true
    y?: true
    z?: true
    xMin?: true
    xMax?: true
    yMin?: true
    yMax?: true
    zMin?: true
    zMax?: true
    radius?: true
  }

  export type MapUniverseCountAggregateInputType = {
    universeID?: true
    universeName?: true
    x?: true
    y?: true
    z?: true
    xMin?: true
    xMax?: true
    yMin?: true
    yMax?: true
    zMin?: true
    zMax?: true
    radius?: true
    _all?: true
  }

  export type MapUniverseAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which mapUniverse to aggregate.
     */
    where?: mapUniverseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of mapUniverses to fetch.
     */
    orderBy?: mapUniverseOrderByWithRelationInput | mapUniverseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: mapUniverseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` mapUniverses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` mapUniverses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned mapUniverses
    **/
    _count?: true | MapUniverseCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MapUniverseAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MapUniverseSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MapUniverseMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MapUniverseMaxAggregateInputType
  }

  export type GetMapUniverseAggregateType<T extends MapUniverseAggregateArgs> = {
        [P in keyof T & keyof AggregateMapUniverse]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMapUniverse[P]>
      : GetScalarType<T[P], AggregateMapUniverse[P]>
  }




  export type mapUniverseGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: mapUniverseWhereInput
    orderBy?: mapUniverseOrderByWithAggregationInput | mapUniverseOrderByWithAggregationInput[]
    by: MapUniverseScalarFieldEnum[] | MapUniverseScalarFieldEnum
    having?: mapUniverseScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MapUniverseCountAggregateInputType | true
    _avg?: MapUniverseAvgAggregateInputType
    _sum?: MapUniverseSumAggregateInputType
    _min?: MapUniverseMinAggregateInputType
    _max?: MapUniverseMaxAggregateInputType
  }

  export type MapUniverseGroupByOutputType = {
    universeID: number
    universeName: string | null
    x: number | null
    y: number | null
    z: number | null
    xMin: number | null
    xMax: number | null
    yMin: number | null
    yMax: number | null
    zMin: number | null
    zMax: number | null
    radius: number | null
    _count: MapUniverseCountAggregateOutputType | null
    _avg: MapUniverseAvgAggregateOutputType | null
    _sum: MapUniverseSumAggregateOutputType | null
    _min: MapUniverseMinAggregateOutputType | null
    _max: MapUniverseMaxAggregateOutputType | null
  }

  type GetMapUniverseGroupByPayload<T extends mapUniverseGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MapUniverseGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MapUniverseGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MapUniverseGroupByOutputType[P]>
            : GetScalarType<T[P], MapUniverseGroupByOutputType[P]>
        }
      >
    >


  export type mapUniverseSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    universeID?: boolean
    universeName?: boolean
    x?: boolean
    y?: boolean
    z?: boolean
    xMin?: boolean
    xMax?: boolean
    yMin?: boolean
    yMax?: boolean
    zMin?: boolean
    zMax?: boolean
    radius?: boolean
  }, ExtArgs["result"]["mapUniverse"]>

  export type mapUniverseSelectScalar = {
    universeID?: boolean
    universeName?: boolean
    x?: boolean
    y?: boolean
    z?: boolean
    xMin?: boolean
    xMax?: boolean
    yMin?: boolean
    yMax?: boolean
    zMin?: boolean
    zMax?: boolean
    radius?: boolean
  }


  export type $mapUniversePayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    name: "mapUniverse"
    objects: {}
    scalars: $Extensions.GetResult<{
      universeID: number
      universeName: string | null
      x: number | null
      y: number | null
      z: number | null
      xMin: number | null
      xMax: number | null
      yMin: number | null
      yMax: number | null
      zMin: number | null
      zMax: number | null
      radius: number | null
    }, ExtArgs["result"]["mapUniverse"]>
    composites: {}
  }


  type mapUniverseGetPayload<S extends boolean | null | undefined | mapUniverseDefaultArgs> = $Result.GetResult<Prisma.$mapUniversePayload, S>

  type mapUniverseCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<mapUniverseFindManyArgs, 'select' | 'include'> & {
      select?: MapUniverseCountAggregateInputType | true
    }

  export interface mapUniverseDelegate<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['mapUniverse'], meta: { name: 'mapUniverse' } }
    /**
     * Find zero or one MapUniverse that matches the filter.
     * @param {mapUniverseFindUniqueArgs} args - Arguments to find a MapUniverse
     * @example
     * // Get one MapUniverse
     * const mapUniverse = await prisma.mapUniverse.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends mapUniverseFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, mapUniverseFindUniqueArgs<ExtArgs>>
    ): Prisma__mapUniverseClient<$Result.GetResult<Prisma.$mapUniversePayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one MapUniverse that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {mapUniverseFindUniqueOrThrowArgs} args - Arguments to find a MapUniverse
     * @example
     * // Get one MapUniverse
     * const mapUniverse = await prisma.mapUniverse.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends mapUniverseFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, mapUniverseFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__mapUniverseClient<$Result.GetResult<Prisma.$mapUniversePayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first MapUniverse that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {mapUniverseFindFirstArgs} args - Arguments to find a MapUniverse
     * @example
     * // Get one MapUniverse
     * const mapUniverse = await prisma.mapUniverse.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends mapUniverseFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, mapUniverseFindFirstArgs<ExtArgs>>
    ): Prisma__mapUniverseClient<$Result.GetResult<Prisma.$mapUniversePayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first MapUniverse that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {mapUniverseFindFirstOrThrowArgs} args - Arguments to find a MapUniverse
     * @example
     * // Get one MapUniverse
     * const mapUniverse = await prisma.mapUniverse.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends mapUniverseFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, mapUniverseFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__mapUniverseClient<$Result.GetResult<Prisma.$mapUniversePayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more MapUniverses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {mapUniverseFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MapUniverses
     * const mapUniverses = await prisma.mapUniverse.findMany()
     * 
     * // Get first 10 MapUniverses
     * const mapUniverses = await prisma.mapUniverse.findMany({ take: 10 })
     * 
     * // Only select the `universeID`
     * const mapUniverseWithUniverseIDOnly = await prisma.mapUniverse.findMany({ select: { universeID: true } })
     * 
    **/
    findMany<T extends mapUniverseFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, mapUniverseFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$mapUniversePayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a MapUniverse.
     * @param {mapUniverseCreateArgs} args - Arguments to create a MapUniverse.
     * @example
     * // Create one MapUniverse
     * const MapUniverse = await prisma.mapUniverse.create({
     *   data: {
     *     // ... data to create a MapUniverse
     *   }
     * })
     * 
    **/
    create<T extends mapUniverseCreateArgs<ExtArgs>>(
      args: SelectSubset<T, mapUniverseCreateArgs<ExtArgs>>
    ): Prisma__mapUniverseClient<$Result.GetResult<Prisma.$mapUniversePayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many MapUniverses.
     *     @param {mapUniverseCreateManyArgs} args - Arguments to create many MapUniverses.
     *     @example
     *     // Create many MapUniverses
     *     const mapUniverse = await prisma.mapUniverse.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends mapUniverseCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, mapUniverseCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a MapUniverse.
     * @param {mapUniverseDeleteArgs} args - Arguments to delete one MapUniverse.
     * @example
     * // Delete one MapUniverse
     * const MapUniverse = await prisma.mapUniverse.delete({
     *   where: {
     *     // ... filter to delete one MapUniverse
     *   }
     * })
     * 
    **/
    delete<T extends mapUniverseDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, mapUniverseDeleteArgs<ExtArgs>>
    ): Prisma__mapUniverseClient<$Result.GetResult<Prisma.$mapUniversePayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one MapUniverse.
     * @param {mapUniverseUpdateArgs} args - Arguments to update one MapUniverse.
     * @example
     * // Update one MapUniverse
     * const mapUniverse = await prisma.mapUniverse.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends mapUniverseUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, mapUniverseUpdateArgs<ExtArgs>>
    ): Prisma__mapUniverseClient<$Result.GetResult<Prisma.$mapUniversePayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more MapUniverses.
     * @param {mapUniverseDeleteManyArgs} args - Arguments to filter MapUniverses to delete.
     * @example
     * // Delete a few MapUniverses
     * const { count } = await prisma.mapUniverse.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends mapUniverseDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, mapUniverseDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MapUniverses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {mapUniverseUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MapUniverses
     * const mapUniverse = await prisma.mapUniverse.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends mapUniverseUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, mapUniverseUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one MapUniverse.
     * @param {mapUniverseUpsertArgs} args - Arguments to update or create a MapUniverse.
     * @example
     * // Update or create a MapUniverse
     * const mapUniverse = await prisma.mapUniverse.upsert({
     *   create: {
     *     // ... data to create a MapUniverse
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MapUniverse we want to update
     *   }
     * })
    **/
    upsert<T extends mapUniverseUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, mapUniverseUpsertArgs<ExtArgs>>
    ): Prisma__mapUniverseClient<$Result.GetResult<Prisma.$mapUniversePayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of MapUniverses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {mapUniverseCountArgs} args - Arguments to filter MapUniverses to count.
     * @example
     * // Count the number of MapUniverses
     * const count = await prisma.mapUniverse.count({
     *   where: {
     *     // ... the filter for the MapUniverses we want to count
     *   }
     * })
    **/
    count<T extends mapUniverseCountArgs>(
      args?: Subset<T, mapUniverseCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MapUniverseCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MapUniverse.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MapUniverseAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MapUniverseAggregateArgs>(args: Subset<T, MapUniverseAggregateArgs>): Prisma.PrismaPromise<GetMapUniverseAggregateType<T>>

    /**
     * Group by MapUniverse.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {mapUniverseGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends mapUniverseGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: mapUniverseGroupByArgs['orderBy'] }
        : { orderBy?: mapUniverseGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, mapUniverseGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMapUniverseGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the mapUniverse model
   */
  readonly fields: mapUniverseFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for mapUniverse.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__mapUniverseClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';


    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the mapUniverse model
   */ 
  interface mapUniverseFieldRefs {
    readonly universeID: FieldRef<"mapUniverse", 'Int'>
    readonly universeName: FieldRef<"mapUniverse", 'String'>
    readonly x: FieldRef<"mapUniverse", 'Float'>
    readonly y: FieldRef<"mapUniverse", 'Float'>
    readonly z: FieldRef<"mapUniverse", 'Float'>
    readonly xMin: FieldRef<"mapUniverse", 'Float'>
    readonly xMax: FieldRef<"mapUniverse", 'Float'>
    readonly yMin: FieldRef<"mapUniverse", 'Float'>
    readonly yMax: FieldRef<"mapUniverse", 'Float'>
    readonly zMin: FieldRef<"mapUniverse", 'Float'>
    readonly zMax: FieldRef<"mapUniverse", 'Float'>
    readonly radius: FieldRef<"mapUniverse", 'Float'>
  }
    

  // Custom InputTypes

  /**
   * mapUniverse findUnique
   */
  export type mapUniverseFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the mapUniverse
     */
    select?: mapUniverseSelect<ExtArgs> | null
    /**
     * Filter, which mapUniverse to fetch.
     */
    where: mapUniverseWhereUniqueInput
  }


  /**
   * mapUniverse findUniqueOrThrow
   */
  export type mapUniverseFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the mapUniverse
     */
    select?: mapUniverseSelect<ExtArgs> | null
    /**
     * Filter, which mapUniverse to fetch.
     */
    where: mapUniverseWhereUniqueInput
  }


  /**
   * mapUniverse findFirst
   */
  export type mapUniverseFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the mapUniverse
     */
    select?: mapUniverseSelect<ExtArgs> | null
    /**
     * Filter, which mapUniverse to fetch.
     */
    where?: mapUniverseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of mapUniverses to fetch.
     */
    orderBy?: mapUniverseOrderByWithRelationInput | mapUniverseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for mapUniverses.
     */
    cursor?: mapUniverseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` mapUniverses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` mapUniverses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of mapUniverses.
     */
    distinct?: MapUniverseScalarFieldEnum | MapUniverseScalarFieldEnum[]
  }


  /**
   * mapUniverse findFirstOrThrow
   */
  export type mapUniverseFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the mapUniverse
     */
    select?: mapUniverseSelect<ExtArgs> | null
    /**
     * Filter, which mapUniverse to fetch.
     */
    where?: mapUniverseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of mapUniverses to fetch.
     */
    orderBy?: mapUniverseOrderByWithRelationInput | mapUniverseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for mapUniverses.
     */
    cursor?: mapUniverseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` mapUniverses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` mapUniverses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of mapUniverses.
     */
    distinct?: MapUniverseScalarFieldEnum | MapUniverseScalarFieldEnum[]
  }


  /**
   * mapUniverse findMany
   */
  export type mapUniverseFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the mapUniverse
     */
    select?: mapUniverseSelect<ExtArgs> | null
    /**
     * Filter, which mapUniverses to fetch.
     */
    where?: mapUniverseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of mapUniverses to fetch.
     */
    orderBy?: mapUniverseOrderByWithRelationInput | mapUniverseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing mapUniverses.
     */
    cursor?: mapUniverseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` mapUniverses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` mapUniverses.
     */
    skip?: number
    distinct?: MapUniverseScalarFieldEnum | MapUniverseScalarFieldEnum[]
  }


  /**
   * mapUniverse create
   */
  export type mapUniverseCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the mapUniverse
     */
    select?: mapUniverseSelect<ExtArgs> | null
    /**
     * The data needed to create a mapUniverse.
     */
    data: XOR<mapUniverseCreateInput, mapUniverseUncheckedCreateInput>
  }


  /**
   * mapUniverse createMany
   */
  export type mapUniverseCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many mapUniverses.
     */
    data: mapUniverseCreateManyInput | mapUniverseCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * mapUniverse update
   */
  export type mapUniverseUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the mapUniverse
     */
    select?: mapUniverseSelect<ExtArgs> | null
    /**
     * The data needed to update a mapUniverse.
     */
    data: XOR<mapUniverseUpdateInput, mapUniverseUncheckedUpdateInput>
    /**
     * Choose, which mapUniverse to update.
     */
    where: mapUniverseWhereUniqueInput
  }


  /**
   * mapUniverse updateMany
   */
  export type mapUniverseUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update mapUniverses.
     */
    data: XOR<mapUniverseUpdateManyMutationInput, mapUniverseUncheckedUpdateManyInput>
    /**
     * Filter which mapUniverses to update
     */
    where?: mapUniverseWhereInput
  }


  /**
   * mapUniverse upsert
   */
  export type mapUniverseUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the mapUniverse
     */
    select?: mapUniverseSelect<ExtArgs> | null
    /**
     * The filter to search for the mapUniverse to update in case it exists.
     */
    where: mapUniverseWhereUniqueInput
    /**
     * In case the mapUniverse found by the `where` argument doesn't exist, create a new mapUniverse with this data.
     */
    create: XOR<mapUniverseCreateInput, mapUniverseUncheckedCreateInput>
    /**
     * In case the mapUniverse was found with the provided `where` argument, update it with this data.
     */
    update: XOR<mapUniverseUpdateInput, mapUniverseUncheckedUpdateInput>
  }


  /**
   * mapUniverse delete
   */
  export type mapUniverseDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the mapUniverse
     */
    select?: mapUniverseSelect<ExtArgs> | null
    /**
     * Filter which mapUniverse to delete.
     */
    where: mapUniverseWhereUniqueInput
  }


  /**
   * mapUniverse deleteMany
   */
  export type mapUniverseDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which mapUniverses to delete
     */
    where?: mapUniverseWhereInput
  }


  /**
   * mapUniverse without action
   */
  export type mapUniverseDefaultArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the mapUniverse
     */
    select?: mapUniverseSelect<ExtArgs> | null
  }



  /**
   * Model planetSchematics
   */

  export type AggregatePlanetSchematics = {
    _count: PlanetSchematicsCountAggregateOutputType | null
    _avg: PlanetSchematicsAvgAggregateOutputType | null
    _sum: PlanetSchematicsSumAggregateOutputType | null
    _min: PlanetSchematicsMinAggregateOutputType | null
    _max: PlanetSchematicsMaxAggregateOutputType | null
  }

  export type PlanetSchematicsAvgAggregateOutputType = {
    schematicID: number | null
    cycleTime: number | null
  }

  export type PlanetSchematicsSumAggregateOutputType = {
    schematicID: number | null
    cycleTime: number | null
  }

  export type PlanetSchematicsMinAggregateOutputType = {
    schematicID: number | null
    schematicName: string | null
    cycleTime: number | null
  }

  export type PlanetSchematicsMaxAggregateOutputType = {
    schematicID: number | null
    schematicName: string | null
    cycleTime: number | null
  }

  export type PlanetSchematicsCountAggregateOutputType = {
    schematicID: number
    schematicName: number
    cycleTime: number
    _all: number
  }


  export type PlanetSchematicsAvgAggregateInputType = {
    schematicID?: true
    cycleTime?: true
  }

  export type PlanetSchematicsSumAggregateInputType = {
    schematicID?: true
    cycleTime?: true
  }

  export type PlanetSchematicsMinAggregateInputType = {
    schematicID?: true
    schematicName?: true
    cycleTime?: true
  }

  export type PlanetSchematicsMaxAggregateInputType = {
    schematicID?: true
    schematicName?: true
    cycleTime?: true
  }

  export type PlanetSchematicsCountAggregateInputType = {
    schematicID?: true
    schematicName?: true
    cycleTime?: true
    _all?: true
  }

  export type PlanetSchematicsAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which planetSchematics to aggregate.
     */
    where?: planetSchematicsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of planetSchematics to fetch.
     */
    orderBy?: planetSchematicsOrderByWithRelationInput | planetSchematicsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: planetSchematicsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` planetSchematics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` planetSchematics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned planetSchematics
    **/
    _count?: true | PlanetSchematicsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PlanetSchematicsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PlanetSchematicsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PlanetSchematicsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PlanetSchematicsMaxAggregateInputType
  }

  export type GetPlanetSchematicsAggregateType<T extends PlanetSchematicsAggregateArgs> = {
        [P in keyof T & keyof AggregatePlanetSchematics]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePlanetSchematics[P]>
      : GetScalarType<T[P], AggregatePlanetSchematics[P]>
  }




  export type planetSchematicsGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: planetSchematicsWhereInput
    orderBy?: planetSchematicsOrderByWithAggregationInput | planetSchematicsOrderByWithAggregationInput[]
    by: PlanetSchematicsScalarFieldEnum[] | PlanetSchematicsScalarFieldEnum
    having?: planetSchematicsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PlanetSchematicsCountAggregateInputType | true
    _avg?: PlanetSchematicsAvgAggregateInputType
    _sum?: PlanetSchematicsSumAggregateInputType
    _min?: PlanetSchematicsMinAggregateInputType
    _max?: PlanetSchematicsMaxAggregateInputType
  }

  export type PlanetSchematicsGroupByOutputType = {
    schematicID: number
    schematicName: string | null
    cycleTime: number | null
    _count: PlanetSchematicsCountAggregateOutputType | null
    _avg: PlanetSchematicsAvgAggregateOutputType | null
    _sum: PlanetSchematicsSumAggregateOutputType | null
    _min: PlanetSchematicsMinAggregateOutputType | null
    _max: PlanetSchematicsMaxAggregateOutputType | null
  }

  type GetPlanetSchematicsGroupByPayload<T extends planetSchematicsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PlanetSchematicsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PlanetSchematicsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PlanetSchematicsGroupByOutputType[P]>
            : GetScalarType<T[P], PlanetSchematicsGroupByOutputType[P]>
        }
      >
    >


  export type planetSchematicsSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    schematicID?: boolean
    schematicName?: boolean
    cycleTime?: boolean
  }, ExtArgs["result"]["planetSchematics"]>

  export type planetSchematicsSelectScalar = {
    schematicID?: boolean
    schematicName?: boolean
    cycleTime?: boolean
  }


  export type $planetSchematicsPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    name: "planetSchematics"
    objects: {}
    scalars: $Extensions.GetResult<{
      schematicID: number
      schematicName: string | null
      cycleTime: number | null
    }, ExtArgs["result"]["planetSchematics"]>
    composites: {}
  }


  type planetSchematicsGetPayload<S extends boolean | null | undefined | planetSchematicsDefaultArgs> = $Result.GetResult<Prisma.$planetSchematicsPayload, S>

  type planetSchematicsCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<planetSchematicsFindManyArgs, 'select' | 'include'> & {
      select?: PlanetSchematicsCountAggregateInputType | true
    }

  export interface planetSchematicsDelegate<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['planetSchematics'], meta: { name: 'planetSchematics' } }
    /**
     * Find zero or one PlanetSchematics that matches the filter.
     * @param {planetSchematicsFindUniqueArgs} args - Arguments to find a PlanetSchematics
     * @example
     * // Get one PlanetSchematics
     * const planetSchematics = await prisma.planetSchematics.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends planetSchematicsFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, planetSchematicsFindUniqueArgs<ExtArgs>>
    ): Prisma__planetSchematicsClient<$Result.GetResult<Prisma.$planetSchematicsPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one PlanetSchematics that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {planetSchematicsFindUniqueOrThrowArgs} args - Arguments to find a PlanetSchematics
     * @example
     * // Get one PlanetSchematics
     * const planetSchematics = await prisma.planetSchematics.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends planetSchematicsFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, planetSchematicsFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__planetSchematicsClient<$Result.GetResult<Prisma.$planetSchematicsPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first PlanetSchematics that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {planetSchematicsFindFirstArgs} args - Arguments to find a PlanetSchematics
     * @example
     * // Get one PlanetSchematics
     * const planetSchematics = await prisma.planetSchematics.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends planetSchematicsFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, planetSchematicsFindFirstArgs<ExtArgs>>
    ): Prisma__planetSchematicsClient<$Result.GetResult<Prisma.$planetSchematicsPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first PlanetSchematics that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {planetSchematicsFindFirstOrThrowArgs} args - Arguments to find a PlanetSchematics
     * @example
     * // Get one PlanetSchematics
     * const planetSchematics = await prisma.planetSchematics.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends planetSchematicsFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, planetSchematicsFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__planetSchematicsClient<$Result.GetResult<Prisma.$planetSchematicsPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more PlanetSchematics that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {planetSchematicsFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PlanetSchematics
     * const planetSchematics = await prisma.planetSchematics.findMany()
     * 
     * // Get first 10 PlanetSchematics
     * const planetSchematics = await prisma.planetSchematics.findMany({ take: 10 })
     * 
     * // Only select the `schematicID`
     * const planetSchematicsWithSchematicIDOnly = await prisma.planetSchematics.findMany({ select: { schematicID: true } })
     * 
    **/
    findMany<T extends planetSchematicsFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, planetSchematicsFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$planetSchematicsPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a PlanetSchematics.
     * @param {planetSchematicsCreateArgs} args - Arguments to create a PlanetSchematics.
     * @example
     * // Create one PlanetSchematics
     * const PlanetSchematics = await prisma.planetSchematics.create({
     *   data: {
     *     // ... data to create a PlanetSchematics
     *   }
     * })
     * 
    **/
    create<T extends planetSchematicsCreateArgs<ExtArgs>>(
      args: SelectSubset<T, planetSchematicsCreateArgs<ExtArgs>>
    ): Prisma__planetSchematicsClient<$Result.GetResult<Prisma.$planetSchematicsPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many PlanetSchematics.
     *     @param {planetSchematicsCreateManyArgs} args - Arguments to create many PlanetSchematics.
     *     @example
     *     // Create many PlanetSchematics
     *     const planetSchematics = await prisma.planetSchematics.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends planetSchematicsCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, planetSchematicsCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a PlanetSchematics.
     * @param {planetSchematicsDeleteArgs} args - Arguments to delete one PlanetSchematics.
     * @example
     * // Delete one PlanetSchematics
     * const PlanetSchematics = await prisma.planetSchematics.delete({
     *   where: {
     *     // ... filter to delete one PlanetSchematics
     *   }
     * })
     * 
    **/
    delete<T extends planetSchematicsDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, planetSchematicsDeleteArgs<ExtArgs>>
    ): Prisma__planetSchematicsClient<$Result.GetResult<Prisma.$planetSchematicsPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one PlanetSchematics.
     * @param {planetSchematicsUpdateArgs} args - Arguments to update one PlanetSchematics.
     * @example
     * // Update one PlanetSchematics
     * const planetSchematics = await prisma.planetSchematics.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends planetSchematicsUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, planetSchematicsUpdateArgs<ExtArgs>>
    ): Prisma__planetSchematicsClient<$Result.GetResult<Prisma.$planetSchematicsPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more PlanetSchematics.
     * @param {planetSchematicsDeleteManyArgs} args - Arguments to filter PlanetSchematics to delete.
     * @example
     * // Delete a few PlanetSchematics
     * const { count } = await prisma.planetSchematics.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends planetSchematicsDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, planetSchematicsDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PlanetSchematics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {planetSchematicsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PlanetSchematics
     * const planetSchematics = await prisma.planetSchematics.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends planetSchematicsUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, planetSchematicsUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one PlanetSchematics.
     * @param {planetSchematicsUpsertArgs} args - Arguments to update or create a PlanetSchematics.
     * @example
     * // Update or create a PlanetSchematics
     * const planetSchematics = await prisma.planetSchematics.upsert({
     *   create: {
     *     // ... data to create a PlanetSchematics
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PlanetSchematics we want to update
     *   }
     * })
    **/
    upsert<T extends planetSchematicsUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, planetSchematicsUpsertArgs<ExtArgs>>
    ): Prisma__planetSchematicsClient<$Result.GetResult<Prisma.$planetSchematicsPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of PlanetSchematics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {planetSchematicsCountArgs} args - Arguments to filter PlanetSchematics to count.
     * @example
     * // Count the number of PlanetSchematics
     * const count = await prisma.planetSchematics.count({
     *   where: {
     *     // ... the filter for the PlanetSchematics we want to count
     *   }
     * })
    **/
    count<T extends planetSchematicsCountArgs>(
      args?: Subset<T, planetSchematicsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PlanetSchematicsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PlanetSchematics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlanetSchematicsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PlanetSchematicsAggregateArgs>(args: Subset<T, PlanetSchematicsAggregateArgs>): Prisma.PrismaPromise<GetPlanetSchematicsAggregateType<T>>

    /**
     * Group by PlanetSchematics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {planetSchematicsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends planetSchematicsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: planetSchematicsGroupByArgs['orderBy'] }
        : { orderBy?: planetSchematicsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, planetSchematicsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPlanetSchematicsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the planetSchematics model
   */
  readonly fields: planetSchematicsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for planetSchematics.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__planetSchematicsClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';


    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the planetSchematics model
   */ 
  interface planetSchematicsFieldRefs {
    readonly schematicID: FieldRef<"planetSchematics", 'Int'>
    readonly schematicName: FieldRef<"planetSchematics", 'String'>
    readonly cycleTime: FieldRef<"planetSchematics", 'Int'>
  }
    

  // Custom InputTypes

  /**
   * planetSchematics findUnique
   */
  export type planetSchematicsFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the planetSchematics
     */
    select?: planetSchematicsSelect<ExtArgs> | null
    /**
     * Filter, which planetSchematics to fetch.
     */
    where: planetSchematicsWhereUniqueInput
  }


  /**
   * planetSchematics findUniqueOrThrow
   */
  export type planetSchematicsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the planetSchematics
     */
    select?: planetSchematicsSelect<ExtArgs> | null
    /**
     * Filter, which planetSchematics to fetch.
     */
    where: planetSchematicsWhereUniqueInput
  }


  /**
   * planetSchematics findFirst
   */
  export type planetSchematicsFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the planetSchematics
     */
    select?: planetSchematicsSelect<ExtArgs> | null
    /**
     * Filter, which planetSchematics to fetch.
     */
    where?: planetSchematicsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of planetSchematics to fetch.
     */
    orderBy?: planetSchematicsOrderByWithRelationInput | planetSchematicsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for planetSchematics.
     */
    cursor?: planetSchematicsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` planetSchematics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` planetSchematics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of planetSchematics.
     */
    distinct?: PlanetSchematicsScalarFieldEnum | PlanetSchematicsScalarFieldEnum[]
  }


  /**
   * planetSchematics findFirstOrThrow
   */
  export type planetSchematicsFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the planetSchematics
     */
    select?: planetSchematicsSelect<ExtArgs> | null
    /**
     * Filter, which planetSchematics to fetch.
     */
    where?: planetSchematicsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of planetSchematics to fetch.
     */
    orderBy?: planetSchematicsOrderByWithRelationInput | planetSchematicsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for planetSchematics.
     */
    cursor?: planetSchematicsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` planetSchematics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` planetSchematics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of planetSchematics.
     */
    distinct?: PlanetSchematicsScalarFieldEnum | PlanetSchematicsScalarFieldEnum[]
  }


  /**
   * planetSchematics findMany
   */
  export type planetSchematicsFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the planetSchematics
     */
    select?: planetSchematicsSelect<ExtArgs> | null
    /**
     * Filter, which planetSchematics to fetch.
     */
    where?: planetSchematicsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of planetSchematics to fetch.
     */
    orderBy?: planetSchematicsOrderByWithRelationInput | planetSchematicsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing planetSchematics.
     */
    cursor?: planetSchematicsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` planetSchematics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` planetSchematics.
     */
    skip?: number
    distinct?: PlanetSchematicsScalarFieldEnum | PlanetSchematicsScalarFieldEnum[]
  }


  /**
   * planetSchematics create
   */
  export type planetSchematicsCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the planetSchematics
     */
    select?: planetSchematicsSelect<ExtArgs> | null
    /**
     * The data needed to create a planetSchematics.
     */
    data: XOR<planetSchematicsCreateInput, planetSchematicsUncheckedCreateInput>
  }


  /**
   * planetSchematics createMany
   */
  export type planetSchematicsCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many planetSchematics.
     */
    data: planetSchematicsCreateManyInput | planetSchematicsCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * planetSchematics update
   */
  export type planetSchematicsUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the planetSchematics
     */
    select?: planetSchematicsSelect<ExtArgs> | null
    /**
     * The data needed to update a planetSchematics.
     */
    data: XOR<planetSchematicsUpdateInput, planetSchematicsUncheckedUpdateInput>
    /**
     * Choose, which planetSchematics to update.
     */
    where: planetSchematicsWhereUniqueInput
  }


  /**
   * planetSchematics updateMany
   */
  export type planetSchematicsUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update planetSchematics.
     */
    data: XOR<planetSchematicsUpdateManyMutationInput, planetSchematicsUncheckedUpdateManyInput>
    /**
     * Filter which planetSchematics to update
     */
    where?: planetSchematicsWhereInput
  }


  /**
   * planetSchematics upsert
   */
  export type planetSchematicsUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the planetSchematics
     */
    select?: planetSchematicsSelect<ExtArgs> | null
    /**
     * The filter to search for the planetSchematics to update in case it exists.
     */
    where: planetSchematicsWhereUniqueInput
    /**
     * In case the planetSchematics found by the `where` argument doesn't exist, create a new planetSchematics with this data.
     */
    create: XOR<planetSchematicsCreateInput, planetSchematicsUncheckedCreateInput>
    /**
     * In case the planetSchematics was found with the provided `where` argument, update it with this data.
     */
    update: XOR<planetSchematicsUpdateInput, planetSchematicsUncheckedUpdateInput>
  }


  /**
   * planetSchematics delete
   */
  export type planetSchematicsDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the planetSchematics
     */
    select?: planetSchematicsSelect<ExtArgs> | null
    /**
     * Filter which planetSchematics to delete.
     */
    where: planetSchematicsWhereUniqueInput
  }


  /**
   * planetSchematics deleteMany
   */
  export type planetSchematicsDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which planetSchematics to delete
     */
    where?: planetSchematicsWhereInput
  }


  /**
   * planetSchematics without action
   */
  export type planetSchematicsDefaultArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the planetSchematics
     */
    select?: planetSchematicsSelect<ExtArgs> | null
  }



  /**
   * Model planetSchematicsPinMap
   */

  export type AggregatePlanetSchematicsPinMap = {
    _count: PlanetSchematicsPinMapCountAggregateOutputType | null
    _avg: PlanetSchematicsPinMapAvgAggregateOutputType | null
    _sum: PlanetSchematicsPinMapSumAggregateOutputType | null
    _min: PlanetSchematicsPinMapMinAggregateOutputType | null
    _max: PlanetSchematicsPinMapMaxAggregateOutputType | null
  }

  export type PlanetSchematicsPinMapAvgAggregateOutputType = {
    schematicID: number | null
    pinTypeID: number | null
  }

  export type PlanetSchematicsPinMapSumAggregateOutputType = {
    schematicID: number | null
    pinTypeID: number | null
  }

  export type PlanetSchematicsPinMapMinAggregateOutputType = {
    schematicID: number | null
    pinTypeID: number | null
  }

  export type PlanetSchematicsPinMapMaxAggregateOutputType = {
    schematicID: number | null
    pinTypeID: number | null
  }

  export type PlanetSchematicsPinMapCountAggregateOutputType = {
    schematicID: number
    pinTypeID: number
    _all: number
  }


  export type PlanetSchematicsPinMapAvgAggregateInputType = {
    schematicID?: true
    pinTypeID?: true
  }

  export type PlanetSchematicsPinMapSumAggregateInputType = {
    schematicID?: true
    pinTypeID?: true
  }

  export type PlanetSchematicsPinMapMinAggregateInputType = {
    schematicID?: true
    pinTypeID?: true
  }

  export type PlanetSchematicsPinMapMaxAggregateInputType = {
    schematicID?: true
    pinTypeID?: true
  }

  export type PlanetSchematicsPinMapCountAggregateInputType = {
    schematicID?: true
    pinTypeID?: true
    _all?: true
  }

  export type PlanetSchematicsPinMapAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which planetSchematicsPinMap to aggregate.
     */
    where?: planetSchematicsPinMapWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of planetSchematicsPinMaps to fetch.
     */
    orderBy?: planetSchematicsPinMapOrderByWithRelationInput | planetSchematicsPinMapOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: planetSchematicsPinMapWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` planetSchematicsPinMaps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` planetSchematicsPinMaps.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned planetSchematicsPinMaps
    **/
    _count?: true | PlanetSchematicsPinMapCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PlanetSchematicsPinMapAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PlanetSchematicsPinMapSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PlanetSchematicsPinMapMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PlanetSchematicsPinMapMaxAggregateInputType
  }

  export type GetPlanetSchematicsPinMapAggregateType<T extends PlanetSchematicsPinMapAggregateArgs> = {
        [P in keyof T & keyof AggregatePlanetSchematicsPinMap]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePlanetSchematicsPinMap[P]>
      : GetScalarType<T[P], AggregatePlanetSchematicsPinMap[P]>
  }




  export type planetSchematicsPinMapGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: planetSchematicsPinMapWhereInput
    orderBy?: planetSchematicsPinMapOrderByWithAggregationInput | planetSchematicsPinMapOrderByWithAggregationInput[]
    by: PlanetSchematicsPinMapScalarFieldEnum[] | PlanetSchematicsPinMapScalarFieldEnum
    having?: planetSchematicsPinMapScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PlanetSchematicsPinMapCountAggregateInputType | true
    _avg?: PlanetSchematicsPinMapAvgAggregateInputType
    _sum?: PlanetSchematicsPinMapSumAggregateInputType
    _min?: PlanetSchematicsPinMapMinAggregateInputType
    _max?: PlanetSchematicsPinMapMaxAggregateInputType
  }

  export type PlanetSchematicsPinMapGroupByOutputType = {
    schematicID: number
    pinTypeID: number
    _count: PlanetSchematicsPinMapCountAggregateOutputType | null
    _avg: PlanetSchematicsPinMapAvgAggregateOutputType | null
    _sum: PlanetSchematicsPinMapSumAggregateOutputType | null
    _min: PlanetSchematicsPinMapMinAggregateOutputType | null
    _max: PlanetSchematicsPinMapMaxAggregateOutputType | null
  }

  type GetPlanetSchematicsPinMapGroupByPayload<T extends planetSchematicsPinMapGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PlanetSchematicsPinMapGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PlanetSchematicsPinMapGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PlanetSchematicsPinMapGroupByOutputType[P]>
            : GetScalarType<T[P], PlanetSchematicsPinMapGroupByOutputType[P]>
        }
      >
    >


  export type planetSchematicsPinMapSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    schematicID?: boolean
    pinTypeID?: boolean
  }, ExtArgs["result"]["planetSchematicsPinMap"]>

  export type planetSchematicsPinMapSelectScalar = {
    schematicID?: boolean
    pinTypeID?: boolean
  }


  export type $planetSchematicsPinMapPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    name: "planetSchematicsPinMap"
    objects: {}
    scalars: $Extensions.GetResult<{
      schematicID: number
      pinTypeID: number
    }, ExtArgs["result"]["planetSchematicsPinMap"]>
    composites: {}
  }


  type planetSchematicsPinMapGetPayload<S extends boolean | null | undefined | planetSchematicsPinMapDefaultArgs> = $Result.GetResult<Prisma.$planetSchematicsPinMapPayload, S>

  type planetSchematicsPinMapCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<planetSchematicsPinMapFindManyArgs, 'select' | 'include'> & {
      select?: PlanetSchematicsPinMapCountAggregateInputType | true
    }

  export interface planetSchematicsPinMapDelegate<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['planetSchematicsPinMap'], meta: { name: 'planetSchematicsPinMap' } }
    /**
     * Find zero or one PlanetSchematicsPinMap that matches the filter.
     * @param {planetSchematicsPinMapFindUniqueArgs} args - Arguments to find a PlanetSchematicsPinMap
     * @example
     * // Get one PlanetSchematicsPinMap
     * const planetSchematicsPinMap = await prisma.planetSchematicsPinMap.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends planetSchematicsPinMapFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, planetSchematicsPinMapFindUniqueArgs<ExtArgs>>
    ): Prisma__planetSchematicsPinMapClient<$Result.GetResult<Prisma.$planetSchematicsPinMapPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one PlanetSchematicsPinMap that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {planetSchematicsPinMapFindUniqueOrThrowArgs} args - Arguments to find a PlanetSchematicsPinMap
     * @example
     * // Get one PlanetSchematicsPinMap
     * const planetSchematicsPinMap = await prisma.planetSchematicsPinMap.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends planetSchematicsPinMapFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, planetSchematicsPinMapFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__planetSchematicsPinMapClient<$Result.GetResult<Prisma.$planetSchematicsPinMapPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first PlanetSchematicsPinMap that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {planetSchematicsPinMapFindFirstArgs} args - Arguments to find a PlanetSchematicsPinMap
     * @example
     * // Get one PlanetSchematicsPinMap
     * const planetSchematicsPinMap = await prisma.planetSchematicsPinMap.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends planetSchematicsPinMapFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, planetSchematicsPinMapFindFirstArgs<ExtArgs>>
    ): Prisma__planetSchematicsPinMapClient<$Result.GetResult<Prisma.$planetSchematicsPinMapPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first PlanetSchematicsPinMap that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {planetSchematicsPinMapFindFirstOrThrowArgs} args - Arguments to find a PlanetSchematicsPinMap
     * @example
     * // Get one PlanetSchematicsPinMap
     * const planetSchematicsPinMap = await prisma.planetSchematicsPinMap.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends planetSchematicsPinMapFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, planetSchematicsPinMapFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__planetSchematicsPinMapClient<$Result.GetResult<Prisma.$planetSchematicsPinMapPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more PlanetSchematicsPinMaps that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {planetSchematicsPinMapFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PlanetSchematicsPinMaps
     * const planetSchematicsPinMaps = await prisma.planetSchematicsPinMap.findMany()
     * 
     * // Get first 10 PlanetSchematicsPinMaps
     * const planetSchematicsPinMaps = await prisma.planetSchematicsPinMap.findMany({ take: 10 })
     * 
     * // Only select the `schematicID`
     * const planetSchematicsPinMapWithSchematicIDOnly = await prisma.planetSchematicsPinMap.findMany({ select: { schematicID: true } })
     * 
    **/
    findMany<T extends planetSchematicsPinMapFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, planetSchematicsPinMapFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$planetSchematicsPinMapPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a PlanetSchematicsPinMap.
     * @param {planetSchematicsPinMapCreateArgs} args - Arguments to create a PlanetSchematicsPinMap.
     * @example
     * // Create one PlanetSchematicsPinMap
     * const PlanetSchematicsPinMap = await prisma.planetSchematicsPinMap.create({
     *   data: {
     *     // ... data to create a PlanetSchematicsPinMap
     *   }
     * })
     * 
    **/
    create<T extends planetSchematicsPinMapCreateArgs<ExtArgs>>(
      args: SelectSubset<T, planetSchematicsPinMapCreateArgs<ExtArgs>>
    ): Prisma__planetSchematicsPinMapClient<$Result.GetResult<Prisma.$planetSchematicsPinMapPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many PlanetSchematicsPinMaps.
     *     @param {planetSchematicsPinMapCreateManyArgs} args - Arguments to create many PlanetSchematicsPinMaps.
     *     @example
     *     // Create many PlanetSchematicsPinMaps
     *     const planetSchematicsPinMap = await prisma.planetSchematicsPinMap.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends planetSchematicsPinMapCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, planetSchematicsPinMapCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a PlanetSchematicsPinMap.
     * @param {planetSchematicsPinMapDeleteArgs} args - Arguments to delete one PlanetSchematicsPinMap.
     * @example
     * // Delete one PlanetSchematicsPinMap
     * const PlanetSchematicsPinMap = await prisma.planetSchematicsPinMap.delete({
     *   where: {
     *     // ... filter to delete one PlanetSchematicsPinMap
     *   }
     * })
     * 
    **/
    delete<T extends planetSchematicsPinMapDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, planetSchematicsPinMapDeleteArgs<ExtArgs>>
    ): Prisma__planetSchematicsPinMapClient<$Result.GetResult<Prisma.$planetSchematicsPinMapPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one PlanetSchematicsPinMap.
     * @param {planetSchematicsPinMapUpdateArgs} args - Arguments to update one PlanetSchematicsPinMap.
     * @example
     * // Update one PlanetSchematicsPinMap
     * const planetSchematicsPinMap = await prisma.planetSchematicsPinMap.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends planetSchematicsPinMapUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, planetSchematicsPinMapUpdateArgs<ExtArgs>>
    ): Prisma__planetSchematicsPinMapClient<$Result.GetResult<Prisma.$planetSchematicsPinMapPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more PlanetSchematicsPinMaps.
     * @param {planetSchematicsPinMapDeleteManyArgs} args - Arguments to filter PlanetSchematicsPinMaps to delete.
     * @example
     * // Delete a few PlanetSchematicsPinMaps
     * const { count } = await prisma.planetSchematicsPinMap.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends planetSchematicsPinMapDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, planetSchematicsPinMapDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PlanetSchematicsPinMaps.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {planetSchematicsPinMapUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PlanetSchematicsPinMaps
     * const planetSchematicsPinMap = await prisma.planetSchematicsPinMap.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends planetSchematicsPinMapUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, planetSchematicsPinMapUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one PlanetSchematicsPinMap.
     * @param {planetSchematicsPinMapUpsertArgs} args - Arguments to update or create a PlanetSchematicsPinMap.
     * @example
     * // Update or create a PlanetSchematicsPinMap
     * const planetSchematicsPinMap = await prisma.planetSchematicsPinMap.upsert({
     *   create: {
     *     // ... data to create a PlanetSchematicsPinMap
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PlanetSchematicsPinMap we want to update
     *   }
     * })
    **/
    upsert<T extends planetSchematicsPinMapUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, planetSchematicsPinMapUpsertArgs<ExtArgs>>
    ): Prisma__planetSchematicsPinMapClient<$Result.GetResult<Prisma.$planetSchematicsPinMapPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of PlanetSchematicsPinMaps.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {planetSchematicsPinMapCountArgs} args - Arguments to filter PlanetSchematicsPinMaps to count.
     * @example
     * // Count the number of PlanetSchematicsPinMaps
     * const count = await prisma.planetSchematicsPinMap.count({
     *   where: {
     *     // ... the filter for the PlanetSchematicsPinMaps we want to count
     *   }
     * })
    **/
    count<T extends planetSchematicsPinMapCountArgs>(
      args?: Subset<T, planetSchematicsPinMapCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PlanetSchematicsPinMapCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PlanetSchematicsPinMap.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlanetSchematicsPinMapAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PlanetSchematicsPinMapAggregateArgs>(args: Subset<T, PlanetSchematicsPinMapAggregateArgs>): Prisma.PrismaPromise<GetPlanetSchematicsPinMapAggregateType<T>>

    /**
     * Group by PlanetSchematicsPinMap.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {planetSchematicsPinMapGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends planetSchematicsPinMapGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: planetSchematicsPinMapGroupByArgs['orderBy'] }
        : { orderBy?: planetSchematicsPinMapGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, planetSchematicsPinMapGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPlanetSchematicsPinMapGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the planetSchematicsPinMap model
   */
  readonly fields: planetSchematicsPinMapFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for planetSchematicsPinMap.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__planetSchematicsPinMapClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';


    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the planetSchematicsPinMap model
   */ 
  interface planetSchematicsPinMapFieldRefs {
    readonly schematicID: FieldRef<"planetSchematicsPinMap", 'Int'>
    readonly pinTypeID: FieldRef<"planetSchematicsPinMap", 'Int'>
  }
    

  // Custom InputTypes

  /**
   * planetSchematicsPinMap findUnique
   */
  export type planetSchematicsPinMapFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the planetSchematicsPinMap
     */
    select?: planetSchematicsPinMapSelect<ExtArgs> | null
    /**
     * Filter, which planetSchematicsPinMap to fetch.
     */
    where: planetSchematicsPinMapWhereUniqueInput
  }


  /**
   * planetSchematicsPinMap findUniqueOrThrow
   */
  export type planetSchematicsPinMapFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the planetSchematicsPinMap
     */
    select?: planetSchematicsPinMapSelect<ExtArgs> | null
    /**
     * Filter, which planetSchematicsPinMap to fetch.
     */
    where: planetSchematicsPinMapWhereUniqueInput
  }


  /**
   * planetSchematicsPinMap findFirst
   */
  export type planetSchematicsPinMapFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the planetSchematicsPinMap
     */
    select?: planetSchematicsPinMapSelect<ExtArgs> | null
    /**
     * Filter, which planetSchematicsPinMap to fetch.
     */
    where?: planetSchematicsPinMapWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of planetSchematicsPinMaps to fetch.
     */
    orderBy?: planetSchematicsPinMapOrderByWithRelationInput | planetSchematicsPinMapOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for planetSchematicsPinMaps.
     */
    cursor?: planetSchematicsPinMapWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` planetSchematicsPinMaps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` planetSchematicsPinMaps.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of planetSchematicsPinMaps.
     */
    distinct?: PlanetSchematicsPinMapScalarFieldEnum | PlanetSchematicsPinMapScalarFieldEnum[]
  }


  /**
   * planetSchematicsPinMap findFirstOrThrow
   */
  export type planetSchematicsPinMapFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the planetSchematicsPinMap
     */
    select?: planetSchematicsPinMapSelect<ExtArgs> | null
    /**
     * Filter, which planetSchematicsPinMap to fetch.
     */
    where?: planetSchematicsPinMapWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of planetSchematicsPinMaps to fetch.
     */
    orderBy?: planetSchematicsPinMapOrderByWithRelationInput | planetSchematicsPinMapOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for planetSchematicsPinMaps.
     */
    cursor?: planetSchematicsPinMapWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` planetSchematicsPinMaps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` planetSchematicsPinMaps.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of planetSchematicsPinMaps.
     */
    distinct?: PlanetSchematicsPinMapScalarFieldEnum | PlanetSchematicsPinMapScalarFieldEnum[]
  }


  /**
   * planetSchematicsPinMap findMany
   */
  export type planetSchematicsPinMapFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the planetSchematicsPinMap
     */
    select?: planetSchematicsPinMapSelect<ExtArgs> | null
    /**
     * Filter, which planetSchematicsPinMaps to fetch.
     */
    where?: planetSchematicsPinMapWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of planetSchematicsPinMaps to fetch.
     */
    orderBy?: planetSchematicsPinMapOrderByWithRelationInput | planetSchematicsPinMapOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing planetSchematicsPinMaps.
     */
    cursor?: planetSchematicsPinMapWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` planetSchematicsPinMaps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` planetSchematicsPinMaps.
     */
    skip?: number
    distinct?: PlanetSchematicsPinMapScalarFieldEnum | PlanetSchematicsPinMapScalarFieldEnum[]
  }


  /**
   * planetSchematicsPinMap create
   */
  export type planetSchematicsPinMapCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the planetSchematicsPinMap
     */
    select?: planetSchematicsPinMapSelect<ExtArgs> | null
    /**
     * The data needed to create a planetSchematicsPinMap.
     */
    data: XOR<planetSchematicsPinMapCreateInput, planetSchematicsPinMapUncheckedCreateInput>
  }


  /**
   * planetSchematicsPinMap createMany
   */
  export type planetSchematicsPinMapCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many planetSchematicsPinMaps.
     */
    data: planetSchematicsPinMapCreateManyInput | planetSchematicsPinMapCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * planetSchematicsPinMap update
   */
  export type planetSchematicsPinMapUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the planetSchematicsPinMap
     */
    select?: planetSchematicsPinMapSelect<ExtArgs> | null
    /**
     * The data needed to update a planetSchematicsPinMap.
     */
    data: XOR<planetSchematicsPinMapUpdateInput, planetSchematicsPinMapUncheckedUpdateInput>
    /**
     * Choose, which planetSchematicsPinMap to update.
     */
    where: planetSchematicsPinMapWhereUniqueInput
  }


  /**
   * planetSchematicsPinMap updateMany
   */
  export type planetSchematicsPinMapUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update planetSchematicsPinMaps.
     */
    data: XOR<planetSchematicsPinMapUpdateManyMutationInput, planetSchematicsPinMapUncheckedUpdateManyInput>
    /**
     * Filter which planetSchematicsPinMaps to update
     */
    where?: planetSchematicsPinMapWhereInput
  }


  /**
   * planetSchematicsPinMap upsert
   */
  export type planetSchematicsPinMapUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the planetSchematicsPinMap
     */
    select?: planetSchematicsPinMapSelect<ExtArgs> | null
    /**
     * The filter to search for the planetSchematicsPinMap to update in case it exists.
     */
    where: planetSchematicsPinMapWhereUniqueInput
    /**
     * In case the planetSchematicsPinMap found by the `where` argument doesn't exist, create a new planetSchematicsPinMap with this data.
     */
    create: XOR<planetSchematicsPinMapCreateInput, planetSchematicsPinMapUncheckedCreateInput>
    /**
     * In case the planetSchematicsPinMap was found with the provided `where` argument, update it with this data.
     */
    update: XOR<planetSchematicsPinMapUpdateInput, planetSchematicsPinMapUncheckedUpdateInput>
  }


  /**
   * planetSchematicsPinMap delete
   */
  export type planetSchematicsPinMapDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the planetSchematicsPinMap
     */
    select?: planetSchematicsPinMapSelect<ExtArgs> | null
    /**
     * Filter which planetSchematicsPinMap to delete.
     */
    where: planetSchematicsPinMapWhereUniqueInput
  }


  /**
   * planetSchematicsPinMap deleteMany
   */
  export type planetSchematicsPinMapDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which planetSchematicsPinMaps to delete
     */
    where?: planetSchematicsPinMapWhereInput
  }


  /**
   * planetSchematicsPinMap without action
   */
  export type planetSchematicsPinMapDefaultArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the planetSchematicsPinMap
     */
    select?: planetSchematicsPinMapSelect<ExtArgs> | null
  }



  /**
   * Model planetSchematicsTypeMap
   */

  export type AggregatePlanetSchematicsTypeMap = {
    _count: PlanetSchematicsTypeMapCountAggregateOutputType | null
    _avg: PlanetSchematicsTypeMapAvgAggregateOutputType | null
    _sum: PlanetSchematicsTypeMapSumAggregateOutputType | null
    _min: PlanetSchematicsTypeMapMinAggregateOutputType | null
    _max: PlanetSchematicsTypeMapMaxAggregateOutputType | null
  }

  export type PlanetSchematicsTypeMapAvgAggregateOutputType = {
    schematicID: number | null
    typeID: number | null
    quantity: number | null
  }

  export type PlanetSchematicsTypeMapSumAggregateOutputType = {
    schematicID: number | null
    typeID: number | null
    quantity: number | null
  }

  export type PlanetSchematicsTypeMapMinAggregateOutputType = {
    schematicID: number | null
    typeID: number | null
    quantity: number | null
    isInput: boolean | null
  }

  export type PlanetSchematicsTypeMapMaxAggregateOutputType = {
    schematicID: number | null
    typeID: number | null
    quantity: number | null
    isInput: boolean | null
  }

  export type PlanetSchematicsTypeMapCountAggregateOutputType = {
    schematicID: number
    typeID: number
    quantity: number
    isInput: number
    _all: number
  }


  export type PlanetSchematicsTypeMapAvgAggregateInputType = {
    schematicID?: true
    typeID?: true
    quantity?: true
  }

  export type PlanetSchematicsTypeMapSumAggregateInputType = {
    schematicID?: true
    typeID?: true
    quantity?: true
  }

  export type PlanetSchematicsTypeMapMinAggregateInputType = {
    schematicID?: true
    typeID?: true
    quantity?: true
    isInput?: true
  }

  export type PlanetSchematicsTypeMapMaxAggregateInputType = {
    schematicID?: true
    typeID?: true
    quantity?: true
    isInput?: true
  }

  export type PlanetSchematicsTypeMapCountAggregateInputType = {
    schematicID?: true
    typeID?: true
    quantity?: true
    isInput?: true
    _all?: true
  }

  export type PlanetSchematicsTypeMapAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which planetSchematicsTypeMap to aggregate.
     */
    where?: planetSchematicsTypeMapWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of planetSchematicsTypeMaps to fetch.
     */
    orderBy?: planetSchematicsTypeMapOrderByWithRelationInput | planetSchematicsTypeMapOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: planetSchematicsTypeMapWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` planetSchematicsTypeMaps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` planetSchematicsTypeMaps.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned planetSchematicsTypeMaps
    **/
    _count?: true | PlanetSchematicsTypeMapCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PlanetSchematicsTypeMapAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PlanetSchematicsTypeMapSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PlanetSchematicsTypeMapMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PlanetSchematicsTypeMapMaxAggregateInputType
  }

  export type GetPlanetSchematicsTypeMapAggregateType<T extends PlanetSchematicsTypeMapAggregateArgs> = {
        [P in keyof T & keyof AggregatePlanetSchematicsTypeMap]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePlanetSchematicsTypeMap[P]>
      : GetScalarType<T[P], AggregatePlanetSchematicsTypeMap[P]>
  }




  export type planetSchematicsTypeMapGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: planetSchematicsTypeMapWhereInput
    orderBy?: planetSchematicsTypeMapOrderByWithAggregationInput | planetSchematicsTypeMapOrderByWithAggregationInput[]
    by: PlanetSchematicsTypeMapScalarFieldEnum[] | PlanetSchematicsTypeMapScalarFieldEnum
    having?: planetSchematicsTypeMapScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PlanetSchematicsTypeMapCountAggregateInputType | true
    _avg?: PlanetSchematicsTypeMapAvgAggregateInputType
    _sum?: PlanetSchematicsTypeMapSumAggregateInputType
    _min?: PlanetSchematicsTypeMapMinAggregateInputType
    _max?: PlanetSchematicsTypeMapMaxAggregateInputType
  }

  export type PlanetSchematicsTypeMapGroupByOutputType = {
    schematicID: number
    typeID: number
    quantity: number | null
    isInput: boolean | null
    _count: PlanetSchematicsTypeMapCountAggregateOutputType | null
    _avg: PlanetSchematicsTypeMapAvgAggregateOutputType | null
    _sum: PlanetSchematicsTypeMapSumAggregateOutputType | null
    _min: PlanetSchematicsTypeMapMinAggregateOutputType | null
    _max: PlanetSchematicsTypeMapMaxAggregateOutputType | null
  }

  type GetPlanetSchematicsTypeMapGroupByPayload<T extends planetSchematicsTypeMapGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PlanetSchematicsTypeMapGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PlanetSchematicsTypeMapGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PlanetSchematicsTypeMapGroupByOutputType[P]>
            : GetScalarType<T[P], PlanetSchematicsTypeMapGroupByOutputType[P]>
        }
      >
    >


  export type planetSchematicsTypeMapSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    schematicID?: boolean
    typeID?: boolean
    quantity?: boolean
    isInput?: boolean
  }, ExtArgs["result"]["planetSchematicsTypeMap"]>

  export type planetSchematicsTypeMapSelectScalar = {
    schematicID?: boolean
    typeID?: boolean
    quantity?: boolean
    isInput?: boolean
  }


  export type $planetSchematicsTypeMapPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    name: "planetSchematicsTypeMap"
    objects: {}
    scalars: $Extensions.GetResult<{
      schematicID: number
      typeID: number
      quantity: number | null
      isInput: boolean | null
    }, ExtArgs["result"]["planetSchematicsTypeMap"]>
    composites: {}
  }


  type planetSchematicsTypeMapGetPayload<S extends boolean | null | undefined | planetSchematicsTypeMapDefaultArgs> = $Result.GetResult<Prisma.$planetSchematicsTypeMapPayload, S>

  type planetSchematicsTypeMapCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<planetSchematicsTypeMapFindManyArgs, 'select' | 'include'> & {
      select?: PlanetSchematicsTypeMapCountAggregateInputType | true
    }

  export interface planetSchematicsTypeMapDelegate<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['planetSchematicsTypeMap'], meta: { name: 'planetSchematicsTypeMap' } }
    /**
     * Find zero or one PlanetSchematicsTypeMap that matches the filter.
     * @param {planetSchematicsTypeMapFindUniqueArgs} args - Arguments to find a PlanetSchematicsTypeMap
     * @example
     * // Get one PlanetSchematicsTypeMap
     * const planetSchematicsTypeMap = await prisma.planetSchematicsTypeMap.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends planetSchematicsTypeMapFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, planetSchematicsTypeMapFindUniqueArgs<ExtArgs>>
    ): Prisma__planetSchematicsTypeMapClient<$Result.GetResult<Prisma.$planetSchematicsTypeMapPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one PlanetSchematicsTypeMap that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {planetSchematicsTypeMapFindUniqueOrThrowArgs} args - Arguments to find a PlanetSchematicsTypeMap
     * @example
     * // Get one PlanetSchematicsTypeMap
     * const planetSchematicsTypeMap = await prisma.planetSchematicsTypeMap.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends planetSchematicsTypeMapFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, planetSchematicsTypeMapFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__planetSchematicsTypeMapClient<$Result.GetResult<Prisma.$planetSchematicsTypeMapPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first PlanetSchematicsTypeMap that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {planetSchematicsTypeMapFindFirstArgs} args - Arguments to find a PlanetSchematicsTypeMap
     * @example
     * // Get one PlanetSchematicsTypeMap
     * const planetSchematicsTypeMap = await prisma.planetSchematicsTypeMap.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends planetSchematicsTypeMapFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, planetSchematicsTypeMapFindFirstArgs<ExtArgs>>
    ): Prisma__planetSchematicsTypeMapClient<$Result.GetResult<Prisma.$planetSchematicsTypeMapPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first PlanetSchematicsTypeMap that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {planetSchematicsTypeMapFindFirstOrThrowArgs} args - Arguments to find a PlanetSchematicsTypeMap
     * @example
     * // Get one PlanetSchematicsTypeMap
     * const planetSchematicsTypeMap = await prisma.planetSchematicsTypeMap.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends planetSchematicsTypeMapFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, planetSchematicsTypeMapFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__planetSchematicsTypeMapClient<$Result.GetResult<Prisma.$planetSchematicsTypeMapPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more PlanetSchematicsTypeMaps that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {planetSchematicsTypeMapFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PlanetSchematicsTypeMaps
     * const planetSchematicsTypeMaps = await prisma.planetSchematicsTypeMap.findMany()
     * 
     * // Get first 10 PlanetSchematicsTypeMaps
     * const planetSchematicsTypeMaps = await prisma.planetSchematicsTypeMap.findMany({ take: 10 })
     * 
     * // Only select the `schematicID`
     * const planetSchematicsTypeMapWithSchematicIDOnly = await prisma.planetSchematicsTypeMap.findMany({ select: { schematicID: true } })
     * 
    **/
    findMany<T extends planetSchematicsTypeMapFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, planetSchematicsTypeMapFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$planetSchematicsTypeMapPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a PlanetSchematicsTypeMap.
     * @param {planetSchematicsTypeMapCreateArgs} args - Arguments to create a PlanetSchematicsTypeMap.
     * @example
     * // Create one PlanetSchematicsTypeMap
     * const PlanetSchematicsTypeMap = await prisma.planetSchematicsTypeMap.create({
     *   data: {
     *     // ... data to create a PlanetSchematicsTypeMap
     *   }
     * })
     * 
    **/
    create<T extends planetSchematicsTypeMapCreateArgs<ExtArgs>>(
      args: SelectSubset<T, planetSchematicsTypeMapCreateArgs<ExtArgs>>
    ): Prisma__planetSchematicsTypeMapClient<$Result.GetResult<Prisma.$planetSchematicsTypeMapPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many PlanetSchematicsTypeMaps.
     *     @param {planetSchematicsTypeMapCreateManyArgs} args - Arguments to create many PlanetSchematicsTypeMaps.
     *     @example
     *     // Create many PlanetSchematicsTypeMaps
     *     const planetSchematicsTypeMap = await prisma.planetSchematicsTypeMap.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends planetSchematicsTypeMapCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, planetSchematicsTypeMapCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a PlanetSchematicsTypeMap.
     * @param {planetSchematicsTypeMapDeleteArgs} args - Arguments to delete one PlanetSchematicsTypeMap.
     * @example
     * // Delete one PlanetSchematicsTypeMap
     * const PlanetSchematicsTypeMap = await prisma.planetSchematicsTypeMap.delete({
     *   where: {
     *     // ... filter to delete one PlanetSchematicsTypeMap
     *   }
     * })
     * 
    **/
    delete<T extends planetSchematicsTypeMapDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, planetSchematicsTypeMapDeleteArgs<ExtArgs>>
    ): Prisma__planetSchematicsTypeMapClient<$Result.GetResult<Prisma.$planetSchematicsTypeMapPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one PlanetSchematicsTypeMap.
     * @param {planetSchematicsTypeMapUpdateArgs} args - Arguments to update one PlanetSchematicsTypeMap.
     * @example
     * // Update one PlanetSchematicsTypeMap
     * const planetSchematicsTypeMap = await prisma.planetSchematicsTypeMap.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends planetSchematicsTypeMapUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, planetSchematicsTypeMapUpdateArgs<ExtArgs>>
    ): Prisma__planetSchematicsTypeMapClient<$Result.GetResult<Prisma.$planetSchematicsTypeMapPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more PlanetSchematicsTypeMaps.
     * @param {planetSchematicsTypeMapDeleteManyArgs} args - Arguments to filter PlanetSchematicsTypeMaps to delete.
     * @example
     * // Delete a few PlanetSchematicsTypeMaps
     * const { count } = await prisma.planetSchematicsTypeMap.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends planetSchematicsTypeMapDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, planetSchematicsTypeMapDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PlanetSchematicsTypeMaps.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {planetSchematicsTypeMapUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PlanetSchematicsTypeMaps
     * const planetSchematicsTypeMap = await prisma.planetSchematicsTypeMap.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends planetSchematicsTypeMapUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, planetSchematicsTypeMapUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one PlanetSchematicsTypeMap.
     * @param {planetSchematicsTypeMapUpsertArgs} args - Arguments to update or create a PlanetSchematicsTypeMap.
     * @example
     * // Update or create a PlanetSchematicsTypeMap
     * const planetSchematicsTypeMap = await prisma.planetSchematicsTypeMap.upsert({
     *   create: {
     *     // ... data to create a PlanetSchematicsTypeMap
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PlanetSchematicsTypeMap we want to update
     *   }
     * })
    **/
    upsert<T extends planetSchematicsTypeMapUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, planetSchematicsTypeMapUpsertArgs<ExtArgs>>
    ): Prisma__planetSchematicsTypeMapClient<$Result.GetResult<Prisma.$planetSchematicsTypeMapPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of PlanetSchematicsTypeMaps.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {planetSchematicsTypeMapCountArgs} args - Arguments to filter PlanetSchematicsTypeMaps to count.
     * @example
     * // Count the number of PlanetSchematicsTypeMaps
     * const count = await prisma.planetSchematicsTypeMap.count({
     *   where: {
     *     // ... the filter for the PlanetSchematicsTypeMaps we want to count
     *   }
     * })
    **/
    count<T extends planetSchematicsTypeMapCountArgs>(
      args?: Subset<T, planetSchematicsTypeMapCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PlanetSchematicsTypeMapCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PlanetSchematicsTypeMap.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlanetSchematicsTypeMapAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PlanetSchematicsTypeMapAggregateArgs>(args: Subset<T, PlanetSchematicsTypeMapAggregateArgs>): Prisma.PrismaPromise<GetPlanetSchematicsTypeMapAggregateType<T>>

    /**
     * Group by PlanetSchematicsTypeMap.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {planetSchematicsTypeMapGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends planetSchematicsTypeMapGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: planetSchematicsTypeMapGroupByArgs['orderBy'] }
        : { orderBy?: planetSchematicsTypeMapGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, planetSchematicsTypeMapGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPlanetSchematicsTypeMapGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the planetSchematicsTypeMap model
   */
  readonly fields: planetSchematicsTypeMapFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for planetSchematicsTypeMap.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__planetSchematicsTypeMapClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';


    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the planetSchematicsTypeMap model
   */ 
  interface planetSchematicsTypeMapFieldRefs {
    readonly schematicID: FieldRef<"planetSchematicsTypeMap", 'Int'>
    readonly typeID: FieldRef<"planetSchematicsTypeMap", 'Int'>
    readonly quantity: FieldRef<"planetSchematicsTypeMap", 'Int'>
    readonly isInput: FieldRef<"planetSchematicsTypeMap", 'Boolean'>
  }
    

  // Custom InputTypes

  /**
   * planetSchematicsTypeMap findUnique
   */
  export type planetSchematicsTypeMapFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the planetSchematicsTypeMap
     */
    select?: planetSchematicsTypeMapSelect<ExtArgs> | null
    /**
     * Filter, which planetSchematicsTypeMap to fetch.
     */
    where: planetSchematicsTypeMapWhereUniqueInput
  }


  /**
   * planetSchematicsTypeMap findUniqueOrThrow
   */
  export type planetSchematicsTypeMapFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the planetSchematicsTypeMap
     */
    select?: planetSchematicsTypeMapSelect<ExtArgs> | null
    /**
     * Filter, which planetSchematicsTypeMap to fetch.
     */
    where: planetSchematicsTypeMapWhereUniqueInput
  }


  /**
   * planetSchematicsTypeMap findFirst
   */
  export type planetSchematicsTypeMapFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the planetSchematicsTypeMap
     */
    select?: planetSchematicsTypeMapSelect<ExtArgs> | null
    /**
     * Filter, which planetSchematicsTypeMap to fetch.
     */
    where?: planetSchematicsTypeMapWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of planetSchematicsTypeMaps to fetch.
     */
    orderBy?: planetSchematicsTypeMapOrderByWithRelationInput | planetSchematicsTypeMapOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for planetSchematicsTypeMaps.
     */
    cursor?: planetSchematicsTypeMapWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` planetSchematicsTypeMaps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` planetSchematicsTypeMaps.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of planetSchematicsTypeMaps.
     */
    distinct?: PlanetSchematicsTypeMapScalarFieldEnum | PlanetSchematicsTypeMapScalarFieldEnum[]
  }


  /**
   * planetSchematicsTypeMap findFirstOrThrow
   */
  export type planetSchematicsTypeMapFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the planetSchematicsTypeMap
     */
    select?: planetSchematicsTypeMapSelect<ExtArgs> | null
    /**
     * Filter, which planetSchematicsTypeMap to fetch.
     */
    where?: planetSchematicsTypeMapWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of planetSchematicsTypeMaps to fetch.
     */
    orderBy?: planetSchematicsTypeMapOrderByWithRelationInput | planetSchematicsTypeMapOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for planetSchematicsTypeMaps.
     */
    cursor?: planetSchematicsTypeMapWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` planetSchematicsTypeMaps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` planetSchematicsTypeMaps.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of planetSchematicsTypeMaps.
     */
    distinct?: PlanetSchematicsTypeMapScalarFieldEnum | PlanetSchematicsTypeMapScalarFieldEnum[]
  }


  /**
   * planetSchematicsTypeMap findMany
   */
  export type planetSchematicsTypeMapFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the planetSchematicsTypeMap
     */
    select?: planetSchematicsTypeMapSelect<ExtArgs> | null
    /**
     * Filter, which planetSchematicsTypeMaps to fetch.
     */
    where?: planetSchematicsTypeMapWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of planetSchematicsTypeMaps to fetch.
     */
    orderBy?: planetSchematicsTypeMapOrderByWithRelationInput | planetSchematicsTypeMapOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing planetSchematicsTypeMaps.
     */
    cursor?: planetSchematicsTypeMapWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` planetSchematicsTypeMaps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` planetSchematicsTypeMaps.
     */
    skip?: number
    distinct?: PlanetSchematicsTypeMapScalarFieldEnum | PlanetSchematicsTypeMapScalarFieldEnum[]
  }


  /**
   * planetSchematicsTypeMap create
   */
  export type planetSchematicsTypeMapCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the planetSchematicsTypeMap
     */
    select?: planetSchematicsTypeMapSelect<ExtArgs> | null
    /**
     * The data needed to create a planetSchematicsTypeMap.
     */
    data: XOR<planetSchematicsTypeMapCreateInput, planetSchematicsTypeMapUncheckedCreateInput>
  }


  /**
   * planetSchematicsTypeMap createMany
   */
  export type planetSchematicsTypeMapCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many planetSchematicsTypeMaps.
     */
    data: planetSchematicsTypeMapCreateManyInput | planetSchematicsTypeMapCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * planetSchematicsTypeMap update
   */
  export type planetSchematicsTypeMapUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the planetSchematicsTypeMap
     */
    select?: planetSchematicsTypeMapSelect<ExtArgs> | null
    /**
     * The data needed to update a planetSchematicsTypeMap.
     */
    data: XOR<planetSchematicsTypeMapUpdateInput, planetSchematicsTypeMapUncheckedUpdateInput>
    /**
     * Choose, which planetSchematicsTypeMap to update.
     */
    where: planetSchematicsTypeMapWhereUniqueInput
  }


  /**
   * planetSchematicsTypeMap updateMany
   */
  export type planetSchematicsTypeMapUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update planetSchematicsTypeMaps.
     */
    data: XOR<planetSchematicsTypeMapUpdateManyMutationInput, planetSchematicsTypeMapUncheckedUpdateManyInput>
    /**
     * Filter which planetSchematicsTypeMaps to update
     */
    where?: planetSchematicsTypeMapWhereInput
  }


  /**
   * planetSchematicsTypeMap upsert
   */
  export type planetSchematicsTypeMapUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the planetSchematicsTypeMap
     */
    select?: planetSchematicsTypeMapSelect<ExtArgs> | null
    /**
     * The filter to search for the planetSchematicsTypeMap to update in case it exists.
     */
    where: planetSchematicsTypeMapWhereUniqueInput
    /**
     * In case the planetSchematicsTypeMap found by the `where` argument doesn't exist, create a new planetSchematicsTypeMap with this data.
     */
    create: XOR<planetSchematicsTypeMapCreateInput, planetSchematicsTypeMapUncheckedCreateInput>
    /**
     * In case the planetSchematicsTypeMap was found with the provided `where` argument, update it with this data.
     */
    update: XOR<planetSchematicsTypeMapUpdateInput, planetSchematicsTypeMapUncheckedUpdateInput>
  }


  /**
   * planetSchematicsTypeMap delete
   */
  export type planetSchematicsTypeMapDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the planetSchematicsTypeMap
     */
    select?: planetSchematicsTypeMapSelect<ExtArgs> | null
    /**
     * Filter which planetSchematicsTypeMap to delete.
     */
    where: planetSchematicsTypeMapWhereUniqueInput
  }


  /**
   * planetSchematicsTypeMap deleteMany
   */
  export type planetSchematicsTypeMapDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which planetSchematicsTypeMaps to delete
     */
    where?: planetSchematicsTypeMapWhereInput
  }


  /**
   * planetSchematicsTypeMap without action
   */
  export type planetSchematicsTypeMapDefaultArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the planetSchematicsTypeMap
     */
    select?: planetSchematicsTypeMapSelect<ExtArgs> | null
  }



  /**
   * Model ramActivities
   */

  export type AggregateRamActivities = {
    _count: RamActivitiesCountAggregateOutputType | null
    _avg: RamActivitiesAvgAggregateOutputType | null
    _sum: RamActivitiesSumAggregateOutputType | null
    _min: RamActivitiesMinAggregateOutputType | null
    _max: RamActivitiesMaxAggregateOutputType | null
  }

  export type RamActivitiesAvgAggregateOutputType = {
    activityID: number | null
  }

  export type RamActivitiesSumAggregateOutputType = {
    activityID: number | null
  }

  export type RamActivitiesMinAggregateOutputType = {
    activityID: number | null
    activityName: string | null
    iconNo: string | null
    description: string | null
    published: boolean | null
  }

  export type RamActivitiesMaxAggregateOutputType = {
    activityID: number | null
    activityName: string | null
    iconNo: string | null
    description: string | null
    published: boolean | null
  }

  export type RamActivitiesCountAggregateOutputType = {
    activityID: number
    activityName: number
    iconNo: number
    description: number
    published: number
    _all: number
  }


  export type RamActivitiesAvgAggregateInputType = {
    activityID?: true
  }

  export type RamActivitiesSumAggregateInputType = {
    activityID?: true
  }

  export type RamActivitiesMinAggregateInputType = {
    activityID?: true
    activityName?: true
    iconNo?: true
    description?: true
    published?: true
  }

  export type RamActivitiesMaxAggregateInputType = {
    activityID?: true
    activityName?: true
    iconNo?: true
    description?: true
    published?: true
  }

  export type RamActivitiesCountAggregateInputType = {
    activityID?: true
    activityName?: true
    iconNo?: true
    description?: true
    published?: true
    _all?: true
  }

  export type RamActivitiesAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which ramActivities to aggregate.
     */
    where?: ramActivitiesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ramActivities to fetch.
     */
    orderBy?: ramActivitiesOrderByWithRelationInput | ramActivitiesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ramActivitiesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ramActivities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ramActivities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ramActivities
    **/
    _count?: true | RamActivitiesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RamActivitiesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RamActivitiesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RamActivitiesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RamActivitiesMaxAggregateInputType
  }

  export type GetRamActivitiesAggregateType<T extends RamActivitiesAggregateArgs> = {
        [P in keyof T & keyof AggregateRamActivities]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRamActivities[P]>
      : GetScalarType<T[P], AggregateRamActivities[P]>
  }




  export type ramActivitiesGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: ramActivitiesWhereInput
    orderBy?: ramActivitiesOrderByWithAggregationInput | ramActivitiesOrderByWithAggregationInput[]
    by: RamActivitiesScalarFieldEnum[] | RamActivitiesScalarFieldEnum
    having?: ramActivitiesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RamActivitiesCountAggregateInputType | true
    _avg?: RamActivitiesAvgAggregateInputType
    _sum?: RamActivitiesSumAggregateInputType
    _min?: RamActivitiesMinAggregateInputType
    _max?: RamActivitiesMaxAggregateInputType
  }

  export type RamActivitiesGroupByOutputType = {
    activityID: number
    activityName: string | null
    iconNo: string | null
    description: string | null
    published: boolean | null
    _count: RamActivitiesCountAggregateOutputType | null
    _avg: RamActivitiesAvgAggregateOutputType | null
    _sum: RamActivitiesSumAggregateOutputType | null
    _min: RamActivitiesMinAggregateOutputType | null
    _max: RamActivitiesMaxAggregateOutputType | null
  }

  type GetRamActivitiesGroupByPayload<T extends ramActivitiesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RamActivitiesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RamActivitiesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RamActivitiesGroupByOutputType[P]>
            : GetScalarType<T[P], RamActivitiesGroupByOutputType[P]>
        }
      >
    >


  export type ramActivitiesSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    activityID?: boolean
    activityName?: boolean
    iconNo?: boolean
    description?: boolean
    published?: boolean
  }, ExtArgs["result"]["ramActivities"]>

  export type ramActivitiesSelectScalar = {
    activityID?: boolean
    activityName?: boolean
    iconNo?: boolean
    description?: boolean
    published?: boolean
  }


  export type $ramActivitiesPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    name: "ramActivities"
    objects: {}
    scalars: $Extensions.GetResult<{
      activityID: number
      activityName: string | null
      iconNo: string | null
      description: string | null
      published: boolean | null
    }, ExtArgs["result"]["ramActivities"]>
    composites: {}
  }


  type ramActivitiesGetPayload<S extends boolean | null | undefined | ramActivitiesDefaultArgs> = $Result.GetResult<Prisma.$ramActivitiesPayload, S>

  type ramActivitiesCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<ramActivitiesFindManyArgs, 'select' | 'include'> & {
      select?: RamActivitiesCountAggregateInputType | true
    }

  export interface ramActivitiesDelegate<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ramActivities'], meta: { name: 'ramActivities' } }
    /**
     * Find zero or one RamActivities that matches the filter.
     * @param {ramActivitiesFindUniqueArgs} args - Arguments to find a RamActivities
     * @example
     * // Get one RamActivities
     * const ramActivities = await prisma.ramActivities.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ramActivitiesFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, ramActivitiesFindUniqueArgs<ExtArgs>>
    ): Prisma__ramActivitiesClient<$Result.GetResult<Prisma.$ramActivitiesPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one RamActivities that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {ramActivitiesFindUniqueOrThrowArgs} args - Arguments to find a RamActivities
     * @example
     * // Get one RamActivities
     * const ramActivities = await prisma.ramActivities.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends ramActivitiesFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ramActivitiesFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__ramActivitiesClient<$Result.GetResult<Prisma.$ramActivitiesPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first RamActivities that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ramActivitiesFindFirstArgs} args - Arguments to find a RamActivities
     * @example
     * // Get one RamActivities
     * const ramActivities = await prisma.ramActivities.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ramActivitiesFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, ramActivitiesFindFirstArgs<ExtArgs>>
    ): Prisma__ramActivitiesClient<$Result.GetResult<Prisma.$ramActivitiesPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first RamActivities that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ramActivitiesFindFirstOrThrowArgs} args - Arguments to find a RamActivities
     * @example
     * // Get one RamActivities
     * const ramActivities = await prisma.ramActivities.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends ramActivitiesFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ramActivitiesFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__ramActivitiesClient<$Result.GetResult<Prisma.$ramActivitiesPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more RamActivities that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ramActivitiesFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RamActivities
     * const ramActivities = await prisma.ramActivities.findMany()
     * 
     * // Get first 10 RamActivities
     * const ramActivities = await prisma.ramActivities.findMany({ take: 10 })
     * 
     * // Only select the `activityID`
     * const ramActivitiesWithActivityIDOnly = await prisma.ramActivities.findMany({ select: { activityID: true } })
     * 
    **/
    findMany<T extends ramActivitiesFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ramActivitiesFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ramActivitiesPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a RamActivities.
     * @param {ramActivitiesCreateArgs} args - Arguments to create a RamActivities.
     * @example
     * // Create one RamActivities
     * const RamActivities = await prisma.ramActivities.create({
     *   data: {
     *     // ... data to create a RamActivities
     *   }
     * })
     * 
    **/
    create<T extends ramActivitiesCreateArgs<ExtArgs>>(
      args: SelectSubset<T, ramActivitiesCreateArgs<ExtArgs>>
    ): Prisma__ramActivitiesClient<$Result.GetResult<Prisma.$ramActivitiesPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many RamActivities.
     *     @param {ramActivitiesCreateManyArgs} args - Arguments to create many RamActivities.
     *     @example
     *     // Create many RamActivities
     *     const ramActivities = await prisma.ramActivities.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ramActivitiesCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ramActivitiesCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a RamActivities.
     * @param {ramActivitiesDeleteArgs} args - Arguments to delete one RamActivities.
     * @example
     * // Delete one RamActivities
     * const RamActivities = await prisma.ramActivities.delete({
     *   where: {
     *     // ... filter to delete one RamActivities
     *   }
     * })
     * 
    **/
    delete<T extends ramActivitiesDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, ramActivitiesDeleteArgs<ExtArgs>>
    ): Prisma__ramActivitiesClient<$Result.GetResult<Prisma.$ramActivitiesPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one RamActivities.
     * @param {ramActivitiesUpdateArgs} args - Arguments to update one RamActivities.
     * @example
     * // Update one RamActivities
     * const ramActivities = await prisma.ramActivities.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ramActivitiesUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, ramActivitiesUpdateArgs<ExtArgs>>
    ): Prisma__ramActivitiesClient<$Result.GetResult<Prisma.$ramActivitiesPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more RamActivities.
     * @param {ramActivitiesDeleteManyArgs} args - Arguments to filter RamActivities to delete.
     * @example
     * // Delete a few RamActivities
     * const { count } = await prisma.ramActivities.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ramActivitiesDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ramActivitiesDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RamActivities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ramActivitiesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RamActivities
     * const ramActivities = await prisma.ramActivities.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ramActivitiesUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, ramActivitiesUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one RamActivities.
     * @param {ramActivitiesUpsertArgs} args - Arguments to update or create a RamActivities.
     * @example
     * // Update or create a RamActivities
     * const ramActivities = await prisma.ramActivities.upsert({
     *   create: {
     *     // ... data to create a RamActivities
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RamActivities we want to update
     *   }
     * })
    **/
    upsert<T extends ramActivitiesUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, ramActivitiesUpsertArgs<ExtArgs>>
    ): Prisma__ramActivitiesClient<$Result.GetResult<Prisma.$ramActivitiesPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of RamActivities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ramActivitiesCountArgs} args - Arguments to filter RamActivities to count.
     * @example
     * // Count the number of RamActivities
     * const count = await prisma.ramActivities.count({
     *   where: {
     *     // ... the filter for the RamActivities we want to count
     *   }
     * })
    **/
    count<T extends ramActivitiesCountArgs>(
      args?: Subset<T, ramActivitiesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RamActivitiesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RamActivities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RamActivitiesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RamActivitiesAggregateArgs>(args: Subset<T, RamActivitiesAggregateArgs>): Prisma.PrismaPromise<GetRamActivitiesAggregateType<T>>

    /**
     * Group by RamActivities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ramActivitiesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ramActivitiesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ramActivitiesGroupByArgs['orderBy'] }
        : { orderBy?: ramActivitiesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ramActivitiesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRamActivitiesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ramActivities model
   */
  readonly fields: ramActivitiesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ramActivities.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ramActivitiesClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';


    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the ramActivities model
   */ 
  interface ramActivitiesFieldRefs {
    readonly activityID: FieldRef<"ramActivities", 'Int'>
    readonly activityName: FieldRef<"ramActivities", 'String'>
    readonly iconNo: FieldRef<"ramActivities", 'String'>
    readonly description: FieldRef<"ramActivities", 'String'>
    readonly published: FieldRef<"ramActivities", 'Boolean'>
  }
    

  // Custom InputTypes

  /**
   * ramActivities findUnique
   */
  export type ramActivitiesFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ramActivities
     */
    select?: ramActivitiesSelect<ExtArgs> | null
    /**
     * Filter, which ramActivities to fetch.
     */
    where: ramActivitiesWhereUniqueInput
  }


  /**
   * ramActivities findUniqueOrThrow
   */
  export type ramActivitiesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ramActivities
     */
    select?: ramActivitiesSelect<ExtArgs> | null
    /**
     * Filter, which ramActivities to fetch.
     */
    where: ramActivitiesWhereUniqueInput
  }


  /**
   * ramActivities findFirst
   */
  export type ramActivitiesFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ramActivities
     */
    select?: ramActivitiesSelect<ExtArgs> | null
    /**
     * Filter, which ramActivities to fetch.
     */
    where?: ramActivitiesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ramActivities to fetch.
     */
    orderBy?: ramActivitiesOrderByWithRelationInput | ramActivitiesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ramActivities.
     */
    cursor?: ramActivitiesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ramActivities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ramActivities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ramActivities.
     */
    distinct?: RamActivitiesScalarFieldEnum | RamActivitiesScalarFieldEnum[]
  }


  /**
   * ramActivities findFirstOrThrow
   */
  export type ramActivitiesFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ramActivities
     */
    select?: ramActivitiesSelect<ExtArgs> | null
    /**
     * Filter, which ramActivities to fetch.
     */
    where?: ramActivitiesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ramActivities to fetch.
     */
    orderBy?: ramActivitiesOrderByWithRelationInput | ramActivitiesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ramActivities.
     */
    cursor?: ramActivitiesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ramActivities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ramActivities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ramActivities.
     */
    distinct?: RamActivitiesScalarFieldEnum | RamActivitiesScalarFieldEnum[]
  }


  /**
   * ramActivities findMany
   */
  export type ramActivitiesFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ramActivities
     */
    select?: ramActivitiesSelect<ExtArgs> | null
    /**
     * Filter, which ramActivities to fetch.
     */
    where?: ramActivitiesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ramActivities to fetch.
     */
    orderBy?: ramActivitiesOrderByWithRelationInput | ramActivitiesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ramActivities.
     */
    cursor?: ramActivitiesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ramActivities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ramActivities.
     */
    skip?: number
    distinct?: RamActivitiesScalarFieldEnum | RamActivitiesScalarFieldEnum[]
  }


  /**
   * ramActivities create
   */
  export type ramActivitiesCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ramActivities
     */
    select?: ramActivitiesSelect<ExtArgs> | null
    /**
     * The data needed to create a ramActivities.
     */
    data: XOR<ramActivitiesCreateInput, ramActivitiesUncheckedCreateInput>
  }


  /**
   * ramActivities createMany
   */
  export type ramActivitiesCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ramActivities.
     */
    data: ramActivitiesCreateManyInput | ramActivitiesCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * ramActivities update
   */
  export type ramActivitiesUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ramActivities
     */
    select?: ramActivitiesSelect<ExtArgs> | null
    /**
     * The data needed to update a ramActivities.
     */
    data: XOR<ramActivitiesUpdateInput, ramActivitiesUncheckedUpdateInput>
    /**
     * Choose, which ramActivities to update.
     */
    where: ramActivitiesWhereUniqueInput
  }


  /**
   * ramActivities updateMany
   */
  export type ramActivitiesUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ramActivities.
     */
    data: XOR<ramActivitiesUpdateManyMutationInput, ramActivitiesUncheckedUpdateManyInput>
    /**
     * Filter which ramActivities to update
     */
    where?: ramActivitiesWhereInput
  }


  /**
   * ramActivities upsert
   */
  export type ramActivitiesUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ramActivities
     */
    select?: ramActivitiesSelect<ExtArgs> | null
    /**
     * The filter to search for the ramActivities to update in case it exists.
     */
    where: ramActivitiesWhereUniqueInput
    /**
     * In case the ramActivities found by the `where` argument doesn't exist, create a new ramActivities with this data.
     */
    create: XOR<ramActivitiesCreateInput, ramActivitiesUncheckedCreateInput>
    /**
     * In case the ramActivities was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ramActivitiesUpdateInput, ramActivitiesUncheckedUpdateInput>
  }


  /**
   * ramActivities delete
   */
  export type ramActivitiesDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ramActivities
     */
    select?: ramActivitiesSelect<ExtArgs> | null
    /**
     * Filter which ramActivities to delete.
     */
    where: ramActivitiesWhereUniqueInput
  }


  /**
   * ramActivities deleteMany
   */
  export type ramActivitiesDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which ramActivities to delete
     */
    where?: ramActivitiesWhereInput
  }


  /**
   * ramActivities without action
   */
  export type ramActivitiesDefaultArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ramActivities
     */
    select?: ramActivitiesSelect<ExtArgs> | null
  }



  /**
   * Model ramAssemblyLineStations
   */

  export type AggregateRamAssemblyLineStations = {
    _count: RamAssemblyLineStationsCountAggregateOutputType | null
    _avg: RamAssemblyLineStationsAvgAggregateOutputType | null
    _sum: RamAssemblyLineStationsSumAggregateOutputType | null
    _min: RamAssemblyLineStationsMinAggregateOutputType | null
    _max: RamAssemblyLineStationsMaxAggregateOutputType | null
  }

  export type RamAssemblyLineStationsAvgAggregateOutputType = {
    stationID: number | null
    assemblyLineTypeID: number | null
    quantity: number | null
    stationTypeID: number | null
    ownerID: number | null
    solarSystemID: number | null
    regionID: number | null
  }

  export type RamAssemblyLineStationsSumAggregateOutputType = {
    stationID: number | null
    assemblyLineTypeID: number | null
    quantity: number | null
    stationTypeID: number | null
    ownerID: number | null
    solarSystemID: number | null
    regionID: number | null
  }

  export type RamAssemblyLineStationsMinAggregateOutputType = {
    stationID: number | null
    assemblyLineTypeID: number | null
    quantity: number | null
    stationTypeID: number | null
    ownerID: number | null
    solarSystemID: number | null
    regionID: number | null
  }

  export type RamAssemblyLineStationsMaxAggregateOutputType = {
    stationID: number | null
    assemblyLineTypeID: number | null
    quantity: number | null
    stationTypeID: number | null
    ownerID: number | null
    solarSystemID: number | null
    regionID: number | null
  }

  export type RamAssemblyLineStationsCountAggregateOutputType = {
    stationID: number
    assemblyLineTypeID: number
    quantity: number
    stationTypeID: number
    ownerID: number
    solarSystemID: number
    regionID: number
    _all: number
  }


  export type RamAssemblyLineStationsAvgAggregateInputType = {
    stationID?: true
    assemblyLineTypeID?: true
    quantity?: true
    stationTypeID?: true
    ownerID?: true
    solarSystemID?: true
    regionID?: true
  }

  export type RamAssemblyLineStationsSumAggregateInputType = {
    stationID?: true
    assemblyLineTypeID?: true
    quantity?: true
    stationTypeID?: true
    ownerID?: true
    solarSystemID?: true
    regionID?: true
  }

  export type RamAssemblyLineStationsMinAggregateInputType = {
    stationID?: true
    assemblyLineTypeID?: true
    quantity?: true
    stationTypeID?: true
    ownerID?: true
    solarSystemID?: true
    regionID?: true
  }

  export type RamAssemblyLineStationsMaxAggregateInputType = {
    stationID?: true
    assemblyLineTypeID?: true
    quantity?: true
    stationTypeID?: true
    ownerID?: true
    solarSystemID?: true
    regionID?: true
  }

  export type RamAssemblyLineStationsCountAggregateInputType = {
    stationID?: true
    assemblyLineTypeID?: true
    quantity?: true
    stationTypeID?: true
    ownerID?: true
    solarSystemID?: true
    regionID?: true
    _all?: true
  }

  export type RamAssemblyLineStationsAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which ramAssemblyLineStations to aggregate.
     */
    where?: ramAssemblyLineStationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ramAssemblyLineStations to fetch.
     */
    orderBy?: ramAssemblyLineStationsOrderByWithRelationInput | ramAssemblyLineStationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ramAssemblyLineStationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ramAssemblyLineStations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ramAssemblyLineStations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ramAssemblyLineStations
    **/
    _count?: true | RamAssemblyLineStationsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RamAssemblyLineStationsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RamAssemblyLineStationsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RamAssemblyLineStationsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RamAssemblyLineStationsMaxAggregateInputType
  }

  export type GetRamAssemblyLineStationsAggregateType<T extends RamAssemblyLineStationsAggregateArgs> = {
        [P in keyof T & keyof AggregateRamAssemblyLineStations]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRamAssemblyLineStations[P]>
      : GetScalarType<T[P], AggregateRamAssemblyLineStations[P]>
  }




  export type ramAssemblyLineStationsGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: ramAssemblyLineStationsWhereInput
    orderBy?: ramAssemblyLineStationsOrderByWithAggregationInput | ramAssemblyLineStationsOrderByWithAggregationInput[]
    by: RamAssemblyLineStationsScalarFieldEnum[] | RamAssemblyLineStationsScalarFieldEnum
    having?: ramAssemblyLineStationsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RamAssemblyLineStationsCountAggregateInputType | true
    _avg?: RamAssemblyLineStationsAvgAggregateInputType
    _sum?: RamAssemblyLineStationsSumAggregateInputType
    _min?: RamAssemblyLineStationsMinAggregateInputType
    _max?: RamAssemblyLineStationsMaxAggregateInputType
  }

  export type RamAssemblyLineStationsGroupByOutputType = {
    stationID: number
    assemblyLineTypeID: number
    quantity: number | null
    stationTypeID: number | null
    ownerID: number | null
    solarSystemID: number | null
    regionID: number | null
    _count: RamAssemblyLineStationsCountAggregateOutputType | null
    _avg: RamAssemblyLineStationsAvgAggregateOutputType | null
    _sum: RamAssemblyLineStationsSumAggregateOutputType | null
    _min: RamAssemblyLineStationsMinAggregateOutputType | null
    _max: RamAssemblyLineStationsMaxAggregateOutputType | null
  }

  type GetRamAssemblyLineStationsGroupByPayload<T extends ramAssemblyLineStationsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RamAssemblyLineStationsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RamAssemblyLineStationsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RamAssemblyLineStationsGroupByOutputType[P]>
            : GetScalarType<T[P], RamAssemblyLineStationsGroupByOutputType[P]>
        }
      >
    >


  export type ramAssemblyLineStationsSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    stationID?: boolean
    assemblyLineTypeID?: boolean
    quantity?: boolean
    stationTypeID?: boolean
    ownerID?: boolean
    solarSystemID?: boolean
    regionID?: boolean
  }, ExtArgs["result"]["ramAssemblyLineStations"]>

  export type ramAssemblyLineStationsSelectScalar = {
    stationID?: boolean
    assemblyLineTypeID?: boolean
    quantity?: boolean
    stationTypeID?: boolean
    ownerID?: boolean
    solarSystemID?: boolean
    regionID?: boolean
  }


  export type $ramAssemblyLineStationsPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    name: "ramAssemblyLineStations"
    objects: {}
    scalars: $Extensions.GetResult<{
      stationID: number
      assemblyLineTypeID: number
      quantity: number | null
      stationTypeID: number | null
      ownerID: number | null
      solarSystemID: number | null
      regionID: number | null
    }, ExtArgs["result"]["ramAssemblyLineStations"]>
    composites: {}
  }


  type ramAssemblyLineStationsGetPayload<S extends boolean | null | undefined | ramAssemblyLineStationsDefaultArgs> = $Result.GetResult<Prisma.$ramAssemblyLineStationsPayload, S>

  type ramAssemblyLineStationsCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<ramAssemblyLineStationsFindManyArgs, 'select' | 'include'> & {
      select?: RamAssemblyLineStationsCountAggregateInputType | true
    }

  export interface ramAssemblyLineStationsDelegate<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ramAssemblyLineStations'], meta: { name: 'ramAssemblyLineStations' } }
    /**
     * Find zero or one RamAssemblyLineStations that matches the filter.
     * @param {ramAssemblyLineStationsFindUniqueArgs} args - Arguments to find a RamAssemblyLineStations
     * @example
     * // Get one RamAssemblyLineStations
     * const ramAssemblyLineStations = await prisma.ramAssemblyLineStations.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ramAssemblyLineStationsFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, ramAssemblyLineStationsFindUniqueArgs<ExtArgs>>
    ): Prisma__ramAssemblyLineStationsClient<$Result.GetResult<Prisma.$ramAssemblyLineStationsPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one RamAssemblyLineStations that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {ramAssemblyLineStationsFindUniqueOrThrowArgs} args - Arguments to find a RamAssemblyLineStations
     * @example
     * // Get one RamAssemblyLineStations
     * const ramAssemblyLineStations = await prisma.ramAssemblyLineStations.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends ramAssemblyLineStationsFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ramAssemblyLineStationsFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__ramAssemblyLineStationsClient<$Result.GetResult<Prisma.$ramAssemblyLineStationsPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first RamAssemblyLineStations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ramAssemblyLineStationsFindFirstArgs} args - Arguments to find a RamAssemblyLineStations
     * @example
     * // Get one RamAssemblyLineStations
     * const ramAssemblyLineStations = await prisma.ramAssemblyLineStations.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ramAssemblyLineStationsFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, ramAssemblyLineStationsFindFirstArgs<ExtArgs>>
    ): Prisma__ramAssemblyLineStationsClient<$Result.GetResult<Prisma.$ramAssemblyLineStationsPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first RamAssemblyLineStations that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ramAssemblyLineStationsFindFirstOrThrowArgs} args - Arguments to find a RamAssemblyLineStations
     * @example
     * // Get one RamAssemblyLineStations
     * const ramAssemblyLineStations = await prisma.ramAssemblyLineStations.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends ramAssemblyLineStationsFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ramAssemblyLineStationsFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__ramAssemblyLineStationsClient<$Result.GetResult<Prisma.$ramAssemblyLineStationsPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more RamAssemblyLineStations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ramAssemblyLineStationsFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RamAssemblyLineStations
     * const ramAssemblyLineStations = await prisma.ramAssemblyLineStations.findMany()
     * 
     * // Get first 10 RamAssemblyLineStations
     * const ramAssemblyLineStations = await prisma.ramAssemblyLineStations.findMany({ take: 10 })
     * 
     * // Only select the `stationID`
     * const ramAssemblyLineStationsWithStationIDOnly = await prisma.ramAssemblyLineStations.findMany({ select: { stationID: true } })
     * 
    **/
    findMany<T extends ramAssemblyLineStationsFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ramAssemblyLineStationsFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ramAssemblyLineStationsPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a RamAssemblyLineStations.
     * @param {ramAssemblyLineStationsCreateArgs} args - Arguments to create a RamAssemblyLineStations.
     * @example
     * // Create one RamAssemblyLineStations
     * const RamAssemblyLineStations = await prisma.ramAssemblyLineStations.create({
     *   data: {
     *     // ... data to create a RamAssemblyLineStations
     *   }
     * })
     * 
    **/
    create<T extends ramAssemblyLineStationsCreateArgs<ExtArgs>>(
      args: SelectSubset<T, ramAssemblyLineStationsCreateArgs<ExtArgs>>
    ): Prisma__ramAssemblyLineStationsClient<$Result.GetResult<Prisma.$ramAssemblyLineStationsPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many RamAssemblyLineStations.
     *     @param {ramAssemblyLineStationsCreateManyArgs} args - Arguments to create many RamAssemblyLineStations.
     *     @example
     *     // Create many RamAssemblyLineStations
     *     const ramAssemblyLineStations = await prisma.ramAssemblyLineStations.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ramAssemblyLineStationsCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ramAssemblyLineStationsCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a RamAssemblyLineStations.
     * @param {ramAssemblyLineStationsDeleteArgs} args - Arguments to delete one RamAssemblyLineStations.
     * @example
     * // Delete one RamAssemblyLineStations
     * const RamAssemblyLineStations = await prisma.ramAssemblyLineStations.delete({
     *   where: {
     *     // ... filter to delete one RamAssemblyLineStations
     *   }
     * })
     * 
    **/
    delete<T extends ramAssemblyLineStationsDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, ramAssemblyLineStationsDeleteArgs<ExtArgs>>
    ): Prisma__ramAssemblyLineStationsClient<$Result.GetResult<Prisma.$ramAssemblyLineStationsPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one RamAssemblyLineStations.
     * @param {ramAssemblyLineStationsUpdateArgs} args - Arguments to update one RamAssemblyLineStations.
     * @example
     * // Update one RamAssemblyLineStations
     * const ramAssemblyLineStations = await prisma.ramAssemblyLineStations.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ramAssemblyLineStationsUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, ramAssemblyLineStationsUpdateArgs<ExtArgs>>
    ): Prisma__ramAssemblyLineStationsClient<$Result.GetResult<Prisma.$ramAssemblyLineStationsPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more RamAssemblyLineStations.
     * @param {ramAssemblyLineStationsDeleteManyArgs} args - Arguments to filter RamAssemblyLineStations to delete.
     * @example
     * // Delete a few RamAssemblyLineStations
     * const { count } = await prisma.ramAssemblyLineStations.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ramAssemblyLineStationsDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ramAssemblyLineStationsDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RamAssemblyLineStations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ramAssemblyLineStationsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RamAssemblyLineStations
     * const ramAssemblyLineStations = await prisma.ramAssemblyLineStations.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ramAssemblyLineStationsUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, ramAssemblyLineStationsUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one RamAssemblyLineStations.
     * @param {ramAssemblyLineStationsUpsertArgs} args - Arguments to update or create a RamAssemblyLineStations.
     * @example
     * // Update or create a RamAssemblyLineStations
     * const ramAssemblyLineStations = await prisma.ramAssemblyLineStations.upsert({
     *   create: {
     *     // ... data to create a RamAssemblyLineStations
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RamAssemblyLineStations we want to update
     *   }
     * })
    **/
    upsert<T extends ramAssemblyLineStationsUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, ramAssemblyLineStationsUpsertArgs<ExtArgs>>
    ): Prisma__ramAssemblyLineStationsClient<$Result.GetResult<Prisma.$ramAssemblyLineStationsPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of RamAssemblyLineStations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ramAssemblyLineStationsCountArgs} args - Arguments to filter RamAssemblyLineStations to count.
     * @example
     * // Count the number of RamAssemblyLineStations
     * const count = await prisma.ramAssemblyLineStations.count({
     *   where: {
     *     // ... the filter for the RamAssemblyLineStations we want to count
     *   }
     * })
    **/
    count<T extends ramAssemblyLineStationsCountArgs>(
      args?: Subset<T, ramAssemblyLineStationsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RamAssemblyLineStationsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RamAssemblyLineStations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RamAssemblyLineStationsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RamAssemblyLineStationsAggregateArgs>(args: Subset<T, RamAssemblyLineStationsAggregateArgs>): Prisma.PrismaPromise<GetRamAssemblyLineStationsAggregateType<T>>

    /**
     * Group by RamAssemblyLineStations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ramAssemblyLineStationsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ramAssemblyLineStationsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ramAssemblyLineStationsGroupByArgs['orderBy'] }
        : { orderBy?: ramAssemblyLineStationsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ramAssemblyLineStationsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRamAssemblyLineStationsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ramAssemblyLineStations model
   */
  readonly fields: ramAssemblyLineStationsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ramAssemblyLineStations.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ramAssemblyLineStationsClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';


    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the ramAssemblyLineStations model
   */ 
  interface ramAssemblyLineStationsFieldRefs {
    readonly stationID: FieldRef<"ramAssemblyLineStations", 'Int'>
    readonly assemblyLineTypeID: FieldRef<"ramAssemblyLineStations", 'Int'>
    readonly quantity: FieldRef<"ramAssemblyLineStations", 'Int'>
    readonly stationTypeID: FieldRef<"ramAssemblyLineStations", 'Int'>
    readonly ownerID: FieldRef<"ramAssemblyLineStations", 'Int'>
    readonly solarSystemID: FieldRef<"ramAssemblyLineStations", 'Int'>
    readonly regionID: FieldRef<"ramAssemblyLineStations", 'Int'>
  }
    

  // Custom InputTypes

  /**
   * ramAssemblyLineStations findUnique
   */
  export type ramAssemblyLineStationsFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ramAssemblyLineStations
     */
    select?: ramAssemblyLineStationsSelect<ExtArgs> | null
    /**
     * Filter, which ramAssemblyLineStations to fetch.
     */
    where: ramAssemblyLineStationsWhereUniqueInput
  }


  /**
   * ramAssemblyLineStations findUniqueOrThrow
   */
  export type ramAssemblyLineStationsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ramAssemblyLineStations
     */
    select?: ramAssemblyLineStationsSelect<ExtArgs> | null
    /**
     * Filter, which ramAssemblyLineStations to fetch.
     */
    where: ramAssemblyLineStationsWhereUniqueInput
  }


  /**
   * ramAssemblyLineStations findFirst
   */
  export type ramAssemblyLineStationsFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ramAssemblyLineStations
     */
    select?: ramAssemblyLineStationsSelect<ExtArgs> | null
    /**
     * Filter, which ramAssemblyLineStations to fetch.
     */
    where?: ramAssemblyLineStationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ramAssemblyLineStations to fetch.
     */
    orderBy?: ramAssemblyLineStationsOrderByWithRelationInput | ramAssemblyLineStationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ramAssemblyLineStations.
     */
    cursor?: ramAssemblyLineStationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ramAssemblyLineStations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ramAssemblyLineStations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ramAssemblyLineStations.
     */
    distinct?: RamAssemblyLineStationsScalarFieldEnum | RamAssemblyLineStationsScalarFieldEnum[]
  }


  /**
   * ramAssemblyLineStations findFirstOrThrow
   */
  export type ramAssemblyLineStationsFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ramAssemblyLineStations
     */
    select?: ramAssemblyLineStationsSelect<ExtArgs> | null
    /**
     * Filter, which ramAssemblyLineStations to fetch.
     */
    where?: ramAssemblyLineStationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ramAssemblyLineStations to fetch.
     */
    orderBy?: ramAssemblyLineStationsOrderByWithRelationInput | ramAssemblyLineStationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ramAssemblyLineStations.
     */
    cursor?: ramAssemblyLineStationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ramAssemblyLineStations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ramAssemblyLineStations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ramAssemblyLineStations.
     */
    distinct?: RamAssemblyLineStationsScalarFieldEnum | RamAssemblyLineStationsScalarFieldEnum[]
  }


  /**
   * ramAssemblyLineStations findMany
   */
  export type ramAssemblyLineStationsFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ramAssemblyLineStations
     */
    select?: ramAssemblyLineStationsSelect<ExtArgs> | null
    /**
     * Filter, which ramAssemblyLineStations to fetch.
     */
    where?: ramAssemblyLineStationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ramAssemblyLineStations to fetch.
     */
    orderBy?: ramAssemblyLineStationsOrderByWithRelationInput | ramAssemblyLineStationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ramAssemblyLineStations.
     */
    cursor?: ramAssemblyLineStationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ramAssemblyLineStations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ramAssemblyLineStations.
     */
    skip?: number
    distinct?: RamAssemblyLineStationsScalarFieldEnum | RamAssemblyLineStationsScalarFieldEnum[]
  }


  /**
   * ramAssemblyLineStations create
   */
  export type ramAssemblyLineStationsCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ramAssemblyLineStations
     */
    select?: ramAssemblyLineStationsSelect<ExtArgs> | null
    /**
     * The data needed to create a ramAssemblyLineStations.
     */
    data: XOR<ramAssemblyLineStationsCreateInput, ramAssemblyLineStationsUncheckedCreateInput>
  }


  /**
   * ramAssemblyLineStations createMany
   */
  export type ramAssemblyLineStationsCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ramAssemblyLineStations.
     */
    data: ramAssemblyLineStationsCreateManyInput | ramAssemblyLineStationsCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * ramAssemblyLineStations update
   */
  export type ramAssemblyLineStationsUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ramAssemblyLineStations
     */
    select?: ramAssemblyLineStationsSelect<ExtArgs> | null
    /**
     * The data needed to update a ramAssemblyLineStations.
     */
    data: XOR<ramAssemblyLineStationsUpdateInput, ramAssemblyLineStationsUncheckedUpdateInput>
    /**
     * Choose, which ramAssemblyLineStations to update.
     */
    where: ramAssemblyLineStationsWhereUniqueInput
  }


  /**
   * ramAssemblyLineStations updateMany
   */
  export type ramAssemblyLineStationsUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ramAssemblyLineStations.
     */
    data: XOR<ramAssemblyLineStationsUpdateManyMutationInput, ramAssemblyLineStationsUncheckedUpdateManyInput>
    /**
     * Filter which ramAssemblyLineStations to update
     */
    where?: ramAssemblyLineStationsWhereInput
  }


  /**
   * ramAssemblyLineStations upsert
   */
  export type ramAssemblyLineStationsUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ramAssemblyLineStations
     */
    select?: ramAssemblyLineStationsSelect<ExtArgs> | null
    /**
     * The filter to search for the ramAssemblyLineStations to update in case it exists.
     */
    where: ramAssemblyLineStationsWhereUniqueInput
    /**
     * In case the ramAssemblyLineStations found by the `where` argument doesn't exist, create a new ramAssemblyLineStations with this data.
     */
    create: XOR<ramAssemblyLineStationsCreateInput, ramAssemblyLineStationsUncheckedCreateInput>
    /**
     * In case the ramAssemblyLineStations was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ramAssemblyLineStationsUpdateInput, ramAssemblyLineStationsUncheckedUpdateInput>
  }


  /**
   * ramAssemblyLineStations delete
   */
  export type ramAssemblyLineStationsDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ramAssemblyLineStations
     */
    select?: ramAssemblyLineStationsSelect<ExtArgs> | null
    /**
     * Filter which ramAssemblyLineStations to delete.
     */
    where: ramAssemblyLineStationsWhereUniqueInput
  }


  /**
   * ramAssemblyLineStations deleteMany
   */
  export type ramAssemblyLineStationsDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which ramAssemblyLineStations to delete
     */
    where?: ramAssemblyLineStationsWhereInput
  }


  /**
   * ramAssemblyLineStations without action
   */
  export type ramAssemblyLineStationsDefaultArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ramAssemblyLineStations
     */
    select?: ramAssemblyLineStationsSelect<ExtArgs> | null
  }



  /**
   * Model ramAssemblyLineTypeDetailPerCategory
   */

  export type AggregateRamAssemblyLineTypeDetailPerCategory = {
    _count: RamAssemblyLineTypeDetailPerCategoryCountAggregateOutputType | null
    _avg: RamAssemblyLineTypeDetailPerCategoryAvgAggregateOutputType | null
    _sum: RamAssemblyLineTypeDetailPerCategorySumAggregateOutputType | null
    _min: RamAssemblyLineTypeDetailPerCategoryMinAggregateOutputType | null
    _max: RamAssemblyLineTypeDetailPerCategoryMaxAggregateOutputType | null
  }

  export type RamAssemblyLineTypeDetailPerCategoryAvgAggregateOutputType = {
    assemblyLineTypeID: number | null
    categoryID: number | null
    timeMultiplier: number | null
    materialMultiplier: number | null
    costMultiplier: number | null
  }

  export type RamAssemblyLineTypeDetailPerCategorySumAggregateOutputType = {
    assemblyLineTypeID: number | null
    categoryID: number | null
    timeMultiplier: number | null
    materialMultiplier: number | null
    costMultiplier: number | null
  }

  export type RamAssemblyLineTypeDetailPerCategoryMinAggregateOutputType = {
    assemblyLineTypeID: number | null
    categoryID: number | null
    timeMultiplier: number | null
    materialMultiplier: number | null
    costMultiplier: number | null
  }

  export type RamAssemblyLineTypeDetailPerCategoryMaxAggregateOutputType = {
    assemblyLineTypeID: number | null
    categoryID: number | null
    timeMultiplier: number | null
    materialMultiplier: number | null
    costMultiplier: number | null
  }

  export type RamAssemblyLineTypeDetailPerCategoryCountAggregateOutputType = {
    assemblyLineTypeID: number
    categoryID: number
    timeMultiplier: number
    materialMultiplier: number
    costMultiplier: number
    _all: number
  }


  export type RamAssemblyLineTypeDetailPerCategoryAvgAggregateInputType = {
    assemblyLineTypeID?: true
    categoryID?: true
    timeMultiplier?: true
    materialMultiplier?: true
    costMultiplier?: true
  }

  export type RamAssemblyLineTypeDetailPerCategorySumAggregateInputType = {
    assemblyLineTypeID?: true
    categoryID?: true
    timeMultiplier?: true
    materialMultiplier?: true
    costMultiplier?: true
  }

  export type RamAssemblyLineTypeDetailPerCategoryMinAggregateInputType = {
    assemblyLineTypeID?: true
    categoryID?: true
    timeMultiplier?: true
    materialMultiplier?: true
    costMultiplier?: true
  }

  export type RamAssemblyLineTypeDetailPerCategoryMaxAggregateInputType = {
    assemblyLineTypeID?: true
    categoryID?: true
    timeMultiplier?: true
    materialMultiplier?: true
    costMultiplier?: true
  }

  export type RamAssemblyLineTypeDetailPerCategoryCountAggregateInputType = {
    assemblyLineTypeID?: true
    categoryID?: true
    timeMultiplier?: true
    materialMultiplier?: true
    costMultiplier?: true
    _all?: true
  }

  export type RamAssemblyLineTypeDetailPerCategoryAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which ramAssemblyLineTypeDetailPerCategory to aggregate.
     */
    where?: ramAssemblyLineTypeDetailPerCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ramAssemblyLineTypeDetailPerCategories to fetch.
     */
    orderBy?: ramAssemblyLineTypeDetailPerCategoryOrderByWithRelationInput | ramAssemblyLineTypeDetailPerCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ramAssemblyLineTypeDetailPerCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ramAssemblyLineTypeDetailPerCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ramAssemblyLineTypeDetailPerCategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ramAssemblyLineTypeDetailPerCategories
    **/
    _count?: true | RamAssemblyLineTypeDetailPerCategoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RamAssemblyLineTypeDetailPerCategoryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RamAssemblyLineTypeDetailPerCategorySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RamAssemblyLineTypeDetailPerCategoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RamAssemblyLineTypeDetailPerCategoryMaxAggregateInputType
  }

  export type GetRamAssemblyLineTypeDetailPerCategoryAggregateType<T extends RamAssemblyLineTypeDetailPerCategoryAggregateArgs> = {
        [P in keyof T & keyof AggregateRamAssemblyLineTypeDetailPerCategory]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRamAssemblyLineTypeDetailPerCategory[P]>
      : GetScalarType<T[P], AggregateRamAssemblyLineTypeDetailPerCategory[P]>
  }




  export type ramAssemblyLineTypeDetailPerCategoryGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: ramAssemblyLineTypeDetailPerCategoryWhereInput
    orderBy?: ramAssemblyLineTypeDetailPerCategoryOrderByWithAggregationInput | ramAssemblyLineTypeDetailPerCategoryOrderByWithAggregationInput[]
    by: RamAssemblyLineTypeDetailPerCategoryScalarFieldEnum[] | RamAssemblyLineTypeDetailPerCategoryScalarFieldEnum
    having?: ramAssemblyLineTypeDetailPerCategoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RamAssemblyLineTypeDetailPerCategoryCountAggregateInputType | true
    _avg?: RamAssemblyLineTypeDetailPerCategoryAvgAggregateInputType
    _sum?: RamAssemblyLineTypeDetailPerCategorySumAggregateInputType
    _min?: RamAssemblyLineTypeDetailPerCategoryMinAggregateInputType
    _max?: RamAssemblyLineTypeDetailPerCategoryMaxAggregateInputType
  }

  export type RamAssemblyLineTypeDetailPerCategoryGroupByOutputType = {
    assemblyLineTypeID: number
    categoryID: number
    timeMultiplier: number | null
    materialMultiplier: number | null
    costMultiplier: number | null
    _count: RamAssemblyLineTypeDetailPerCategoryCountAggregateOutputType | null
    _avg: RamAssemblyLineTypeDetailPerCategoryAvgAggregateOutputType | null
    _sum: RamAssemblyLineTypeDetailPerCategorySumAggregateOutputType | null
    _min: RamAssemblyLineTypeDetailPerCategoryMinAggregateOutputType | null
    _max: RamAssemblyLineTypeDetailPerCategoryMaxAggregateOutputType | null
  }

  type GetRamAssemblyLineTypeDetailPerCategoryGroupByPayload<T extends ramAssemblyLineTypeDetailPerCategoryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RamAssemblyLineTypeDetailPerCategoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RamAssemblyLineTypeDetailPerCategoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RamAssemblyLineTypeDetailPerCategoryGroupByOutputType[P]>
            : GetScalarType<T[P], RamAssemblyLineTypeDetailPerCategoryGroupByOutputType[P]>
        }
      >
    >


  export type ramAssemblyLineTypeDetailPerCategorySelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    assemblyLineTypeID?: boolean
    categoryID?: boolean
    timeMultiplier?: boolean
    materialMultiplier?: boolean
    costMultiplier?: boolean
  }, ExtArgs["result"]["ramAssemblyLineTypeDetailPerCategory"]>

  export type ramAssemblyLineTypeDetailPerCategorySelectScalar = {
    assemblyLineTypeID?: boolean
    categoryID?: boolean
    timeMultiplier?: boolean
    materialMultiplier?: boolean
    costMultiplier?: boolean
  }


  export type $ramAssemblyLineTypeDetailPerCategoryPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    name: "ramAssemblyLineTypeDetailPerCategory"
    objects: {}
    scalars: $Extensions.GetResult<{
      assemblyLineTypeID: number
      categoryID: number
      timeMultiplier: number | null
      materialMultiplier: number | null
      costMultiplier: number | null
    }, ExtArgs["result"]["ramAssemblyLineTypeDetailPerCategory"]>
    composites: {}
  }


  type ramAssemblyLineTypeDetailPerCategoryGetPayload<S extends boolean | null | undefined | ramAssemblyLineTypeDetailPerCategoryDefaultArgs> = $Result.GetResult<Prisma.$ramAssemblyLineTypeDetailPerCategoryPayload, S>

  type ramAssemblyLineTypeDetailPerCategoryCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<ramAssemblyLineTypeDetailPerCategoryFindManyArgs, 'select' | 'include'> & {
      select?: RamAssemblyLineTypeDetailPerCategoryCountAggregateInputType | true
    }

  export interface ramAssemblyLineTypeDetailPerCategoryDelegate<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ramAssemblyLineTypeDetailPerCategory'], meta: { name: 'ramAssemblyLineTypeDetailPerCategory' } }
    /**
     * Find zero or one RamAssemblyLineTypeDetailPerCategory that matches the filter.
     * @param {ramAssemblyLineTypeDetailPerCategoryFindUniqueArgs} args - Arguments to find a RamAssemblyLineTypeDetailPerCategory
     * @example
     * // Get one RamAssemblyLineTypeDetailPerCategory
     * const ramAssemblyLineTypeDetailPerCategory = await prisma.ramAssemblyLineTypeDetailPerCategory.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ramAssemblyLineTypeDetailPerCategoryFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, ramAssemblyLineTypeDetailPerCategoryFindUniqueArgs<ExtArgs>>
    ): Prisma__ramAssemblyLineTypeDetailPerCategoryClient<$Result.GetResult<Prisma.$ramAssemblyLineTypeDetailPerCategoryPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one RamAssemblyLineTypeDetailPerCategory that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {ramAssemblyLineTypeDetailPerCategoryFindUniqueOrThrowArgs} args - Arguments to find a RamAssemblyLineTypeDetailPerCategory
     * @example
     * // Get one RamAssemblyLineTypeDetailPerCategory
     * const ramAssemblyLineTypeDetailPerCategory = await prisma.ramAssemblyLineTypeDetailPerCategory.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends ramAssemblyLineTypeDetailPerCategoryFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ramAssemblyLineTypeDetailPerCategoryFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__ramAssemblyLineTypeDetailPerCategoryClient<$Result.GetResult<Prisma.$ramAssemblyLineTypeDetailPerCategoryPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first RamAssemblyLineTypeDetailPerCategory that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ramAssemblyLineTypeDetailPerCategoryFindFirstArgs} args - Arguments to find a RamAssemblyLineTypeDetailPerCategory
     * @example
     * // Get one RamAssemblyLineTypeDetailPerCategory
     * const ramAssemblyLineTypeDetailPerCategory = await prisma.ramAssemblyLineTypeDetailPerCategory.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ramAssemblyLineTypeDetailPerCategoryFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, ramAssemblyLineTypeDetailPerCategoryFindFirstArgs<ExtArgs>>
    ): Prisma__ramAssemblyLineTypeDetailPerCategoryClient<$Result.GetResult<Prisma.$ramAssemblyLineTypeDetailPerCategoryPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first RamAssemblyLineTypeDetailPerCategory that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ramAssemblyLineTypeDetailPerCategoryFindFirstOrThrowArgs} args - Arguments to find a RamAssemblyLineTypeDetailPerCategory
     * @example
     * // Get one RamAssemblyLineTypeDetailPerCategory
     * const ramAssemblyLineTypeDetailPerCategory = await prisma.ramAssemblyLineTypeDetailPerCategory.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends ramAssemblyLineTypeDetailPerCategoryFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ramAssemblyLineTypeDetailPerCategoryFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__ramAssemblyLineTypeDetailPerCategoryClient<$Result.GetResult<Prisma.$ramAssemblyLineTypeDetailPerCategoryPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more RamAssemblyLineTypeDetailPerCategories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ramAssemblyLineTypeDetailPerCategoryFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RamAssemblyLineTypeDetailPerCategories
     * const ramAssemblyLineTypeDetailPerCategories = await prisma.ramAssemblyLineTypeDetailPerCategory.findMany()
     * 
     * // Get first 10 RamAssemblyLineTypeDetailPerCategories
     * const ramAssemblyLineTypeDetailPerCategories = await prisma.ramAssemblyLineTypeDetailPerCategory.findMany({ take: 10 })
     * 
     * // Only select the `assemblyLineTypeID`
     * const ramAssemblyLineTypeDetailPerCategoryWithAssemblyLineTypeIDOnly = await prisma.ramAssemblyLineTypeDetailPerCategory.findMany({ select: { assemblyLineTypeID: true } })
     * 
    **/
    findMany<T extends ramAssemblyLineTypeDetailPerCategoryFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ramAssemblyLineTypeDetailPerCategoryFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ramAssemblyLineTypeDetailPerCategoryPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a RamAssemblyLineTypeDetailPerCategory.
     * @param {ramAssemblyLineTypeDetailPerCategoryCreateArgs} args - Arguments to create a RamAssemblyLineTypeDetailPerCategory.
     * @example
     * // Create one RamAssemblyLineTypeDetailPerCategory
     * const RamAssemblyLineTypeDetailPerCategory = await prisma.ramAssemblyLineTypeDetailPerCategory.create({
     *   data: {
     *     // ... data to create a RamAssemblyLineTypeDetailPerCategory
     *   }
     * })
     * 
    **/
    create<T extends ramAssemblyLineTypeDetailPerCategoryCreateArgs<ExtArgs>>(
      args: SelectSubset<T, ramAssemblyLineTypeDetailPerCategoryCreateArgs<ExtArgs>>
    ): Prisma__ramAssemblyLineTypeDetailPerCategoryClient<$Result.GetResult<Prisma.$ramAssemblyLineTypeDetailPerCategoryPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many RamAssemblyLineTypeDetailPerCategories.
     *     @param {ramAssemblyLineTypeDetailPerCategoryCreateManyArgs} args - Arguments to create many RamAssemblyLineTypeDetailPerCategories.
     *     @example
     *     // Create many RamAssemblyLineTypeDetailPerCategories
     *     const ramAssemblyLineTypeDetailPerCategory = await prisma.ramAssemblyLineTypeDetailPerCategory.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ramAssemblyLineTypeDetailPerCategoryCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ramAssemblyLineTypeDetailPerCategoryCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a RamAssemblyLineTypeDetailPerCategory.
     * @param {ramAssemblyLineTypeDetailPerCategoryDeleteArgs} args - Arguments to delete one RamAssemblyLineTypeDetailPerCategory.
     * @example
     * // Delete one RamAssemblyLineTypeDetailPerCategory
     * const RamAssemblyLineTypeDetailPerCategory = await prisma.ramAssemblyLineTypeDetailPerCategory.delete({
     *   where: {
     *     // ... filter to delete one RamAssemblyLineTypeDetailPerCategory
     *   }
     * })
     * 
    **/
    delete<T extends ramAssemblyLineTypeDetailPerCategoryDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, ramAssemblyLineTypeDetailPerCategoryDeleteArgs<ExtArgs>>
    ): Prisma__ramAssemblyLineTypeDetailPerCategoryClient<$Result.GetResult<Prisma.$ramAssemblyLineTypeDetailPerCategoryPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one RamAssemblyLineTypeDetailPerCategory.
     * @param {ramAssemblyLineTypeDetailPerCategoryUpdateArgs} args - Arguments to update one RamAssemblyLineTypeDetailPerCategory.
     * @example
     * // Update one RamAssemblyLineTypeDetailPerCategory
     * const ramAssemblyLineTypeDetailPerCategory = await prisma.ramAssemblyLineTypeDetailPerCategory.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ramAssemblyLineTypeDetailPerCategoryUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, ramAssemblyLineTypeDetailPerCategoryUpdateArgs<ExtArgs>>
    ): Prisma__ramAssemblyLineTypeDetailPerCategoryClient<$Result.GetResult<Prisma.$ramAssemblyLineTypeDetailPerCategoryPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more RamAssemblyLineTypeDetailPerCategories.
     * @param {ramAssemblyLineTypeDetailPerCategoryDeleteManyArgs} args - Arguments to filter RamAssemblyLineTypeDetailPerCategories to delete.
     * @example
     * // Delete a few RamAssemblyLineTypeDetailPerCategories
     * const { count } = await prisma.ramAssemblyLineTypeDetailPerCategory.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ramAssemblyLineTypeDetailPerCategoryDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ramAssemblyLineTypeDetailPerCategoryDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RamAssemblyLineTypeDetailPerCategories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ramAssemblyLineTypeDetailPerCategoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RamAssemblyLineTypeDetailPerCategories
     * const ramAssemblyLineTypeDetailPerCategory = await prisma.ramAssemblyLineTypeDetailPerCategory.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ramAssemblyLineTypeDetailPerCategoryUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, ramAssemblyLineTypeDetailPerCategoryUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one RamAssemblyLineTypeDetailPerCategory.
     * @param {ramAssemblyLineTypeDetailPerCategoryUpsertArgs} args - Arguments to update or create a RamAssemblyLineTypeDetailPerCategory.
     * @example
     * // Update or create a RamAssemblyLineTypeDetailPerCategory
     * const ramAssemblyLineTypeDetailPerCategory = await prisma.ramAssemblyLineTypeDetailPerCategory.upsert({
     *   create: {
     *     // ... data to create a RamAssemblyLineTypeDetailPerCategory
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RamAssemblyLineTypeDetailPerCategory we want to update
     *   }
     * })
    **/
    upsert<T extends ramAssemblyLineTypeDetailPerCategoryUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, ramAssemblyLineTypeDetailPerCategoryUpsertArgs<ExtArgs>>
    ): Prisma__ramAssemblyLineTypeDetailPerCategoryClient<$Result.GetResult<Prisma.$ramAssemblyLineTypeDetailPerCategoryPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of RamAssemblyLineTypeDetailPerCategories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ramAssemblyLineTypeDetailPerCategoryCountArgs} args - Arguments to filter RamAssemblyLineTypeDetailPerCategories to count.
     * @example
     * // Count the number of RamAssemblyLineTypeDetailPerCategories
     * const count = await prisma.ramAssemblyLineTypeDetailPerCategory.count({
     *   where: {
     *     // ... the filter for the RamAssemblyLineTypeDetailPerCategories we want to count
     *   }
     * })
    **/
    count<T extends ramAssemblyLineTypeDetailPerCategoryCountArgs>(
      args?: Subset<T, ramAssemblyLineTypeDetailPerCategoryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RamAssemblyLineTypeDetailPerCategoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RamAssemblyLineTypeDetailPerCategory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RamAssemblyLineTypeDetailPerCategoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RamAssemblyLineTypeDetailPerCategoryAggregateArgs>(args: Subset<T, RamAssemblyLineTypeDetailPerCategoryAggregateArgs>): Prisma.PrismaPromise<GetRamAssemblyLineTypeDetailPerCategoryAggregateType<T>>

    /**
     * Group by RamAssemblyLineTypeDetailPerCategory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ramAssemblyLineTypeDetailPerCategoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ramAssemblyLineTypeDetailPerCategoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ramAssemblyLineTypeDetailPerCategoryGroupByArgs['orderBy'] }
        : { orderBy?: ramAssemblyLineTypeDetailPerCategoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ramAssemblyLineTypeDetailPerCategoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRamAssemblyLineTypeDetailPerCategoryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ramAssemblyLineTypeDetailPerCategory model
   */
  readonly fields: ramAssemblyLineTypeDetailPerCategoryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ramAssemblyLineTypeDetailPerCategory.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ramAssemblyLineTypeDetailPerCategoryClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';


    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the ramAssemblyLineTypeDetailPerCategory model
   */ 
  interface ramAssemblyLineTypeDetailPerCategoryFieldRefs {
    readonly assemblyLineTypeID: FieldRef<"ramAssemblyLineTypeDetailPerCategory", 'Int'>
    readonly categoryID: FieldRef<"ramAssemblyLineTypeDetailPerCategory", 'Int'>
    readonly timeMultiplier: FieldRef<"ramAssemblyLineTypeDetailPerCategory", 'Float'>
    readonly materialMultiplier: FieldRef<"ramAssemblyLineTypeDetailPerCategory", 'Float'>
    readonly costMultiplier: FieldRef<"ramAssemblyLineTypeDetailPerCategory", 'Float'>
  }
    

  // Custom InputTypes

  /**
   * ramAssemblyLineTypeDetailPerCategory findUnique
   */
  export type ramAssemblyLineTypeDetailPerCategoryFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ramAssemblyLineTypeDetailPerCategory
     */
    select?: ramAssemblyLineTypeDetailPerCategorySelect<ExtArgs> | null
    /**
     * Filter, which ramAssemblyLineTypeDetailPerCategory to fetch.
     */
    where: ramAssemblyLineTypeDetailPerCategoryWhereUniqueInput
  }


  /**
   * ramAssemblyLineTypeDetailPerCategory findUniqueOrThrow
   */
  export type ramAssemblyLineTypeDetailPerCategoryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ramAssemblyLineTypeDetailPerCategory
     */
    select?: ramAssemblyLineTypeDetailPerCategorySelect<ExtArgs> | null
    /**
     * Filter, which ramAssemblyLineTypeDetailPerCategory to fetch.
     */
    where: ramAssemblyLineTypeDetailPerCategoryWhereUniqueInput
  }


  /**
   * ramAssemblyLineTypeDetailPerCategory findFirst
   */
  export type ramAssemblyLineTypeDetailPerCategoryFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ramAssemblyLineTypeDetailPerCategory
     */
    select?: ramAssemblyLineTypeDetailPerCategorySelect<ExtArgs> | null
    /**
     * Filter, which ramAssemblyLineTypeDetailPerCategory to fetch.
     */
    where?: ramAssemblyLineTypeDetailPerCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ramAssemblyLineTypeDetailPerCategories to fetch.
     */
    orderBy?: ramAssemblyLineTypeDetailPerCategoryOrderByWithRelationInput | ramAssemblyLineTypeDetailPerCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ramAssemblyLineTypeDetailPerCategories.
     */
    cursor?: ramAssemblyLineTypeDetailPerCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ramAssemblyLineTypeDetailPerCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ramAssemblyLineTypeDetailPerCategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ramAssemblyLineTypeDetailPerCategories.
     */
    distinct?: RamAssemblyLineTypeDetailPerCategoryScalarFieldEnum | RamAssemblyLineTypeDetailPerCategoryScalarFieldEnum[]
  }


  /**
   * ramAssemblyLineTypeDetailPerCategory findFirstOrThrow
   */
  export type ramAssemblyLineTypeDetailPerCategoryFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ramAssemblyLineTypeDetailPerCategory
     */
    select?: ramAssemblyLineTypeDetailPerCategorySelect<ExtArgs> | null
    /**
     * Filter, which ramAssemblyLineTypeDetailPerCategory to fetch.
     */
    where?: ramAssemblyLineTypeDetailPerCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ramAssemblyLineTypeDetailPerCategories to fetch.
     */
    orderBy?: ramAssemblyLineTypeDetailPerCategoryOrderByWithRelationInput | ramAssemblyLineTypeDetailPerCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ramAssemblyLineTypeDetailPerCategories.
     */
    cursor?: ramAssemblyLineTypeDetailPerCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ramAssemblyLineTypeDetailPerCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ramAssemblyLineTypeDetailPerCategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ramAssemblyLineTypeDetailPerCategories.
     */
    distinct?: RamAssemblyLineTypeDetailPerCategoryScalarFieldEnum | RamAssemblyLineTypeDetailPerCategoryScalarFieldEnum[]
  }


  /**
   * ramAssemblyLineTypeDetailPerCategory findMany
   */
  export type ramAssemblyLineTypeDetailPerCategoryFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ramAssemblyLineTypeDetailPerCategory
     */
    select?: ramAssemblyLineTypeDetailPerCategorySelect<ExtArgs> | null
    /**
     * Filter, which ramAssemblyLineTypeDetailPerCategories to fetch.
     */
    where?: ramAssemblyLineTypeDetailPerCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ramAssemblyLineTypeDetailPerCategories to fetch.
     */
    orderBy?: ramAssemblyLineTypeDetailPerCategoryOrderByWithRelationInput | ramAssemblyLineTypeDetailPerCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ramAssemblyLineTypeDetailPerCategories.
     */
    cursor?: ramAssemblyLineTypeDetailPerCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ramAssemblyLineTypeDetailPerCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ramAssemblyLineTypeDetailPerCategories.
     */
    skip?: number
    distinct?: RamAssemblyLineTypeDetailPerCategoryScalarFieldEnum | RamAssemblyLineTypeDetailPerCategoryScalarFieldEnum[]
  }


  /**
   * ramAssemblyLineTypeDetailPerCategory create
   */
  export type ramAssemblyLineTypeDetailPerCategoryCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ramAssemblyLineTypeDetailPerCategory
     */
    select?: ramAssemblyLineTypeDetailPerCategorySelect<ExtArgs> | null
    /**
     * The data needed to create a ramAssemblyLineTypeDetailPerCategory.
     */
    data: XOR<ramAssemblyLineTypeDetailPerCategoryCreateInput, ramAssemblyLineTypeDetailPerCategoryUncheckedCreateInput>
  }


  /**
   * ramAssemblyLineTypeDetailPerCategory createMany
   */
  export type ramAssemblyLineTypeDetailPerCategoryCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ramAssemblyLineTypeDetailPerCategories.
     */
    data: ramAssemblyLineTypeDetailPerCategoryCreateManyInput | ramAssemblyLineTypeDetailPerCategoryCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * ramAssemblyLineTypeDetailPerCategory update
   */
  export type ramAssemblyLineTypeDetailPerCategoryUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ramAssemblyLineTypeDetailPerCategory
     */
    select?: ramAssemblyLineTypeDetailPerCategorySelect<ExtArgs> | null
    /**
     * The data needed to update a ramAssemblyLineTypeDetailPerCategory.
     */
    data: XOR<ramAssemblyLineTypeDetailPerCategoryUpdateInput, ramAssemblyLineTypeDetailPerCategoryUncheckedUpdateInput>
    /**
     * Choose, which ramAssemblyLineTypeDetailPerCategory to update.
     */
    where: ramAssemblyLineTypeDetailPerCategoryWhereUniqueInput
  }


  /**
   * ramAssemblyLineTypeDetailPerCategory updateMany
   */
  export type ramAssemblyLineTypeDetailPerCategoryUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ramAssemblyLineTypeDetailPerCategories.
     */
    data: XOR<ramAssemblyLineTypeDetailPerCategoryUpdateManyMutationInput, ramAssemblyLineTypeDetailPerCategoryUncheckedUpdateManyInput>
    /**
     * Filter which ramAssemblyLineTypeDetailPerCategories to update
     */
    where?: ramAssemblyLineTypeDetailPerCategoryWhereInput
  }


  /**
   * ramAssemblyLineTypeDetailPerCategory upsert
   */
  export type ramAssemblyLineTypeDetailPerCategoryUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ramAssemblyLineTypeDetailPerCategory
     */
    select?: ramAssemblyLineTypeDetailPerCategorySelect<ExtArgs> | null
    /**
     * The filter to search for the ramAssemblyLineTypeDetailPerCategory to update in case it exists.
     */
    where: ramAssemblyLineTypeDetailPerCategoryWhereUniqueInput
    /**
     * In case the ramAssemblyLineTypeDetailPerCategory found by the `where` argument doesn't exist, create a new ramAssemblyLineTypeDetailPerCategory with this data.
     */
    create: XOR<ramAssemblyLineTypeDetailPerCategoryCreateInput, ramAssemblyLineTypeDetailPerCategoryUncheckedCreateInput>
    /**
     * In case the ramAssemblyLineTypeDetailPerCategory was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ramAssemblyLineTypeDetailPerCategoryUpdateInput, ramAssemblyLineTypeDetailPerCategoryUncheckedUpdateInput>
  }


  /**
   * ramAssemblyLineTypeDetailPerCategory delete
   */
  export type ramAssemblyLineTypeDetailPerCategoryDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ramAssemblyLineTypeDetailPerCategory
     */
    select?: ramAssemblyLineTypeDetailPerCategorySelect<ExtArgs> | null
    /**
     * Filter which ramAssemblyLineTypeDetailPerCategory to delete.
     */
    where: ramAssemblyLineTypeDetailPerCategoryWhereUniqueInput
  }


  /**
   * ramAssemblyLineTypeDetailPerCategory deleteMany
   */
  export type ramAssemblyLineTypeDetailPerCategoryDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which ramAssemblyLineTypeDetailPerCategories to delete
     */
    where?: ramAssemblyLineTypeDetailPerCategoryWhereInput
  }


  /**
   * ramAssemblyLineTypeDetailPerCategory without action
   */
  export type ramAssemblyLineTypeDetailPerCategoryDefaultArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ramAssemblyLineTypeDetailPerCategory
     */
    select?: ramAssemblyLineTypeDetailPerCategorySelect<ExtArgs> | null
  }



  /**
   * Model ramAssemblyLineTypeDetailPerGroup
   */

  export type AggregateRamAssemblyLineTypeDetailPerGroup = {
    _count: RamAssemblyLineTypeDetailPerGroupCountAggregateOutputType | null
    _avg: RamAssemblyLineTypeDetailPerGroupAvgAggregateOutputType | null
    _sum: RamAssemblyLineTypeDetailPerGroupSumAggregateOutputType | null
    _min: RamAssemblyLineTypeDetailPerGroupMinAggregateOutputType | null
    _max: RamAssemblyLineTypeDetailPerGroupMaxAggregateOutputType | null
  }

  export type RamAssemblyLineTypeDetailPerGroupAvgAggregateOutputType = {
    assemblyLineTypeID: number | null
    groupID: number | null
    timeMultiplier: number | null
    materialMultiplier: number | null
    costMultiplier: number | null
  }

  export type RamAssemblyLineTypeDetailPerGroupSumAggregateOutputType = {
    assemblyLineTypeID: number | null
    groupID: number | null
    timeMultiplier: number | null
    materialMultiplier: number | null
    costMultiplier: number | null
  }

  export type RamAssemblyLineTypeDetailPerGroupMinAggregateOutputType = {
    assemblyLineTypeID: number | null
    groupID: number | null
    timeMultiplier: number | null
    materialMultiplier: number | null
    costMultiplier: number | null
  }

  export type RamAssemblyLineTypeDetailPerGroupMaxAggregateOutputType = {
    assemblyLineTypeID: number | null
    groupID: number | null
    timeMultiplier: number | null
    materialMultiplier: number | null
    costMultiplier: number | null
  }

  export type RamAssemblyLineTypeDetailPerGroupCountAggregateOutputType = {
    assemblyLineTypeID: number
    groupID: number
    timeMultiplier: number
    materialMultiplier: number
    costMultiplier: number
    _all: number
  }


  export type RamAssemblyLineTypeDetailPerGroupAvgAggregateInputType = {
    assemblyLineTypeID?: true
    groupID?: true
    timeMultiplier?: true
    materialMultiplier?: true
    costMultiplier?: true
  }

  export type RamAssemblyLineTypeDetailPerGroupSumAggregateInputType = {
    assemblyLineTypeID?: true
    groupID?: true
    timeMultiplier?: true
    materialMultiplier?: true
    costMultiplier?: true
  }

  export type RamAssemblyLineTypeDetailPerGroupMinAggregateInputType = {
    assemblyLineTypeID?: true
    groupID?: true
    timeMultiplier?: true
    materialMultiplier?: true
    costMultiplier?: true
  }

  export type RamAssemblyLineTypeDetailPerGroupMaxAggregateInputType = {
    assemblyLineTypeID?: true
    groupID?: true
    timeMultiplier?: true
    materialMultiplier?: true
    costMultiplier?: true
  }

  export type RamAssemblyLineTypeDetailPerGroupCountAggregateInputType = {
    assemblyLineTypeID?: true
    groupID?: true
    timeMultiplier?: true
    materialMultiplier?: true
    costMultiplier?: true
    _all?: true
  }

  export type RamAssemblyLineTypeDetailPerGroupAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which ramAssemblyLineTypeDetailPerGroup to aggregate.
     */
    where?: ramAssemblyLineTypeDetailPerGroupWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ramAssemblyLineTypeDetailPerGroups to fetch.
     */
    orderBy?: ramAssemblyLineTypeDetailPerGroupOrderByWithRelationInput | ramAssemblyLineTypeDetailPerGroupOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ramAssemblyLineTypeDetailPerGroupWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ramAssemblyLineTypeDetailPerGroups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ramAssemblyLineTypeDetailPerGroups.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ramAssemblyLineTypeDetailPerGroups
    **/
    _count?: true | RamAssemblyLineTypeDetailPerGroupCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RamAssemblyLineTypeDetailPerGroupAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RamAssemblyLineTypeDetailPerGroupSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RamAssemblyLineTypeDetailPerGroupMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RamAssemblyLineTypeDetailPerGroupMaxAggregateInputType
  }

  export type GetRamAssemblyLineTypeDetailPerGroupAggregateType<T extends RamAssemblyLineTypeDetailPerGroupAggregateArgs> = {
        [P in keyof T & keyof AggregateRamAssemblyLineTypeDetailPerGroup]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRamAssemblyLineTypeDetailPerGroup[P]>
      : GetScalarType<T[P], AggregateRamAssemblyLineTypeDetailPerGroup[P]>
  }




  export type ramAssemblyLineTypeDetailPerGroupGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: ramAssemblyLineTypeDetailPerGroupWhereInput
    orderBy?: ramAssemblyLineTypeDetailPerGroupOrderByWithAggregationInput | ramAssemblyLineTypeDetailPerGroupOrderByWithAggregationInput[]
    by: RamAssemblyLineTypeDetailPerGroupScalarFieldEnum[] | RamAssemblyLineTypeDetailPerGroupScalarFieldEnum
    having?: ramAssemblyLineTypeDetailPerGroupScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RamAssemblyLineTypeDetailPerGroupCountAggregateInputType | true
    _avg?: RamAssemblyLineTypeDetailPerGroupAvgAggregateInputType
    _sum?: RamAssemblyLineTypeDetailPerGroupSumAggregateInputType
    _min?: RamAssemblyLineTypeDetailPerGroupMinAggregateInputType
    _max?: RamAssemblyLineTypeDetailPerGroupMaxAggregateInputType
  }

  export type RamAssemblyLineTypeDetailPerGroupGroupByOutputType = {
    assemblyLineTypeID: number
    groupID: number
    timeMultiplier: number | null
    materialMultiplier: number | null
    costMultiplier: number | null
    _count: RamAssemblyLineTypeDetailPerGroupCountAggregateOutputType | null
    _avg: RamAssemblyLineTypeDetailPerGroupAvgAggregateOutputType | null
    _sum: RamAssemblyLineTypeDetailPerGroupSumAggregateOutputType | null
    _min: RamAssemblyLineTypeDetailPerGroupMinAggregateOutputType | null
    _max: RamAssemblyLineTypeDetailPerGroupMaxAggregateOutputType | null
  }

  type GetRamAssemblyLineTypeDetailPerGroupGroupByPayload<T extends ramAssemblyLineTypeDetailPerGroupGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RamAssemblyLineTypeDetailPerGroupGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RamAssemblyLineTypeDetailPerGroupGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RamAssemblyLineTypeDetailPerGroupGroupByOutputType[P]>
            : GetScalarType<T[P], RamAssemblyLineTypeDetailPerGroupGroupByOutputType[P]>
        }
      >
    >


  export type ramAssemblyLineTypeDetailPerGroupSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    assemblyLineTypeID?: boolean
    groupID?: boolean
    timeMultiplier?: boolean
    materialMultiplier?: boolean
    costMultiplier?: boolean
  }, ExtArgs["result"]["ramAssemblyLineTypeDetailPerGroup"]>

  export type ramAssemblyLineTypeDetailPerGroupSelectScalar = {
    assemblyLineTypeID?: boolean
    groupID?: boolean
    timeMultiplier?: boolean
    materialMultiplier?: boolean
    costMultiplier?: boolean
  }


  export type $ramAssemblyLineTypeDetailPerGroupPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    name: "ramAssemblyLineTypeDetailPerGroup"
    objects: {}
    scalars: $Extensions.GetResult<{
      assemblyLineTypeID: number
      groupID: number
      timeMultiplier: number | null
      materialMultiplier: number | null
      costMultiplier: number | null
    }, ExtArgs["result"]["ramAssemblyLineTypeDetailPerGroup"]>
    composites: {}
  }


  type ramAssemblyLineTypeDetailPerGroupGetPayload<S extends boolean | null | undefined | ramAssemblyLineTypeDetailPerGroupDefaultArgs> = $Result.GetResult<Prisma.$ramAssemblyLineTypeDetailPerGroupPayload, S>

  type ramAssemblyLineTypeDetailPerGroupCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<ramAssemblyLineTypeDetailPerGroupFindManyArgs, 'select' | 'include'> & {
      select?: RamAssemblyLineTypeDetailPerGroupCountAggregateInputType | true
    }

  export interface ramAssemblyLineTypeDetailPerGroupDelegate<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ramAssemblyLineTypeDetailPerGroup'], meta: { name: 'ramAssemblyLineTypeDetailPerGroup' } }
    /**
     * Find zero or one RamAssemblyLineTypeDetailPerGroup that matches the filter.
     * @param {ramAssemblyLineTypeDetailPerGroupFindUniqueArgs} args - Arguments to find a RamAssemblyLineTypeDetailPerGroup
     * @example
     * // Get one RamAssemblyLineTypeDetailPerGroup
     * const ramAssemblyLineTypeDetailPerGroup = await prisma.ramAssemblyLineTypeDetailPerGroup.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ramAssemblyLineTypeDetailPerGroupFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, ramAssemblyLineTypeDetailPerGroupFindUniqueArgs<ExtArgs>>
    ): Prisma__ramAssemblyLineTypeDetailPerGroupClient<$Result.GetResult<Prisma.$ramAssemblyLineTypeDetailPerGroupPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one RamAssemblyLineTypeDetailPerGroup that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {ramAssemblyLineTypeDetailPerGroupFindUniqueOrThrowArgs} args - Arguments to find a RamAssemblyLineTypeDetailPerGroup
     * @example
     * // Get one RamAssemblyLineTypeDetailPerGroup
     * const ramAssemblyLineTypeDetailPerGroup = await prisma.ramAssemblyLineTypeDetailPerGroup.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends ramAssemblyLineTypeDetailPerGroupFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ramAssemblyLineTypeDetailPerGroupFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__ramAssemblyLineTypeDetailPerGroupClient<$Result.GetResult<Prisma.$ramAssemblyLineTypeDetailPerGroupPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first RamAssemblyLineTypeDetailPerGroup that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ramAssemblyLineTypeDetailPerGroupFindFirstArgs} args - Arguments to find a RamAssemblyLineTypeDetailPerGroup
     * @example
     * // Get one RamAssemblyLineTypeDetailPerGroup
     * const ramAssemblyLineTypeDetailPerGroup = await prisma.ramAssemblyLineTypeDetailPerGroup.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ramAssemblyLineTypeDetailPerGroupFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, ramAssemblyLineTypeDetailPerGroupFindFirstArgs<ExtArgs>>
    ): Prisma__ramAssemblyLineTypeDetailPerGroupClient<$Result.GetResult<Prisma.$ramAssemblyLineTypeDetailPerGroupPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first RamAssemblyLineTypeDetailPerGroup that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ramAssemblyLineTypeDetailPerGroupFindFirstOrThrowArgs} args - Arguments to find a RamAssemblyLineTypeDetailPerGroup
     * @example
     * // Get one RamAssemblyLineTypeDetailPerGroup
     * const ramAssemblyLineTypeDetailPerGroup = await prisma.ramAssemblyLineTypeDetailPerGroup.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends ramAssemblyLineTypeDetailPerGroupFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ramAssemblyLineTypeDetailPerGroupFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__ramAssemblyLineTypeDetailPerGroupClient<$Result.GetResult<Prisma.$ramAssemblyLineTypeDetailPerGroupPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more RamAssemblyLineTypeDetailPerGroups that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ramAssemblyLineTypeDetailPerGroupFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RamAssemblyLineTypeDetailPerGroups
     * const ramAssemblyLineTypeDetailPerGroups = await prisma.ramAssemblyLineTypeDetailPerGroup.findMany()
     * 
     * // Get first 10 RamAssemblyLineTypeDetailPerGroups
     * const ramAssemblyLineTypeDetailPerGroups = await prisma.ramAssemblyLineTypeDetailPerGroup.findMany({ take: 10 })
     * 
     * // Only select the `assemblyLineTypeID`
     * const ramAssemblyLineTypeDetailPerGroupWithAssemblyLineTypeIDOnly = await prisma.ramAssemblyLineTypeDetailPerGroup.findMany({ select: { assemblyLineTypeID: true } })
     * 
    **/
    findMany<T extends ramAssemblyLineTypeDetailPerGroupFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ramAssemblyLineTypeDetailPerGroupFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ramAssemblyLineTypeDetailPerGroupPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a RamAssemblyLineTypeDetailPerGroup.
     * @param {ramAssemblyLineTypeDetailPerGroupCreateArgs} args - Arguments to create a RamAssemblyLineTypeDetailPerGroup.
     * @example
     * // Create one RamAssemblyLineTypeDetailPerGroup
     * const RamAssemblyLineTypeDetailPerGroup = await prisma.ramAssemblyLineTypeDetailPerGroup.create({
     *   data: {
     *     // ... data to create a RamAssemblyLineTypeDetailPerGroup
     *   }
     * })
     * 
    **/
    create<T extends ramAssemblyLineTypeDetailPerGroupCreateArgs<ExtArgs>>(
      args: SelectSubset<T, ramAssemblyLineTypeDetailPerGroupCreateArgs<ExtArgs>>
    ): Prisma__ramAssemblyLineTypeDetailPerGroupClient<$Result.GetResult<Prisma.$ramAssemblyLineTypeDetailPerGroupPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many RamAssemblyLineTypeDetailPerGroups.
     *     @param {ramAssemblyLineTypeDetailPerGroupCreateManyArgs} args - Arguments to create many RamAssemblyLineTypeDetailPerGroups.
     *     @example
     *     // Create many RamAssemblyLineTypeDetailPerGroups
     *     const ramAssemblyLineTypeDetailPerGroup = await prisma.ramAssemblyLineTypeDetailPerGroup.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ramAssemblyLineTypeDetailPerGroupCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ramAssemblyLineTypeDetailPerGroupCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a RamAssemblyLineTypeDetailPerGroup.
     * @param {ramAssemblyLineTypeDetailPerGroupDeleteArgs} args - Arguments to delete one RamAssemblyLineTypeDetailPerGroup.
     * @example
     * // Delete one RamAssemblyLineTypeDetailPerGroup
     * const RamAssemblyLineTypeDetailPerGroup = await prisma.ramAssemblyLineTypeDetailPerGroup.delete({
     *   where: {
     *     // ... filter to delete one RamAssemblyLineTypeDetailPerGroup
     *   }
     * })
     * 
    **/
    delete<T extends ramAssemblyLineTypeDetailPerGroupDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, ramAssemblyLineTypeDetailPerGroupDeleteArgs<ExtArgs>>
    ): Prisma__ramAssemblyLineTypeDetailPerGroupClient<$Result.GetResult<Prisma.$ramAssemblyLineTypeDetailPerGroupPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one RamAssemblyLineTypeDetailPerGroup.
     * @param {ramAssemblyLineTypeDetailPerGroupUpdateArgs} args - Arguments to update one RamAssemblyLineTypeDetailPerGroup.
     * @example
     * // Update one RamAssemblyLineTypeDetailPerGroup
     * const ramAssemblyLineTypeDetailPerGroup = await prisma.ramAssemblyLineTypeDetailPerGroup.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ramAssemblyLineTypeDetailPerGroupUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, ramAssemblyLineTypeDetailPerGroupUpdateArgs<ExtArgs>>
    ): Prisma__ramAssemblyLineTypeDetailPerGroupClient<$Result.GetResult<Prisma.$ramAssemblyLineTypeDetailPerGroupPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more RamAssemblyLineTypeDetailPerGroups.
     * @param {ramAssemblyLineTypeDetailPerGroupDeleteManyArgs} args - Arguments to filter RamAssemblyLineTypeDetailPerGroups to delete.
     * @example
     * // Delete a few RamAssemblyLineTypeDetailPerGroups
     * const { count } = await prisma.ramAssemblyLineTypeDetailPerGroup.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ramAssemblyLineTypeDetailPerGroupDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ramAssemblyLineTypeDetailPerGroupDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RamAssemblyLineTypeDetailPerGroups.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ramAssemblyLineTypeDetailPerGroupUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RamAssemblyLineTypeDetailPerGroups
     * const ramAssemblyLineTypeDetailPerGroup = await prisma.ramAssemblyLineTypeDetailPerGroup.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ramAssemblyLineTypeDetailPerGroupUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, ramAssemblyLineTypeDetailPerGroupUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one RamAssemblyLineTypeDetailPerGroup.
     * @param {ramAssemblyLineTypeDetailPerGroupUpsertArgs} args - Arguments to update or create a RamAssemblyLineTypeDetailPerGroup.
     * @example
     * // Update or create a RamAssemblyLineTypeDetailPerGroup
     * const ramAssemblyLineTypeDetailPerGroup = await prisma.ramAssemblyLineTypeDetailPerGroup.upsert({
     *   create: {
     *     // ... data to create a RamAssemblyLineTypeDetailPerGroup
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RamAssemblyLineTypeDetailPerGroup we want to update
     *   }
     * })
    **/
    upsert<T extends ramAssemblyLineTypeDetailPerGroupUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, ramAssemblyLineTypeDetailPerGroupUpsertArgs<ExtArgs>>
    ): Prisma__ramAssemblyLineTypeDetailPerGroupClient<$Result.GetResult<Prisma.$ramAssemblyLineTypeDetailPerGroupPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of RamAssemblyLineTypeDetailPerGroups.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ramAssemblyLineTypeDetailPerGroupCountArgs} args - Arguments to filter RamAssemblyLineTypeDetailPerGroups to count.
     * @example
     * // Count the number of RamAssemblyLineTypeDetailPerGroups
     * const count = await prisma.ramAssemblyLineTypeDetailPerGroup.count({
     *   where: {
     *     // ... the filter for the RamAssemblyLineTypeDetailPerGroups we want to count
     *   }
     * })
    **/
    count<T extends ramAssemblyLineTypeDetailPerGroupCountArgs>(
      args?: Subset<T, ramAssemblyLineTypeDetailPerGroupCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RamAssemblyLineTypeDetailPerGroupCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RamAssemblyLineTypeDetailPerGroup.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RamAssemblyLineTypeDetailPerGroupAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RamAssemblyLineTypeDetailPerGroupAggregateArgs>(args: Subset<T, RamAssemblyLineTypeDetailPerGroupAggregateArgs>): Prisma.PrismaPromise<GetRamAssemblyLineTypeDetailPerGroupAggregateType<T>>

    /**
     * Group by RamAssemblyLineTypeDetailPerGroup.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ramAssemblyLineTypeDetailPerGroupGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ramAssemblyLineTypeDetailPerGroupGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ramAssemblyLineTypeDetailPerGroupGroupByArgs['orderBy'] }
        : { orderBy?: ramAssemblyLineTypeDetailPerGroupGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ramAssemblyLineTypeDetailPerGroupGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRamAssemblyLineTypeDetailPerGroupGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ramAssemblyLineTypeDetailPerGroup model
   */
  readonly fields: ramAssemblyLineTypeDetailPerGroupFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ramAssemblyLineTypeDetailPerGroup.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ramAssemblyLineTypeDetailPerGroupClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';


    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the ramAssemblyLineTypeDetailPerGroup model
   */ 
  interface ramAssemblyLineTypeDetailPerGroupFieldRefs {
    readonly assemblyLineTypeID: FieldRef<"ramAssemblyLineTypeDetailPerGroup", 'Int'>
    readonly groupID: FieldRef<"ramAssemblyLineTypeDetailPerGroup", 'Int'>
    readonly timeMultiplier: FieldRef<"ramAssemblyLineTypeDetailPerGroup", 'Float'>
    readonly materialMultiplier: FieldRef<"ramAssemblyLineTypeDetailPerGroup", 'Float'>
    readonly costMultiplier: FieldRef<"ramAssemblyLineTypeDetailPerGroup", 'Float'>
  }
    

  // Custom InputTypes

  /**
   * ramAssemblyLineTypeDetailPerGroup findUnique
   */
  export type ramAssemblyLineTypeDetailPerGroupFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ramAssemblyLineTypeDetailPerGroup
     */
    select?: ramAssemblyLineTypeDetailPerGroupSelect<ExtArgs> | null
    /**
     * Filter, which ramAssemblyLineTypeDetailPerGroup to fetch.
     */
    where: ramAssemblyLineTypeDetailPerGroupWhereUniqueInput
  }


  /**
   * ramAssemblyLineTypeDetailPerGroup findUniqueOrThrow
   */
  export type ramAssemblyLineTypeDetailPerGroupFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ramAssemblyLineTypeDetailPerGroup
     */
    select?: ramAssemblyLineTypeDetailPerGroupSelect<ExtArgs> | null
    /**
     * Filter, which ramAssemblyLineTypeDetailPerGroup to fetch.
     */
    where: ramAssemblyLineTypeDetailPerGroupWhereUniqueInput
  }


  /**
   * ramAssemblyLineTypeDetailPerGroup findFirst
   */
  export type ramAssemblyLineTypeDetailPerGroupFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ramAssemblyLineTypeDetailPerGroup
     */
    select?: ramAssemblyLineTypeDetailPerGroupSelect<ExtArgs> | null
    /**
     * Filter, which ramAssemblyLineTypeDetailPerGroup to fetch.
     */
    where?: ramAssemblyLineTypeDetailPerGroupWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ramAssemblyLineTypeDetailPerGroups to fetch.
     */
    orderBy?: ramAssemblyLineTypeDetailPerGroupOrderByWithRelationInput | ramAssemblyLineTypeDetailPerGroupOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ramAssemblyLineTypeDetailPerGroups.
     */
    cursor?: ramAssemblyLineTypeDetailPerGroupWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ramAssemblyLineTypeDetailPerGroups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ramAssemblyLineTypeDetailPerGroups.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ramAssemblyLineTypeDetailPerGroups.
     */
    distinct?: RamAssemblyLineTypeDetailPerGroupScalarFieldEnum | RamAssemblyLineTypeDetailPerGroupScalarFieldEnum[]
  }


  /**
   * ramAssemblyLineTypeDetailPerGroup findFirstOrThrow
   */
  export type ramAssemblyLineTypeDetailPerGroupFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ramAssemblyLineTypeDetailPerGroup
     */
    select?: ramAssemblyLineTypeDetailPerGroupSelect<ExtArgs> | null
    /**
     * Filter, which ramAssemblyLineTypeDetailPerGroup to fetch.
     */
    where?: ramAssemblyLineTypeDetailPerGroupWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ramAssemblyLineTypeDetailPerGroups to fetch.
     */
    orderBy?: ramAssemblyLineTypeDetailPerGroupOrderByWithRelationInput | ramAssemblyLineTypeDetailPerGroupOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ramAssemblyLineTypeDetailPerGroups.
     */
    cursor?: ramAssemblyLineTypeDetailPerGroupWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ramAssemblyLineTypeDetailPerGroups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ramAssemblyLineTypeDetailPerGroups.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ramAssemblyLineTypeDetailPerGroups.
     */
    distinct?: RamAssemblyLineTypeDetailPerGroupScalarFieldEnum | RamAssemblyLineTypeDetailPerGroupScalarFieldEnum[]
  }


  /**
   * ramAssemblyLineTypeDetailPerGroup findMany
   */
  export type ramAssemblyLineTypeDetailPerGroupFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ramAssemblyLineTypeDetailPerGroup
     */
    select?: ramAssemblyLineTypeDetailPerGroupSelect<ExtArgs> | null
    /**
     * Filter, which ramAssemblyLineTypeDetailPerGroups to fetch.
     */
    where?: ramAssemblyLineTypeDetailPerGroupWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ramAssemblyLineTypeDetailPerGroups to fetch.
     */
    orderBy?: ramAssemblyLineTypeDetailPerGroupOrderByWithRelationInput | ramAssemblyLineTypeDetailPerGroupOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ramAssemblyLineTypeDetailPerGroups.
     */
    cursor?: ramAssemblyLineTypeDetailPerGroupWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ramAssemblyLineTypeDetailPerGroups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ramAssemblyLineTypeDetailPerGroups.
     */
    skip?: number
    distinct?: RamAssemblyLineTypeDetailPerGroupScalarFieldEnum | RamAssemblyLineTypeDetailPerGroupScalarFieldEnum[]
  }


  /**
   * ramAssemblyLineTypeDetailPerGroup create
   */
  export type ramAssemblyLineTypeDetailPerGroupCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ramAssemblyLineTypeDetailPerGroup
     */
    select?: ramAssemblyLineTypeDetailPerGroupSelect<ExtArgs> | null
    /**
     * The data needed to create a ramAssemblyLineTypeDetailPerGroup.
     */
    data: XOR<ramAssemblyLineTypeDetailPerGroupCreateInput, ramAssemblyLineTypeDetailPerGroupUncheckedCreateInput>
  }


  /**
   * ramAssemblyLineTypeDetailPerGroup createMany
   */
  export type ramAssemblyLineTypeDetailPerGroupCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ramAssemblyLineTypeDetailPerGroups.
     */
    data: ramAssemblyLineTypeDetailPerGroupCreateManyInput | ramAssemblyLineTypeDetailPerGroupCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * ramAssemblyLineTypeDetailPerGroup update
   */
  export type ramAssemblyLineTypeDetailPerGroupUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ramAssemblyLineTypeDetailPerGroup
     */
    select?: ramAssemblyLineTypeDetailPerGroupSelect<ExtArgs> | null
    /**
     * The data needed to update a ramAssemblyLineTypeDetailPerGroup.
     */
    data: XOR<ramAssemblyLineTypeDetailPerGroupUpdateInput, ramAssemblyLineTypeDetailPerGroupUncheckedUpdateInput>
    /**
     * Choose, which ramAssemblyLineTypeDetailPerGroup to update.
     */
    where: ramAssemblyLineTypeDetailPerGroupWhereUniqueInput
  }


  /**
   * ramAssemblyLineTypeDetailPerGroup updateMany
   */
  export type ramAssemblyLineTypeDetailPerGroupUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ramAssemblyLineTypeDetailPerGroups.
     */
    data: XOR<ramAssemblyLineTypeDetailPerGroupUpdateManyMutationInput, ramAssemblyLineTypeDetailPerGroupUncheckedUpdateManyInput>
    /**
     * Filter which ramAssemblyLineTypeDetailPerGroups to update
     */
    where?: ramAssemblyLineTypeDetailPerGroupWhereInput
  }


  /**
   * ramAssemblyLineTypeDetailPerGroup upsert
   */
  export type ramAssemblyLineTypeDetailPerGroupUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ramAssemblyLineTypeDetailPerGroup
     */
    select?: ramAssemblyLineTypeDetailPerGroupSelect<ExtArgs> | null
    /**
     * The filter to search for the ramAssemblyLineTypeDetailPerGroup to update in case it exists.
     */
    where: ramAssemblyLineTypeDetailPerGroupWhereUniqueInput
    /**
     * In case the ramAssemblyLineTypeDetailPerGroup found by the `where` argument doesn't exist, create a new ramAssemblyLineTypeDetailPerGroup with this data.
     */
    create: XOR<ramAssemblyLineTypeDetailPerGroupCreateInput, ramAssemblyLineTypeDetailPerGroupUncheckedCreateInput>
    /**
     * In case the ramAssemblyLineTypeDetailPerGroup was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ramAssemblyLineTypeDetailPerGroupUpdateInput, ramAssemblyLineTypeDetailPerGroupUncheckedUpdateInput>
  }


  /**
   * ramAssemblyLineTypeDetailPerGroup delete
   */
  export type ramAssemblyLineTypeDetailPerGroupDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ramAssemblyLineTypeDetailPerGroup
     */
    select?: ramAssemblyLineTypeDetailPerGroupSelect<ExtArgs> | null
    /**
     * Filter which ramAssemblyLineTypeDetailPerGroup to delete.
     */
    where: ramAssemblyLineTypeDetailPerGroupWhereUniqueInput
  }


  /**
   * ramAssemblyLineTypeDetailPerGroup deleteMany
   */
  export type ramAssemblyLineTypeDetailPerGroupDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which ramAssemblyLineTypeDetailPerGroups to delete
     */
    where?: ramAssemblyLineTypeDetailPerGroupWhereInput
  }


  /**
   * ramAssemblyLineTypeDetailPerGroup without action
   */
  export type ramAssemblyLineTypeDetailPerGroupDefaultArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ramAssemblyLineTypeDetailPerGroup
     */
    select?: ramAssemblyLineTypeDetailPerGroupSelect<ExtArgs> | null
  }



  /**
   * Model ramAssemblyLineTypes
   */

  export type AggregateRamAssemblyLineTypes = {
    _count: RamAssemblyLineTypesCountAggregateOutputType | null
    _avg: RamAssemblyLineTypesAvgAggregateOutputType | null
    _sum: RamAssemblyLineTypesSumAggregateOutputType | null
    _min: RamAssemblyLineTypesMinAggregateOutputType | null
    _max: RamAssemblyLineTypesMaxAggregateOutputType | null
  }

  export type RamAssemblyLineTypesAvgAggregateOutputType = {
    assemblyLineTypeID: number | null
    baseTimeMultiplier: number | null
    baseMaterialMultiplier: number | null
    baseCostMultiplier: number | null
    volume: number | null
    activityID: number | null
    minCostPerHour: number | null
  }

  export type RamAssemblyLineTypesSumAggregateOutputType = {
    assemblyLineTypeID: number | null
    baseTimeMultiplier: number | null
    baseMaterialMultiplier: number | null
    baseCostMultiplier: number | null
    volume: number | null
    activityID: number | null
    minCostPerHour: number | null
  }

  export type RamAssemblyLineTypesMinAggregateOutputType = {
    assemblyLineTypeID: number | null
    assemblyLineTypeName: string | null
    description: string | null
    baseTimeMultiplier: number | null
    baseMaterialMultiplier: number | null
    baseCostMultiplier: number | null
    volume: number | null
    activityID: number | null
    minCostPerHour: number | null
  }

  export type RamAssemblyLineTypesMaxAggregateOutputType = {
    assemblyLineTypeID: number | null
    assemblyLineTypeName: string | null
    description: string | null
    baseTimeMultiplier: number | null
    baseMaterialMultiplier: number | null
    baseCostMultiplier: number | null
    volume: number | null
    activityID: number | null
    minCostPerHour: number | null
  }

  export type RamAssemblyLineTypesCountAggregateOutputType = {
    assemblyLineTypeID: number
    assemblyLineTypeName: number
    description: number
    baseTimeMultiplier: number
    baseMaterialMultiplier: number
    baseCostMultiplier: number
    volume: number
    activityID: number
    minCostPerHour: number
    _all: number
  }


  export type RamAssemblyLineTypesAvgAggregateInputType = {
    assemblyLineTypeID?: true
    baseTimeMultiplier?: true
    baseMaterialMultiplier?: true
    baseCostMultiplier?: true
    volume?: true
    activityID?: true
    minCostPerHour?: true
  }

  export type RamAssemblyLineTypesSumAggregateInputType = {
    assemblyLineTypeID?: true
    baseTimeMultiplier?: true
    baseMaterialMultiplier?: true
    baseCostMultiplier?: true
    volume?: true
    activityID?: true
    minCostPerHour?: true
  }

  export type RamAssemblyLineTypesMinAggregateInputType = {
    assemblyLineTypeID?: true
    assemblyLineTypeName?: true
    description?: true
    baseTimeMultiplier?: true
    baseMaterialMultiplier?: true
    baseCostMultiplier?: true
    volume?: true
    activityID?: true
    minCostPerHour?: true
  }

  export type RamAssemblyLineTypesMaxAggregateInputType = {
    assemblyLineTypeID?: true
    assemblyLineTypeName?: true
    description?: true
    baseTimeMultiplier?: true
    baseMaterialMultiplier?: true
    baseCostMultiplier?: true
    volume?: true
    activityID?: true
    minCostPerHour?: true
  }

  export type RamAssemblyLineTypesCountAggregateInputType = {
    assemblyLineTypeID?: true
    assemblyLineTypeName?: true
    description?: true
    baseTimeMultiplier?: true
    baseMaterialMultiplier?: true
    baseCostMultiplier?: true
    volume?: true
    activityID?: true
    minCostPerHour?: true
    _all?: true
  }

  export type RamAssemblyLineTypesAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which ramAssemblyLineTypes to aggregate.
     */
    where?: ramAssemblyLineTypesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ramAssemblyLineTypes to fetch.
     */
    orderBy?: ramAssemblyLineTypesOrderByWithRelationInput | ramAssemblyLineTypesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ramAssemblyLineTypesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ramAssemblyLineTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ramAssemblyLineTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ramAssemblyLineTypes
    **/
    _count?: true | RamAssemblyLineTypesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RamAssemblyLineTypesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RamAssemblyLineTypesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RamAssemblyLineTypesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RamAssemblyLineTypesMaxAggregateInputType
  }

  export type GetRamAssemblyLineTypesAggregateType<T extends RamAssemblyLineTypesAggregateArgs> = {
        [P in keyof T & keyof AggregateRamAssemblyLineTypes]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRamAssemblyLineTypes[P]>
      : GetScalarType<T[P], AggregateRamAssemblyLineTypes[P]>
  }




  export type ramAssemblyLineTypesGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: ramAssemblyLineTypesWhereInput
    orderBy?: ramAssemblyLineTypesOrderByWithAggregationInput | ramAssemblyLineTypesOrderByWithAggregationInput[]
    by: RamAssemblyLineTypesScalarFieldEnum[] | RamAssemblyLineTypesScalarFieldEnum
    having?: ramAssemblyLineTypesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RamAssemblyLineTypesCountAggregateInputType | true
    _avg?: RamAssemblyLineTypesAvgAggregateInputType
    _sum?: RamAssemblyLineTypesSumAggregateInputType
    _min?: RamAssemblyLineTypesMinAggregateInputType
    _max?: RamAssemblyLineTypesMaxAggregateInputType
  }

  export type RamAssemblyLineTypesGroupByOutputType = {
    assemblyLineTypeID: number
    assemblyLineTypeName: string | null
    description: string | null
    baseTimeMultiplier: number | null
    baseMaterialMultiplier: number | null
    baseCostMultiplier: number | null
    volume: number | null
    activityID: number | null
    minCostPerHour: number | null
    _count: RamAssemblyLineTypesCountAggregateOutputType | null
    _avg: RamAssemblyLineTypesAvgAggregateOutputType | null
    _sum: RamAssemblyLineTypesSumAggregateOutputType | null
    _min: RamAssemblyLineTypesMinAggregateOutputType | null
    _max: RamAssemblyLineTypesMaxAggregateOutputType | null
  }

  type GetRamAssemblyLineTypesGroupByPayload<T extends ramAssemblyLineTypesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RamAssemblyLineTypesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RamAssemblyLineTypesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RamAssemblyLineTypesGroupByOutputType[P]>
            : GetScalarType<T[P], RamAssemblyLineTypesGroupByOutputType[P]>
        }
      >
    >


  export type ramAssemblyLineTypesSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    assemblyLineTypeID?: boolean
    assemblyLineTypeName?: boolean
    description?: boolean
    baseTimeMultiplier?: boolean
    baseMaterialMultiplier?: boolean
    baseCostMultiplier?: boolean
    volume?: boolean
    activityID?: boolean
    minCostPerHour?: boolean
  }, ExtArgs["result"]["ramAssemblyLineTypes"]>

  export type ramAssemblyLineTypesSelectScalar = {
    assemblyLineTypeID?: boolean
    assemblyLineTypeName?: boolean
    description?: boolean
    baseTimeMultiplier?: boolean
    baseMaterialMultiplier?: boolean
    baseCostMultiplier?: boolean
    volume?: boolean
    activityID?: boolean
    minCostPerHour?: boolean
  }


  export type $ramAssemblyLineTypesPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    name: "ramAssemblyLineTypes"
    objects: {}
    scalars: $Extensions.GetResult<{
      assemblyLineTypeID: number
      assemblyLineTypeName: string | null
      description: string | null
      baseTimeMultiplier: number | null
      baseMaterialMultiplier: number | null
      baseCostMultiplier: number | null
      volume: number | null
      activityID: number | null
      minCostPerHour: number | null
    }, ExtArgs["result"]["ramAssemblyLineTypes"]>
    composites: {}
  }


  type ramAssemblyLineTypesGetPayload<S extends boolean | null | undefined | ramAssemblyLineTypesDefaultArgs> = $Result.GetResult<Prisma.$ramAssemblyLineTypesPayload, S>

  type ramAssemblyLineTypesCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<ramAssemblyLineTypesFindManyArgs, 'select' | 'include'> & {
      select?: RamAssemblyLineTypesCountAggregateInputType | true
    }

  export interface ramAssemblyLineTypesDelegate<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ramAssemblyLineTypes'], meta: { name: 'ramAssemblyLineTypes' } }
    /**
     * Find zero or one RamAssemblyLineTypes that matches the filter.
     * @param {ramAssemblyLineTypesFindUniqueArgs} args - Arguments to find a RamAssemblyLineTypes
     * @example
     * // Get one RamAssemblyLineTypes
     * const ramAssemblyLineTypes = await prisma.ramAssemblyLineTypes.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ramAssemblyLineTypesFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, ramAssemblyLineTypesFindUniqueArgs<ExtArgs>>
    ): Prisma__ramAssemblyLineTypesClient<$Result.GetResult<Prisma.$ramAssemblyLineTypesPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one RamAssemblyLineTypes that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {ramAssemblyLineTypesFindUniqueOrThrowArgs} args - Arguments to find a RamAssemblyLineTypes
     * @example
     * // Get one RamAssemblyLineTypes
     * const ramAssemblyLineTypes = await prisma.ramAssemblyLineTypes.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends ramAssemblyLineTypesFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ramAssemblyLineTypesFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__ramAssemblyLineTypesClient<$Result.GetResult<Prisma.$ramAssemblyLineTypesPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first RamAssemblyLineTypes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ramAssemblyLineTypesFindFirstArgs} args - Arguments to find a RamAssemblyLineTypes
     * @example
     * // Get one RamAssemblyLineTypes
     * const ramAssemblyLineTypes = await prisma.ramAssemblyLineTypes.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ramAssemblyLineTypesFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, ramAssemblyLineTypesFindFirstArgs<ExtArgs>>
    ): Prisma__ramAssemblyLineTypesClient<$Result.GetResult<Prisma.$ramAssemblyLineTypesPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first RamAssemblyLineTypes that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ramAssemblyLineTypesFindFirstOrThrowArgs} args - Arguments to find a RamAssemblyLineTypes
     * @example
     * // Get one RamAssemblyLineTypes
     * const ramAssemblyLineTypes = await prisma.ramAssemblyLineTypes.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends ramAssemblyLineTypesFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ramAssemblyLineTypesFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__ramAssemblyLineTypesClient<$Result.GetResult<Prisma.$ramAssemblyLineTypesPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more RamAssemblyLineTypes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ramAssemblyLineTypesFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RamAssemblyLineTypes
     * const ramAssemblyLineTypes = await prisma.ramAssemblyLineTypes.findMany()
     * 
     * // Get first 10 RamAssemblyLineTypes
     * const ramAssemblyLineTypes = await prisma.ramAssemblyLineTypes.findMany({ take: 10 })
     * 
     * // Only select the `assemblyLineTypeID`
     * const ramAssemblyLineTypesWithAssemblyLineTypeIDOnly = await prisma.ramAssemblyLineTypes.findMany({ select: { assemblyLineTypeID: true } })
     * 
    **/
    findMany<T extends ramAssemblyLineTypesFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ramAssemblyLineTypesFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ramAssemblyLineTypesPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a RamAssemblyLineTypes.
     * @param {ramAssemblyLineTypesCreateArgs} args - Arguments to create a RamAssemblyLineTypes.
     * @example
     * // Create one RamAssemblyLineTypes
     * const RamAssemblyLineTypes = await prisma.ramAssemblyLineTypes.create({
     *   data: {
     *     // ... data to create a RamAssemblyLineTypes
     *   }
     * })
     * 
    **/
    create<T extends ramAssemblyLineTypesCreateArgs<ExtArgs>>(
      args: SelectSubset<T, ramAssemblyLineTypesCreateArgs<ExtArgs>>
    ): Prisma__ramAssemblyLineTypesClient<$Result.GetResult<Prisma.$ramAssemblyLineTypesPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many RamAssemblyLineTypes.
     *     @param {ramAssemblyLineTypesCreateManyArgs} args - Arguments to create many RamAssemblyLineTypes.
     *     @example
     *     // Create many RamAssemblyLineTypes
     *     const ramAssemblyLineTypes = await prisma.ramAssemblyLineTypes.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ramAssemblyLineTypesCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ramAssemblyLineTypesCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a RamAssemblyLineTypes.
     * @param {ramAssemblyLineTypesDeleteArgs} args - Arguments to delete one RamAssemblyLineTypes.
     * @example
     * // Delete one RamAssemblyLineTypes
     * const RamAssemblyLineTypes = await prisma.ramAssemblyLineTypes.delete({
     *   where: {
     *     // ... filter to delete one RamAssemblyLineTypes
     *   }
     * })
     * 
    **/
    delete<T extends ramAssemblyLineTypesDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, ramAssemblyLineTypesDeleteArgs<ExtArgs>>
    ): Prisma__ramAssemblyLineTypesClient<$Result.GetResult<Prisma.$ramAssemblyLineTypesPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one RamAssemblyLineTypes.
     * @param {ramAssemblyLineTypesUpdateArgs} args - Arguments to update one RamAssemblyLineTypes.
     * @example
     * // Update one RamAssemblyLineTypes
     * const ramAssemblyLineTypes = await prisma.ramAssemblyLineTypes.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ramAssemblyLineTypesUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, ramAssemblyLineTypesUpdateArgs<ExtArgs>>
    ): Prisma__ramAssemblyLineTypesClient<$Result.GetResult<Prisma.$ramAssemblyLineTypesPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more RamAssemblyLineTypes.
     * @param {ramAssemblyLineTypesDeleteManyArgs} args - Arguments to filter RamAssemblyLineTypes to delete.
     * @example
     * // Delete a few RamAssemblyLineTypes
     * const { count } = await prisma.ramAssemblyLineTypes.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ramAssemblyLineTypesDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ramAssemblyLineTypesDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RamAssemblyLineTypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ramAssemblyLineTypesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RamAssemblyLineTypes
     * const ramAssemblyLineTypes = await prisma.ramAssemblyLineTypes.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ramAssemblyLineTypesUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, ramAssemblyLineTypesUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one RamAssemblyLineTypes.
     * @param {ramAssemblyLineTypesUpsertArgs} args - Arguments to update or create a RamAssemblyLineTypes.
     * @example
     * // Update or create a RamAssemblyLineTypes
     * const ramAssemblyLineTypes = await prisma.ramAssemblyLineTypes.upsert({
     *   create: {
     *     // ... data to create a RamAssemblyLineTypes
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RamAssemblyLineTypes we want to update
     *   }
     * })
    **/
    upsert<T extends ramAssemblyLineTypesUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, ramAssemblyLineTypesUpsertArgs<ExtArgs>>
    ): Prisma__ramAssemblyLineTypesClient<$Result.GetResult<Prisma.$ramAssemblyLineTypesPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of RamAssemblyLineTypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ramAssemblyLineTypesCountArgs} args - Arguments to filter RamAssemblyLineTypes to count.
     * @example
     * // Count the number of RamAssemblyLineTypes
     * const count = await prisma.ramAssemblyLineTypes.count({
     *   where: {
     *     // ... the filter for the RamAssemblyLineTypes we want to count
     *   }
     * })
    **/
    count<T extends ramAssemblyLineTypesCountArgs>(
      args?: Subset<T, ramAssemblyLineTypesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RamAssemblyLineTypesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RamAssemblyLineTypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RamAssemblyLineTypesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RamAssemblyLineTypesAggregateArgs>(args: Subset<T, RamAssemblyLineTypesAggregateArgs>): Prisma.PrismaPromise<GetRamAssemblyLineTypesAggregateType<T>>

    /**
     * Group by RamAssemblyLineTypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ramAssemblyLineTypesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ramAssemblyLineTypesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ramAssemblyLineTypesGroupByArgs['orderBy'] }
        : { orderBy?: ramAssemblyLineTypesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ramAssemblyLineTypesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRamAssemblyLineTypesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ramAssemblyLineTypes model
   */
  readonly fields: ramAssemblyLineTypesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ramAssemblyLineTypes.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ramAssemblyLineTypesClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';


    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the ramAssemblyLineTypes model
   */ 
  interface ramAssemblyLineTypesFieldRefs {
    readonly assemblyLineTypeID: FieldRef<"ramAssemblyLineTypes", 'Int'>
    readonly assemblyLineTypeName: FieldRef<"ramAssemblyLineTypes", 'String'>
    readonly description: FieldRef<"ramAssemblyLineTypes", 'String'>
    readonly baseTimeMultiplier: FieldRef<"ramAssemblyLineTypes", 'Float'>
    readonly baseMaterialMultiplier: FieldRef<"ramAssemblyLineTypes", 'Float'>
    readonly baseCostMultiplier: FieldRef<"ramAssemblyLineTypes", 'Float'>
    readonly volume: FieldRef<"ramAssemblyLineTypes", 'Float'>
    readonly activityID: FieldRef<"ramAssemblyLineTypes", 'Int'>
    readonly minCostPerHour: FieldRef<"ramAssemblyLineTypes", 'Float'>
  }
    

  // Custom InputTypes

  /**
   * ramAssemblyLineTypes findUnique
   */
  export type ramAssemblyLineTypesFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ramAssemblyLineTypes
     */
    select?: ramAssemblyLineTypesSelect<ExtArgs> | null
    /**
     * Filter, which ramAssemblyLineTypes to fetch.
     */
    where: ramAssemblyLineTypesWhereUniqueInput
  }


  /**
   * ramAssemblyLineTypes findUniqueOrThrow
   */
  export type ramAssemblyLineTypesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ramAssemblyLineTypes
     */
    select?: ramAssemblyLineTypesSelect<ExtArgs> | null
    /**
     * Filter, which ramAssemblyLineTypes to fetch.
     */
    where: ramAssemblyLineTypesWhereUniqueInput
  }


  /**
   * ramAssemblyLineTypes findFirst
   */
  export type ramAssemblyLineTypesFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ramAssemblyLineTypes
     */
    select?: ramAssemblyLineTypesSelect<ExtArgs> | null
    /**
     * Filter, which ramAssemblyLineTypes to fetch.
     */
    where?: ramAssemblyLineTypesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ramAssemblyLineTypes to fetch.
     */
    orderBy?: ramAssemblyLineTypesOrderByWithRelationInput | ramAssemblyLineTypesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ramAssemblyLineTypes.
     */
    cursor?: ramAssemblyLineTypesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ramAssemblyLineTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ramAssemblyLineTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ramAssemblyLineTypes.
     */
    distinct?: RamAssemblyLineTypesScalarFieldEnum | RamAssemblyLineTypesScalarFieldEnum[]
  }


  /**
   * ramAssemblyLineTypes findFirstOrThrow
   */
  export type ramAssemblyLineTypesFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ramAssemblyLineTypes
     */
    select?: ramAssemblyLineTypesSelect<ExtArgs> | null
    /**
     * Filter, which ramAssemblyLineTypes to fetch.
     */
    where?: ramAssemblyLineTypesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ramAssemblyLineTypes to fetch.
     */
    orderBy?: ramAssemblyLineTypesOrderByWithRelationInput | ramAssemblyLineTypesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ramAssemblyLineTypes.
     */
    cursor?: ramAssemblyLineTypesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ramAssemblyLineTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ramAssemblyLineTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ramAssemblyLineTypes.
     */
    distinct?: RamAssemblyLineTypesScalarFieldEnum | RamAssemblyLineTypesScalarFieldEnum[]
  }


  /**
   * ramAssemblyLineTypes findMany
   */
  export type ramAssemblyLineTypesFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ramAssemblyLineTypes
     */
    select?: ramAssemblyLineTypesSelect<ExtArgs> | null
    /**
     * Filter, which ramAssemblyLineTypes to fetch.
     */
    where?: ramAssemblyLineTypesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ramAssemblyLineTypes to fetch.
     */
    orderBy?: ramAssemblyLineTypesOrderByWithRelationInput | ramAssemblyLineTypesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ramAssemblyLineTypes.
     */
    cursor?: ramAssemblyLineTypesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ramAssemblyLineTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ramAssemblyLineTypes.
     */
    skip?: number
    distinct?: RamAssemblyLineTypesScalarFieldEnum | RamAssemblyLineTypesScalarFieldEnum[]
  }


  /**
   * ramAssemblyLineTypes create
   */
  export type ramAssemblyLineTypesCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ramAssemblyLineTypes
     */
    select?: ramAssemblyLineTypesSelect<ExtArgs> | null
    /**
     * The data needed to create a ramAssemblyLineTypes.
     */
    data: XOR<ramAssemblyLineTypesCreateInput, ramAssemblyLineTypesUncheckedCreateInput>
  }


  /**
   * ramAssemblyLineTypes createMany
   */
  export type ramAssemblyLineTypesCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ramAssemblyLineTypes.
     */
    data: ramAssemblyLineTypesCreateManyInput | ramAssemblyLineTypesCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * ramAssemblyLineTypes update
   */
  export type ramAssemblyLineTypesUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ramAssemblyLineTypes
     */
    select?: ramAssemblyLineTypesSelect<ExtArgs> | null
    /**
     * The data needed to update a ramAssemblyLineTypes.
     */
    data: XOR<ramAssemblyLineTypesUpdateInput, ramAssemblyLineTypesUncheckedUpdateInput>
    /**
     * Choose, which ramAssemblyLineTypes to update.
     */
    where: ramAssemblyLineTypesWhereUniqueInput
  }


  /**
   * ramAssemblyLineTypes updateMany
   */
  export type ramAssemblyLineTypesUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ramAssemblyLineTypes.
     */
    data: XOR<ramAssemblyLineTypesUpdateManyMutationInput, ramAssemblyLineTypesUncheckedUpdateManyInput>
    /**
     * Filter which ramAssemblyLineTypes to update
     */
    where?: ramAssemblyLineTypesWhereInput
  }


  /**
   * ramAssemblyLineTypes upsert
   */
  export type ramAssemblyLineTypesUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ramAssemblyLineTypes
     */
    select?: ramAssemblyLineTypesSelect<ExtArgs> | null
    /**
     * The filter to search for the ramAssemblyLineTypes to update in case it exists.
     */
    where: ramAssemblyLineTypesWhereUniqueInput
    /**
     * In case the ramAssemblyLineTypes found by the `where` argument doesn't exist, create a new ramAssemblyLineTypes with this data.
     */
    create: XOR<ramAssemblyLineTypesCreateInput, ramAssemblyLineTypesUncheckedCreateInput>
    /**
     * In case the ramAssemblyLineTypes was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ramAssemblyLineTypesUpdateInput, ramAssemblyLineTypesUncheckedUpdateInput>
  }


  /**
   * ramAssemblyLineTypes delete
   */
  export type ramAssemblyLineTypesDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ramAssemblyLineTypes
     */
    select?: ramAssemblyLineTypesSelect<ExtArgs> | null
    /**
     * Filter which ramAssemblyLineTypes to delete.
     */
    where: ramAssemblyLineTypesWhereUniqueInput
  }


  /**
   * ramAssemblyLineTypes deleteMany
   */
  export type ramAssemblyLineTypesDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which ramAssemblyLineTypes to delete
     */
    where?: ramAssemblyLineTypesWhereInput
  }


  /**
   * ramAssemblyLineTypes without action
   */
  export type ramAssemblyLineTypesDefaultArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ramAssemblyLineTypes
     */
    select?: ramAssemblyLineTypesSelect<ExtArgs> | null
  }



  /**
   * Model ramInstallationTypeContents
   */

  export type AggregateRamInstallationTypeContents = {
    _count: RamInstallationTypeContentsCountAggregateOutputType | null
    _avg: RamInstallationTypeContentsAvgAggregateOutputType | null
    _sum: RamInstallationTypeContentsSumAggregateOutputType | null
    _min: RamInstallationTypeContentsMinAggregateOutputType | null
    _max: RamInstallationTypeContentsMaxAggregateOutputType | null
  }

  export type RamInstallationTypeContentsAvgAggregateOutputType = {
    installationTypeID: number | null
    assemblyLineTypeID: number | null
    quantity: number | null
  }

  export type RamInstallationTypeContentsSumAggregateOutputType = {
    installationTypeID: number | null
    assemblyLineTypeID: number | null
    quantity: number | null
  }

  export type RamInstallationTypeContentsMinAggregateOutputType = {
    installationTypeID: number | null
    assemblyLineTypeID: number | null
    quantity: number | null
  }

  export type RamInstallationTypeContentsMaxAggregateOutputType = {
    installationTypeID: number | null
    assemblyLineTypeID: number | null
    quantity: number | null
  }

  export type RamInstallationTypeContentsCountAggregateOutputType = {
    installationTypeID: number
    assemblyLineTypeID: number
    quantity: number
    _all: number
  }


  export type RamInstallationTypeContentsAvgAggregateInputType = {
    installationTypeID?: true
    assemblyLineTypeID?: true
    quantity?: true
  }

  export type RamInstallationTypeContentsSumAggregateInputType = {
    installationTypeID?: true
    assemblyLineTypeID?: true
    quantity?: true
  }

  export type RamInstallationTypeContentsMinAggregateInputType = {
    installationTypeID?: true
    assemblyLineTypeID?: true
    quantity?: true
  }

  export type RamInstallationTypeContentsMaxAggregateInputType = {
    installationTypeID?: true
    assemblyLineTypeID?: true
    quantity?: true
  }

  export type RamInstallationTypeContentsCountAggregateInputType = {
    installationTypeID?: true
    assemblyLineTypeID?: true
    quantity?: true
    _all?: true
  }

  export type RamInstallationTypeContentsAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which ramInstallationTypeContents to aggregate.
     */
    where?: ramInstallationTypeContentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ramInstallationTypeContents to fetch.
     */
    orderBy?: ramInstallationTypeContentsOrderByWithRelationInput | ramInstallationTypeContentsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ramInstallationTypeContentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ramInstallationTypeContents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ramInstallationTypeContents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ramInstallationTypeContents
    **/
    _count?: true | RamInstallationTypeContentsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RamInstallationTypeContentsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RamInstallationTypeContentsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RamInstallationTypeContentsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RamInstallationTypeContentsMaxAggregateInputType
  }

  export type GetRamInstallationTypeContentsAggregateType<T extends RamInstallationTypeContentsAggregateArgs> = {
        [P in keyof T & keyof AggregateRamInstallationTypeContents]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRamInstallationTypeContents[P]>
      : GetScalarType<T[P], AggregateRamInstallationTypeContents[P]>
  }




  export type ramInstallationTypeContentsGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: ramInstallationTypeContentsWhereInput
    orderBy?: ramInstallationTypeContentsOrderByWithAggregationInput | ramInstallationTypeContentsOrderByWithAggregationInput[]
    by: RamInstallationTypeContentsScalarFieldEnum[] | RamInstallationTypeContentsScalarFieldEnum
    having?: ramInstallationTypeContentsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RamInstallationTypeContentsCountAggregateInputType | true
    _avg?: RamInstallationTypeContentsAvgAggregateInputType
    _sum?: RamInstallationTypeContentsSumAggregateInputType
    _min?: RamInstallationTypeContentsMinAggregateInputType
    _max?: RamInstallationTypeContentsMaxAggregateInputType
  }

  export type RamInstallationTypeContentsGroupByOutputType = {
    installationTypeID: number
    assemblyLineTypeID: number
    quantity: number | null
    _count: RamInstallationTypeContentsCountAggregateOutputType | null
    _avg: RamInstallationTypeContentsAvgAggregateOutputType | null
    _sum: RamInstallationTypeContentsSumAggregateOutputType | null
    _min: RamInstallationTypeContentsMinAggregateOutputType | null
    _max: RamInstallationTypeContentsMaxAggregateOutputType | null
  }

  type GetRamInstallationTypeContentsGroupByPayload<T extends ramInstallationTypeContentsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RamInstallationTypeContentsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RamInstallationTypeContentsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RamInstallationTypeContentsGroupByOutputType[P]>
            : GetScalarType<T[P], RamInstallationTypeContentsGroupByOutputType[P]>
        }
      >
    >


  export type ramInstallationTypeContentsSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    installationTypeID?: boolean
    assemblyLineTypeID?: boolean
    quantity?: boolean
  }, ExtArgs["result"]["ramInstallationTypeContents"]>

  export type ramInstallationTypeContentsSelectScalar = {
    installationTypeID?: boolean
    assemblyLineTypeID?: boolean
    quantity?: boolean
  }


  export type $ramInstallationTypeContentsPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    name: "ramInstallationTypeContents"
    objects: {}
    scalars: $Extensions.GetResult<{
      installationTypeID: number
      assemblyLineTypeID: number
      quantity: number | null
    }, ExtArgs["result"]["ramInstallationTypeContents"]>
    composites: {}
  }


  type ramInstallationTypeContentsGetPayload<S extends boolean | null | undefined | ramInstallationTypeContentsDefaultArgs> = $Result.GetResult<Prisma.$ramInstallationTypeContentsPayload, S>

  type ramInstallationTypeContentsCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<ramInstallationTypeContentsFindManyArgs, 'select' | 'include'> & {
      select?: RamInstallationTypeContentsCountAggregateInputType | true
    }

  export interface ramInstallationTypeContentsDelegate<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ramInstallationTypeContents'], meta: { name: 'ramInstallationTypeContents' } }
    /**
     * Find zero or one RamInstallationTypeContents that matches the filter.
     * @param {ramInstallationTypeContentsFindUniqueArgs} args - Arguments to find a RamInstallationTypeContents
     * @example
     * // Get one RamInstallationTypeContents
     * const ramInstallationTypeContents = await prisma.ramInstallationTypeContents.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ramInstallationTypeContentsFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, ramInstallationTypeContentsFindUniqueArgs<ExtArgs>>
    ): Prisma__ramInstallationTypeContentsClient<$Result.GetResult<Prisma.$ramInstallationTypeContentsPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one RamInstallationTypeContents that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {ramInstallationTypeContentsFindUniqueOrThrowArgs} args - Arguments to find a RamInstallationTypeContents
     * @example
     * // Get one RamInstallationTypeContents
     * const ramInstallationTypeContents = await prisma.ramInstallationTypeContents.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends ramInstallationTypeContentsFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ramInstallationTypeContentsFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__ramInstallationTypeContentsClient<$Result.GetResult<Prisma.$ramInstallationTypeContentsPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first RamInstallationTypeContents that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ramInstallationTypeContentsFindFirstArgs} args - Arguments to find a RamInstallationTypeContents
     * @example
     * // Get one RamInstallationTypeContents
     * const ramInstallationTypeContents = await prisma.ramInstallationTypeContents.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ramInstallationTypeContentsFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, ramInstallationTypeContentsFindFirstArgs<ExtArgs>>
    ): Prisma__ramInstallationTypeContentsClient<$Result.GetResult<Prisma.$ramInstallationTypeContentsPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first RamInstallationTypeContents that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ramInstallationTypeContentsFindFirstOrThrowArgs} args - Arguments to find a RamInstallationTypeContents
     * @example
     * // Get one RamInstallationTypeContents
     * const ramInstallationTypeContents = await prisma.ramInstallationTypeContents.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends ramInstallationTypeContentsFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ramInstallationTypeContentsFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__ramInstallationTypeContentsClient<$Result.GetResult<Prisma.$ramInstallationTypeContentsPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more RamInstallationTypeContents that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ramInstallationTypeContentsFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RamInstallationTypeContents
     * const ramInstallationTypeContents = await prisma.ramInstallationTypeContents.findMany()
     * 
     * // Get first 10 RamInstallationTypeContents
     * const ramInstallationTypeContents = await prisma.ramInstallationTypeContents.findMany({ take: 10 })
     * 
     * // Only select the `installationTypeID`
     * const ramInstallationTypeContentsWithInstallationTypeIDOnly = await prisma.ramInstallationTypeContents.findMany({ select: { installationTypeID: true } })
     * 
    **/
    findMany<T extends ramInstallationTypeContentsFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ramInstallationTypeContentsFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ramInstallationTypeContentsPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a RamInstallationTypeContents.
     * @param {ramInstallationTypeContentsCreateArgs} args - Arguments to create a RamInstallationTypeContents.
     * @example
     * // Create one RamInstallationTypeContents
     * const RamInstallationTypeContents = await prisma.ramInstallationTypeContents.create({
     *   data: {
     *     // ... data to create a RamInstallationTypeContents
     *   }
     * })
     * 
    **/
    create<T extends ramInstallationTypeContentsCreateArgs<ExtArgs>>(
      args: SelectSubset<T, ramInstallationTypeContentsCreateArgs<ExtArgs>>
    ): Prisma__ramInstallationTypeContentsClient<$Result.GetResult<Prisma.$ramInstallationTypeContentsPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many RamInstallationTypeContents.
     *     @param {ramInstallationTypeContentsCreateManyArgs} args - Arguments to create many RamInstallationTypeContents.
     *     @example
     *     // Create many RamInstallationTypeContents
     *     const ramInstallationTypeContents = await prisma.ramInstallationTypeContents.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ramInstallationTypeContentsCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ramInstallationTypeContentsCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a RamInstallationTypeContents.
     * @param {ramInstallationTypeContentsDeleteArgs} args - Arguments to delete one RamInstallationTypeContents.
     * @example
     * // Delete one RamInstallationTypeContents
     * const RamInstallationTypeContents = await prisma.ramInstallationTypeContents.delete({
     *   where: {
     *     // ... filter to delete one RamInstallationTypeContents
     *   }
     * })
     * 
    **/
    delete<T extends ramInstallationTypeContentsDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, ramInstallationTypeContentsDeleteArgs<ExtArgs>>
    ): Prisma__ramInstallationTypeContentsClient<$Result.GetResult<Prisma.$ramInstallationTypeContentsPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one RamInstallationTypeContents.
     * @param {ramInstallationTypeContentsUpdateArgs} args - Arguments to update one RamInstallationTypeContents.
     * @example
     * // Update one RamInstallationTypeContents
     * const ramInstallationTypeContents = await prisma.ramInstallationTypeContents.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ramInstallationTypeContentsUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, ramInstallationTypeContentsUpdateArgs<ExtArgs>>
    ): Prisma__ramInstallationTypeContentsClient<$Result.GetResult<Prisma.$ramInstallationTypeContentsPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more RamInstallationTypeContents.
     * @param {ramInstallationTypeContentsDeleteManyArgs} args - Arguments to filter RamInstallationTypeContents to delete.
     * @example
     * // Delete a few RamInstallationTypeContents
     * const { count } = await prisma.ramInstallationTypeContents.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ramInstallationTypeContentsDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ramInstallationTypeContentsDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RamInstallationTypeContents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ramInstallationTypeContentsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RamInstallationTypeContents
     * const ramInstallationTypeContents = await prisma.ramInstallationTypeContents.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ramInstallationTypeContentsUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, ramInstallationTypeContentsUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one RamInstallationTypeContents.
     * @param {ramInstallationTypeContentsUpsertArgs} args - Arguments to update or create a RamInstallationTypeContents.
     * @example
     * // Update or create a RamInstallationTypeContents
     * const ramInstallationTypeContents = await prisma.ramInstallationTypeContents.upsert({
     *   create: {
     *     // ... data to create a RamInstallationTypeContents
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RamInstallationTypeContents we want to update
     *   }
     * })
    **/
    upsert<T extends ramInstallationTypeContentsUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, ramInstallationTypeContentsUpsertArgs<ExtArgs>>
    ): Prisma__ramInstallationTypeContentsClient<$Result.GetResult<Prisma.$ramInstallationTypeContentsPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of RamInstallationTypeContents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ramInstallationTypeContentsCountArgs} args - Arguments to filter RamInstallationTypeContents to count.
     * @example
     * // Count the number of RamInstallationTypeContents
     * const count = await prisma.ramInstallationTypeContents.count({
     *   where: {
     *     // ... the filter for the RamInstallationTypeContents we want to count
     *   }
     * })
    **/
    count<T extends ramInstallationTypeContentsCountArgs>(
      args?: Subset<T, ramInstallationTypeContentsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RamInstallationTypeContentsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RamInstallationTypeContents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RamInstallationTypeContentsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RamInstallationTypeContentsAggregateArgs>(args: Subset<T, RamInstallationTypeContentsAggregateArgs>): Prisma.PrismaPromise<GetRamInstallationTypeContentsAggregateType<T>>

    /**
     * Group by RamInstallationTypeContents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ramInstallationTypeContentsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ramInstallationTypeContentsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ramInstallationTypeContentsGroupByArgs['orderBy'] }
        : { orderBy?: ramInstallationTypeContentsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ramInstallationTypeContentsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRamInstallationTypeContentsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ramInstallationTypeContents model
   */
  readonly fields: ramInstallationTypeContentsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ramInstallationTypeContents.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ramInstallationTypeContentsClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';


    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the ramInstallationTypeContents model
   */ 
  interface ramInstallationTypeContentsFieldRefs {
    readonly installationTypeID: FieldRef<"ramInstallationTypeContents", 'Int'>
    readonly assemblyLineTypeID: FieldRef<"ramInstallationTypeContents", 'Int'>
    readonly quantity: FieldRef<"ramInstallationTypeContents", 'Int'>
  }
    

  // Custom InputTypes

  /**
   * ramInstallationTypeContents findUnique
   */
  export type ramInstallationTypeContentsFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ramInstallationTypeContents
     */
    select?: ramInstallationTypeContentsSelect<ExtArgs> | null
    /**
     * Filter, which ramInstallationTypeContents to fetch.
     */
    where: ramInstallationTypeContentsWhereUniqueInput
  }


  /**
   * ramInstallationTypeContents findUniqueOrThrow
   */
  export type ramInstallationTypeContentsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ramInstallationTypeContents
     */
    select?: ramInstallationTypeContentsSelect<ExtArgs> | null
    /**
     * Filter, which ramInstallationTypeContents to fetch.
     */
    where: ramInstallationTypeContentsWhereUniqueInput
  }


  /**
   * ramInstallationTypeContents findFirst
   */
  export type ramInstallationTypeContentsFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ramInstallationTypeContents
     */
    select?: ramInstallationTypeContentsSelect<ExtArgs> | null
    /**
     * Filter, which ramInstallationTypeContents to fetch.
     */
    where?: ramInstallationTypeContentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ramInstallationTypeContents to fetch.
     */
    orderBy?: ramInstallationTypeContentsOrderByWithRelationInput | ramInstallationTypeContentsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ramInstallationTypeContents.
     */
    cursor?: ramInstallationTypeContentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ramInstallationTypeContents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ramInstallationTypeContents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ramInstallationTypeContents.
     */
    distinct?: RamInstallationTypeContentsScalarFieldEnum | RamInstallationTypeContentsScalarFieldEnum[]
  }


  /**
   * ramInstallationTypeContents findFirstOrThrow
   */
  export type ramInstallationTypeContentsFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ramInstallationTypeContents
     */
    select?: ramInstallationTypeContentsSelect<ExtArgs> | null
    /**
     * Filter, which ramInstallationTypeContents to fetch.
     */
    where?: ramInstallationTypeContentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ramInstallationTypeContents to fetch.
     */
    orderBy?: ramInstallationTypeContentsOrderByWithRelationInput | ramInstallationTypeContentsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ramInstallationTypeContents.
     */
    cursor?: ramInstallationTypeContentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ramInstallationTypeContents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ramInstallationTypeContents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ramInstallationTypeContents.
     */
    distinct?: RamInstallationTypeContentsScalarFieldEnum | RamInstallationTypeContentsScalarFieldEnum[]
  }


  /**
   * ramInstallationTypeContents findMany
   */
  export type ramInstallationTypeContentsFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ramInstallationTypeContents
     */
    select?: ramInstallationTypeContentsSelect<ExtArgs> | null
    /**
     * Filter, which ramInstallationTypeContents to fetch.
     */
    where?: ramInstallationTypeContentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ramInstallationTypeContents to fetch.
     */
    orderBy?: ramInstallationTypeContentsOrderByWithRelationInput | ramInstallationTypeContentsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ramInstallationTypeContents.
     */
    cursor?: ramInstallationTypeContentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ramInstallationTypeContents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ramInstallationTypeContents.
     */
    skip?: number
    distinct?: RamInstallationTypeContentsScalarFieldEnum | RamInstallationTypeContentsScalarFieldEnum[]
  }


  /**
   * ramInstallationTypeContents create
   */
  export type ramInstallationTypeContentsCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ramInstallationTypeContents
     */
    select?: ramInstallationTypeContentsSelect<ExtArgs> | null
    /**
     * The data needed to create a ramInstallationTypeContents.
     */
    data: XOR<ramInstallationTypeContentsCreateInput, ramInstallationTypeContentsUncheckedCreateInput>
  }


  /**
   * ramInstallationTypeContents createMany
   */
  export type ramInstallationTypeContentsCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ramInstallationTypeContents.
     */
    data: ramInstallationTypeContentsCreateManyInput | ramInstallationTypeContentsCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * ramInstallationTypeContents update
   */
  export type ramInstallationTypeContentsUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ramInstallationTypeContents
     */
    select?: ramInstallationTypeContentsSelect<ExtArgs> | null
    /**
     * The data needed to update a ramInstallationTypeContents.
     */
    data: XOR<ramInstallationTypeContentsUpdateInput, ramInstallationTypeContentsUncheckedUpdateInput>
    /**
     * Choose, which ramInstallationTypeContents to update.
     */
    where: ramInstallationTypeContentsWhereUniqueInput
  }


  /**
   * ramInstallationTypeContents updateMany
   */
  export type ramInstallationTypeContentsUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ramInstallationTypeContents.
     */
    data: XOR<ramInstallationTypeContentsUpdateManyMutationInput, ramInstallationTypeContentsUncheckedUpdateManyInput>
    /**
     * Filter which ramInstallationTypeContents to update
     */
    where?: ramInstallationTypeContentsWhereInput
  }


  /**
   * ramInstallationTypeContents upsert
   */
  export type ramInstallationTypeContentsUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ramInstallationTypeContents
     */
    select?: ramInstallationTypeContentsSelect<ExtArgs> | null
    /**
     * The filter to search for the ramInstallationTypeContents to update in case it exists.
     */
    where: ramInstallationTypeContentsWhereUniqueInput
    /**
     * In case the ramInstallationTypeContents found by the `where` argument doesn't exist, create a new ramInstallationTypeContents with this data.
     */
    create: XOR<ramInstallationTypeContentsCreateInput, ramInstallationTypeContentsUncheckedCreateInput>
    /**
     * In case the ramInstallationTypeContents was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ramInstallationTypeContentsUpdateInput, ramInstallationTypeContentsUncheckedUpdateInput>
  }


  /**
   * ramInstallationTypeContents delete
   */
  export type ramInstallationTypeContentsDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ramInstallationTypeContents
     */
    select?: ramInstallationTypeContentsSelect<ExtArgs> | null
    /**
     * Filter which ramInstallationTypeContents to delete.
     */
    where: ramInstallationTypeContentsWhereUniqueInput
  }


  /**
   * ramInstallationTypeContents deleteMany
   */
  export type ramInstallationTypeContentsDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which ramInstallationTypeContents to delete
     */
    where?: ramInstallationTypeContentsWhereInput
  }


  /**
   * ramInstallationTypeContents without action
   */
  export type ramInstallationTypeContentsDefaultArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ramInstallationTypeContents
     */
    select?: ramInstallationTypeContentsSelect<ExtArgs> | null
  }



  /**
   * Model skinLicense
   */

  export type AggregateSkinLicense = {
    _count: SkinLicenseCountAggregateOutputType | null
    _avg: SkinLicenseAvgAggregateOutputType | null
    _sum: SkinLicenseSumAggregateOutputType | null
    _min: SkinLicenseMinAggregateOutputType | null
    _max: SkinLicenseMaxAggregateOutputType | null
  }

  export type SkinLicenseAvgAggregateOutputType = {
    licenseTypeID: number | null
    duration: number | null
    skinID: number | null
  }

  export type SkinLicenseSumAggregateOutputType = {
    licenseTypeID: number | null
    duration: number | null
    skinID: number | null
  }

  export type SkinLicenseMinAggregateOutputType = {
    licenseTypeID: number | null
    duration: number | null
    skinID: number | null
  }

  export type SkinLicenseMaxAggregateOutputType = {
    licenseTypeID: number | null
    duration: number | null
    skinID: number | null
  }

  export type SkinLicenseCountAggregateOutputType = {
    licenseTypeID: number
    duration: number
    skinID: number
    _all: number
  }


  export type SkinLicenseAvgAggregateInputType = {
    licenseTypeID?: true
    duration?: true
    skinID?: true
  }

  export type SkinLicenseSumAggregateInputType = {
    licenseTypeID?: true
    duration?: true
    skinID?: true
  }

  export type SkinLicenseMinAggregateInputType = {
    licenseTypeID?: true
    duration?: true
    skinID?: true
  }

  export type SkinLicenseMaxAggregateInputType = {
    licenseTypeID?: true
    duration?: true
    skinID?: true
  }

  export type SkinLicenseCountAggregateInputType = {
    licenseTypeID?: true
    duration?: true
    skinID?: true
    _all?: true
  }

  export type SkinLicenseAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which skinLicense to aggregate.
     */
    where?: skinLicenseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of skinLicenses to fetch.
     */
    orderBy?: skinLicenseOrderByWithRelationInput | skinLicenseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: skinLicenseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` skinLicenses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` skinLicenses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned skinLicenses
    **/
    _count?: true | SkinLicenseCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SkinLicenseAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SkinLicenseSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SkinLicenseMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SkinLicenseMaxAggregateInputType
  }

  export type GetSkinLicenseAggregateType<T extends SkinLicenseAggregateArgs> = {
        [P in keyof T & keyof AggregateSkinLicense]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSkinLicense[P]>
      : GetScalarType<T[P], AggregateSkinLicense[P]>
  }




  export type skinLicenseGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: skinLicenseWhereInput
    orderBy?: skinLicenseOrderByWithAggregationInput | skinLicenseOrderByWithAggregationInput[]
    by: SkinLicenseScalarFieldEnum[] | SkinLicenseScalarFieldEnum
    having?: skinLicenseScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SkinLicenseCountAggregateInputType | true
    _avg?: SkinLicenseAvgAggregateInputType
    _sum?: SkinLicenseSumAggregateInputType
    _min?: SkinLicenseMinAggregateInputType
    _max?: SkinLicenseMaxAggregateInputType
  }

  export type SkinLicenseGroupByOutputType = {
    licenseTypeID: number
    duration: number | null
    skinID: number | null
    _count: SkinLicenseCountAggregateOutputType | null
    _avg: SkinLicenseAvgAggregateOutputType | null
    _sum: SkinLicenseSumAggregateOutputType | null
    _min: SkinLicenseMinAggregateOutputType | null
    _max: SkinLicenseMaxAggregateOutputType | null
  }

  type GetSkinLicenseGroupByPayload<T extends skinLicenseGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SkinLicenseGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SkinLicenseGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SkinLicenseGroupByOutputType[P]>
            : GetScalarType<T[P], SkinLicenseGroupByOutputType[P]>
        }
      >
    >


  export type skinLicenseSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    licenseTypeID?: boolean
    duration?: boolean
    skinID?: boolean
  }, ExtArgs["result"]["skinLicense"]>

  export type skinLicenseSelectScalar = {
    licenseTypeID?: boolean
    duration?: boolean
    skinID?: boolean
  }


  export type $skinLicensePayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    name: "skinLicense"
    objects: {}
    scalars: $Extensions.GetResult<{
      licenseTypeID: number
      duration: number | null
      skinID: number | null
    }, ExtArgs["result"]["skinLicense"]>
    composites: {}
  }


  type skinLicenseGetPayload<S extends boolean | null | undefined | skinLicenseDefaultArgs> = $Result.GetResult<Prisma.$skinLicensePayload, S>

  type skinLicenseCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<skinLicenseFindManyArgs, 'select' | 'include'> & {
      select?: SkinLicenseCountAggregateInputType | true
    }

  export interface skinLicenseDelegate<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['skinLicense'], meta: { name: 'skinLicense' } }
    /**
     * Find zero or one SkinLicense that matches the filter.
     * @param {skinLicenseFindUniqueArgs} args - Arguments to find a SkinLicense
     * @example
     * // Get one SkinLicense
     * const skinLicense = await prisma.skinLicense.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends skinLicenseFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, skinLicenseFindUniqueArgs<ExtArgs>>
    ): Prisma__skinLicenseClient<$Result.GetResult<Prisma.$skinLicensePayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one SkinLicense that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {skinLicenseFindUniqueOrThrowArgs} args - Arguments to find a SkinLicense
     * @example
     * // Get one SkinLicense
     * const skinLicense = await prisma.skinLicense.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends skinLicenseFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, skinLicenseFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__skinLicenseClient<$Result.GetResult<Prisma.$skinLicensePayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first SkinLicense that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {skinLicenseFindFirstArgs} args - Arguments to find a SkinLicense
     * @example
     * // Get one SkinLicense
     * const skinLicense = await prisma.skinLicense.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends skinLicenseFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, skinLicenseFindFirstArgs<ExtArgs>>
    ): Prisma__skinLicenseClient<$Result.GetResult<Prisma.$skinLicensePayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first SkinLicense that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {skinLicenseFindFirstOrThrowArgs} args - Arguments to find a SkinLicense
     * @example
     * // Get one SkinLicense
     * const skinLicense = await prisma.skinLicense.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends skinLicenseFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, skinLicenseFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__skinLicenseClient<$Result.GetResult<Prisma.$skinLicensePayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more SkinLicenses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {skinLicenseFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SkinLicenses
     * const skinLicenses = await prisma.skinLicense.findMany()
     * 
     * // Get first 10 SkinLicenses
     * const skinLicenses = await prisma.skinLicense.findMany({ take: 10 })
     * 
     * // Only select the `licenseTypeID`
     * const skinLicenseWithLicenseTypeIDOnly = await prisma.skinLicense.findMany({ select: { licenseTypeID: true } })
     * 
    **/
    findMany<T extends skinLicenseFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, skinLicenseFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$skinLicensePayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a SkinLicense.
     * @param {skinLicenseCreateArgs} args - Arguments to create a SkinLicense.
     * @example
     * // Create one SkinLicense
     * const SkinLicense = await prisma.skinLicense.create({
     *   data: {
     *     // ... data to create a SkinLicense
     *   }
     * })
     * 
    **/
    create<T extends skinLicenseCreateArgs<ExtArgs>>(
      args: SelectSubset<T, skinLicenseCreateArgs<ExtArgs>>
    ): Prisma__skinLicenseClient<$Result.GetResult<Prisma.$skinLicensePayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many SkinLicenses.
     *     @param {skinLicenseCreateManyArgs} args - Arguments to create many SkinLicenses.
     *     @example
     *     // Create many SkinLicenses
     *     const skinLicense = await prisma.skinLicense.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends skinLicenseCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, skinLicenseCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a SkinLicense.
     * @param {skinLicenseDeleteArgs} args - Arguments to delete one SkinLicense.
     * @example
     * // Delete one SkinLicense
     * const SkinLicense = await prisma.skinLicense.delete({
     *   where: {
     *     // ... filter to delete one SkinLicense
     *   }
     * })
     * 
    **/
    delete<T extends skinLicenseDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, skinLicenseDeleteArgs<ExtArgs>>
    ): Prisma__skinLicenseClient<$Result.GetResult<Prisma.$skinLicensePayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one SkinLicense.
     * @param {skinLicenseUpdateArgs} args - Arguments to update one SkinLicense.
     * @example
     * // Update one SkinLicense
     * const skinLicense = await prisma.skinLicense.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends skinLicenseUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, skinLicenseUpdateArgs<ExtArgs>>
    ): Prisma__skinLicenseClient<$Result.GetResult<Prisma.$skinLicensePayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more SkinLicenses.
     * @param {skinLicenseDeleteManyArgs} args - Arguments to filter SkinLicenses to delete.
     * @example
     * // Delete a few SkinLicenses
     * const { count } = await prisma.skinLicense.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends skinLicenseDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, skinLicenseDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SkinLicenses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {skinLicenseUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SkinLicenses
     * const skinLicense = await prisma.skinLicense.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends skinLicenseUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, skinLicenseUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one SkinLicense.
     * @param {skinLicenseUpsertArgs} args - Arguments to update or create a SkinLicense.
     * @example
     * // Update or create a SkinLicense
     * const skinLicense = await prisma.skinLicense.upsert({
     *   create: {
     *     // ... data to create a SkinLicense
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SkinLicense we want to update
     *   }
     * })
    **/
    upsert<T extends skinLicenseUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, skinLicenseUpsertArgs<ExtArgs>>
    ): Prisma__skinLicenseClient<$Result.GetResult<Prisma.$skinLicensePayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of SkinLicenses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {skinLicenseCountArgs} args - Arguments to filter SkinLicenses to count.
     * @example
     * // Count the number of SkinLicenses
     * const count = await prisma.skinLicense.count({
     *   where: {
     *     // ... the filter for the SkinLicenses we want to count
     *   }
     * })
    **/
    count<T extends skinLicenseCountArgs>(
      args?: Subset<T, skinLicenseCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SkinLicenseCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SkinLicense.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SkinLicenseAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SkinLicenseAggregateArgs>(args: Subset<T, SkinLicenseAggregateArgs>): Prisma.PrismaPromise<GetSkinLicenseAggregateType<T>>

    /**
     * Group by SkinLicense.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {skinLicenseGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends skinLicenseGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: skinLicenseGroupByArgs['orderBy'] }
        : { orderBy?: skinLicenseGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, skinLicenseGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSkinLicenseGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the skinLicense model
   */
  readonly fields: skinLicenseFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for skinLicense.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__skinLicenseClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';


    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the skinLicense model
   */ 
  interface skinLicenseFieldRefs {
    readonly licenseTypeID: FieldRef<"skinLicense", 'Int'>
    readonly duration: FieldRef<"skinLicense", 'Int'>
    readonly skinID: FieldRef<"skinLicense", 'Int'>
  }
    

  // Custom InputTypes

  /**
   * skinLicense findUnique
   */
  export type skinLicenseFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the skinLicense
     */
    select?: skinLicenseSelect<ExtArgs> | null
    /**
     * Filter, which skinLicense to fetch.
     */
    where: skinLicenseWhereUniqueInput
  }


  /**
   * skinLicense findUniqueOrThrow
   */
  export type skinLicenseFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the skinLicense
     */
    select?: skinLicenseSelect<ExtArgs> | null
    /**
     * Filter, which skinLicense to fetch.
     */
    where: skinLicenseWhereUniqueInput
  }


  /**
   * skinLicense findFirst
   */
  export type skinLicenseFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the skinLicense
     */
    select?: skinLicenseSelect<ExtArgs> | null
    /**
     * Filter, which skinLicense to fetch.
     */
    where?: skinLicenseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of skinLicenses to fetch.
     */
    orderBy?: skinLicenseOrderByWithRelationInput | skinLicenseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for skinLicenses.
     */
    cursor?: skinLicenseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` skinLicenses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` skinLicenses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of skinLicenses.
     */
    distinct?: SkinLicenseScalarFieldEnum | SkinLicenseScalarFieldEnum[]
  }


  /**
   * skinLicense findFirstOrThrow
   */
  export type skinLicenseFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the skinLicense
     */
    select?: skinLicenseSelect<ExtArgs> | null
    /**
     * Filter, which skinLicense to fetch.
     */
    where?: skinLicenseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of skinLicenses to fetch.
     */
    orderBy?: skinLicenseOrderByWithRelationInput | skinLicenseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for skinLicenses.
     */
    cursor?: skinLicenseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` skinLicenses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` skinLicenses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of skinLicenses.
     */
    distinct?: SkinLicenseScalarFieldEnum | SkinLicenseScalarFieldEnum[]
  }


  /**
   * skinLicense findMany
   */
  export type skinLicenseFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the skinLicense
     */
    select?: skinLicenseSelect<ExtArgs> | null
    /**
     * Filter, which skinLicenses to fetch.
     */
    where?: skinLicenseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of skinLicenses to fetch.
     */
    orderBy?: skinLicenseOrderByWithRelationInput | skinLicenseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing skinLicenses.
     */
    cursor?: skinLicenseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` skinLicenses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` skinLicenses.
     */
    skip?: number
    distinct?: SkinLicenseScalarFieldEnum | SkinLicenseScalarFieldEnum[]
  }


  /**
   * skinLicense create
   */
  export type skinLicenseCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the skinLicense
     */
    select?: skinLicenseSelect<ExtArgs> | null
    /**
     * The data needed to create a skinLicense.
     */
    data: XOR<skinLicenseCreateInput, skinLicenseUncheckedCreateInput>
  }


  /**
   * skinLicense createMany
   */
  export type skinLicenseCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many skinLicenses.
     */
    data: skinLicenseCreateManyInput | skinLicenseCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * skinLicense update
   */
  export type skinLicenseUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the skinLicense
     */
    select?: skinLicenseSelect<ExtArgs> | null
    /**
     * The data needed to update a skinLicense.
     */
    data: XOR<skinLicenseUpdateInput, skinLicenseUncheckedUpdateInput>
    /**
     * Choose, which skinLicense to update.
     */
    where: skinLicenseWhereUniqueInput
  }


  /**
   * skinLicense updateMany
   */
  export type skinLicenseUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update skinLicenses.
     */
    data: XOR<skinLicenseUpdateManyMutationInput, skinLicenseUncheckedUpdateManyInput>
    /**
     * Filter which skinLicenses to update
     */
    where?: skinLicenseWhereInput
  }


  /**
   * skinLicense upsert
   */
  export type skinLicenseUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the skinLicense
     */
    select?: skinLicenseSelect<ExtArgs> | null
    /**
     * The filter to search for the skinLicense to update in case it exists.
     */
    where: skinLicenseWhereUniqueInput
    /**
     * In case the skinLicense found by the `where` argument doesn't exist, create a new skinLicense with this data.
     */
    create: XOR<skinLicenseCreateInput, skinLicenseUncheckedCreateInput>
    /**
     * In case the skinLicense was found with the provided `where` argument, update it with this data.
     */
    update: XOR<skinLicenseUpdateInput, skinLicenseUncheckedUpdateInput>
  }


  /**
   * skinLicense delete
   */
  export type skinLicenseDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the skinLicense
     */
    select?: skinLicenseSelect<ExtArgs> | null
    /**
     * Filter which skinLicense to delete.
     */
    where: skinLicenseWhereUniqueInput
  }


  /**
   * skinLicense deleteMany
   */
  export type skinLicenseDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which skinLicenses to delete
     */
    where?: skinLicenseWhereInput
  }


  /**
   * skinLicense without action
   */
  export type skinLicenseDefaultArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the skinLicense
     */
    select?: skinLicenseSelect<ExtArgs> | null
  }



  /**
   * Model skinMaterials
   */

  export type AggregateSkinMaterials = {
    _count: SkinMaterialsCountAggregateOutputType | null
    _avg: SkinMaterialsAvgAggregateOutputType | null
    _sum: SkinMaterialsSumAggregateOutputType | null
    _min: SkinMaterialsMinAggregateOutputType | null
    _max: SkinMaterialsMaxAggregateOutputType | null
  }

  export type SkinMaterialsAvgAggregateOutputType = {
    skinMaterialID: number | null
    displayNameID: number | null
    materialSetID: number | null
  }

  export type SkinMaterialsSumAggregateOutputType = {
    skinMaterialID: number | null
    displayNameID: number | null
    materialSetID: number | null
  }

  export type SkinMaterialsMinAggregateOutputType = {
    skinMaterialID: number | null
    displayNameID: number | null
    materialSetID: number | null
  }

  export type SkinMaterialsMaxAggregateOutputType = {
    skinMaterialID: number | null
    displayNameID: number | null
    materialSetID: number | null
  }

  export type SkinMaterialsCountAggregateOutputType = {
    skinMaterialID: number
    displayNameID: number
    materialSetID: number
    _all: number
  }


  export type SkinMaterialsAvgAggregateInputType = {
    skinMaterialID?: true
    displayNameID?: true
    materialSetID?: true
  }

  export type SkinMaterialsSumAggregateInputType = {
    skinMaterialID?: true
    displayNameID?: true
    materialSetID?: true
  }

  export type SkinMaterialsMinAggregateInputType = {
    skinMaterialID?: true
    displayNameID?: true
    materialSetID?: true
  }

  export type SkinMaterialsMaxAggregateInputType = {
    skinMaterialID?: true
    displayNameID?: true
    materialSetID?: true
  }

  export type SkinMaterialsCountAggregateInputType = {
    skinMaterialID?: true
    displayNameID?: true
    materialSetID?: true
    _all?: true
  }

  export type SkinMaterialsAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which skinMaterials to aggregate.
     */
    where?: skinMaterialsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of skinMaterials to fetch.
     */
    orderBy?: skinMaterialsOrderByWithRelationInput | skinMaterialsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: skinMaterialsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` skinMaterials from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` skinMaterials.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned skinMaterials
    **/
    _count?: true | SkinMaterialsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SkinMaterialsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SkinMaterialsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SkinMaterialsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SkinMaterialsMaxAggregateInputType
  }

  export type GetSkinMaterialsAggregateType<T extends SkinMaterialsAggregateArgs> = {
        [P in keyof T & keyof AggregateSkinMaterials]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSkinMaterials[P]>
      : GetScalarType<T[P], AggregateSkinMaterials[P]>
  }




  export type skinMaterialsGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: skinMaterialsWhereInput
    orderBy?: skinMaterialsOrderByWithAggregationInput | skinMaterialsOrderByWithAggregationInput[]
    by: SkinMaterialsScalarFieldEnum[] | SkinMaterialsScalarFieldEnum
    having?: skinMaterialsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SkinMaterialsCountAggregateInputType | true
    _avg?: SkinMaterialsAvgAggregateInputType
    _sum?: SkinMaterialsSumAggregateInputType
    _min?: SkinMaterialsMinAggregateInputType
    _max?: SkinMaterialsMaxAggregateInputType
  }

  export type SkinMaterialsGroupByOutputType = {
    skinMaterialID: number
    displayNameID: number | null
    materialSetID: number | null
    _count: SkinMaterialsCountAggregateOutputType | null
    _avg: SkinMaterialsAvgAggregateOutputType | null
    _sum: SkinMaterialsSumAggregateOutputType | null
    _min: SkinMaterialsMinAggregateOutputType | null
    _max: SkinMaterialsMaxAggregateOutputType | null
  }

  type GetSkinMaterialsGroupByPayload<T extends skinMaterialsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SkinMaterialsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SkinMaterialsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SkinMaterialsGroupByOutputType[P]>
            : GetScalarType<T[P], SkinMaterialsGroupByOutputType[P]>
        }
      >
    >


  export type skinMaterialsSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    skinMaterialID?: boolean
    displayNameID?: boolean
    materialSetID?: boolean
  }, ExtArgs["result"]["skinMaterials"]>

  export type skinMaterialsSelectScalar = {
    skinMaterialID?: boolean
    displayNameID?: boolean
    materialSetID?: boolean
  }


  export type $skinMaterialsPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    name: "skinMaterials"
    objects: {}
    scalars: $Extensions.GetResult<{
      skinMaterialID: number
      displayNameID: number | null
      materialSetID: number | null
    }, ExtArgs["result"]["skinMaterials"]>
    composites: {}
  }


  type skinMaterialsGetPayload<S extends boolean | null | undefined | skinMaterialsDefaultArgs> = $Result.GetResult<Prisma.$skinMaterialsPayload, S>

  type skinMaterialsCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<skinMaterialsFindManyArgs, 'select' | 'include'> & {
      select?: SkinMaterialsCountAggregateInputType | true
    }

  export interface skinMaterialsDelegate<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['skinMaterials'], meta: { name: 'skinMaterials' } }
    /**
     * Find zero or one SkinMaterials that matches the filter.
     * @param {skinMaterialsFindUniqueArgs} args - Arguments to find a SkinMaterials
     * @example
     * // Get one SkinMaterials
     * const skinMaterials = await prisma.skinMaterials.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends skinMaterialsFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, skinMaterialsFindUniqueArgs<ExtArgs>>
    ): Prisma__skinMaterialsClient<$Result.GetResult<Prisma.$skinMaterialsPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one SkinMaterials that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {skinMaterialsFindUniqueOrThrowArgs} args - Arguments to find a SkinMaterials
     * @example
     * // Get one SkinMaterials
     * const skinMaterials = await prisma.skinMaterials.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends skinMaterialsFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, skinMaterialsFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__skinMaterialsClient<$Result.GetResult<Prisma.$skinMaterialsPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first SkinMaterials that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {skinMaterialsFindFirstArgs} args - Arguments to find a SkinMaterials
     * @example
     * // Get one SkinMaterials
     * const skinMaterials = await prisma.skinMaterials.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends skinMaterialsFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, skinMaterialsFindFirstArgs<ExtArgs>>
    ): Prisma__skinMaterialsClient<$Result.GetResult<Prisma.$skinMaterialsPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first SkinMaterials that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {skinMaterialsFindFirstOrThrowArgs} args - Arguments to find a SkinMaterials
     * @example
     * // Get one SkinMaterials
     * const skinMaterials = await prisma.skinMaterials.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends skinMaterialsFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, skinMaterialsFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__skinMaterialsClient<$Result.GetResult<Prisma.$skinMaterialsPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more SkinMaterials that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {skinMaterialsFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SkinMaterials
     * const skinMaterials = await prisma.skinMaterials.findMany()
     * 
     * // Get first 10 SkinMaterials
     * const skinMaterials = await prisma.skinMaterials.findMany({ take: 10 })
     * 
     * // Only select the `skinMaterialID`
     * const skinMaterialsWithSkinMaterialIDOnly = await prisma.skinMaterials.findMany({ select: { skinMaterialID: true } })
     * 
    **/
    findMany<T extends skinMaterialsFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, skinMaterialsFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$skinMaterialsPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a SkinMaterials.
     * @param {skinMaterialsCreateArgs} args - Arguments to create a SkinMaterials.
     * @example
     * // Create one SkinMaterials
     * const SkinMaterials = await prisma.skinMaterials.create({
     *   data: {
     *     // ... data to create a SkinMaterials
     *   }
     * })
     * 
    **/
    create<T extends skinMaterialsCreateArgs<ExtArgs>>(
      args: SelectSubset<T, skinMaterialsCreateArgs<ExtArgs>>
    ): Prisma__skinMaterialsClient<$Result.GetResult<Prisma.$skinMaterialsPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many SkinMaterials.
     *     @param {skinMaterialsCreateManyArgs} args - Arguments to create many SkinMaterials.
     *     @example
     *     // Create many SkinMaterials
     *     const skinMaterials = await prisma.skinMaterials.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends skinMaterialsCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, skinMaterialsCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a SkinMaterials.
     * @param {skinMaterialsDeleteArgs} args - Arguments to delete one SkinMaterials.
     * @example
     * // Delete one SkinMaterials
     * const SkinMaterials = await prisma.skinMaterials.delete({
     *   where: {
     *     // ... filter to delete one SkinMaterials
     *   }
     * })
     * 
    **/
    delete<T extends skinMaterialsDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, skinMaterialsDeleteArgs<ExtArgs>>
    ): Prisma__skinMaterialsClient<$Result.GetResult<Prisma.$skinMaterialsPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one SkinMaterials.
     * @param {skinMaterialsUpdateArgs} args - Arguments to update one SkinMaterials.
     * @example
     * // Update one SkinMaterials
     * const skinMaterials = await prisma.skinMaterials.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends skinMaterialsUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, skinMaterialsUpdateArgs<ExtArgs>>
    ): Prisma__skinMaterialsClient<$Result.GetResult<Prisma.$skinMaterialsPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more SkinMaterials.
     * @param {skinMaterialsDeleteManyArgs} args - Arguments to filter SkinMaterials to delete.
     * @example
     * // Delete a few SkinMaterials
     * const { count } = await prisma.skinMaterials.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends skinMaterialsDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, skinMaterialsDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SkinMaterials.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {skinMaterialsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SkinMaterials
     * const skinMaterials = await prisma.skinMaterials.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends skinMaterialsUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, skinMaterialsUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one SkinMaterials.
     * @param {skinMaterialsUpsertArgs} args - Arguments to update or create a SkinMaterials.
     * @example
     * // Update or create a SkinMaterials
     * const skinMaterials = await prisma.skinMaterials.upsert({
     *   create: {
     *     // ... data to create a SkinMaterials
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SkinMaterials we want to update
     *   }
     * })
    **/
    upsert<T extends skinMaterialsUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, skinMaterialsUpsertArgs<ExtArgs>>
    ): Prisma__skinMaterialsClient<$Result.GetResult<Prisma.$skinMaterialsPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of SkinMaterials.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {skinMaterialsCountArgs} args - Arguments to filter SkinMaterials to count.
     * @example
     * // Count the number of SkinMaterials
     * const count = await prisma.skinMaterials.count({
     *   where: {
     *     // ... the filter for the SkinMaterials we want to count
     *   }
     * })
    **/
    count<T extends skinMaterialsCountArgs>(
      args?: Subset<T, skinMaterialsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SkinMaterialsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SkinMaterials.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SkinMaterialsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SkinMaterialsAggregateArgs>(args: Subset<T, SkinMaterialsAggregateArgs>): Prisma.PrismaPromise<GetSkinMaterialsAggregateType<T>>

    /**
     * Group by SkinMaterials.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {skinMaterialsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends skinMaterialsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: skinMaterialsGroupByArgs['orderBy'] }
        : { orderBy?: skinMaterialsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, skinMaterialsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSkinMaterialsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the skinMaterials model
   */
  readonly fields: skinMaterialsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for skinMaterials.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__skinMaterialsClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';


    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the skinMaterials model
   */ 
  interface skinMaterialsFieldRefs {
    readonly skinMaterialID: FieldRef<"skinMaterials", 'Int'>
    readonly displayNameID: FieldRef<"skinMaterials", 'Int'>
    readonly materialSetID: FieldRef<"skinMaterials", 'Int'>
  }
    

  // Custom InputTypes

  /**
   * skinMaterials findUnique
   */
  export type skinMaterialsFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the skinMaterials
     */
    select?: skinMaterialsSelect<ExtArgs> | null
    /**
     * Filter, which skinMaterials to fetch.
     */
    where: skinMaterialsWhereUniqueInput
  }


  /**
   * skinMaterials findUniqueOrThrow
   */
  export type skinMaterialsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the skinMaterials
     */
    select?: skinMaterialsSelect<ExtArgs> | null
    /**
     * Filter, which skinMaterials to fetch.
     */
    where: skinMaterialsWhereUniqueInput
  }


  /**
   * skinMaterials findFirst
   */
  export type skinMaterialsFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the skinMaterials
     */
    select?: skinMaterialsSelect<ExtArgs> | null
    /**
     * Filter, which skinMaterials to fetch.
     */
    where?: skinMaterialsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of skinMaterials to fetch.
     */
    orderBy?: skinMaterialsOrderByWithRelationInput | skinMaterialsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for skinMaterials.
     */
    cursor?: skinMaterialsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` skinMaterials from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` skinMaterials.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of skinMaterials.
     */
    distinct?: SkinMaterialsScalarFieldEnum | SkinMaterialsScalarFieldEnum[]
  }


  /**
   * skinMaterials findFirstOrThrow
   */
  export type skinMaterialsFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the skinMaterials
     */
    select?: skinMaterialsSelect<ExtArgs> | null
    /**
     * Filter, which skinMaterials to fetch.
     */
    where?: skinMaterialsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of skinMaterials to fetch.
     */
    orderBy?: skinMaterialsOrderByWithRelationInput | skinMaterialsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for skinMaterials.
     */
    cursor?: skinMaterialsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` skinMaterials from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` skinMaterials.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of skinMaterials.
     */
    distinct?: SkinMaterialsScalarFieldEnum | SkinMaterialsScalarFieldEnum[]
  }


  /**
   * skinMaterials findMany
   */
  export type skinMaterialsFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the skinMaterials
     */
    select?: skinMaterialsSelect<ExtArgs> | null
    /**
     * Filter, which skinMaterials to fetch.
     */
    where?: skinMaterialsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of skinMaterials to fetch.
     */
    orderBy?: skinMaterialsOrderByWithRelationInput | skinMaterialsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing skinMaterials.
     */
    cursor?: skinMaterialsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` skinMaterials from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` skinMaterials.
     */
    skip?: number
    distinct?: SkinMaterialsScalarFieldEnum | SkinMaterialsScalarFieldEnum[]
  }


  /**
   * skinMaterials create
   */
  export type skinMaterialsCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the skinMaterials
     */
    select?: skinMaterialsSelect<ExtArgs> | null
    /**
     * The data needed to create a skinMaterials.
     */
    data: XOR<skinMaterialsCreateInput, skinMaterialsUncheckedCreateInput>
  }


  /**
   * skinMaterials createMany
   */
  export type skinMaterialsCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many skinMaterials.
     */
    data: skinMaterialsCreateManyInput | skinMaterialsCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * skinMaterials update
   */
  export type skinMaterialsUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the skinMaterials
     */
    select?: skinMaterialsSelect<ExtArgs> | null
    /**
     * The data needed to update a skinMaterials.
     */
    data: XOR<skinMaterialsUpdateInput, skinMaterialsUncheckedUpdateInput>
    /**
     * Choose, which skinMaterials to update.
     */
    where: skinMaterialsWhereUniqueInput
  }


  /**
   * skinMaterials updateMany
   */
  export type skinMaterialsUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update skinMaterials.
     */
    data: XOR<skinMaterialsUpdateManyMutationInput, skinMaterialsUncheckedUpdateManyInput>
    /**
     * Filter which skinMaterials to update
     */
    where?: skinMaterialsWhereInput
  }


  /**
   * skinMaterials upsert
   */
  export type skinMaterialsUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the skinMaterials
     */
    select?: skinMaterialsSelect<ExtArgs> | null
    /**
     * The filter to search for the skinMaterials to update in case it exists.
     */
    where: skinMaterialsWhereUniqueInput
    /**
     * In case the skinMaterials found by the `where` argument doesn't exist, create a new skinMaterials with this data.
     */
    create: XOR<skinMaterialsCreateInput, skinMaterialsUncheckedCreateInput>
    /**
     * In case the skinMaterials was found with the provided `where` argument, update it with this data.
     */
    update: XOR<skinMaterialsUpdateInput, skinMaterialsUncheckedUpdateInput>
  }


  /**
   * skinMaterials delete
   */
  export type skinMaterialsDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the skinMaterials
     */
    select?: skinMaterialsSelect<ExtArgs> | null
    /**
     * Filter which skinMaterials to delete.
     */
    where: skinMaterialsWhereUniqueInput
  }


  /**
   * skinMaterials deleteMany
   */
  export type skinMaterialsDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which skinMaterials to delete
     */
    where?: skinMaterialsWhereInput
  }


  /**
   * skinMaterials without action
   */
  export type skinMaterialsDefaultArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the skinMaterials
     */
    select?: skinMaterialsSelect<ExtArgs> | null
  }



  /**
   * Model skins
   */

  export type AggregateSkins = {
    _count: SkinsCountAggregateOutputType | null
    _avg: SkinsAvgAggregateOutputType | null
    _sum: SkinsSumAggregateOutputType | null
    _min: SkinsMinAggregateOutputType | null
    _max: SkinsMaxAggregateOutputType | null
  }

  export type SkinsAvgAggregateOutputType = {
    skinID: number | null
    skinMaterialID: number | null
  }

  export type SkinsSumAggregateOutputType = {
    skinID: number | null
    skinMaterialID: number | null
  }

  export type SkinsMinAggregateOutputType = {
    skinID: number | null
    internalName: string | null
    skinMaterialID: number | null
  }

  export type SkinsMaxAggregateOutputType = {
    skinID: number | null
    internalName: string | null
    skinMaterialID: number | null
  }

  export type SkinsCountAggregateOutputType = {
    skinID: number
    internalName: number
    skinMaterialID: number
    _all: number
  }


  export type SkinsAvgAggregateInputType = {
    skinID?: true
    skinMaterialID?: true
  }

  export type SkinsSumAggregateInputType = {
    skinID?: true
    skinMaterialID?: true
  }

  export type SkinsMinAggregateInputType = {
    skinID?: true
    internalName?: true
    skinMaterialID?: true
  }

  export type SkinsMaxAggregateInputType = {
    skinID?: true
    internalName?: true
    skinMaterialID?: true
  }

  export type SkinsCountAggregateInputType = {
    skinID?: true
    internalName?: true
    skinMaterialID?: true
    _all?: true
  }

  export type SkinsAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which skins to aggregate.
     */
    where?: skinsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of skins to fetch.
     */
    orderBy?: skinsOrderByWithRelationInput | skinsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: skinsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` skins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` skins.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned skins
    **/
    _count?: true | SkinsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SkinsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SkinsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SkinsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SkinsMaxAggregateInputType
  }

  export type GetSkinsAggregateType<T extends SkinsAggregateArgs> = {
        [P in keyof T & keyof AggregateSkins]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSkins[P]>
      : GetScalarType<T[P], AggregateSkins[P]>
  }




  export type skinsGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: skinsWhereInput
    orderBy?: skinsOrderByWithAggregationInput | skinsOrderByWithAggregationInput[]
    by: SkinsScalarFieldEnum[] | SkinsScalarFieldEnum
    having?: skinsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SkinsCountAggregateInputType | true
    _avg?: SkinsAvgAggregateInputType
    _sum?: SkinsSumAggregateInputType
    _min?: SkinsMinAggregateInputType
    _max?: SkinsMaxAggregateInputType
  }

  export type SkinsGroupByOutputType = {
    skinID: number
    internalName: string | null
    skinMaterialID: number | null
    _count: SkinsCountAggregateOutputType | null
    _avg: SkinsAvgAggregateOutputType | null
    _sum: SkinsSumAggregateOutputType | null
    _min: SkinsMinAggregateOutputType | null
    _max: SkinsMaxAggregateOutputType | null
  }

  type GetSkinsGroupByPayload<T extends skinsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SkinsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SkinsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SkinsGroupByOutputType[P]>
            : GetScalarType<T[P], SkinsGroupByOutputType[P]>
        }
      >
    >


  export type skinsSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    skinID?: boolean
    internalName?: boolean
    skinMaterialID?: boolean
  }, ExtArgs["result"]["skins"]>

  export type skinsSelectScalar = {
    skinID?: boolean
    internalName?: boolean
    skinMaterialID?: boolean
  }


  export type $skinsPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    name: "skins"
    objects: {}
    scalars: $Extensions.GetResult<{
      skinID: number
      internalName: string | null
      skinMaterialID: number | null
    }, ExtArgs["result"]["skins"]>
    composites: {}
  }


  type skinsGetPayload<S extends boolean | null | undefined | skinsDefaultArgs> = $Result.GetResult<Prisma.$skinsPayload, S>

  type skinsCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<skinsFindManyArgs, 'select' | 'include'> & {
      select?: SkinsCountAggregateInputType | true
    }

  export interface skinsDelegate<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['skins'], meta: { name: 'skins' } }
    /**
     * Find zero or one Skins that matches the filter.
     * @param {skinsFindUniqueArgs} args - Arguments to find a Skins
     * @example
     * // Get one Skins
     * const skins = await prisma.skins.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends skinsFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, skinsFindUniqueArgs<ExtArgs>>
    ): Prisma__skinsClient<$Result.GetResult<Prisma.$skinsPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Skins that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {skinsFindUniqueOrThrowArgs} args - Arguments to find a Skins
     * @example
     * // Get one Skins
     * const skins = await prisma.skins.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends skinsFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, skinsFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__skinsClient<$Result.GetResult<Prisma.$skinsPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Skins that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {skinsFindFirstArgs} args - Arguments to find a Skins
     * @example
     * // Get one Skins
     * const skins = await prisma.skins.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends skinsFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, skinsFindFirstArgs<ExtArgs>>
    ): Prisma__skinsClient<$Result.GetResult<Prisma.$skinsPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Skins that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {skinsFindFirstOrThrowArgs} args - Arguments to find a Skins
     * @example
     * // Get one Skins
     * const skins = await prisma.skins.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends skinsFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, skinsFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__skinsClient<$Result.GetResult<Prisma.$skinsPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Skins that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {skinsFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Skins
     * const skins = await prisma.skins.findMany()
     * 
     * // Get first 10 Skins
     * const skins = await prisma.skins.findMany({ take: 10 })
     * 
     * // Only select the `skinID`
     * const skinsWithSkinIDOnly = await prisma.skins.findMany({ select: { skinID: true } })
     * 
    **/
    findMany<T extends skinsFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, skinsFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$skinsPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Skins.
     * @param {skinsCreateArgs} args - Arguments to create a Skins.
     * @example
     * // Create one Skins
     * const Skins = await prisma.skins.create({
     *   data: {
     *     // ... data to create a Skins
     *   }
     * })
     * 
    **/
    create<T extends skinsCreateArgs<ExtArgs>>(
      args: SelectSubset<T, skinsCreateArgs<ExtArgs>>
    ): Prisma__skinsClient<$Result.GetResult<Prisma.$skinsPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Skins.
     *     @param {skinsCreateManyArgs} args - Arguments to create many Skins.
     *     @example
     *     // Create many Skins
     *     const skins = await prisma.skins.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends skinsCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, skinsCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Skins.
     * @param {skinsDeleteArgs} args - Arguments to delete one Skins.
     * @example
     * // Delete one Skins
     * const Skins = await prisma.skins.delete({
     *   where: {
     *     // ... filter to delete one Skins
     *   }
     * })
     * 
    **/
    delete<T extends skinsDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, skinsDeleteArgs<ExtArgs>>
    ): Prisma__skinsClient<$Result.GetResult<Prisma.$skinsPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Skins.
     * @param {skinsUpdateArgs} args - Arguments to update one Skins.
     * @example
     * // Update one Skins
     * const skins = await prisma.skins.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends skinsUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, skinsUpdateArgs<ExtArgs>>
    ): Prisma__skinsClient<$Result.GetResult<Prisma.$skinsPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Skins.
     * @param {skinsDeleteManyArgs} args - Arguments to filter Skins to delete.
     * @example
     * // Delete a few Skins
     * const { count } = await prisma.skins.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends skinsDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, skinsDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Skins.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {skinsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Skins
     * const skins = await prisma.skins.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends skinsUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, skinsUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Skins.
     * @param {skinsUpsertArgs} args - Arguments to update or create a Skins.
     * @example
     * // Update or create a Skins
     * const skins = await prisma.skins.upsert({
     *   create: {
     *     // ... data to create a Skins
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Skins we want to update
     *   }
     * })
    **/
    upsert<T extends skinsUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, skinsUpsertArgs<ExtArgs>>
    ): Prisma__skinsClient<$Result.GetResult<Prisma.$skinsPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Skins.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {skinsCountArgs} args - Arguments to filter Skins to count.
     * @example
     * // Count the number of Skins
     * const count = await prisma.skins.count({
     *   where: {
     *     // ... the filter for the Skins we want to count
     *   }
     * })
    **/
    count<T extends skinsCountArgs>(
      args?: Subset<T, skinsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SkinsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Skins.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SkinsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SkinsAggregateArgs>(args: Subset<T, SkinsAggregateArgs>): Prisma.PrismaPromise<GetSkinsAggregateType<T>>

    /**
     * Group by Skins.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {skinsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends skinsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: skinsGroupByArgs['orderBy'] }
        : { orderBy?: skinsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, skinsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSkinsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the skins model
   */
  readonly fields: skinsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for skins.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__skinsClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';


    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the skins model
   */ 
  interface skinsFieldRefs {
    readonly skinID: FieldRef<"skins", 'Int'>
    readonly internalName: FieldRef<"skins", 'String'>
    readonly skinMaterialID: FieldRef<"skins", 'Int'>
  }
    

  // Custom InputTypes

  /**
   * skins findUnique
   */
  export type skinsFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the skins
     */
    select?: skinsSelect<ExtArgs> | null
    /**
     * Filter, which skins to fetch.
     */
    where: skinsWhereUniqueInput
  }


  /**
   * skins findUniqueOrThrow
   */
  export type skinsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the skins
     */
    select?: skinsSelect<ExtArgs> | null
    /**
     * Filter, which skins to fetch.
     */
    where: skinsWhereUniqueInput
  }


  /**
   * skins findFirst
   */
  export type skinsFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the skins
     */
    select?: skinsSelect<ExtArgs> | null
    /**
     * Filter, which skins to fetch.
     */
    where?: skinsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of skins to fetch.
     */
    orderBy?: skinsOrderByWithRelationInput | skinsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for skins.
     */
    cursor?: skinsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` skins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` skins.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of skins.
     */
    distinct?: SkinsScalarFieldEnum | SkinsScalarFieldEnum[]
  }


  /**
   * skins findFirstOrThrow
   */
  export type skinsFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the skins
     */
    select?: skinsSelect<ExtArgs> | null
    /**
     * Filter, which skins to fetch.
     */
    where?: skinsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of skins to fetch.
     */
    orderBy?: skinsOrderByWithRelationInput | skinsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for skins.
     */
    cursor?: skinsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` skins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` skins.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of skins.
     */
    distinct?: SkinsScalarFieldEnum | SkinsScalarFieldEnum[]
  }


  /**
   * skins findMany
   */
  export type skinsFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the skins
     */
    select?: skinsSelect<ExtArgs> | null
    /**
     * Filter, which skins to fetch.
     */
    where?: skinsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of skins to fetch.
     */
    orderBy?: skinsOrderByWithRelationInput | skinsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing skins.
     */
    cursor?: skinsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` skins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` skins.
     */
    skip?: number
    distinct?: SkinsScalarFieldEnum | SkinsScalarFieldEnum[]
  }


  /**
   * skins create
   */
  export type skinsCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the skins
     */
    select?: skinsSelect<ExtArgs> | null
    /**
     * The data needed to create a skins.
     */
    data: XOR<skinsCreateInput, skinsUncheckedCreateInput>
  }


  /**
   * skins createMany
   */
  export type skinsCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many skins.
     */
    data: skinsCreateManyInput | skinsCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * skins update
   */
  export type skinsUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the skins
     */
    select?: skinsSelect<ExtArgs> | null
    /**
     * The data needed to update a skins.
     */
    data: XOR<skinsUpdateInput, skinsUncheckedUpdateInput>
    /**
     * Choose, which skins to update.
     */
    where: skinsWhereUniqueInput
  }


  /**
   * skins updateMany
   */
  export type skinsUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update skins.
     */
    data: XOR<skinsUpdateManyMutationInput, skinsUncheckedUpdateManyInput>
    /**
     * Filter which skins to update
     */
    where?: skinsWhereInput
  }


  /**
   * skins upsert
   */
  export type skinsUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the skins
     */
    select?: skinsSelect<ExtArgs> | null
    /**
     * The filter to search for the skins to update in case it exists.
     */
    where: skinsWhereUniqueInput
    /**
     * In case the skins found by the `where` argument doesn't exist, create a new skins with this data.
     */
    create: XOR<skinsCreateInput, skinsUncheckedCreateInput>
    /**
     * In case the skins was found with the provided `where` argument, update it with this data.
     */
    update: XOR<skinsUpdateInput, skinsUncheckedUpdateInput>
  }


  /**
   * skins delete
   */
  export type skinsDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the skins
     */
    select?: skinsSelect<ExtArgs> | null
    /**
     * Filter which skins to delete.
     */
    where: skinsWhereUniqueInput
  }


  /**
   * skins deleteMany
   */
  export type skinsDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which skins to delete
     */
    where?: skinsWhereInput
  }


  /**
   * skins without action
   */
  export type skinsDefaultArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the skins
     */
    select?: skinsSelect<ExtArgs> | null
  }



  /**
   * Model staOperationServices
   */

  export type AggregateStaOperationServices = {
    _count: StaOperationServicesCountAggregateOutputType | null
    _avg: StaOperationServicesAvgAggregateOutputType | null
    _sum: StaOperationServicesSumAggregateOutputType | null
    _min: StaOperationServicesMinAggregateOutputType | null
    _max: StaOperationServicesMaxAggregateOutputType | null
  }

  export type StaOperationServicesAvgAggregateOutputType = {
    operationID: number | null
    serviceID: number | null
  }

  export type StaOperationServicesSumAggregateOutputType = {
    operationID: number | null
    serviceID: number | null
  }

  export type StaOperationServicesMinAggregateOutputType = {
    operationID: number | null
    serviceID: number | null
  }

  export type StaOperationServicesMaxAggregateOutputType = {
    operationID: number | null
    serviceID: number | null
  }

  export type StaOperationServicesCountAggregateOutputType = {
    operationID: number
    serviceID: number
    _all: number
  }


  export type StaOperationServicesAvgAggregateInputType = {
    operationID?: true
    serviceID?: true
  }

  export type StaOperationServicesSumAggregateInputType = {
    operationID?: true
    serviceID?: true
  }

  export type StaOperationServicesMinAggregateInputType = {
    operationID?: true
    serviceID?: true
  }

  export type StaOperationServicesMaxAggregateInputType = {
    operationID?: true
    serviceID?: true
  }

  export type StaOperationServicesCountAggregateInputType = {
    operationID?: true
    serviceID?: true
    _all?: true
  }

  export type StaOperationServicesAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which staOperationServices to aggregate.
     */
    where?: staOperationServicesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of staOperationServices to fetch.
     */
    orderBy?: staOperationServicesOrderByWithRelationInput | staOperationServicesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: staOperationServicesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` staOperationServices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` staOperationServices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned staOperationServices
    **/
    _count?: true | StaOperationServicesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: StaOperationServicesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: StaOperationServicesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: StaOperationServicesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: StaOperationServicesMaxAggregateInputType
  }

  export type GetStaOperationServicesAggregateType<T extends StaOperationServicesAggregateArgs> = {
        [P in keyof T & keyof AggregateStaOperationServices]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStaOperationServices[P]>
      : GetScalarType<T[P], AggregateStaOperationServices[P]>
  }




  export type staOperationServicesGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: staOperationServicesWhereInput
    orderBy?: staOperationServicesOrderByWithAggregationInput | staOperationServicesOrderByWithAggregationInput[]
    by: StaOperationServicesScalarFieldEnum[] | StaOperationServicesScalarFieldEnum
    having?: staOperationServicesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: StaOperationServicesCountAggregateInputType | true
    _avg?: StaOperationServicesAvgAggregateInputType
    _sum?: StaOperationServicesSumAggregateInputType
    _min?: StaOperationServicesMinAggregateInputType
    _max?: StaOperationServicesMaxAggregateInputType
  }

  export type StaOperationServicesGroupByOutputType = {
    operationID: number
    serviceID: number
    _count: StaOperationServicesCountAggregateOutputType | null
    _avg: StaOperationServicesAvgAggregateOutputType | null
    _sum: StaOperationServicesSumAggregateOutputType | null
    _min: StaOperationServicesMinAggregateOutputType | null
    _max: StaOperationServicesMaxAggregateOutputType | null
  }

  type GetStaOperationServicesGroupByPayload<T extends staOperationServicesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<StaOperationServicesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof StaOperationServicesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], StaOperationServicesGroupByOutputType[P]>
            : GetScalarType<T[P], StaOperationServicesGroupByOutputType[P]>
        }
      >
    >


  export type staOperationServicesSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    operationID?: boolean
    serviceID?: boolean
  }, ExtArgs["result"]["staOperationServices"]>

  export type staOperationServicesSelectScalar = {
    operationID?: boolean
    serviceID?: boolean
  }


  export type $staOperationServicesPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    name: "staOperationServices"
    objects: {}
    scalars: $Extensions.GetResult<{
      operationID: number
      serviceID: number
    }, ExtArgs["result"]["staOperationServices"]>
    composites: {}
  }


  type staOperationServicesGetPayload<S extends boolean | null | undefined | staOperationServicesDefaultArgs> = $Result.GetResult<Prisma.$staOperationServicesPayload, S>

  type staOperationServicesCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<staOperationServicesFindManyArgs, 'select' | 'include'> & {
      select?: StaOperationServicesCountAggregateInputType | true
    }

  export interface staOperationServicesDelegate<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['staOperationServices'], meta: { name: 'staOperationServices' } }
    /**
     * Find zero or one StaOperationServices that matches the filter.
     * @param {staOperationServicesFindUniqueArgs} args - Arguments to find a StaOperationServices
     * @example
     * // Get one StaOperationServices
     * const staOperationServices = await prisma.staOperationServices.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends staOperationServicesFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, staOperationServicesFindUniqueArgs<ExtArgs>>
    ): Prisma__staOperationServicesClient<$Result.GetResult<Prisma.$staOperationServicesPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one StaOperationServices that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {staOperationServicesFindUniqueOrThrowArgs} args - Arguments to find a StaOperationServices
     * @example
     * // Get one StaOperationServices
     * const staOperationServices = await prisma.staOperationServices.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends staOperationServicesFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, staOperationServicesFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__staOperationServicesClient<$Result.GetResult<Prisma.$staOperationServicesPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first StaOperationServices that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {staOperationServicesFindFirstArgs} args - Arguments to find a StaOperationServices
     * @example
     * // Get one StaOperationServices
     * const staOperationServices = await prisma.staOperationServices.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends staOperationServicesFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, staOperationServicesFindFirstArgs<ExtArgs>>
    ): Prisma__staOperationServicesClient<$Result.GetResult<Prisma.$staOperationServicesPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first StaOperationServices that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {staOperationServicesFindFirstOrThrowArgs} args - Arguments to find a StaOperationServices
     * @example
     * // Get one StaOperationServices
     * const staOperationServices = await prisma.staOperationServices.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends staOperationServicesFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, staOperationServicesFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__staOperationServicesClient<$Result.GetResult<Prisma.$staOperationServicesPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more StaOperationServices that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {staOperationServicesFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all StaOperationServices
     * const staOperationServices = await prisma.staOperationServices.findMany()
     * 
     * // Get first 10 StaOperationServices
     * const staOperationServices = await prisma.staOperationServices.findMany({ take: 10 })
     * 
     * // Only select the `operationID`
     * const staOperationServicesWithOperationIDOnly = await prisma.staOperationServices.findMany({ select: { operationID: true } })
     * 
    **/
    findMany<T extends staOperationServicesFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, staOperationServicesFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$staOperationServicesPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a StaOperationServices.
     * @param {staOperationServicesCreateArgs} args - Arguments to create a StaOperationServices.
     * @example
     * // Create one StaOperationServices
     * const StaOperationServices = await prisma.staOperationServices.create({
     *   data: {
     *     // ... data to create a StaOperationServices
     *   }
     * })
     * 
    **/
    create<T extends staOperationServicesCreateArgs<ExtArgs>>(
      args: SelectSubset<T, staOperationServicesCreateArgs<ExtArgs>>
    ): Prisma__staOperationServicesClient<$Result.GetResult<Prisma.$staOperationServicesPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many StaOperationServices.
     *     @param {staOperationServicesCreateManyArgs} args - Arguments to create many StaOperationServices.
     *     @example
     *     // Create many StaOperationServices
     *     const staOperationServices = await prisma.staOperationServices.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends staOperationServicesCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, staOperationServicesCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a StaOperationServices.
     * @param {staOperationServicesDeleteArgs} args - Arguments to delete one StaOperationServices.
     * @example
     * // Delete one StaOperationServices
     * const StaOperationServices = await prisma.staOperationServices.delete({
     *   where: {
     *     // ... filter to delete one StaOperationServices
     *   }
     * })
     * 
    **/
    delete<T extends staOperationServicesDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, staOperationServicesDeleteArgs<ExtArgs>>
    ): Prisma__staOperationServicesClient<$Result.GetResult<Prisma.$staOperationServicesPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one StaOperationServices.
     * @param {staOperationServicesUpdateArgs} args - Arguments to update one StaOperationServices.
     * @example
     * // Update one StaOperationServices
     * const staOperationServices = await prisma.staOperationServices.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends staOperationServicesUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, staOperationServicesUpdateArgs<ExtArgs>>
    ): Prisma__staOperationServicesClient<$Result.GetResult<Prisma.$staOperationServicesPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more StaOperationServices.
     * @param {staOperationServicesDeleteManyArgs} args - Arguments to filter StaOperationServices to delete.
     * @example
     * // Delete a few StaOperationServices
     * const { count } = await prisma.staOperationServices.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends staOperationServicesDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, staOperationServicesDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more StaOperationServices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {staOperationServicesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many StaOperationServices
     * const staOperationServices = await prisma.staOperationServices.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends staOperationServicesUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, staOperationServicesUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one StaOperationServices.
     * @param {staOperationServicesUpsertArgs} args - Arguments to update or create a StaOperationServices.
     * @example
     * // Update or create a StaOperationServices
     * const staOperationServices = await prisma.staOperationServices.upsert({
     *   create: {
     *     // ... data to create a StaOperationServices
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the StaOperationServices we want to update
     *   }
     * })
    **/
    upsert<T extends staOperationServicesUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, staOperationServicesUpsertArgs<ExtArgs>>
    ): Prisma__staOperationServicesClient<$Result.GetResult<Prisma.$staOperationServicesPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of StaOperationServices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {staOperationServicesCountArgs} args - Arguments to filter StaOperationServices to count.
     * @example
     * // Count the number of StaOperationServices
     * const count = await prisma.staOperationServices.count({
     *   where: {
     *     // ... the filter for the StaOperationServices we want to count
     *   }
     * })
    **/
    count<T extends staOperationServicesCountArgs>(
      args?: Subset<T, staOperationServicesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], StaOperationServicesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a StaOperationServices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StaOperationServicesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends StaOperationServicesAggregateArgs>(args: Subset<T, StaOperationServicesAggregateArgs>): Prisma.PrismaPromise<GetStaOperationServicesAggregateType<T>>

    /**
     * Group by StaOperationServices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {staOperationServicesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends staOperationServicesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: staOperationServicesGroupByArgs['orderBy'] }
        : { orderBy?: staOperationServicesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, staOperationServicesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStaOperationServicesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the staOperationServices model
   */
  readonly fields: staOperationServicesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for staOperationServices.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__staOperationServicesClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';


    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the staOperationServices model
   */ 
  interface staOperationServicesFieldRefs {
    readonly operationID: FieldRef<"staOperationServices", 'Int'>
    readonly serviceID: FieldRef<"staOperationServices", 'Int'>
  }
    

  // Custom InputTypes

  /**
   * staOperationServices findUnique
   */
  export type staOperationServicesFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the staOperationServices
     */
    select?: staOperationServicesSelect<ExtArgs> | null
    /**
     * Filter, which staOperationServices to fetch.
     */
    where: staOperationServicesWhereUniqueInput
  }


  /**
   * staOperationServices findUniqueOrThrow
   */
  export type staOperationServicesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the staOperationServices
     */
    select?: staOperationServicesSelect<ExtArgs> | null
    /**
     * Filter, which staOperationServices to fetch.
     */
    where: staOperationServicesWhereUniqueInput
  }


  /**
   * staOperationServices findFirst
   */
  export type staOperationServicesFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the staOperationServices
     */
    select?: staOperationServicesSelect<ExtArgs> | null
    /**
     * Filter, which staOperationServices to fetch.
     */
    where?: staOperationServicesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of staOperationServices to fetch.
     */
    orderBy?: staOperationServicesOrderByWithRelationInput | staOperationServicesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for staOperationServices.
     */
    cursor?: staOperationServicesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` staOperationServices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` staOperationServices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of staOperationServices.
     */
    distinct?: StaOperationServicesScalarFieldEnum | StaOperationServicesScalarFieldEnum[]
  }


  /**
   * staOperationServices findFirstOrThrow
   */
  export type staOperationServicesFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the staOperationServices
     */
    select?: staOperationServicesSelect<ExtArgs> | null
    /**
     * Filter, which staOperationServices to fetch.
     */
    where?: staOperationServicesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of staOperationServices to fetch.
     */
    orderBy?: staOperationServicesOrderByWithRelationInput | staOperationServicesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for staOperationServices.
     */
    cursor?: staOperationServicesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` staOperationServices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` staOperationServices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of staOperationServices.
     */
    distinct?: StaOperationServicesScalarFieldEnum | StaOperationServicesScalarFieldEnum[]
  }


  /**
   * staOperationServices findMany
   */
  export type staOperationServicesFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the staOperationServices
     */
    select?: staOperationServicesSelect<ExtArgs> | null
    /**
     * Filter, which staOperationServices to fetch.
     */
    where?: staOperationServicesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of staOperationServices to fetch.
     */
    orderBy?: staOperationServicesOrderByWithRelationInput | staOperationServicesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing staOperationServices.
     */
    cursor?: staOperationServicesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` staOperationServices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` staOperationServices.
     */
    skip?: number
    distinct?: StaOperationServicesScalarFieldEnum | StaOperationServicesScalarFieldEnum[]
  }


  /**
   * staOperationServices create
   */
  export type staOperationServicesCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the staOperationServices
     */
    select?: staOperationServicesSelect<ExtArgs> | null
    /**
     * The data needed to create a staOperationServices.
     */
    data: XOR<staOperationServicesCreateInput, staOperationServicesUncheckedCreateInput>
  }


  /**
   * staOperationServices createMany
   */
  export type staOperationServicesCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many staOperationServices.
     */
    data: staOperationServicesCreateManyInput | staOperationServicesCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * staOperationServices update
   */
  export type staOperationServicesUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the staOperationServices
     */
    select?: staOperationServicesSelect<ExtArgs> | null
    /**
     * The data needed to update a staOperationServices.
     */
    data: XOR<staOperationServicesUpdateInput, staOperationServicesUncheckedUpdateInput>
    /**
     * Choose, which staOperationServices to update.
     */
    where: staOperationServicesWhereUniqueInput
  }


  /**
   * staOperationServices updateMany
   */
  export type staOperationServicesUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update staOperationServices.
     */
    data: XOR<staOperationServicesUpdateManyMutationInput, staOperationServicesUncheckedUpdateManyInput>
    /**
     * Filter which staOperationServices to update
     */
    where?: staOperationServicesWhereInput
  }


  /**
   * staOperationServices upsert
   */
  export type staOperationServicesUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the staOperationServices
     */
    select?: staOperationServicesSelect<ExtArgs> | null
    /**
     * The filter to search for the staOperationServices to update in case it exists.
     */
    where: staOperationServicesWhereUniqueInput
    /**
     * In case the staOperationServices found by the `where` argument doesn't exist, create a new staOperationServices with this data.
     */
    create: XOR<staOperationServicesCreateInput, staOperationServicesUncheckedCreateInput>
    /**
     * In case the staOperationServices was found with the provided `where` argument, update it with this data.
     */
    update: XOR<staOperationServicesUpdateInput, staOperationServicesUncheckedUpdateInput>
  }


  /**
   * staOperationServices delete
   */
  export type staOperationServicesDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the staOperationServices
     */
    select?: staOperationServicesSelect<ExtArgs> | null
    /**
     * Filter which staOperationServices to delete.
     */
    where: staOperationServicesWhereUniqueInput
  }


  /**
   * staOperationServices deleteMany
   */
  export type staOperationServicesDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which staOperationServices to delete
     */
    where?: staOperationServicesWhereInput
  }


  /**
   * staOperationServices without action
   */
  export type staOperationServicesDefaultArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the staOperationServices
     */
    select?: staOperationServicesSelect<ExtArgs> | null
  }



  /**
   * Model staOperations
   */

  export type AggregateStaOperations = {
    _count: StaOperationsCountAggregateOutputType | null
    _avg: StaOperationsAvgAggregateOutputType | null
    _sum: StaOperationsSumAggregateOutputType | null
    _min: StaOperationsMinAggregateOutputType | null
    _max: StaOperationsMaxAggregateOutputType | null
  }

  export type StaOperationsAvgAggregateOutputType = {
    activityID: number | null
    operationID: number | null
    fringe: number | null
    corridor: number | null
    hub: number | null
    border: number | null
    ratio: number | null
    caldariStationTypeID: number | null
    minmatarStationTypeID: number | null
    amarrStationTypeID: number | null
    gallenteStationTypeID: number | null
    joveStationTypeID: number | null
  }

  export type StaOperationsSumAggregateOutputType = {
    activityID: number | null
    operationID: number | null
    fringe: number | null
    corridor: number | null
    hub: number | null
    border: number | null
    ratio: number | null
    caldariStationTypeID: number | null
    minmatarStationTypeID: number | null
    amarrStationTypeID: number | null
    gallenteStationTypeID: number | null
    joveStationTypeID: number | null
  }

  export type StaOperationsMinAggregateOutputType = {
    activityID: number | null
    operationID: number | null
    operationName: string | null
    description: string | null
    fringe: number | null
    corridor: number | null
    hub: number | null
    border: number | null
    ratio: number | null
    caldariStationTypeID: number | null
    minmatarStationTypeID: number | null
    amarrStationTypeID: number | null
    gallenteStationTypeID: number | null
    joveStationTypeID: number | null
  }

  export type StaOperationsMaxAggregateOutputType = {
    activityID: number | null
    operationID: number | null
    operationName: string | null
    description: string | null
    fringe: number | null
    corridor: number | null
    hub: number | null
    border: number | null
    ratio: number | null
    caldariStationTypeID: number | null
    minmatarStationTypeID: number | null
    amarrStationTypeID: number | null
    gallenteStationTypeID: number | null
    joveStationTypeID: number | null
  }

  export type StaOperationsCountAggregateOutputType = {
    activityID: number
    operationID: number
    operationName: number
    description: number
    fringe: number
    corridor: number
    hub: number
    border: number
    ratio: number
    caldariStationTypeID: number
    minmatarStationTypeID: number
    amarrStationTypeID: number
    gallenteStationTypeID: number
    joveStationTypeID: number
    _all: number
  }


  export type StaOperationsAvgAggregateInputType = {
    activityID?: true
    operationID?: true
    fringe?: true
    corridor?: true
    hub?: true
    border?: true
    ratio?: true
    caldariStationTypeID?: true
    minmatarStationTypeID?: true
    amarrStationTypeID?: true
    gallenteStationTypeID?: true
    joveStationTypeID?: true
  }

  export type StaOperationsSumAggregateInputType = {
    activityID?: true
    operationID?: true
    fringe?: true
    corridor?: true
    hub?: true
    border?: true
    ratio?: true
    caldariStationTypeID?: true
    minmatarStationTypeID?: true
    amarrStationTypeID?: true
    gallenteStationTypeID?: true
    joveStationTypeID?: true
  }

  export type StaOperationsMinAggregateInputType = {
    activityID?: true
    operationID?: true
    operationName?: true
    description?: true
    fringe?: true
    corridor?: true
    hub?: true
    border?: true
    ratio?: true
    caldariStationTypeID?: true
    minmatarStationTypeID?: true
    amarrStationTypeID?: true
    gallenteStationTypeID?: true
    joveStationTypeID?: true
  }

  export type StaOperationsMaxAggregateInputType = {
    activityID?: true
    operationID?: true
    operationName?: true
    description?: true
    fringe?: true
    corridor?: true
    hub?: true
    border?: true
    ratio?: true
    caldariStationTypeID?: true
    minmatarStationTypeID?: true
    amarrStationTypeID?: true
    gallenteStationTypeID?: true
    joveStationTypeID?: true
  }

  export type StaOperationsCountAggregateInputType = {
    activityID?: true
    operationID?: true
    operationName?: true
    description?: true
    fringe?: true
    corridor?: true
    hub?: true
    border?: true
    ratio?: true
    caldariStationTypeID?: true
    minmatarStationTypeID?: true
    amarrStationTypeID?: true
    gallenteStationTypeID?: true
    joveStationTypeID?: true
    _all?: true
  }

  export type StaOperationsAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which staOperations to aggregate.
     */
    where?: staOperationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of staOperations to fetch.
     */
    orderBy?: staOperationsOrderByWithRelationInput | staOperationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: staOperationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` staOperations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` staOperations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned staOperations
    **/
    _count?: true | StaOperationsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: StaOperationsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: StaOperationsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: StaOperationsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: StaOperationsMaxAggregateInputType
  }

  export type GetStaOperationsAggregateType<T extends StaOperationsAggregateArgs> = {
        [P in keyof T & keyof AggregateStaOperations]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStaOperations[P]>
      : GetScalarType<T[P], AggregateStaOperations[P]>
  }




  export type staOperationsGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: staOperationsWhereInput
    orderBy?: staOperationsOrderByWithAggregationInput | staOperationsOrderByWithAggregationInput[]
    by: StaOperationsScalarFieldEnum[] | StaOperationsScalarFieldEnum
    having?: staOperationsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: StaOperationsCountAggregateInputType | true
    _avg?: StaOperationsAvgAggregateInputType
    _sum?: StaOperationsSumAggregateInputType
    _min?: StaOperationsMinAggregateInputType
    _max?: StaOperationsMaxAggregateInputType
  }

  export type StaOperationsGroupByOutputType = {
    activityID: number | null
    operationID: number
    operationName: string | null
    description: string | null
    fringe: number | null
    corridor: number | null
    hub: number | null
    border: number | null
    ratio: number | null
    caldariStationTypeID: number | null
    minmatarStationTypeID: number | null
    amarrStationTypeID: number | null
    gallenteStationTypeID: number | null
    joveStationTypeID: number | null
    _count: StaOperationsCountAggregateOutputType | null
    _avg: StaOperationsAvgAggregateOutputType | null
    _sum: StaOperationsSumAggregateOutputType | null
    _min: StaOperationsMinAggregateOutputType | null
    _max: StaOperationsMaxAggregateOutputType | null
  }

  type GetStaOperationsGroupByPayload<T extends staOperationsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<StaOperationsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof StaOperationsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], StaOperationsGroupByOutputType[P]>
            : GetScalarType<T[P], StaOperationsGroupByOutputType[P]>
        }
      >
    >


  export type staOperationsSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    activityID?: boolean
    operationID?: boolean
    operationName?: boolean
    description?: boolean
    fringe?: boolean
    corridor?: boolean
    hub?: boolean
    border?: boolean
    ratio?: boolean
    caldariStationTypeID?: boolean
    minmatarStationTypeID?: boolean
    amarrStationTypeID?: boolean
    gallenteStationTypeID?: boolean
    joveStationTypeID?: boolean
  }, ExtArgs["result"]["staOperations"]>

  export type staOperationsSelectScalar = {
    activityID?: boolean
    operationID?: boolean
    operationName?: boolean
    description?: boolean
    fringe?: boolean
    corridor?: boolean
    hub?: boolean
    border?: boolean
    ratio?: boolean
    caldariStationTypeID?: boolean
    minmatarStationTypeID?: boolean
    amarrStationTypeID?: boolean
    gallenteStationTypeID?: boolean
    joveStationTypeID?: boolean
  }


  export type $staOperationsPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    name: "staOperations"
    objects: {}
    scalars: $Extensions.GetResult<{
      activityID: number | null
      operationID: number
      operationName: string | null
      description: string | null
      fringe: number | null
      corridor: number | null
      hub: number | null
      border: number | null
      ratio: number | null
      caldariStationTypeID: number | null
      minmatarStationTypeID: number | null
      amarrStationTypeID: number | null
      gallenteStationTypeID: number | null
      joveStationTypeID: number | null
    }, ExtArgs["result"]["staOperations"]>
    composites: {}
  }


  type staOperationsGetPayload<S extends boolean | null | undefined | staOperationsDefaultArgs> = $Result.GetResult<Prisma.$staOperationsPayload, S>

  type staOperationsCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<staOperationsFindManyArgs, 'select' | 'include'> & {
      select?: StaOperationsCountAggregateInputType | true
    }

  export interface staOperationsDelegate<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['staOperations'], meta: { name: 'staOperations' } }
    /**
     * Find zero or one StaOperations that matches the filter.
     * @param {staOperationsFindUniqueArgs} args - Arguments to find a StaOperations
     * @example
     * // Get one StaOperations
     * const staOperations = await prisma.staOperations.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends staOperationsFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, staOperationsFindUniqueArgs<ExtArgs>>
    ): Prisma__staOperationsClient<$Result.GetResult<Prisma.$staOperationsPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one StaOperations that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {staOperationsFindUniqueOrThrowArgs} args - Arguments to find a StaOperations
     * @example
     * // Get one StaOperations
     * const staOperations = await prisma.staOperations.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends staOperationsFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, staOperationsFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__staOperationsClient<$Result.GetResult<Prisma.$staOperationsPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first StaOperations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {staOperationsFindFirstArgs} args - Arguments to find a StaOperations
     * @example
     * // Get one StaOperations
     * const staOperations = await prisma.staOperations.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends staOperationsFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, staOperationsFindFirstArgs<ExtArgs>>
    ): Prisma__staOperationsClient<$Result.GetResult<Prisma.$staOperationsPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first StaOperations that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {staOperationsFindFirstOrThrowArgs} args - Arguments to find a StaOperations
     * @example
     * // Get one StaOperations
     * const staOperations = await prisma.staOperations.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends staOperationsFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, staOperationsFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__staOperationsClient<$Result.GetResult<Prisma.$staOperationsPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more StaOperations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {staOperationsFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all StaOperations
     * const staOperations = await prisma.staOperations.findMany()
     * 
     * // Get first 10 StaOperations
     * const staOperations = await prisma.staOperations.findMany({ take: 10 })
     * 
     * // Only select the `activityID`
     * const staOperationsWithActivityIDOnly = await prisma.staOperations.findMany({ select: { activityID: true } })
     * 
    **/
    findMany<T extends staOperationsFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, staOperationsFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$staOperationsPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a StaOperations.
     * @param {staOperationsCreateArgs} args - Arguments to create a StaOperations.
     * @example
     * // Create one StaOperations
     * const StaOperations = await prisma.staOperations.create({
     *   data: {
     *     // ... data to create a StaOperations
     *   }
     * })
     * 
    **/
    create<T extends staOperationsCreateArgs<ExtArgs>>(
      args: SelectSubset<T, staOperationsCreateArgs<ExtArgs>>
    ): Prisma__staOperationsClient<$Result.GetResult<Prisma.$staOperationsPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many StaOperations.
     *     @param {staOperationsCreateManyArgs} args - Arguments to create many StaOperations.
     *     @example
     *     // Create many StaOperations
     *     const staOperations = await prisma.staOperations.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends staOperationsCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, staOperationsCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a StaOperations.
     * @param {staOperationsDeleteArgs} args - Arguments to delete one StaOperations.
     * @example
     * // Delete one StaOperations
     * const StaOperations = await prisma.staOperations.delete({
     *   where: {
     *     // ... filter to delete one StaOperations
     *   }
     * })
     * 
    **/
    delete<T extends staOperationsDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, staOperationsDeleteArgs<ExtArgs>>
    ): Prisma__staOperationsClient<$Result.GetResult<Prisma.$staOperationsPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one StaOperations.
     * @param {staOperationsUpdateArgs} args - Arguments to update one StaOperations.
     * @example
     * // Update one StaOperations
     * const staOperations = await prisma.staOperations.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends staOperationsUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, staOperationsUpdateArgs<ExtArgs>>
    ): Prisma__staOperationsClient<$Result.GetResult<Prisma.$staOperationsPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more StaOperations.
     * @param {staOperationsDeleteManyArgs} args - Arguments to filter StaOperations to delete.
     * @example
     * // Delete a few StaOperations
     * const { count } = await prisma.staOperations.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends staOperationsDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, staOperationsDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more StaOperations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {staOperationsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many StaOperations
     * const staOperations = await prisma.staOperations.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends staOperationsUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, staOperationsUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one StaOperations.
     * @param {staOperationsUpsertArgs} args - Arguments to update or create a StaOperations.
     * @example
     * // Update or create a StaOperations
     * const staOperations = await prisma.staOperations.upsert({
     *   create: {
     *     // ... data to create a StaOperations
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the StaOperations we want to update
     *   }
     * })
    **/
    upsert<T extends staOperationsUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, staOperationsUpsertArgs<ExtArgs>>
    ): Prisma__staOperationsClient<$Result.GetResult<Prisma.$staOperationsPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of StaOperations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {staOperationsCountArgs} args - Arguments to filter StaOperations to count.
     * @example
     * // Count the number of StaOperations
     * const count = await prisma.staOperations.count({
     *   where: {
     *     // ... the filter for the StaOperations we want to count
     *   }
     * })
    **/
    count<T extends staOperationsCountArgs>(
      args?: Subset<T, staOperationsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], StaOperationsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a StaOperations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StaOperationsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends StaOperationsAggregateArgs>(args: Subset<T, StaOperationsAggregateArgs>): Prisma.PrismaPromise<GetStaOperationsAggregateType<T>>

    /**
     * Group by StaOperations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {staOperationsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends staOperationsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: staOperationsGroupByArgs['orderBy'] }
        : { orderBy?: staOperationsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, staOperationsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStaOperationsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the staOperations model
   */
  readonly fields: staOperationsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for staOperations.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__staOperationsClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';


    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the staOperations model
   */ 
  interface staOperationsFieldRefs {
    readonly activityID: FieldRef<"staOperations", 'Int'>
    readonly operationID: FieldRef<"staOperations", 'Int'>
    readonly operationName: FieldRef<"staOperations", 'String'>
    readonly description: FieldRef<"staOperations", 'String'>
    readonly fringe: FieldRef<"staOperations", 'Int'>
    readonly corridor: FieldRef<"staOperations", 'Int'>
    readonly hub: FieldRef<"staOperations", 'Int'>
    readonly border: FieldRef<"staOperations", 'Int'>
    readonly ratio: FieldRef<"staOperations", 'Int'>
    readonly caldariStationTypeID: FieldRef<"staOperations", 'Int'>
    readonly minmatarStationTypeID: FieldRef<"staOperations", 'Int'>
    readonly amarrStationTypeID: FieldRef<"staOperations", 'Int'>
    readonly gallenteStationTypeID: FieldRef<"staOperations", 'Int'>
    readonly joveStationTypeID: FieldRef<"staOperations", 'Int'>
  }
    

  // Custom InputTypes

  /**
   * staOperations findUnique
   */
  export type staOperationsFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the staOperations
     */
    select?: staOperationsSelect<ExtArgs> | null
    /**
     * Filter, which staOperations to fetch.
     */
    where: staOperationsWhereUniqueInput
  }


  /**
   * staOperations findUniqueOrThrow
   */
  export type staOperationsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the staOperations
     */
    select?: staOperationsSelect<ExtArgs> | null
    /**
     * Filter, which staOperations to fetch.
     */
    where: staOperationsWhereUniqueInput
  }


  /**
   * staOperations findFirst
   */
  export type staOperationsFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the staOperations
     */
    select?: staOperationsSelect<ExtArgs> | null
    /**
     * Filter, which staOperations to fetch.
     */
    where?: staOperationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of staOperations to fetch.
     */
    orderBy?: staOperationsOrderByWithRelationInput | staOperationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for staOperations.
     */
    cursor?: staOperationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` staOperations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` staOperations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of staOperations.
     */
    distinct?: StaOperationsScalarFieldEnum | StaOperationsScalarFieldEnum[]
  }


  /**
   * staOperations findFirstOrThrow
   */
  export type staOperationsFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the staOperations
     */
    select?: staOperationsSelect<ExtArgs> | null
    /**
     * Filter, which staOperations to fetch.
     */
    where?: staOperationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of staOperations to fetch.
     */
    orderBy?: staOperationsOrderByWithRelationInput | staOperationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for staOperations.
     */
    cursor?: staOperationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` staOperations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` staOperations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of staOperations.
     */
    distinct?: StaOperationsScalarFieldEnum | StaOperationsScalarFieldEnum[]
  }


  /**
   * staOperations findMany
   */
  export type staOperationsFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the staOperations
     */
    select?: staOperationsSelect<ExtArgs> | null
    /**
     * Filter, which staOperations to fetch.
     */
    where?: staOperationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of staOperations to fetch.
     */
    orderBy?: staOperationsOrderByWithRelationInput | staOperationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing staOperations.
     */
    cursor?: staOperationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` staOperations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` staOperations.
     */
    skip?: number
    distinct?: StaOperationsScalarFieldEnum | StaOperationsScalarFieldEnum[]
  }


  /**
   * staOperations create
   */
  export type staOperationsCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the staOperations
     */
    select?: staOperationsSelect<ExtArgs> | null
    /**
     * The data needed to create a staOperations.
     */
    data: XOR<staOperationsCreateInput, staOperationsUncheckedCreateInput>
  }


  /**
   * staOperations createMany
   */
  export type staOperationsCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many staOperations.
     */
    data: staOperationsCreateManyInput | staOperationsCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * staOperations update
   */
  export type staOperationsUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the staOperations
     */
    select?: staOperationsSelect<ExtArgs> | null
    /**
     * The data needed to update a staOperations.
     */
    data: XOR<staOperationsUpdateInput, staOperationsUncheckedUpdateInput>
    /**
     * Choose, which staOperations to update.
     */
    where: staOperationsWhereUniqueInput
  }


  /**
   * staOperations updateMany
   */
  export type staOperationsUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update staOperations.
     */
    data: XOR<staOperationsUpdateManyMutationInput, staOperationsUncheckedUpdateManyInput>
    /**
     * Filter which staOperations to update
     */
    where?: staOperationsWhereInput
  }


  /**
   * staOperations upsert
   */
  export type staOperationsUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the staOperations
     */
    select?: staOperationsSelect<ExtArgs> | null
    /**
     * The filter to search for the staOperations to update in case it exists.
     */
    where: staOperationsWhereUniqueInput
    /**
     * In case the staOperations found by the `where` argument doesn't exist, create a new staOperations with this data.
     */
    create: XOR<staOperationsCreateInput, staOperationsUncheckedCreateInput>
    /**
     * In case the staOperations was found with the provided `where` argument, update it with this data.
     */
    update: XOR<staOperationsUpdateInput, staOperationsUncheckedUpdateInput>
  }


  /**
   * staOperations delete
   */
  export type staOperationsDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the staOperations
     */
    select?: staOperationsSelect<ExtArgs> | null
    /**
     * Filter which staOperations to delete.
     */
    where: staOperationsWhereUniqueInput
  }


  /**
   * staOperations deleteMany
   */
  export type staOperationsDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which staOperations to delete
     */
    where?: staOperationsWhereInput
  }


  /**
   * staOperations without action
   */
  export type staOperationsDefaultArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the staOperations
     */
    select?: staOperationsSelect<ExtArgs> | null
  }



  /**
   * Model staServices
   */

  export type AggregateStaServices = {
    _count: StaServicesCountAggregateOutputType | null
    _avg: StaServicesAvgAggregateOutputType | null
    _sum: StaServicesSumAggregateOutputType | null
    _min: StaServicesMinAggregateOutputType | null
    _max: StaServicesMaxAggregateOutputType | null
  }

  export type StaServicesAvgAggregateOutputType = {
    serviceID: number | null
  }

  export type StaServicesSumAggregateOutputType = {
    serviceID: number | null
  }

  export type StaServicesMinAggregateOutputType = {
    serviceID: number | null
    serviceName: string | null
    description: string | null
  }

  export type StaServicesMaxAggregateOutputType = {
    serviceID: number | null
    serviceName: string | null
    description: string | null
  }

  export type StaServicesCountAggregateOutputType = {
    serviceID: number
    serviceName: number
    description: number
    _all: number
  }


  export type StaServicesAvgAggregateInputType = {
    serviceID?: true
  }

  export type StaServicesSumAggregateInputType = {
    serviceID?: true
  }

  export type StaServicesMinAggregateInputType = {
    serviceID?: true
    serviceName?: true
    description?: true
  }

  export type StaServicesMaxAggregateInputType = {
    serviceID?: true
    serviceName?: true
    description?: true
  }

  export type StaServicesCountAggregateInputType = {
    serviceID?: true
    serviceName?: true
    description?: true
    _all?: true
  }

  export type StaServicesAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which staServices to aggregate.
     */
    where?: staServicesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of staServices to fetch.
     */
    orderBy?: staServicesOrderByWithRelationInput | staServicesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: staServicesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` staServices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` staServices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned staServices
    **/
    _count?: true | StaServicesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: StaServicesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: StaServicesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: StaServicesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: StaServicesMaxAggregateInputType
  }

  export type GetStaServicesAggregateType<T extends StaServicesAggregateArgs> = {
        [P in keyof T & keyof AggregateStaServices]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStaServices[P]>
      : GetScalarType<T[P], AggregateStaServices[P]>
  }




  export type staServicesGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: staServicesWhereInput
    orderBy?: staServicesOrderByWithAggregationInput | staServicesOrderByWithAggregationInput[]
    by: StaServicesScalarFieldEnum[] | StaServicesScalarFieldEnum
    having?: staServicesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: StaServicesCountAggregateInputType | true
    _avg?: StaServicesAvgAggregateInputType
    _sum?: StaServicesSumAggregateInputType
    _min?: StaServicesMinAggregateInputType
    _max?: StaServicesMaxAggregateInputType
  }

  export type StaServicesGroupByOutputType = {
    serviceID: number
    serviceName: string | null
    description: string | null
    _count: StaServicesCountAggregateOutputType | null
    _avg: StaServicesAvgAggregateOutputType | null
    _sum: StaServicesSumAggregateOutputType | null
    _min: StaServicesMinAggregateOutputType | null
    _max: StaServicesMaxAggregateOutputType | null
  }

  type GetStaServicesGroupByPayload<T extends staServicesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<StaServicesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof StaServicesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], StaServicesGroupByOutputType[P]>
            : GetScalarType<T[P], StaServicesGroupByOutputType[P]>
        }
      >
    >


  export type staServicesSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    serviceID?: boolean
    serviceName?: boolean
    description?: boolean
  }, ExtArgs["result"]["staServices"]>

  export type staServicesSelectScalar = {
    serviceID?: boolean
    serviceName?: boolean
    description?: boolean
  }


  export type $staServicesPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    name: "staServices"
    objects: {}
    scalars: $Extensions.GetResult<{
      serviceID: number
      serviceName: string | null
      description: string | null
    }, ExtArgs["result"]["staServices"]>
    composites: {}
  }


  type staServicesGetPayload<S extends boolean | null | undefined | staServicesDefaultArgs> = $Result.GetResult<Prisma.$staServicesPayload, S>

  type staServicesCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<staServicesFindManyArgs, 'select' | 'include'> & {
      select?: StaServicesCountAggregateInputType | true
    }

  export interface staServicesDelegate<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['staServices'], meta: { name: 'staServices' } }
    /**
     * Find zero or one StaServices that matches the filter.
     * @param {staServicesFindUniqueArgs} args - Arguments to find a StaServices
     * @example
     * // Get one StaServices
     * const staServices = await prisma.staServices.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends staServicesFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, staServicesFindUniqueArgs<ExtArgs>>
    ): Prisma__staServicesClient<$Result.GetResult<Prisma.$staServicesPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one StaServices that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {staServicesFindUniqueOrThrowArgs} args - Arguments to find a StaServices
     * @example
     * // Get one StaServices
     * const staServices = await prisma.staServices.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends staServicesFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, staServicesFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__staServicesClient<$Result.GetResult<Prisma.$staServicesPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first StaServices that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {staServicesFindFirstArgs} args - Arguments to find a StaServices
     * @example
     * // Get one StaServices
     * const staServices = await prisma.staServices.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends staServicesFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, staServicesFindFirstArgs<ExtArgs>>
    ): Prisma__staServicesClient<$Result.GetResult<Prisma.$staServicesPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first StaServices that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {staServicesFindFirstOrThrowArgs} args - Arguments to find a StaServices
     * @example
     * // Get one StaServices
     * const staServices = await prisma.staServices.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends staServicesFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, staServicesFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__staServicesClient<$Result.GetResult<Prisma.$staServicesPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more StaServices that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {staServicesFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all StaServices
     * const staServices = await prisma.staServices.findMany()
     * 
     * // Get first 10 StaServices
     * const staServices = await prisma.staServices.findMany({ take: 10 })
     * 
     * // Only select the `serviceID`
     * const staServicesWithServiceIDOnly = await prisma.staServices.findMany({ select: { serviceID: true } })
     * 
    **/
    findMany<T extends staServicesFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, staServicesFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$staServicesPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a StaServices.
     * @param {staServicesCreateArgs} args - Arguments to create a StaServices.
     * @example
     * // Create one StaServices
     * const StaServices = await prisma.staServices.create({
     *   data: {
     *     // ... data to create a StaServices
     *   }
     * })
     * 
    **/
    create<T extends staServicesCreateArgs<ExtArgs>>(
      args: SelectSubset<T, staServicesCreateArgs<ExtArgs>>
    ): Prisma__staServicesClient<$Result.GetResult<Prisma.$staServicesPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many StaServices.
     *     @param {staServicesCreateManyArgs} args - Arguments to create many StaServices.
     *     @example
     *     // Create many StaServices
     *     const staServices = await prisma.staServices.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends staServicesCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, staServicesCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a StaServices.
     * @param {staServicesDeleteArgs} args - Arguments to delete one StaServices.
     * @example
     * // Delete one StaServices
     * const StaServices = await prisma.staServices.delete({
     *   where: {
     *     // ... filter to delete one StaServices
     *   }
     * })
     * 
    **/
    delete<T extends staServicesDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, staServicesDeleteArgs<ExtArgs>>
    ): Prisma__staServicesClient<$Result.GetResult<Prisma.$staServicesPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one StaServices.
     * @param {staServicesUpdateArgs} args - Arguments to update one StaServices.
     * @example
     * // Update one StaServices
     * const staServices = await prisma.staServices.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends staServicesUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, staServicesUpdateArgs<ExtArgs>>
    ): Prisma__staServicesClient<$Result.GetResult<Prisma.$staServicesPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more StaServices.
     * @param {staServicesDeleteManyArgs} args - Arguments to filter StaServices to delete.
     * @example
     * // Delete a few StaServices
     * const { count } = await prisma.staServices.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends staServicesDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, staServicesDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more StaServices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {staServicesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many StaServices
     * const staServices = await prisma.staServices.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends staServicesUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, staServicesUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one StaServices.
     * @param {staServicesUpsertArgs} args - Arguments to update or create a StaServices.
     * @example
     * // Update or create a StaServices
     * const staServices = await prisma.staServices.upsert({
     *   create: {
     *     // ... data to create a StaServices
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the StaServices we want to update
     *   }
     * })
    **/
    upsert<T extends staServicesUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, staServicesUpsertArgs<ExtArgs>>
    ): Prisma__staServicesClient<$Result.GetResult<Prisma.$staServicesPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of StaServices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {staServicesCountArgs} args - Arguments to filter StaServices to count.
     * @example
     * // Count the number of StaServices
     * const count = await prisma.staServices.count({
     *   where: {
     *     // ... the filter for the StaServices we want to count
     *   }
     * })
    **/
    count<T extends staServicesCountArgs>(
      args?: Subset<T, staServicesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], StaServicesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a StaServices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StaServicesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends StaServicesAggregateArgs>(args: Subset<T, StaServicesAggregateArgs>): Prisma.PrismaPromise<GetStaServicesAggregateType<T>>

    /**
     * Group by StaServices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {staServicesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends staServicesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: staServicesGroupByArgs['orderBy'] }
        : { orderBy?: staServicesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, staServicesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStaServicesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the staServices model
   */
  readonly fields: staServicesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for staServices.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__staServicesClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';


    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the staServices model
   */ 
  interface staServicesFieldRefs {
    readonly serviceID: FieldRef<"staServices", 'Int'>
    readonly serviceName: FieldRef<"staServices", 'String'>
    readonly description: FieldRef<"staServices", 'String'>
  }
    

  // Custom InputTypes

  /**
   * staServices findUnique
   */
  export type staServicesFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the staServices
     */
    select?: staServicesSelect<ExtArgs> | null
    /**
     * Filter, which staServices to fetch.
     */
    where: staServicesWhereUniqueInput
  }


  /**
   * staServices findUniqueOrThrow
   */
  export type staServicesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the staServices
     */
    select?: staServicesSelect<ExtArgs> | null
    /**
     * Filter, which staServices to fetch.
     */
    where: staServicesWhereUniqueInput
  }


  /**
   * staServices findFirst
   */
  export type staServicesFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the staServices
     */
    select?: staServicesSelect<ExtArgs> | null
    /**
     * Filter, which staServices to fetch.
     */
    where?: staServicesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of staServices to fetch.
     */
    orderBy?: staServicesOrderByWithRelationInput | staServicesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for staServices.
     */
    cursor?: staServicesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` staServices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` staServices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of staServices.
     */
    distinct?: StaServicesScalarFieldEnum | StaServicesScalarFieldEnum[]
  }


  /**
   * staServices findFirstOrThrow
   */
  export type staServicesFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the staServices
     */
    select?: staServicesSelect<ExtArgs> | null
    /**
     * Filter, which staServices to fetch.
     */
    where?: staServicesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of staServices to fetch.
     */
    orderBy?: staServicesOrderByWithRelationInput | staServicesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for staServices.
     */
    cursor?: staServicesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` staServices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` staServices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of staServices.
     */
    distinct?: StaServicesScalarFieldEnum | StaServicesScalarFieldEnum[]
  }


  /**
   * staServices findMany
   */
  export type staServicesFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the staServices
     */
    select?: staServicesSelect<ExtArgs> | null
    /**
     * Filter, which staServices to fetch.
     */
    where?: staServicesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of staServices to fetch.
     */
    orderBy?: staServicesOrderByWithRelationInput | staServicesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing staServices.
     */
    cursor?: staServicesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` staServices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` staServices.
     */
    skip?: number
    distinct?: StaServicesScalarFieldEnum | StaServicesScalarFieldEnum[]
  }


  /**
   * staServices create
   */
  export type staServicesCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the staServices
     */
    select?: staServicesSelect<ExtArgs> | null
    /**
     * The data needed to create a staServices.
     */
    data: XOR<staServicesCreateInput, staServicesUncheckedCreateInput>
  }


  /**
   * staServices createMany
   */
  export type staServicesCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many staServices.
     */
    data: staServicesCreateManyInput | staServicesCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * staServices update
   */
  export type staServicesUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the staServices
     */
    select?: staServicesSelect<ExtArgs> | null
    /**
     * The data needed to update a staServices.
     */
    data: XOR<staServicesUpdateInput, staServicesUncheckedUpdateInput>
    /**
     * Choose, which staServices to update.
     */
    where: staServicesWhereUniqueInput
  }


  /**
   * staServices updateMany
   */
  export type staServicesUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update staServices.
     */
    data: XOR<staServicesUpdateManyMutationInput, staServicesUncheckedUpdateManyInput>
    /**
     * Filter which staServices to update
     */
    where?: staServicesWhereInput
  }


  /**
   * staServices upsert
   */
  export type staServicesUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the staServices
     */
    select?: staServicesSelect<ExtArgs> | null
    /**
     * The filter to search for the staServices to update in case it exists.
     */
    where: staServicesWhereUniqueInput
    /**
     * In case the staServices found by the `where` argument doesn't exist, create a new staServices with this data.
     */
    create: XOR<staServicesCreateInput, staServicesUncheckedCreateInput>
    /**
     * In case the staServices was found with the provided `where` argument, update it with this data.
     */
    update: XOR<staServicesUpdateInput, staServicesUncheckedUpdateInput>
  }


  /**
   * staServices delete
   */
  export type staServicesDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the staServices
     */
    select?: staServicesSelect<ExtArgs> | null
    /**
     * Filter which staServices to delete.
     */
    where: staServicesWhereUniqueInput
  }


  /**
   * staServices deleteMany
   */
  export type staServicesDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which staServices to delete
     */
    where?: staServicesWhereInput
  }


  /**
   * staServices without action
   */
  export type staServicesDefaultArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the staServices
     */
    select?: staServicesSelect<ExtArgs> | null
  }



  /**
   * Model staStationTypes
   */

  export type AggregateStaStationTypes = {
    _count: StaStationTypesCountAggregateOutputType | null
    _avg: StaStationTypesAvgAggregateOutputType | null
    _sum: StaStationTypesSumAggregateOutputType | null
    _min: StaStationTypesMinAggregateOutputType | null
    _max: StaStationTypesMaxAggregateOutputType | null
  }

  export type StaStationTypesAvgAggregateOutputType = {
    stationTypeID: number | null
    dockEntryX: number | null
    dockEntryY: number | null
    dockEntryZ: number | null
    dockOrientationX: number | null
    dockOrientationY: number | null
    dockOrientationZ: number | null
    operationID: number | null
    officeSlots: number | null
    reprocessingEfficiency: number | null
  }

  export type StaStationTypesSumAggregateOutputType = {
    stationTypeID: number | null
    dockEntryX: number | null
    dockEntryY: number | null
    dockEntryZ: number | null
    dockOrientationX: number | null
    dockOrientationY: number | null
    dockOrientationZ: number | null
    operationID: number | null
    officeSlots: number | null
    reprocessingEfficiency: number | null
  }

  export type StaStationTypesMinAggregateOutputType = {
    stationTypeID: number | null
    dockEntryX: number | null
    dockEntryY: number | null
    dockEntryZ: number | null
    dockOrientationX: number | null
    dockOrientationY: number | null
    dockOrientationZ: number | null
    operationID: number | null
    officeSlots: number | null
    reprocessingEfficiency: number | null
    conquerable: boolean | null
  }

  export type StaStationTypesMaxAggregateOutputType = {
    stationTypeID: number | null
    dockEntryX: number | null
    dockEntryY: number | null
    dockEntryZ: number | null
    dockOrientationX: number | null
    dockOrientationY: number | null
    dockOrientationZ: number | null
    operationID: number | null
    officeSlots: number | null
    reprocessingEfficiency: number | null
    conquerable: boolean | null
  }

  export type StaStationTypesCountAggregateOutputType = {
    stationTypeID: number
    dockEntryX: number
    dockEntryY: number
    dockEntryZ: number
    dockOrientationX: number
    dockOrientationY: number
    dockOrientationZ: number
    operationID: number
    officeSlots: number
    reprocessingEfficiency: number
    conquerable: number
    _all: number
  }


  export type StaStationTypesAvgAggregateInputType = {
    stationTypeID?: true
    dockEntryX?: true
    dockEntryY?: true
    dockEntryZ?: true
    dockOrientationX?: true
    dockOrientationY?: true
    dockOrientationZ?: true
    operationID?: true
    officeSlots?: true
    reprocessingEfficiency?: true
  }

  export type StaStationTypesSumAggregateInputType = {
    stationTypeID?: true
    dockEntryX?: true
    dockEntryY?: true
    dockEntryZ?: true
    dockOrientationX?: true
    dockOrientationY?: true
    dockOrientationZ?: true
    operationID?: true
    officeSlots?: true
    reprocessingEfficiency?: true
  }

  export type StaStationTypesMinAggregateInputType = {
    stationTypeID?: true
    dockEntryX?: true
    dockEntryY?: true
    dockEntryZ?: true
    dockOrientationX?: true
    dockOrientationY?: true
    dockOrientationZ?: true
    operationID?: true
    officeSlots?: true
    reprocessingEfficiency?: true
    conquerable?: true
  }

  export type StaStationTypesMaxAggregateInputType = {
    stationTypeID?: true
    dockEntryX?: true
    dockEntryY?: true
    dockEntryZ?: true
    dockOrientationX?: true
    dockOrientationY?: true
    dockOrientationZ?: true
    operationID?: true
    officeSlots?: true
    reprocessingEfficiency?: true
    conquerable?: true
  }

  export type StaStationTypesCountAggregateInputType = {
    stationTypeID?: true
    dockEntryX?: true
    dockEntryY?: true
    dockEntryZ?: true
    dockOrientationX?: true
    dockOrientationY?: true
    dockOrientationZ?: true
    operationID?: true
    officeSlots?: true
    reprocessingEfficiency?: true
    conquerable?: true
    _all?: true
  }

  export type StaStationTypesAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which staStationTypes to aggregate.
     */
    where?: staStationTypesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of staStationTypes to fetch.
     */
    orderBy?: staStationTypesOrderByWithRelationInput | staStationTypesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: staStationTypesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` staStationTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` staStationTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned staStationTypes
    **/
    _count?: true | StaStationTypesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: StaStationTypesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: StaStationTypesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: StaStationTypesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: StaStationTypesMaxAggregateInputType
  }

  export type GetStaStationTypesAggregateType<T extends StaStationTypesAggregateArgs> = {
        [P in keyof T & keyof AggregateStaStationTypes]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStaStationTypes[P]>
      : GetScalarType<T[P], AggregateStaStationTypes[P]>
  }




  export type staStationTypesGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: staStationTypesWhereInput
    orderBy?: staStationTypesOrderByWithAggregationInput | staStationTypesOrderByWithAggregationInput[]
    by: StaStationTypesScalarFieldEnum[] | StaStationTypesScalarFieldEnum
    having?: staStationTypesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: StaStationTypesCountAggregateInputType | true
    _avg?: StaStationTypesAvgAggregateInputType
    _sum?: StaStationTypesSumAggregateInputType
    _min?: StaStationTypesMinAggregateInputType
    _max?: StaStationTypesMaxAggregateInputType
  }

  export type StaStationTypesGroupByOutputType = {
    stationTypeID: number
    dockEntryX: number | null
    dockEntryY: number | null
    dockEntryZ: number | null
    dockOrientationX: number | null
    dockOrientationY: number | null
    dockOrientationZ: number | null
    operationID: number | null
    officeSlots: number | null
    reprocessingEfficiency: number | null
    conquerable: boolean | null
    _count: StaStationTypesCountAggregateOutputType | null
    _avg: StaStationTypesAvgAggregateOutputType | null
    _sum: StaStationTypesSumAggregateOutputType | null
    _min: StaStationTypesMinAggregateOutputType | null
    _max: StaStationTypesMaxAggregateOutputType | null
  }

  type GetStaStationTypesGroupByPayload<T extends staStationTypesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<StaStationTypesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof StaStationTypesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], StaStationTypesGroupByOutputType[P]>
            : GetScalarType<T[P], StaStationTypesGroupByOutputType[P]>
        }
      >
    >


  export type staStationTypesSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    stationTypeID?: boolean
    dockEntryX?: boolean
    dockEntryY?: boolean
    dockEntryZ?: boolean
    dockOrientationX?: boolean
    dockOrientationY?: boolean
    dockOrientationZ?: boolean
    operationID?: boolean
    officeSlots?: boolean
    reprocessingEfficiency?: boolean
    conquerable?: boolean
  }, ExtArgs["result"]["staStationTypes"]>

  export type staStationTypesSelectScalar = {
    stationTypeID?: boolean
    dockEntryX?: boolean
    dockEntryY?: boolean
    dockEntryZ?: boolean
    dockOrientationX?: boolean
    dockOrientationY?: boolean
    dockOrientationZ?: boolean
    operationID?: boolean
    officeSlots?: boolean
    reprocessingEfficiency?: boolean
    conquerable?: boolean
  }


  export type $staStationTypesPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    name: "staStationTypes"
    objects: {}
    scalars: $Extensions.GetResult<{
      stationTypeID: number
      dockEntryX: number | null
      dockEntryY: number | null
      dockEntryZ: number | null
      dockOrientationX: number | null
      dockOrientationY: number | null
      dockOrientationZ: number | null
      operationID: number | null
      officeSlots: number | null
      reprocessingEfficiency: number | null
      conquerable: boolean | null
    }, ExtArgs["result"]["staStationTypes"]>
    composites: {}
  }


  type staStationTypesGetPayload<S extends boolean | null | undefined | staStationTypesDefaultArgs> = $Result.GetResult<Prisma.$staStationTypesPayload, S>

  type staStationTypesCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<staStationTypesFindManyArgs, 'select' | 'include'> & {
      select?: StaStationTypesCountAggregateInputType | true
    }

  export interface staStationTypesDelegate<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['staStationTypes'], meta: { name: 'staStationTypes' } }
    /**
     * Find zero or one StaStationTypes that matches the filter.
     * @param {staStationTypesFindUniqueArgs} args - Arguments to find a StaStationTypes
     * @example
     * // Get one StaStationTypes
     * const staStationTypes = await prisma.staStationTypes.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends staStationTypesFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, staStationTypesFindUniqueArgs<ExtArgs>>
    ): Prisma__staStationTypesClient<$Result.GetResult<Prisma.$staStationTypesPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one StaStationTypes that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {staStationTypesFindUniqueOrThrowArgs} args - Arguments to find a StaStationTypes
     * @example
     * // Get one StaStationTypes
     * const staStationTypes = await prisma.staStationTypes.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends staStationTypesFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, staStationTypesFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__staStationTypesClient<$Result.GetResult<Prisma.$staStationTypesPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first StaStationTypes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {staStationTypesFindFirstArgs} args - Arguments to find a StaStationTypes
     * @example
     * // Get one StaStationTypes
     * const staStationTypes = await prisma.staStationTypes.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends staStationTypesFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, staStationTypesFindFirstArgs<ExtArgs>>
    ): Prisma__staStationTypesClient<$Result.GetResult<Prisma.$staStationTypesPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first StaStationTypes that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {staStationTypesFindFirstOrThrowArgs} args - Arguments to find a StaStationTypes
     * @example
     * // Get one StaStationTypes
     * const staStationTypes = await prisma.staStationTypes.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends staStationTypesFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, staStationTypesFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__staStationTypesClient<$Result.GetResult<Prisma.$staStationTypesPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more StaStationTypes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {staStationTypesFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all StaStationTypes
     * const staStationTypes = await prisma.staStationTypes.findMany()
     * 
     * // Get first 10 StaStationTypes
     * const staStationTypes = await prisma.staStationTypes.findMany({ take: 10 })
     * 
     * // Only select the `stationTypeID`
     * const staStationTypesWithStationTypeIDOnly = await prisma.staStationTypes.findMany({ select: { stationTypeID: true } })
     * 
    **/
    findMany<T extends staStationTypesFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, staStationTypesFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$staStationTypesPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a StaStationTypes.
     * @param {staStationTypesCreateArgs} args - Arguments to create a StaStationTypes.
     * @example
     * // Create one StaStationTypes
     * const StaStationTypes = await prisma.staStationTypes.create({
     *   data: {
     *     // ... data to create a StaStationTypes
     *   }
     * })
     * 
    **/
    create<T extends staStationTypesCreateArgs<ExtArgs>>(
      args: SelectSubset<T, staStationTypesCreateArgs<ExtArgs>>
    ): Prisma__staStationTypesClient<$Result.GetResult<Prisma.$staStationTypesPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many StaStationTypes.
     *     @param {staStationTypesCreateManyArgs} args - Arguments to create many StaStationTypes.
     *     @example
     *     // Create many StaStationTypes
     *     const staStationTypes = await prisma.staStationTypes.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends staStationTypesCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, staStationTypesCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a StaStationTypes.
     * @param {staStationTypesDeleteArgs} args - Arguments to delete one StaStationTypes.
     * @example
     * // Delete one StaStationTypes
     * const StaStationTypes = await prisma.staStationTypes.delete({
     *   where: {
     *     // ... filter to delete one StaStationTypes
     *   }
     * })
     * 
    **/
    delete<T extends staStationTypesDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, staStationTypesDeleteArgs<ExtArgs>>
    ): Prisma__staStationTypesClient<$Result.GetResult<Prisma.$staStationTypesPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one StaStationTypes.
     * @param {staStationTypesUpdateArgs} args - Arguments to update one StaStationTypes.
     * @example
     * // Update one StaStationTypes
     * const staStationTypes = await prisma.staStationTypes.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends staStationTypesUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, staStationTypesUpdateArgs<ExtArgs>>
    ): Prisma__staStationTypesClient<$Result.GetResult<Prisma.$staStationTypesPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more StaStationTypes.
     * @param {staStationTypesDeleteManyArgs} args - Arguments to filter StaStationTypes to delete.
     * @example
     * // Delete a few StaStationTypes
     * const { count } = await prisma.staStationTypes.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends staStationTypesDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, staStationTypesDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more StaStationTypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {staStationTypesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many StaStationTypes
     * const staStationTypes = await prisma.staStationTypes.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends staStationTypesUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, staStationTypesUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one StaStationTypes.
     * @param {staStationTypesUpsertArgs} args - Arguments to update or create a StaStationTypes.
     * @example
     * // Update or create a StaStationTypes
     * const staStationTypes = await prisma.staStationTypes.upsert({
     *   create: {
     *     // ... data to create a StaStationTypes
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the StaStationTypes we want to update
     *   }
     * })
    **/
    upsert<T extends staStationTypesUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, staStationTypesUpsertArgs<ExtArgs>>
    ): Prisma__staStationTypesClient<$Result.GetResult<Prisma.$staStationTypesPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of StaStationTypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {staStationTypesCountArgs} args - Arguments to filter StaStationTypes to count.
     * @example
     * // Count the number of StaStationTypes
     * const count = await prisma.staStationTypes.count({
     *   where: {
     *     // ... the filter for the StaStationTypes we want to count
     *   }
     * })
    **/
    count<T extends staStationTypesCountArgs>(
      args?: Subset<T, staStationTypesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], StaStationTypesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a StaStationTypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StaStationTypesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends StaStationTypesAggregateArgs>(args: Subset<T, StaStationTypesAggregateArgs>): Prisma.PrismaPromise<GetStaStationTypesAggregateType<T>>

    /**
     * Group by StaStationTypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {staStationTypesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends staStationTypesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: staStationTypesGroupByArgs['orderBy'] }
        : { orderBy?: staStationTypesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, staStationTypesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStaStationTypesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the staStationTypes model
   */
  readonly fields: staStationTypesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for staStationTypes.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__staStationTypesClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';


    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the staStationTypes model
   */ 
  interface staStationTypesFieldRefs {
    readonly stationTypeID: FieldRef<"staStationTypes", 'Int'>
    readonly dockEntryX: FieldRef<"staStationTypes", 'Float'>
    readonly dockEntryY: FieldRef<"staStationTypes", 'Float'>
    readonly dockEntryZ: FieldRef<"staStationTypes", 'Float'>
    readonly dockOrientationX: FieldRef<"staStationTypes", 'Float'>
    readonly dockOrientationY: FieldRef<"staStationTypes", 'Float'>
    readonly dockOrientationZ: FieldRef<"staStationTypes", 'Float'>
    readonly operationID: FieldRef<"staStationTypes", 'Int'>
    readonly officeSlots: FieldRef<"staStationTypes", 'Int'>
    readonly reprocessingEfficiency: FieldRef<"staStationTypes", 'Float'>
    readonly conquerable: FieldRef<"staStationTypes", 'Boolean'>
  }
    

  // Custom InputTypes

  /**
   * staStationTypes findUnique
   */
  export type staStationTypesFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the staStationTypes
     */
    select?: staStationTypesSelect<ExtArgs> | null
    /**
     * Filter, which staStationTypes to fetch.
     */
    where: staStationTypesWhereUniqueInput
  }


  /**
   * staStationTypes findUniqueOrThrow
   */
  export type staStationTypesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the staStationTypes
     */
    select?: staStationTypesSelect<ExtArgs> | null
    /**
     * Filter, which staStationTypes to fetch.
     */
    where: staStationTypesWhereUniqueInput
  }


  /**
   * staStationTypes findFirst
   */
  export type staStationTypesFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the staStationTypes
     */
    select?: staStationTypesSelect<ExtArgs> | null
    /**
     * Filter, which staStationTypes to fetch.
     */
    where?: staStationTypesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of staStationTypes to fetch.
     */
    orderBy?: staStationTypesOrderByWithRelationInput | staStationTypesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for staStationTypes.
     */
    cursor?: staStationTypesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` staStationTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` staStationTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of staStationTypes.
     */
    distinct?: StaStationTypesScalarFieldEnum | StaStationTypesScalarFieldEnum[]
  }


  /**
   * staStationTypes findFirstOrThrow
   */
  export type staStationTypesFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the staStationTypes
     */
    select?: staStationTypesSelect<ExtArgs> | null
    /**
     * Filter, which staStationTypes to fetch.
     */
    where?: staStationTypesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of staStationTypes to fetch.
     */
    orderBy?: staStationTypesOrderByWithRelationInput | staStationTypesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for staStationTypes.
     */
    cursor?: staStationTypesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` staStationTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` staStationTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of staStationTypes.
     */
    distinct?: StaStationTypesScalarFieldEnum | StaStationTypesScalarFieldEnum[]
  }


  /**
   * staStationTypes findMany
   */
  export type staStationTypesFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the staStationTypes
     */
    select?: staStationTypesSelect<ExtArgs> | null
    /**
     * Filter, which staStationTypes to fetch.
     */
    where?: staStationTypesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of staStationTypes to fetch.
     */
    orderBy?: staStationTypesOrderByWithRelationInput | staStationTypesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing staStationTypes.
     */
    cursor?: staStationTypesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` staStationTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` staStationTypes.
     */
    skip?: number
    distinct?: StaStationTypesScalarFieldEnum | StaStationTypesScalarFieldEnum[]
  }


  /**
   * staStationTypes create
   */
  export type staStationTypesCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the staStationTypes
     */
    select?: staStationTypesSelect<ExtArgs> | null
    /**
     * The data needed to create a staStationTypes.
     */
    data: XOR<staStationTypesCreateInput, staStationTypesUncheckedCreateInput>
  }


  /**
   * staStationTypes createMany
   */
  export type staStationTypesCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many staStationTypes.
     */
    data: staStationTypesCreateManyInput | staStationTypesCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * staStationTypes update
   */
  export type staStationTypesUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the staStationTypes
     */
    select?: staStationTypesSelect<ExtArgs> | null
    /**
     * The data needed to update a staStationTypes.
     */
    data: XOR<staStationTypesUpdateInput, staStationTypesUncheckedUpdateInput>
    /**
     * Choose, which staStationTypes to update.
     */
    where: staStationTypesWhereUniqueInput
  }


  /**
   * staStationTypes updateMany
   */
  export type staStationTypesUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update staStationTypes.
     */
    data: XOR<staStationTypesUpdateManyMutationInput, staStationTypesUncheckedUpdateManyInput>
    /**
     * Filter which staStationTypes to update
     */
    where?: staStationTypesWhereInput
  }


  /**
   * staStationTypes upsert
   */
  export type staStationTypesUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the staStationTypes
     */
    select?: staStationTypesSelect<ExtArgs> | null
    /**
     * The filter to search for the staStationTypes to update in case it exists.
     */
    where: staStationTypesWhereUniqueInput
    /**
     * In case the staStationTypes found by the `where` argument doesn't exist, create a new staStationTypes with this data.
     */
    create: XOR<staStationTypesCreateInput, staStationTypesUncheckedCreateInput>
    /**
     * In case the staStationTypes was found with the provided `where` argument, update it with this data.
     */
    update: XOR<staStationTypesUpdateInput, staStationTypesUncheckedUpdateInput>
  }


  /**
   * staStationTypes delete
   */
  export type staStationTypesDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the staStationTypes
     */
    select?: staStationTypesSelect<ExtArgs> | null
    /**
     * Filter which staStationTypes to delete.
     */
    where: staStationTypesWhereUniqueInput
  }


  /**
   * staStationTypes deleteMany
   */
  export type staStationTypesDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which staStationTypes to delete
     */
    where?: staStationTypesWhereInput
  }


  /**
   * staStationTypes without action
   */
  export type staStationTypesDefaultArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the staStationTypes
     */
    select?: staStationTypesSelect<ExtArgs> | null
  }



  /**
   * Model staStations
   */

  export type AggregateStaStations = {
    _count: StaStationsCountAggregateOutputType | null
    _avg: StaStationsAvgAggregateOutputType | null
    _sum: StaStationsSumAggregateOutputType | null
    _min: StaStationsMinAggregateOutputType | null
    _max: StaStationsMaxAggregateOutputType | null
  }

  export type StaStationsAvgAggregateOutputType = {
    stationID: number | null
    security: number | null
    dockingCostPerVolume: number | null
    maxShipVolumeDockable: number | null
    officeRentalCost: number | null
    operationID: number | null
    stationTypeID: number | null
    corporationID: number | null
    solarSystemID: number | null
    constellationID: number | null
    regionID: number | null
    x: number | null
    y: number | null
    z: number | null
    reprocessingEfficiency: number | null
    reprocessingStationsTake: number | null
    reprocessingHangarFlag: number | null
  }

  export type StaStationsSumAggregateOutputType = {
    stationID: bigint | null
    security: number | null
    dockingCostPerVolume: number | null
    maxShipVolumeDockable: number | null
    officeRentalCost: number | null
    operationID: number | null
    stationTypeID: number | null
    corporationID: number | null
    solarSystemID: number | null
    constellationID: number | null
    regionID: number | null
    x: number | null
    y: number | null
    z: number | null
    reprocessingEfficiency: number | null
    reprocessingStationsTake: number | null
    reprocessingHangarFlag: number | null
  }

  export type StaStationsMinAggregateOutputType = {
    stationID: bigint | null
    security: number | null
    dockingCostPerVolume: number | null
    maxShipVolumeDockable: number | null
    officeRentalCost: number | null
    operationID: number | null
    stationTypeID: number | null
    corporationID: number | null
    solarSystemID: number | null
    constellationID: number | null
    regionID: number | null
    stationName: string | null
    x: number | null
    y: number | null
    z: number | null
    reprocessingEfficiency: number | null
    reprocessingStationsTake: number | null
    reprocessingHangarFlag: number | null
  }

  export type StaStationsMaxAggregateOutputType = {
    stationID: bigint | null
    security: number | null
    dockingCostPerVolume: number | null
    maxShipVolumeDockable: number | null
    officeRentalCost: number | null
    operationID: number | null
    stationTypeID: number | null
    corporationID: number | null
    solarSystemID: number | null
    constellationID: number | null
    regionID: number | null
    stationName: string | null
    x: number | null
    y: number | null
    z: number | null
    reprocessingEfficiency: number | null
    reprocessingStationsTake: number | null
    reprocessingHangarFlag: number | null
  }

  export type StaStationsCountAggregateOutputType = {
    stationID: number
    security: number
    dockingCostPerVolume: number
    maxShipVolumeDockable: number
    officeRentalCost: number
    operationID: number
    stationTypeID: number
    corporationID: number
    solarSystemID: number
    constellationID: number
    regionID: number
    stationName: number
    x: number
    y: number
    z: number
    reprocessingEfficiency: number
    reprocessingStationsTake: number
    reprocessingHangarFlag: number
    _all: number
  }


  export type StaStationsAvgAggregateInputType = {
    stationID?: true
    security?: true
    dockingCostPerVolume?: true
    maxShipVolumeDockable?: true
    officeRentalCost?: true
    operationID?: true
    stationTypeID?: true
    corporationID?: true
    solarSystemID?: true
    constellationID?: true
    regionID?: true
    x?: true
    y?: true
    z?: true
    reprocessingEfficiency?: true
    reprocessingStationsTake?: true
    reprocessingHangarFlag?: true
  }

  export type StaStationsSumAggregateInputType = {
    stationID?: true
    security?: true
    dockingCostPerVolume?: true
    maxShipVolumeDockable?: true
    officeRentalCost?: true
    operationID?: true
    stationTypeID?: true
    corporationID?: true
    solarSystemID?: true
    constellationID?: true
    regionID?: true
    x?: true
    y?: true
    z?: true
    reprocessingEfficiency?: true
    reprocessingStationsTake?: true
    reprocessingHangarFlag?: true
  }

  export type StaStationsMinAggregateInputType = {
    stationID?: true
    security?: true
    dockingCostPerVolume?: true
    maxShipVolumeDockable?: true
    officeRentalCost?: true
    operationID?: true
    stationTypeID?: true
    corporationID?: true
    solarSystemID?: true
    constellationID?: true
    regionID?: true
    stationName?: true
    x?: true
    y?: true
    z?: true
    reprocessingEfficiency?: true
    reprocessingStationsTake?: true
    reprocessingHangarFlag?: true
  }

  export type StaStationsMaxAggregateInputType = {
    stationID?: true
    security?: true
    dockingCostPerVolume?: true
    maxShipVolumeDockable?: true
    officeRentalCost?: true
    operationID?: true
    stationTypeID?: true
    corporationID?: true
    solarSystemID?: true
    constellationID?: true
    regionID?: true
    stationName?: true
    x?: true
    y?: true
    z?: true
    reprocessingEfficiency?: true
    reprocessingStationsTake?: true
    reprocessingHangarFlag?: true
  }

  export type StaStationsCountAggregateInputType = {
    stationID?: true
    security?: true
    dockingCostPerVolume?: true
    maxShipVolumeDockable?: true
    officeRentalCost?: true
    operationID?: true
    stationTypeID?: true
    corporationID?: true
    solarSystemID?: true
    constellationID?: true
    regionID?: true
    stationName?: true
    x?: true
    y?: true
    z?: true
    reprocessingEfficiency?: true
    reprocessingStationsTake?: true
    reprocessingHangarFlag?: true
    _all?: true
  }

  export type StaStationsAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which staStations to aggregate.
     */
    where?: staStationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of staStations to fetch.
     */
    orderBy?: staStationsOrderByWithRelationInput | staStationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: staStationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` staStations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` staStations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned staStations
    **/
    _count?: true | StaStationsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: StaStationsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: StaStationsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: StaStationsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: StaStationsMaxAggregateInputType
  }

  export type GetStaStationsAggregateType<T extends StaStationsAggregateArgs> = {
        [P in keyof T & keyof AggregateStaStations]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStaStations[P]>
      : GetScalarType<T[P], AggregateStaStations[P]>
  }




  export type staStationsGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: staStationsWhereInput
    orderBy?: staStationsOrderByWithAggregationInput | staStationsOrderByWithAggregationInput[]
    by: StaStationsScalarFieldEnum[] | StaStationsScalarFieldEnum
    having?: staStationsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: StaStationsCountAggregateInputType | true
    _avg?: StaStationsAvgAggregateInputType
    _sum?: StaStationsSumAggregateInputType
    _min?: StaStationsMinAggregateInputType
    _max?: StaStationsMaxAggregateInputType
  }

  export type StaStationsGroupByOutputType = {
    stationID: bigint
    security: number | null
    dockingCostPerVolume: number | null
    maxShipVolumeDockable: number | null
    officeRentalCost: number | null
    operationID: number | null
    stationTypeID: number | null
    corporationID: number | null
    solarSystemID: number | null
    constellationID: number | null
    regionID: number | null
    stationName: string | null
    x: number | null
    y: number | null
    z: number | null
    reprocessingEfficiency: number | null
    reprocessingStationsTake: number | null
    reprocessingHangarFlag: number | null
    _count: StaStationsCountAggregateOutputType | null
    _avg: StaStationsAvgAggregateOutputType | null
    _sum: StaStationsSumAggregateOutputType | null
    _min: StaStationsMinAggregateOutputType | null
    _max: StaStationsMaxAggregateOutputType | null
  }

  type GetStaStationsGroupByPayload<T extends staStationsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<StaStationsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof StaStationsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], StaStationsGroupByOutputType[P]>
            : GetScalarType<T[P], StaStationsGroupByOutputType[P]>
        }
      >
    >


  export type staStationsSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    stationID?: boolean
    security?: boolean
    dockingCostPerVolume?: boolean
    maxShipVolumeDockable?: boolean
    officeRentalCost?: boolean
    operationID?: boolean
    stationTypeID?: boolean
    corporationID?: boolean
    solarSystemID?: boolean
    constellationID?: boolean
    regionID?: boolean
    stationName?: boolean
    x?: boolean
    y?: boolean
    z?: boolean
    reprocessingEfficiency?: boolean
    reprocessingStationsTake?: boolean
    reprocessingHangarFlag?: boolean
  }, ExtArgs["result"]["staStations"]>

  export type staStationsSelectScalar = {
    stationID?: boolean
    security?: boolean
    dockingCostPerVolume?: boolean
    maxShipVolumeDockable?: boolean
    officeRentalCost?: boolean
    operationID?: boolean
    stationTypeID?: boolean
    corporationID?: boolean
    solarSystemID?: boolean
    constellationID?: boolean
    regionID?: boolean
    stationName?: boolean
    x?: boolean
    y?: boolean
    z?: boolean
    reprocessingEfficiency?: boolean
    reprocessingStationsTake?: boolean
    reprocessingHangarFlag?: boolean
  }


  export type $staStationsPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    name: "staStations"
    objects: {}
    scalars: $Extensions.GetResult<{
      stationID: bigint
      security: number | null
      dockingCostPerVolume: number | null
      maxShipVolumeDockable: number | null
      officeRentalCost: number | null
      operationID: number | null
      stationTypeID: number | null
      corporationID: number | null
      solarSystemID: number | null
      constellationID: number | null
      regionID: number | null
      stationName: string | null
      x: number | null
      y: number | null
      z: number | null
      reprocessingEfficiency: number | null
      reprocessingStationsTake: number | null
      reprocessingHangarFlag: number | null
    }, ExtArgs["result"]["staStations"]>
    composites: {}
  }


  type staStationsGetPayload<S extends boolean | null | undefined | staStationsDefaultArgs> = $Result.GetResult<Prisma.$staStationsPayload, S>

  type staStationsCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<staStationsFindManyArgs, 'select' | 'include'> & {
      select?: StaStationsCountAggregateInputType | true
    }

  export interface staStationsDelegate<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['staStations'], meta: { name: 'staStations' } }
    /**
     * Find zero or one StaStations that matches the filter.
     * @param {staStationsFindUniqueArgs} args - Arguments to find a StaStations
     * @example
     * // Get one StaStations
     * const staStations = await prisma.staStations.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends staStationsFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, staStationsFindUniqueArgs<ExtArgs>>
    ): Prisma__staStationsClient<$Result.GetResult<Prisma.$staStationsPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one StaStations that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {staStationsFindUniqueOrThrowArgs} args - Arguments to find a StaStations
     * @example
     * // Get one StaStations
     * const staStations = await prisma.staStations.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends staStationsFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, staStationsFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__staStationsClient<$Result.GetResult<Prisma.$staStationsPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first StaStations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {staStationsFindFirstArgs} args - Arguments to find a StaStations
     * @example
     * // Get one StaStations
     * const staStations = await prisma.staStations.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends staStationsFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, staStationsFindFirstArgs<ExtArgs>>
    ): Prisma__staStationsClient<$Result.GetResult<Prisma.$staStationsPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first StaStations that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {staStationsFindFirstOrThrowArgs} args - Arguments to find a StaStations
     * @example
     * // Get one StaStations
     * const staStations = await prisma.staStations.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends staStationsFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, staStationsFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__staStationsClient<$Result.GetResult<Prisma.$staStationsPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more StaStations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {staStationsFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all StaStations
     * const staStations = await prisma.staStations.findMany()
     * 
     * // Get first 10 StaStations
     * const staStations = await prisma.staStations.findMany({ take: 10 })
     * 
     * // Only select the `stationID`
     * const staStationsWithStationIDOnly = await prisma.staStations.findMany({ select: { stationID: true } })
     * 
    **/
    findMany<T extends staStationsFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, staStationsFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$staStationsPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a StaStations.
     * @param {staStationsCreateArgs} args - Arguments to create a StaStations.
     * @example
     * // Create one StaStations
     * const StaStations = await prisma.staStations.create({
     *   data: {
     *     // ... data to create a StaStations
     *   }
     * })
     * 
    **/
    create<T extends staStationsCreateArgs<ExtArgs>>(
      args: SelectSubset<T, staStationsCreateArgs<ExtArgs>>
    ): Prisma__staStationsClient<$Result.GetResult<Prisma.$staStationsPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many StaStations.
     *     @param {staStationsCreateManyArgs} args - Arguments to create many StaStations.
     *     @example
     *     // Create many StaStations
     *     const staStations = await prisma.staStations.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends staStationsCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, staStationsCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a StaStations.
     * @param {staStationsDeleteArgs} args - Arguments to delete one StaStations.
     * @example
     * // Delete one StaStations
     * const StaStations = await prisma.staStations.delete({
     *   where: {
     *     // ... filter to delete one StaStations
     *   }
     * })
     * 
    **/
    delete<T extends staStationsDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, staStationsDeleteArgs<ExtArgs>>
    ): Prisma__staStationsClient<$Result.GetResult<Prisma.$staStationsPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one StaStations.
     * @param {staStationsUpdateArgs} args - Arguments to update one StaStations.
     * @example
     * // Update one StaStations
     * const staStations = await prisma.staStations.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends staStationsUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, staStationsUpdateArgs<ExtArgs>>
    ): Prisma__staStationsClient<$Result.GetResult<Prisma.$staStationsPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more StaStations.
     * @param {staStationsDeleteManyArgs} args - Arguments to filter StaStations to delete.
     * @example
     * // Delete a few StaStations
     * const { count } = await prisma.staStations.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends staStationsDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, staStationsDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more StaStations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {staStationsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many StaStations
     * const staStations = await prisma.staStations.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends staStationsUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, staStationsUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one StaStations.
     * @param {staStationsUpsertArgs} args - Arguments to update or create a StaStations.
     * @example
     * // Update or create a StaStations
     * const staStations = await prisma.staStations.upsert({
     *   create: {
     *     // ... data to create a StaStations
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the StaStations we want to update
     *   }
     * })
    **/
    upsert<T extends staStationsUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, staStationsUpsertArgs<ExtArgs>>
    ): Prisma__staStationsClient<$Result.GetResult<Prisma.$staStationsPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of StaStations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {staStationsCountArgs} args - Arguments to filter StaStations to count.
     * @example
     * // Count the number of StaStations
     * const count = await prisma.staStations.count({
     *   where: {
     *     // ... the filter for the StaStations we want to count
     *   }
     * })
    **/
    count<T extends staStationsCountArgs>(
      args?: Subset<T, staStationsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], StaStationsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a StaStations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StaStationsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends StaStationsAggregateArgs>(args: Subset<T, StaStationsAggregateArgs>): Prisma.PrismaPromise<GetStaStationsAggregateType<T>>

    /**
     * Group by StaStations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {staStationsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends staStationsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: staStationsGroupByArgs['orderBy'] }
        : { orderBy?: staStationsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, staStationsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStaStationsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the staStations model
   */
  readonly fields: staStationsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for staStations.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__staStationsClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';


    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the staStations model
   */ 
  interface staStationsFieldRefs {
    readonly stationID: FieldRef<"staStations", 'BigInt'>
    readonly security: FieldRef<"staStations", 'Float'>
    readonly dockingCostPerVolume: FieldRef<"staStations", 'Float'>
    readonly maxShipVolumeDockable: FieldRef<"staStations", 'Float'>
    readonly officeRentalCost: FieldRef<"staStations", 'Int'>
    readonly operationID: FieldRef<"staStations", 'Int'>
    readonly stationTypeID: FieldRef<"staStations", 'Int'>
    readonly corporationID: FieldRef<"staStations", 'Int'>
    readonly solarSystemID: FieldRef<"staStations", 'Int'>
    readonly constellationID: FieldRef<"staStations", 'Int'>
    readonly regionID: FieldRef<"staStations", 'Int'>
    readonly stationName: FieldRef<"staStations", 'String'>
    readonly x: FieldRef<"staStations", 'Float'>
    readonly y: FieldRef<"staStations", 'Float'>
    readonly z: FieldRef<"staStations", 'Float'>
    readonly reprocessingEfficiency: FieldRef<"staStations", 'Float'>
    readonly reprocessingStationsTake: FieldRef<"staStations", 'Float'>
    readonly reprocessingHangarFlag: FieldRef<"staStations", 'Int'>
  }
    

  // Custom InputTypes

  /**
   * staStations findUnique
   */
  export type staStationsFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the staStations
     */
    select?: staStationsSelect<ExtArgs> | null
    /**
     * Filter, which staStations to fetch.
     */
    where: staStationsWhereUniqueInput
  }


  /**
   * staStations findUniqueOrThrow
   */
  export type staStationsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the staStations
     */
    select?: staStationsSelect<ExtArgs> | null
    /**
     * Filter, which staStations to fetch.
     */
    where: staStationsWhereUniqueInput
  }


  /**
   * staStations findFirst
   */
  export type staStationsFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the staStations
     */
    select?: staStationsSelect<ExtArgs> | null
    /**
     * Filter, which staStations to fetch.
     */
    where?: staStationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of staStations to fetch.
     */
    orderBy?: staStationsOrderByWithRelationInput | staStationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for staStations.
     */
    cursor?: staStationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` staStations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` staStations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of staStations.
     */
    distinct?: StaStationsScalarFieldEnum | StaStationsScalarFieldEnum[]
  }


  /**
   * staStations findFirstOrThrow
   */
  export type staStationsFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the staStations
     */
    select?: staStationsSelect<ExtArgs> | null
    /**
     * Filter, which staStations to fetch.
     */
    where?: staStationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of staStations to fetch.
     */
    orderBy?: staStationsOrderByWithRelationInput | staStationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for staStations.
     */
    cursor?: staStationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` staStations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` staStations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of staStations.
     */
    distinct?: StaStationsScalarFieldEnum | StaStationsScalarFieldEnum[]
  }


  /**
   * staStations findMany
   */
  export type staStationsFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the staStations
     */
    select?: staStationsSelect<ExtArgs> | null
    /**
     * Filter, which staStations to fetch.
     */
    where?: staStationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of staStations to fetch.
     */
    orderBy?: staStationsOrderByWithRelationInput | staStationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing staStations.
     */
    cursor?: staStationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` staStations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` staStations.
     */
    skip?: number
    distinct?: StaStationsScalarFieldEnum | StaStationsScalarFieldEnum[]
  }


  /**
   * staStations create
   */
  export type staStationsCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the staStations
     */
    select?: staStationsSelect<ExtArgs> | null
    /**
     * The data needed to create a staStations.
     */
    data: XOR<staStationsCreateInput, staStationsUncheckedCreateInput>
  }


  /**
   * staStations createMany
   */
  export type staStationsCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many staStations.
     */
    data: staStationsCreateManyInput | staStationsCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * staStations update
   */
  export type staStationsUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the staStations
     */
    select?: staStationsSelect<ExtArgs> | null
    /**
     * The data needed to update a staStations.
     */
    data: XOR<staStationsUpdateInput, staStationsUncheckedUpdateInput>
    /**
     * Choose, which staStations to update.
     */
    where: staStationsWhereUniqueInput
  }


  /**
   * staStations updateMany
   */
  export type staStationsUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update staStations.
     */
    data: XOR<staStationsUpdateManyMutationInput, staStationsUncheckedUpdateManyInput>
    /**
     * Filter which staStations to update
     */
    where?: staStationsWhereInput
  }


  /**
   * staStations upsert
   */
  export type staStationsUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the staStations
     */
    select?: staStationsSelect<ExtArgs> | null
    /**
     * The filter to search for the staStations to update in case it exists.
     */
    where: staStationsWhereUniqueInput
    /**
     * In case the staStations found by the `where` argument doesn't exist, create a new staStations with this data.
     */
    create: XOR<staStationsCreateInput, staStationsUncheckedCreateInput>
    /**
     * In case the staStations was found with the provided `where` argument, update it with this data.
     */
    update: XOR<staStationsUpdateInput, staStationsUncheckedUpdateInput>
  }


  /**
   * staStations delete
   */
  export type staStationsDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the staStations
     */
    select?: staStationsSelect<ExtArgs> | null
    /**
     * Filter which staStations to delete.
     */
    where: staStationsWhereUniqueInput
  }


  /**
   * staStations deleteMany
   */
  export type staStationsDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which staStations to delete
     */
    where?: staStationsWhereInput
  }


  /**
   * staStations without action
   */
  export type staStationsDefaultArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the staStations
     */
    select?: staStationsSelect<ExtArgs> | null
  }



  /**
   * Model translationTables
   */

  export type AggregateTranslationTables = {
    _count: TranslationTablesCountAggregateOutputType | null
    _avg: TranslationTablesAvgAggregateOutputType | null
    _sum: TranslationTablesSumAggregateOutputType | null
    _min: TranslationTablesMinAggregateOutputType | null
    _max: TranslationTablesMaxAggregateOutputType | null
  }

  export type TranslationTablesAvgAggregateOutputType = {
    tcGroupID: number | null
    tcID: number | null
  }

  export type TranslationTablesSumAggregateOutputType = {
    tcGroupID: number | null
    tcID: number | null
  }

  export type TranslationTablesMinAggregateOutputType = {
    sourceTable: string | null
    destinationTable: string | null
    translatedKey: string | null
    tcGroupID: number | null
    tcID: number | null
  }

  export type TranslationTablesMaxAggregateOutputType = {
    sourceTable: string | null
    destinationTable: string | null
    translatedKey: string | null
    tcGroupID: number | null
    tcID: number | null
  }

  export type TranslationTablesCountAggregateOutputType = {
    sourceTable: number
    destinationTable: number
    translatedKey: number
    tcGroupID: number
    tcID: number
    _all: number
  }


  export type TranslationTablesAvgAggregateInputType = {
    tcGroupID?: true
    tcID?: true
  }

  export type TranslationTablesSumAggregateInputType = {
    tcGroupID?: true
    tcID?: true
  }

  export type TranslationTablesMinAggregateInputType = {
    sourceTable?: true
    destinationTable?: true
    translatedKey?: true
    tcGroupID?: true
    tcID?: true
  }

  export type TranslationTablesMaxAggregateInputType = {
    sourceTable?: true
    destinationTable?: true
    translatedKey?: true
    tcGroupID?: true
    tcID?: true
  }

  export type TranslationTablesCountAggregateInputType = {
    sourceTable?: true
    destinationTable?: true
    translatedKey?: true
    tcGroupID?: true
    tcID?: true
    _all?: true
  }

  export type TranslationTablesAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which translationTables to aggregate.
     */
    where?: translationTablesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of translationTables to fetch.
     */
    orderBy?: translationTablesOrderByWithRelationInput | translationTablesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: translationTablesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` translationTables from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` translationTables.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned translationTables
    **/
    _count?: true | TranslationTablesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TranslationTablesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TranslationTablesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TranslationTablesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TranslationTablesMaxAggregateInputType
  }

  export type GetTranslationTablesAggregateType<T extends TranslationTablesAggregateArgs> = {
        [P in keyof T & keyof AggregateTranslationTables]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTranslationTables[P]>
      : GetScalarType<T[P], AggregateTranslationTables[P]>
  }




  export type translationTablesGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: translationTablesWhereInput
    orderBy?: translationTablesOrderByWithAggregationInput | translationTablesOrderByWithAggregationInput[]
    by: TranslationTablesScalarFieldEnum[] | TranslationTablesScalarFieldEnum
    having?: translationTablesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TranslationTablesCountAggregateInputType | true
    _avg?: TranslationTablesAvgAggregateInputType
    _sum?: TranslationTablesSumAggregateInputType
    _min?: TranslationTablesMinAggregateInputType
    _max?: TranslationTablesMaxAggregateInputType
  }

  export type TranslationTablesGroupByOutputType = {
    sourceTable: string
    destinationTable: string | null
    translatedKey: string
    tcGroupID: number | null
    tcID: number | null
    _count: TranslationTablesCountAggregateOutputType | null
    _avg: TranslationTablesAvgAggregateOutputType | null
    _sum: TranslationTablesSumAggregateOutputType | null
    _min: TranslationTablesMinAggregateOutputType | null
    _max: TranslationTablesMaxAggregateOutputType | null
  }

  type GetTranslationTablesGroupByPayload<T extends translationTablesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TranslationTablesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TranslationTablesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TranslationTablesGroupByOutputType[P]>
            : GetScalarType<T[P], TranslationTablesGroupByOutputType[P]>
        }
      >
    >


  export type translationTablesSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    sourceTable?: boolean
    destinationTable?: boolean
    translatedKey?: boolean
    tcGroupID?: boolean
    tcID?: boolean
  }, ExtArgs["result"]["translationTables"]>

  export type translationTablesSelectScalar = {
    sourceTable?: boolean
    destinationTable?: boolean
    translatedKey?: boolean
    tcGroupID?: boolean
    tcID?: boolean
  }


  export type $translationTablesPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    name: "translationTables"
    objects: {}
    scalars: $Extensions.GetResult<{
      sourceTable: string
      destinationTable: string | null
      translatedKey: string
      tcGroupID: number | null
      tcID: number | null
    }, ExtArgs["result"]["translationTables"]>
    composites: {}
  }


  type translationTablesGetPayload<S extends boolean | null | undefined | translationTablesDefaultArgs> = $Result.GetResult<Prisma.$translationTablesPayload, S>

  type translationTablesCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<translationTablesFindManyArgs, 'select' | 'include'> & {
      select?: TranslationTablesCountAggregateInputType | true
    }

  export interface translationTablesDelegate<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['translationTables'], meta: { name: 'translationTables' } }
    /**
     * Find zero or one TranslationTables that matches the filter.
     * @param {translationTablesFindUniqueArgs} args - Arguments to find a TranslationTables
     * @example
     * // Get one TranslationTables
     * const translationTables = await prisma.translationTables.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends translationTablesFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, translationTablesFindUniqueArgs<ExtArgs>>
    ): Prisma__translationTablesClient<$Result.GetResult<Prisma.$translationTablesPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one TranslationTables that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {translationTablesFindUniqueOrThrowArgs} args - Arguments to find a TranslationTables
     * @example
     * // Get one TranslationTables
     * const translationTables = await prisma.translationTables.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends translationTablesFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, translationTablesFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__translationTablesClient<$Result.GetResult<Prisma.$translationTablesPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first TranslationTables that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {translationTablesFindFirstArgs} args - Arguments to find a TranslationTables
     * @example
     * // Get one TranslationTables
     * const translationTables = await prisma.translationTables.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends translationTablesFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, translationTablesFindFirstArgs<ExtArgs>>
    ): Prisma__translationTablesClient<$Result.GetResult<Prisma.$translationTablesPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first TranslationTables that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {translationTablesFindFirstOrThrowArgs} args - Arguments to find a TranslationTables
     * @example
     * // Get one TranslationTables
     * const translationTables = await prisma.translationTables.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends translationTablesFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, translationTablesFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__translationTablesClient<$Result.GetResult<Prisma.$translationTablesPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more TranslationTables that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {translationTablesFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TranslationTables
     * const translationTables = await prisma.translationTables.findMany()
     * 
     * // Get first 10 TranslationTables
     * const translationTables = await prisma.translationTables.findMany({ take: 10 })
     * 
     * // Only select the `sourceTable`
     * const translationTablesWithSourceTableOnly = await prisma.translationTables.findMany({ select: { sourceTable: true } })
     * 
    **/
    findMany<T extends translationTablesFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, translationTablesFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$translationTablesPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a TranslationTables.
     * @param {translationTablesCreateArgs} args - Arguments to create a TranslationTables.
     * @example
     * // Create one TranslationTables
     * const TranslationTables = await prisma.translationTables.create({
     *   data: {
     *     // ... data to create a TranslationTables
     *   }
     * })
     * 
    **/
    create<T extends translationTablesCreateArgs<ExtArgs>>(
      args: SelectSubset<T, translationTablesCreateArgs<ExtArgs>>
    ): Prisma__translationTablesClient<$Result.GetResult<Prisma.$translationTablesPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many TranslationTables.
     *     @param {translationTablesCreateManyArgs} args - Arguments to create many TranslationTables.
     *     @example
     *     // Create many TranslationTables
     *     const translationTables = await prisma.translationTables.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends translationTablesCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, translationTablesCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a TranslationTables.
     * @param {translationTablesDeleteArgs} args - Arguments to delete one TranslationTables.
     * @example
     * // Delete one TranslationTables
     * const TranslationTables = await prisma.translationTables.delete({
     *   where: {
     *     // ... filter to delete one TranslationTables
     *   }
     * })
     * 
    **/
    delete<T extends translationTablesDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, translationTablesDeleteArgs<ExtArgs>>
    ): Prisma__translationTablesClient<$Result.GetResult<Prisma.$translationTablesPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one TranslationTables.
     * @param {translationTablesUpdateArgs} args - Arguments to update one TranslationTables.
     * @example
     * // Update one TranslationTables
     * const translationTables = await prisma.translationTables.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends translationTablesUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, translationTablesUpdateArgs<ExtArgs>>
    ): Prisma__translationTablesClient<$Result.GetResult<Prisma.$translationTablesPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more TranslationTables.
     * @param {translationTablesDeleteManyArgs} args - Arguments to filter TranslationTables to delete.
     * @example
     * // Delete a few TranslationTables
     * const { count } = await prisma.translationTables.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends translationTablesDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, translationTablesDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TranslationTables.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {translationTablesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TranslationTables
     * const translationTables = await prisma.translationTables.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends translationTablesUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, translationTablesUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one TranslationTables.
     * @param {translationTablesUpsertArgs} args - Arguments to update or create a TranslationTables.
     * @example
     * // Update or create a TranslationTables
     * const translationTables = await prisma.translationTables.upsert({
     *   create: {
     *     // ... data to create a TranslationTables
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TranslationTables we want to update
     *   }
     * })
    **/
    upsert<T extends translationTablesUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, translationTablesUpsertArgs<ExtArgs>>
    ): Prisma__translationTablesClient<$Result.GetResult<Prisma.$translationTablesPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of TranslationTables.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {translationTablesCountArgs} args - Arguments to filter TranslationTables to count.
     * @example
     * // Count the number of TranslationTables
     * const count = await prisma.translationTables.count({
     *   where: {
     *     // ... the filter for the TranslationTables we want to count
     *   }
     * })
    **/
    count<T extends translationTablesCountArgs>(
      args?: Subset<T, translationTablesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TranslationTablesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TranslationTables.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TranslationTablesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TranslationTablesAggregateArgs>(args: Subset<T, TranslationTablesAggregateArgs>): Prisma.PrismaPromise<GetTranslationTablesAggregateType<T>>

    /**
     * Group by TranslationTables.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {translationTablesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends translationTablesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: translationTablesGroupByArgs['orderBy'] }
        : { orderBy?: translationTablesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, translationTablesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTranslationTablesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the translationTables model
   */
  readonly fields: translationTablesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for translationTables.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__translationTablesClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';


    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the translationTables model
   */ 
  interface translationTablesFieldRefs {
    readonly sourceTable: FieldRef<"translationTables", 'String'>
    readonly destinationTable: FieldRef<"translationTables", 'String'>
    readonly translatedKey: FieldRef<"translationTables", 'String'>
    readonly tcGroupID: FieldRef<"translationTables", 'Int'>
    readonly tcID: FieldRef<"translationTables", 'Int'>
  }
    

  // Custom InputTypes

  /**
   * translationTables findUnique
   */
  export type translationTablesFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the translationTables
     */
    select?: translationTablesSelect<ExtArgs> | null
    /**
     * Filter, which translationTables to fetch.
     */
    where: translationTablesWhereUniqueInput
  }


  /**
   * translationTables findUniqueOrThrow
   */
  export type translationTablesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the translationTables
     */
    select?: translationTablesSelect<ExtArgs> | null
    /**
     * Filter, which translationTables to fetch.
     */
    where: translationTablesWhereUniqueInput
  }


  /**
   * translationTables findFirst
   */
  export type translationTablesFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the translationTables
     */
    select?: translationTablesSelect<ExtArgs> | null
    /**
     * Filter, which translationTables to fetch.
     */
    where?: translationTablesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of translationTables to fetch.
     */
    orderBy?: translationTablesOrderByWithRelationInput | translationTablesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for translationTables.
     */
    cursor?: translationTablesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` translationTables from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` translationTables.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of translationTables.
     */
    distinct?: TranslationTablesScalarFieldEnum | TranslationTablesScalarFieldEnum[]
  }


  /**
   * translationTables findFirstOrThrow
   */
  export type translationTablesFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the translationTables
     */
    select?: translationTablesSelect<ExtArgs> | null
    /**
     * Filter, which translationTables to fetch.
     */
    where?: translationTablesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of translationTables to fetch.
     */
    orderBy?: translationTablesOrderByWithRelationInput | translationTablesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for translationTables.
     */
    cursor?: translationTablesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` translationTables from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` translationTables.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of translationTables.
     */
    distinct?: TranslationTablesScalarFieldEnum | TranslationTablesScalarFieldEnum[]
  }


  /**
   * translationTables findMany
   */
  export type translationTablesFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the translationTables
     */
    select?: translationTablesSelect<ExtArgs> | null
    /**
     * Filter, which translationTables to fetch.
     */
    where?: translationTablesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of translationTables to fetch.
     */
    orderBy?: translationTablesOrderByWithRelationInput | translationTablesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing translationTables.
     */
    cursor?: translationTablesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` translationTables from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` translationTables.
     */
    skip?: number
    distinct?: TranslationTablesScalarFieldEnum | TranslationTablesScalarFieldEnum[]
  }


  /**
   * translationTables create
   */
  export type translationTablesCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the translationTables
     */
    select?: translationTablesSelect<ExtArgs> | null
    /**
     * The data needed to create a translationTables.
     */
    data: XOR<translationTablesCreateInput, translationTablesUncheckedCreateInput>
  }


  /**
   * translationTables createMany
   */
  export type translationTablesCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many translationTables.
     */
    data: translationTablesCreateManyInput | translationTablesCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * translationTables update
   */
  export type translationTablesUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the translationTables
     */
    select?: translationTablesSelect<ExtArgs> | null
    /**
     * The data needed to update a translationTables.
     */
    data: XOR<translationTablesUpdateInput, translationTablesUncheckedUpdateInput>
    /**
     * Choose, which translationTables to update.
     */
    where: translationTablesWhereUniqueInput
  }


  /**
   * translationTables updateMany
   */
  export type translationTablesUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update translationTables.
     */
    data: XOR<translationTablesUpdateManyMutationInput, translationTablesUncheckedUpdateManyInput>
    /**
     * Filter which translationTables to update
     */
    where?: translationTablesWhereInput
  }


  /**
   * translationTables upsert
   */
  export type translationTablesUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the translationTables
     */
    select?: translationTablesSelect<ExtArgs> | null
    /**
     * The filter to search for the translationTables to update in case it exists.
     */
    where: translationTablesWhereUniqueInput
    /**
     * In case the translationTables found by the `where` argument doesn't exist, create a new translationTables with this data.
     */
    create: XOR<translationTablesCreateInput, translationTablesUncheckedCreateInput>
    /**
     * In case the translationTables was found with the provided `where` argument, update it with this data.
     */
    update: XOR<translationTablesUpdateInput, translationTablesUncheckedUpdateInput>
  }


  /**
   * translationTables delete
   */
  export type translationTablesDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the translationTables
     */
    select?: translationTablesSelect<ExtArgs> | null
    /**
     * Filter which translationTables to delete.
     */
    where: translationTablesWhereUniqueInput
  }


  /**
   * translationTables deleteMany
   */
  export type translationTablesDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which translationTables to delete
     */
    where?: translationTablesWhereInput
  }


  /**
   * translationTables without action
   */
  export type translationTablesDefaultArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the translationTables
     */
    select?: translationTablesSelect<ExtArgs> | null
  }



  /**
   * Model trnTranslationColumns
   */

  export type AggregateTrnTranslationColumns = {
    _count: TrnTranslationColumnsCountAggregateOutputType | null
    _avg: TrnTranslationColumnsAvgAggregateOutputType | null
    _sum: TrnTranslationColumnsSumAggregateOutputType | null
    _min: TrnTranslationColumnsMinAggregateOutputType | null
    _max: TrnTranslationColumnsMaxAggregateOutputType | null
  }

  export type TrnTranslationColumnsAvgAggregateOutputType = {
    tcGroupID: number | null
    tcID: number | null
  }

  export type TrnTranslationColumnsSumAggregateOutputType = {
    tcGroupID: number | null
    tcID: number | null
  }

  export type TrnTranslationColumnsMinAggregateOutputType = {
    tcGroupID: number | null
    tcID: number | null
    tableName: string | null
    columnName: string | null
    masterID: string | null
  }

  export type TrnTranslationColumnsMaxAggregateOutputType = {
    tcGroupID: number | null
    tcID: number | null
    tableName: string | null
    columnName: string | null
    masterID: string | null
  }

  export type TrnTranslationColumnsCountAggregateOutputType = {
    tcGroupID: number
    tcID: number
    tableName: number
    columnName: number
    masterID: number
    _all: number
  }


  export type TrnTranslationColumnsAvgAggregateInputType = {
    tcGroupID?: true
    tcID?: true
  }

  export type TrnTranslationColumnsSumAggregateInputType = {
    tcGroupID?: true
    tcID?: true
  }

  export type TrnTranslationColumnsMinAggregateInputType = {
    tcGroupID?: true
    tcID?: true
    tableName?: true
    columnName?: true
    masterID?: true
  }

  export type TrnTranslationColumnsMaxAggregateInputType = {
    tcGroupID?: true
    tcID?: true
    tableName?: true
    columnName?: true
    masterID?: true
  }

  export type TrnTranslationColumnsCountAggregateInputType = {
    tcGroupID?: true
    tcID?: true
    tableName?: true
    columnName?: true
    masterID?: true
    _all?: true
  }

  export type TrnTranslationColumnsAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which trnTranslationColumns to aggregate.
     */
    where?: trnTranslationColumnsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of trnTranslationColumns to fetch.
     */
    orderBy?: trnTranslationColumnsOrderByWithRelationInput | trnTranslationColumnsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: trnTranslationColumnsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` trnTranslationColumns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` trnTranslationColumns.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned trnTranslationColumns
    **/
    _count?: true | TrnTranslationColumnsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TrnTranslationColumnsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TrnTranslationColumnsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TrnTranslationColumnsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TrnTranslationColumnsMaxAggregateInputType
  }

  export type GetTrnTranslationColumnsAggregateType<T extends TrnTranslationColumnsAggregateArgs> = {
        [P in keyof T & keyof AggregateTrnTranslationColumns]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTrnTranslationColumns[P]>
      : GetScalarType<T[P], AggregateTrnTranslationColumns[P]>
  }




  export type trnTranslationColumnsGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: trnTranslationColumnsWhereInput
    orderBy?: trnTranslationColumnsOrderByWithAggregationInput | trnTranslationColumnsOrderByWithAggregationInput[]
    by: TrnTranslationColumnsScalarFieldEnum[] | TrnTranslationColumnsScalarFieldEnum
    having?: trnTranslationColumnsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TrnTranslationColumnsCountAggregateInputType | true
    _avg?: TrnTranslationColumnsAvgAggregateInputType
    _sum?: TrnTranslationColumnsSumAggregateInputType
    _min?: TrnTranslationColumnsMinAggregateInputType
    _max?: TrnTranslationColumnsMaxAggregateInputType
  }

  export type TrnTranslationColumnsGroupByOutputType = {
    tcGroupID: number | null
    tcID: number
    tableName: string
    columnName: string
    masterID: string | null
    _count: TrnTranslationColumnsCountAggregateOutputType | null
    _avg: TrnTranslationColumnsAvgAggregateOutputType | null
    _sum: TrnTranslationColumnsSumAggregateOutputType | null
    _min: TrnTranslationColumnsMinAggregateOutputType | null
    _max: TrnTranslationColumnsMaxAggregateOutputType | null
  }

  type GetTrnTranslationColumnsGroupByPayload<T extends trnTranslationColumnsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TrnTranslationColumnsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TrnTranslationColumnsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TrnTranslationColumnsGroupByOutputType[P]>
            : GetScalarType<T[P], TrnTranslationColumnsGroupByOutputType[P]>
        }
      >
    >


  export type trnTranslationColumnsSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    tcGroupID?: boolean
    tcID?: boolean
    tableName?: boolean
    columnName?: boolean
    masterID?: boolean
  }, ExtArgs["result"]["trnTranslationColumns"]>

  export type trnTranslationColumnsSelectScalar = {
    tcGroupID?: boolean
    tcID?: boolean
    tableName?: boolean
    columnName?: boolean
    masterID?: boolean
  }


  export type $trnTranslationColumnsPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    name: "trnTranslationColumns"
    objects: {}
    scalars: $Extensions.GetResult<{
      tcGroupID: number | null
      tcID: number
      tableName: string
      columnName: string
      masterID: string | null
    }, ExtArgs["result"]["trnTranslationColumns"]>
    composites: {}
  }


  type trnTranslationColumnsGetPayload<S extends boolean | null | undefined | trnTranslationColumnsDefaultArgs> = $Result.GetResult<Prisma.$trnTranslationColumnsPayload, S>

  type trnTranslationColumnsCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<trnTranslationColumnsFindManyArgs, 'select' | 'include'> & {
      select?: TrnTranslationColumnsCountAggregateInputType | true
    }

  export interface trnTranslationColumnsDelegate<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['trnTranslationColumns'], meta: { name: 'trnTranslationColumns' } }
    /**
     * Find zero or one TrnTranslationColumns that matches the filter.
     * @param {trnTranslationColumnsFindUniqueArgs} args - Arguments to find a TrnTranslationColumns
     * @example
     * // Get one TrnTranslationColumns
     * const trnTranslationColumns = await prisma.trnTranslationColumns.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends trnTranslationColumnsFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, trnTranslationColumnsFindUniqueArgs<ExtArgs>>
    ): Prisma__trnTranslationColumnsClient<$Result.GetResult<Prisma.$trnTranslationColumnsPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one TrnTranslationColumns that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {trnTranslationColumnsFindUniqueOrThrowArgs} args - Arguments to find a TrnTranslationColumns
     * @example
     * // Get one TrnTranslationColumns
     * const trnTranslationColumns = await prisma.trnTranslationColumns.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends trnTranslationColumnsFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, trnTranslationColumnsFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__trnTranslationColumnsClient<$Result.GetResult<Prisma.$trnTranslationColumnsPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first TrnTranslationColumns that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {trnTranslationColumnsFindFirstArgs} args - Arguments to find a TrnTranslationColumns
     * @example
     * // Get one TrnTranslationColumns
     * const trnTranslationColumns = await prisma.trnTranslationColumns.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends trnTranslationColumnsFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, trnTranslationColumnsFindFirstArgs<ExtArgs>>
    ): Prisma__trnTranslationColumnsClient<$Result.GetResult<Prisma.$trnTranslationColumnsPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first TrnTranslationColumns that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {trnTranslationColumnsFindFirstOrThrowArgs} args - Arguments to find a TrnTranslationColumns
     * @example
     * // Get one TrnTranslationColumns
     * const trnTranslationColumns = await prisma.trnTranslationColumns.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends trnTranslationColumnsFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, trnTranslationColumnsFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__trnTranslationColumnsClient<$Result.GetResult<Prisma.$trnTranslationColumnsPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more TrnTranslationColumns that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {trnTranslationColumnsFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TrnTranslationColumns
     * const trnTranslationColumns = await prisma.trnTranslationColumns.findMany()
     * 
     * // Get first 10 TrnTranslationColumns
     * const trnTranslationColumns = await prisma.trnTranslationColumns.findMany({ take: 10 })
     * 
     * // Only select the `tcGroupID`
     * const trnTranslationColumnsWithTcGroupIDOnly = await prisma.trnTranslationColumns.findMany({ select: { tcGroupID: true } })
     * 
    **/
    findMany<T extends trnTranslationColumnsFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, trnTranslationColumnsFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$trnTranslationColumnsPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a TrnTranslationColumns.
     * @param {trnTranslationColumnsCreateArgs} args - Arguments to create a TrnTranslationColumns.
     * @example
     * // Create one TrnTranslationColumns
     * const TrnTranslationColumns = await prisma.trnTranslationColumns.create({
     *   data: {
     *     // ... data to create a TrnTranslationColumns
     *   }
     * })
     * 
    **/
    create<T extends trnTranslationColumnsCreateArgs<ExtArgs>>(
      args: SelectSubset<T, trnTranslationColumnsCreateArgs<ExtArgs>>
    ): Prisma__trnTranslationColumnsClient<$Result.GetResult<Prisma.$trnTranslationColumnsPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many TrnTranslationColumns.
     *     @param {trnTranslationColumnsCreateManyArgs} args - Arguments to create many TrnTranslationColumns.
     *     @example
     *     // Create many TrnTranslationColumns
     *     const trnTranslationColumns = await prisma.trnTranslationColumns.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends trnTranslationColumnsCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, trnTranslationColumnsCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a TrnTranslationColumns.
     * @param {trnTranslationColumnsDeleteArgs} args - Arguments to delete one TrnTranslationColumns.
     * @example
     * // Delete one TrnTranslationColumns
     * const TrnTranslationColumns = await prisma.trnTranslationColumns.delete({
     *   where: {
     *     // ... filter to delete one TrnTranslationColumns
     *   }
     * })
     * 
    **/
    delete<T extends trnTranslationColumnsDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, trnTranslationColumnsDeleteArgs<ExtArgs>>
    ): Prisma__trnTranslationColumnsClient<$Result.GetResult<Prisma.$trnTranslationColumnsPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one TrnTranslationColumns.
     * @param {trnTranslationColumnsUpdateArgs} args - Arguments to update one TrnTranslationColumns.
     * @example
     * // Update one TrnTranslationColumns
     * const trnTranslationColumns = await prisma.trnTranslationColumns.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends trnTranslationColumnsUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, trnTranslationColumnsUpdateArgs<ExtArgs>>
    ): Prisma__trnTranslationColumnsClient<$Result.GetResult<Prisma.$trnTranslationColumnsPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more TrnTranslationColumns.
     * @param {trnTranslationColumnsDeleteManyArgs} args - Arguments to filter TrnTranslationColumns to delete.
     * @example
     * // Delete a few TrnTranslationColumns
     * const { count } = await prisma.trnTranslationColumns.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends trnTranslationColumnsDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, trnTranslationColumnsDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TrnTranslationColumns.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {trnTranslationColumnsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TrnTranslationColumns
     * const trnTranslationColumns = await prisma.trnTranslationColumns.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends trnTranslationColumnsUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, trnTranslationColumnsUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one TrnTranslationColumns.
     * @param {trnTranslationColumnsUpsertArgs} args - Arguments to update or create a TrnTranslationColumns.
     * @example
     * // Update or create a TrnTranslationColumns
     * const trnTranslationColumns = await prisma.trnTranslationColumns.upsert({
     *   create: {
     *     // ... data to create a TrnTranslationColumns
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TrnTranslationColumns we want to update
     *   }
     * })
    **/
    upsert<T extends trnTranslationColumnsUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, trnTranslationColumnsUpsertArgs<ExtArgs>>
    ): Prisma__trnTranslationColumnsClient<$Result.GetResult<Prisma.$trnTranslationColumnsPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of TrnTranslationColumns.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {trnTranslationColumnsCountArgs} args - Arguments to filter TrnTranslationColumns to count.
     * @example
     * // Count the number of TrnTranslationColumns
     * const count = await prisma.trnTranslationColumns.count({
     *   where: {
     *     // ... the filter for the TrnTranslationColumns we want to count
     *   }
     * })
    **/
    count<T extends trnTranslationColumnsCountArgs>(
      args?: Subset<T, trnTranslationColumnsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TrnTranslationColumnsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TrnTranslationColumns.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrnTranslationColumnsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TrnTranslationColumnsAggregateArgs>(args: Subset<T, TrnTranslationColumnsAggregateArgs>): Prisma.PrismaPromise<GetTrnTranslationColumnsAggregateType<T>>

    /**
     * Group by TrnTranslationColumns.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {trnTranslationColumnsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends trnTranslationColumnsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: trnTranslationColumnsGroupByArgs['orderBy'] }
        : { orderBy?: trnTranslationColumnsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, trnTranslationColumnsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTrnTranslationColumnsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the trnTranslationColumns model
   */
  readonly fields: trnTranslationColumnsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for trnTranslationColumns.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__trnTranslationColumnsClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';


    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the trnTranslationColumns model
   */ 
  interface trnTranslationColumnsFieldRefs {
    readonly tcGroupID: FieldRef<"trnTranslationColumns", 'Int'>
    readonly tcID: FieldRef<"trnTranslationColumns", 'Int'>
    readonly tableName: FieldRef<"trnTranslationColumns", 'String'>
    readonly columnName: FieldRef<"trnTranslationColumns", 'String'>
    readonly masterID: FieldRef<"trnTranslationColumns", 'String'>
  }
    

  // Custom InputTypes

  /**
   * trnTranslationColumns findUnique
   */
  export type trnTranslationColumnsFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the trnTranslationColumns
     */
    select?: trnTranslationColumnsSelect<ExtArgs> | null
    /**
     * Filter, which trnTranslationColumns to fetch.
     */
    where: trnTranslationColumnsWhereUniqueInput
  }


  /**
   * trnTranslationColumns findUniqueOrThrow
   */
  export type trnTranslationColumnsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the trnTranslationColumns
     */
    select?: trnTranslationColumnsSelect<ExtArgs> | null
    /**
     * Filter, which trnTranslationColumns to fetch.
     */
    where: trnTranslationColumnsWhereUniqueInput
  }


  /**
   * trnTranslationColumns findFirst
   */
  export type trnTranslationColumnsFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the trnTranslationColumns
     */
    select?: trnTranslationColumnsSelect<ExtArgs> | null
    /**
     * Filter, which trnTranslationColumns to fetch.
     */
    where?: trnTranslationColumnsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of trnTranslationColumns to fetch.
     */
    orderBy?: trnTranslationColumnsOrderByWithRelationInput | trnTranslationColumnsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for trnTranslationColumns.
     */
    cursor?: trnTranslationColumnsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` trnTranslationColumns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` trnTranslationColumns.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of trnTranslationColumns.
     */
    distinct?: TrnTranslationColumnsScalarFieldEnum | TrnTranslationColumnsScalarFieldEnum[]
  }


  /**
   * trnTranslationColumns findFirstOrThrow
   */
  export type trnTranslationColumnsFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the trnTranslationColumns
     */
    select?: trnTranslationColumnsSelect<ExtArgs> | null
    /**
     * Filter, which trnTranslationColumns to fetch.
     */
    where?: trnTranslationColumnsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of trnTranslationColumns to fetch.
     */
    orderBy?: trnTranslationColumnsOrderByWithRelationInput | trnTranslationColumnsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for trnTranslationColumns.
     */
    cursor?: trnTranslationColumnsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` trnTranslationColumns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` trnTranslationColumns.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of trnTranslationColumns.
     */
    distinct?: TrnTranslationColumnsScalarFieldEnum | TrnTranslationColumnsScalarFieldEnum[]
  }


  /**
   * trnTranslationColumns findMany
   */
  export type trnTranslationColumnsFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the trnTranslationColumns
     */
    select?: trnTranslationColumnsSelect<ExtArgs> | null
    /**
     * Filter, which trnTranslationColumns to fetch.
     */
    where?: trnTranslationColumnsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of trnTranslationColumns to fetch.
     */
    orderBy?: trnTranslationColumnsOrderByWithRelationInput | trnTranslationColumnsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing trnTranslationColumns.
     */
    cursor?: trnTranslationColumnsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` trnTranslationColumns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` trnTranslationColumns.
     */
    skip?: number
    distinct?: TrnTranslationColumnsScalarFieldEnum | TrnTranslationColumnsScalarFieldEnum[]
  }


  /**
   * trnTranslationColumns create
   */
  export type trnTranslationColumnsCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the trnTranslationColumns
     */
    select?: trnTranslationColumnsSelect<ExtArgs> | null
    /**
     * The data needed to create a trnTranslationColumns.
     */
    data: XOR<trnTranslationColumnsCreateInput, trnTranslationColumnsUncheckedCreateInput>
  }


  /**
   * trnTranslationColumns createMany
   */
  export type trnTranslationColumnsCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many trnTranslationColumns.
     */
    data: trnTranslationColumnsCreateManyInput | trnTranslationColumnsCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * trnTranslationColumns update
   */
  export type trnTranslationColumnsUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the trnTranslationColumns
     */
    select?: trnTranslationColumnsSelect<ExtArgs> | null
    /**
     * The data needed to update a trnTranslationColumns.
     */
    data: XOR<trnTranslationColumnsUpdateInput, trnTranslationColumnsUncheckedUpdateInput>
    /**
     * Choose, which trnTranslationColumns to update.
     */
    where: trnTranslationColumnsWhereUniqueInput
  }


  /**
   * trnTranslationColumns updateMany
   */
  export type trnTranslationColumnsUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update trnTranslationColumns.
     */
    data: XOR<trnTranslationColumnsUpdateManyMutationInput, trnTranslationColumnsUncheckedUpdateManyInput>
    /**
     * Filter which trnTranslationColumns to update
     */
    where?: trnTranslationColumnsWhereInput
  }


  /**
   * trnTranslationColumns upsert
   */
  export type trnTranslationColumnsUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the trnTranslationColumns
     */
    select?: trnTranslationColumnsSelect<ExtArgs> | null
    /**
     * The filter to search for the trnTranslationColumns to update in case it exists.
     */
    where: trnTranslationColumnsWhereUniqueInput
    /**
     * In case the trnTranslationColumns found by the `where` argument doesn't exist, create a new trnTranslationColumns with this data.
     */
    create: XOR<trnTranslationColumnsCreateInput, trnTranslationColumnsUncheckedCreateInput>
    /**
     * In case the trnTranslationColumns was found with the provided `where` argument, update it with this data.
     */
    update: XOR<trnTranslationColumnsUpdateInput, trnTranslationColumnsUncheckedUpdateInput>
  }


  /**
   * trnTranslationColumns delete
   */
  export type trnTranslationColumnsDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the trnTranslationColumns
     */
    select?: trnTranslationColumnsSelect<ExtArgs> | null
    /**
     * Filter which trnTranslationColumns to delete.
     */
    where: trnTranslationColumnsWhereUniqueInput
  }


  /**
   * trnTranslationColumns deleteMany
   */
  export type trnTranslationColumnsDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which trnTranslationColumns to delete
     */
    where?: trnTranslationColumnsWhereInput
  }


  /**
   * trnTranslationColumns without action
   */
  export type trnTranslationColumnsDefaultArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the trnTranslationColumns
     */
    select?: trnTranslationColumnsSelect<ExtArgs> | null
  }



  /**
   * Model trnTranslationLanguages
   */

  export type AggregateTrnTranslationLanguages = {
    _count: TrnTranslationLanguagesCountAggregateOutputType | null
    _avg: TrnTranslationLanguagesAvgAggregateOutputType | null
    _sum: TrnTranslationLanguagesSumAggregateOutputType | null
    _min: TrnTranslationLanguagesMinAggregateOutputType | null
    _max: TrnTranslationLanguagesMaxAggregateOutputType | null
  }

  export type TrnTranslationLanguagesAvgAggregateOutputType = {
    numericLanguageID: number | null
  }

  export type TrnTranslationLanguagesSumAggregateOutputType = {
    numericLanguageID: number | null
  }

  export type TrnTranslationLanguagesMinAggregateOutputType = {
    numericLanguageID: number | null
    languageID: string | null
    languageName: string | null
  }

  export type TrnTranslationLanguagesMaxAggregateOutputType = {
    numericLanguageID: number | null
    languageID: string | null
    languageName: string | null
  }

  export type TrnTranslationLanguagesCountAggregateOutputType = {
    numericLanguageID: number
    languageID: number
    languageName: number
    _all: number
  }


  export type TrnTranslationLanguagesAvgAggregateInputType = {
    numericLanguageID?: true
  }

  export type TrnTranslationLanguagesSumAggregateInputType = {
    numericLanguageID?: true
  }

  export type TrnTranslationLanguagesMinAggregateInputType = {
    numericLanguageID?: true
    languageID?: true
    languageName?: true
  }

  export type TrnTranslationLanguagesMaxAggregateInputType = {
    numericLanguageID?: true
    languageID?: true
    languageName?: true
  }

  export type TrnTranslationLanguagesCountAggregateInputType = {
    numericLanguageID?: true
    languageID?: true
    languageName?: true
    _all?: true
  }

  export type TrnTranslationLanguagesAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which trnTranslationLanguages to aggregate.
     */
    where?: trnTranslationLanguagesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of trnTranslationLanguages to fetch.
     */
    orderBy?: trnTranslationLanguagesOrderByWithRelationInput | trnTranslationLanguagesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: trnTranslationLanguagesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` trnTranslationLanguages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` trnTranslationLanguages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned trnTranslationLanguages
    **/
    _count?: true | TrnTranslationLanguagesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TrnTranslationLanguagesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TrnTranslationLanguagesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TrnTranslationLanguagesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TrnTranslationLanguagesMaxAggregateInputType
  }

  export type GetTrnTranslationLanguagesAggregateType<T extends TrnTranslationLanguagesAggregateArgs> = {
        [P in keyof T & keyof AggregateTrnTranslationLanguages]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTrnTranslationLanguages[P]>
      : GetScalarType<T[P], AggregateTrnTranslationLanguages[P]>
  }




  export type trnTranslationLanguagesGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: trnTranslationLanguagesWhereInput
    orderBy?: trnTranslationLanguagesOrderByWithAggregationInput | trnTranslationLanguagesOrderByWithAggregationInput[]
    by: TrnTranslationLanguagesScalarFieldEnum[] | TrnTranslationLanguagesScalarFieldEnum
    having?: trnTranslationLanguagesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TrnTranslationLanguagesCountAggregateInputType | true
    _avg?: TrnTranslationLanguagesAvgAggregateInputType
    _sum?: TrnTranslationLanguagesSumAggregateInputType
    _min?: TrnTranslationLanguagesMinAggregateInputType
    _max?: TrnTranslationLanguagesMaxAggregateInputType
  }

  export type TrnTranslationLanguagesGroupByOutputType = {
    numericLanguageID: number
    languageID: string | null
    languageName: string | null
    _count: TrnTranslationLanguagesCountAggregateOutputType | null
    _avg: TrnTranslationLanguagesAvgAggregateOutputType | null
    _sum: TrnTranslationLanguagesSumAggregateOutputType | null
    _min: TrnTranslationLanguagesMinAggregateOutputType | null
    _max: TrnTranslationLanguagesMaxAggregateOutputType | null
  }

  type GetTrnTranslationLanguagesGroupByPayload<T extends trnTranslationLanguagesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TrnTranslationLanguagesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TrnTranslationLanguagesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TrnTranslationLanguagesGroupByOutputType[P]>
            : GetScalarType<T[P], TrnTranslationLanguagesGroupByOutputType[P]>
        }
      >
    >


  export type trnTranslationLanguagesSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    numericLanguageID?: boolean
    languageID?: boolean
    languageName?: boolean
  }, ExtArgs["result"]["trnTranslationLanguages"]>

  export type trnTranslationLanguagesSelectScalar = {
    numericLanguageID?: boolean
    languageID?: boolean
    languageName?: boolean
  }


  export type $trnTranslationLanguagesPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    name: "trnTranslationLanguages"
    objects: {}
    scalars: $Extensions.GetResult<{
      numericLanguageID: number
      languageID: string | null
      languageName: string | null
    }, ExtArgs["result"]["trnTranslationLanguages"]>
    composites: {}
  }


  type trnTranslationLanguagesGetPayload<S extends boolean | null | undefined | trnTranslationLanguagesDefaultArgs> = $Result.GetResult<Prisma.$trnTranslationLanguagesPayload, S>

  type trnTranslationLanguagesCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<trnTranslationLanguagesFindManyArgs, 'select' | 'include'> & {
      select?: TrnTranslationLanguagesCountAggregateInputType | true
    }

  export interface trnTranslationLanguagesDelegate<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['trnTranslationLanguages'], meta: { name: 'trnTranslationLanguages' } }
    /**
     * Find zero or one TrnTranslationLanguages that matches the filter.
     * @param {trnTranslationLanguagesFindUniqueArgs} args - Arguments to find a TrnTranslationLanguages
     * @example
     * // Get one TrnTranslationLanguages
     * const trnTranslationLanguages = await prisma.trnTranslationLanguages.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends trnTranslationLanguagesFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, trnTranslationLanguagesFindUniqueArgs<ExtArgs>>
    ): Prisma__trnTranslationLanguagesClient<$Result.GetResult<Prisma.$trnTranslationLanguagesPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one TrnTranslationLanguages that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {trnTranslationLanguagesFindUniqueOrThrowArgs} args - Arguments to find a TrnTranslationLanguages
     * @example
     * // Get one TrnTranslationLanguages
     * const trnTranslationLanguages = await prisma.trnTranslationLanguages.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends trnTranslationLanguagesFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, trnTranslationLanguagesFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__trnTranslationLanguagesClient<$Result.GetResult<Prisma.$trnTranslationLanguagesPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first TrnTranslationLanguages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {trnTranslationLanguagesFindFirstArgs} args - Arguments to find a TrnTranslationLanguages
     * @example
     * // Get one TrnTranslationLanguages
     * const trnTranslationLanguages = await prisma.trnTranslationLanguages.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends trnTranslationLanguagesFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, trnTranslationLanguagesFindFirstArgs<ExtArgs>>
    ): Prisma__trnTranslationLanguagesClient<$Result.GetResult<Prisma.$trnTranslationLanguagesPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first TrnTranslationLanguages that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {trnTranslationLanguagesFindFirstOrThrowArgs} args - Arguments to find a TrnTranslationLanguages
     * @example
     * // Get one TrnTranslationLanguages
     * const trnTranslationLanguages = await prisma.trnTranslationLanguages.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends trnTranslationLanguagesFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, trnTranslationLanguagesFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__trnTranslationLanguagesClient<$Result.GetResult<Prisma.$trnTranslationLanguagesPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more TrnTranslationLanguages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {trnTranslationLanguagesFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TrnTranslationLanguages
     * const trnTranslationLanguages = await prisma.trnTranslationLanguages.findMany()
     * 
     * // Get first 10 TrnTranslationLanguages
     * const trnTranslationLanguages = await prisma.trnTranslationLanguages.findMany({ take: 10 })
     * 
     * // Only select the `numericLanguageID`
     * const trnTranslationLanguagesWithNumericLanguageIDOnly = await prisma.trnTranslationLanguages.findMany({ select: { numericLanguageID: true } })
     * 
    **/
    findMany<T extends trnTranslationLanguagesFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, trnTranslationLanguagesFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$trnTranslationLanguagesPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a TrnTranslationLanguages.
     * @param {trnTranslationLanguagesCreateArgs} args - Arguments to create a TrnTranslationLanguages.
     * @example
     * // Create one TrnTranslationLanguages
     * const TrnTranslationLanguages = await prisma.trnTranslationLanguages.create({
     *   data: {
     *     // ... data to create a TrnTranslationLanguages
     *   }
     * })
     * 
    **/
    create<T extends trnTranslationLanguagesCreateArgs<ExtArgs>>(
      args: SelectSubset<T, trnTranslationLanguagesCreateArgs<ExtArgs>>
    ): Prisma__trnTranslationLanguagesClient<$Result.GetResult<Prisma.$trnTranslationLanguagesPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many TrnTranslationLanguages.
     *     @param {trnTranslationLanguagesCreateManyArgs} args - Arguments to create many TrnTranslationLanguages.
     *     @example
     *     // Create many TrnTranslationLanguages
     *     const trnTranslationLanguages = await prisma.trnTranslationLanguages.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends trnTranslationLanguagesCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, trnTranslationLanguagesCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a TrnTranslationLanguages.
     * @param {trnTranslationLanguagesDeleteArgs} args - Arguments to delete one TrnTranslationLanguages.
     * @example
     * // Delete one TrnTranslationLanguages
     * const TrnTranslationLanguages = await prisma.trnTranslationLanguages.delete({
     *   where: {
     *     // ... filter to delete one TrnTranslationLanguages
     *   }
     * })
     * 
    **/
    delete<T extends trnTranslationLanguagesDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, trnTranslationLanguagesDeleteArgs<ExtArgs>>
    ): Prisma__trnTranslationLanguagesClient<$Result.GetResult<Prisma.$trnTranslationLanguagesPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one TrnTranslationLanguages.
     * @param {trnTranslationLanguagesUpdateArgs} args - Arguments to update one TrnTranslationLanguages.
     * @example
     * // Update one TrnTranslationLanguages
     * const trnTranslationLanguages = await prisma.trnTranslationLanguages.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends trnTranslationLanguagesUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, trnTranslationLanguagesUpdateArgs<ExtArgs>>
    ): Prisma__trnTranslationLanguagesClient<$Result.GetResult<Prisma.$trnTranslationLanguagesPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more TrnTranslationLanguages.
     * @param {trnTranslationLanguagesDeleteManyArgs} args - Arguments to filter TrnTranslationLanguages to delete.
     * @example
     * // Delete a few TrnTranslationLanguages
     * const { count } = await prisma.trnTranslationLanguages.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends trnTranslationLanguagesDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, trnTranslationLanguagesDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TrnTranslationLanguages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {trnTranslationLanguagesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TrnTranslationLanguages
     * const trnTranslationLanguages = await prisma.trnTranslationLanguages.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends trnTranslationLanguagesUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, trnTranslationLanguagesUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one TrnTranslationLanguages.
     * @param {trnTranslationLanguagesUpsertArgs} args - Arguments to update or create a TrnTranslationLanguages.
     * @example
     * // Update or create a TrnTranslationLanguages
     * const trnTranslationLanguages = await prisma.trnTranslationLanguages.upsert({
     *   create: {
     *     // ... data to create a TrnTranslationLanguages
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TrnTranslationLanguages we want to update
     *   }
     * })
    **/
    upsert<T extends trnTranslationLanguagesUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, trnTranslationLanguagesUpsertArgs<ExtArgs>>
    ): Prisma__trnTranslationLanguagesClient<$Result.GetResult<Prisma.$trnTranslationLanguagesPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of TrnTranslationLanguages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {trnTranslationLanguagesCountArgs} args - Arguments to filter TrnTranslationLanguages to count.
     * @example
     * // Count the number of TrnTranslationLanguages
     * const count = await prisma.trnTranslationLanguages.count({
     *   where: {
     *     // ... the filter for the TrnTranslationLanguages we want to count
     *   }
     * })
    **/
    count<T extends trnTranslationLanguagesCountArgs>(
      args?: Subset<T, trnTranslationLanguagesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TrnTranslationLanguagesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TrnTranslationLanguages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrnTranslationLanguagesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TrnTranslationLanguagesAggregateArgs>(args: Subset<T, TrnTranslationLanguagesAggregateArgs>): Prisma.PrismaPromise<GetTrnTranslationLanguagesAggregateType<T>>

    /**
     * Group by TrnTranslationLanguages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {trnTranslationLanguagesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends trnTranslationLanguagesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: trnTranslationLanguagesGroupByArgs['orderBy'] }
        : { orderBy?: trnTranslationLanguagesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, trnTranslationLanguagesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTrnTranslationLanguagesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the trnTranslationLanguages model
   */
  readonly fields: trnTranslationLanguagesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for trnTranslationLanguages.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__trnTranslationLanguagesClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';


    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the trnTranslationLanguages model
   */ 
  interface trnTranslationLanguagesFieldRefs {
    readonly numericLanguageID: FieldRef<"trnTranslationLanguages", 'Int'>
    readonly languageID: FieldRef<"trnTranslationLanguages", 'String'>
    readonly languageName: FieldRef<"trnTranslationLanguages", 'String'>
  }
    

  // Custom InputTypes

  /**
   * trnTranslationLanguages findUnique
   */
  export type trnTranslationLanguagesFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the trnTranslationLanguages
     */
    select?: trnTranslationLanguagesSelect<ExtArgs> | null
    /**
     * Filter, which trnTranslationLanguages to fetch.
     */
    where: trnTranslationLanguagesWhereUniqueInput
  }


  /**
   * trnTranslationLanguages findUniqueOrThrow
   */
  export type trnTranslationLanguagesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the trnTranslationLanguages
     */
    select?: trnTranslationLanguagesSelect<ExtArgs> | null
    /**
     * Filter, which trnTranslationLanguages to fetch.
     */
    where: trnTranslationLanguagesWhereUniqueInput
  }


  /**
   * trnTranslationLanguages findFirst
   */
  export type trnTranslationLanguagesFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the trnTranslationLanguages
     */
    select?: trnTranslationLanguagesSelect<ExtArgs> | null
    /**
     * Filter, which trnTranslationLanguages to fetch.
     */
    where?: trnTranslationLanguagesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of trnTranslationLanguages to fetch.
     */
    orderBy?: trnTranslationLanguagesOrderByWithRelationInput | trnTranslationLanguagesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for trnTranslationLanguages.
     */
    cursor?: trnTranslationLanguagesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` trnTranslationLanguages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` trnTranslationLanguages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of trnTranslationLanguages.
     */
    distinct?: TrnTranslationLanguagesScalarFieldEnum | TrnTranslationLanguagesScalarFieldEnum[]
  }


  /**
   * trnTranslationLanguages findFirstOrThrow
   */
  export type trnTranslationLanguagesFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the trnTranslationLanguages
     */
    select?: trnTranslationLanguagesSelect<ExtArgs> | null
    /**
     * Filter, which trnTranslationLanguages to fetch.
     */
    where?: trnTranslationLanguagesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of trnTranslationLanguages to fetch.
     */
    orderBy?: trnTranslationLanguagesOrderByWithRelationInput | trnTranslationLanguagesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for trnTranslationLanguages.
     */
    cursor?: trnTranslationLanguagesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` trnTranslationLanguages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` trnTranslationLanguages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of trnTranslationLanguages.
     */
    distinct?: TrnTranslationLanguagesScalarFieldEnum | TrnTranslationLanguagesScalarFieldEnum[]
  }


  /**
   * trnTranslationLanguages findMany
   */
  export type trnTranslationLanguagesFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the trnTranslationLanguages
     */
    select?: trnTranslationLanguagesSelect<ExtArgs> | null
    /**
     * Filter, which trnTranslationLanguages to fetch.
     */
    where?: trnTranslationLanguagesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of trnTranslationLanguages to fetch.
     */
    orderBy?: trnTranslationLanguagesOrderByWithRelationInput | trnTranslationLanguagesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing trnTranslationLanguages.
     */
    cursor?: trnTranslationLanguagesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` trnTranslationLanguages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` trnTranslationLanguages.
     */
    skip?: number
    distinct?: TrnTranslationLanguagesScalarFieldEnum | TrnTranslationLanguagesScalarFieldEnum[]
  }


  /**
   * trnTranslationLanguages create
   */
  export type trnTranslationLanguagesCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the trnTranslationLanguages
     */
    select?: trnTranslationLanguagesSelect<ExtArgs> | null
    /**
     * The data needed to create a trnTranslationLanguages.
     */
    data: XOR<trnTranslationLanguagesCreateInput, trnTranslationLanguagesUncheckedCreateInput>
  }


  /**
   * trnTranslationLanguages createMany
   */
  export type trnTranslationLanguagesCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many trnTranslationLanguages.
     */
    data: trnTranslationLanguagesCreateManyInput | trnTranslationLanguagesCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * trnTranslationLanguages update
   */
  export type trnTranslationLanguagesUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the trnTranslationLanguages
     */
    select?: trnTranslationLanguagesSelect<ExtArgs> | null
    /**
     * The data needed to update a trnTranslationLanguages.
     */
    data: XOR<trnTranslationLanguagesUpdateInput, trnTranslationLanguagesUncheckedUpdateInput>
    /**
     * Choose, which trnTranslationLanguages to update.
     */
    where: trnTranslationLanguagesWhereUniqueInput
  }


  /**
   * trnTranslationLanguages updateMany
   */
  export type trnTranslationLanguagesUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update trnTranslationLanguages.
     */
    data: XOR<trnTranslationLanguagesUpdateManyMutationInput, trnTranslationLanguagesUncheckedUpdateManyInput>
    /**
     * Filter which trnTranslationLanguages to update
     */
    where?: trnTranslationLanguagesWhereInput
  }


  /**
   * trnTranslationLanguages upsert
   */
  export type trnTranslationLanguagesUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the trnTranslationLanguages
     */
    select?: trnTranslationLanguagesSelect<ExtArgs> | null
    /**
     * The filter to search for the trnTranslationLanguages to update in case it exists.
     */
    where: trnTranslationLanguagesWhereUniqueInput
    /**
     * In case the trnTranslationLanguages found by the `where` argument doesn't exist, create a new trnTranslationLanguages with this data.
     */
    create: XOR<trnTranslationLanguagesCreateInput, trnTranslationLanguagesUncheckedCreateInput>
    /**
     * In case the trnTranslationLanguages was found with the provided `where` argument, update it with this data.
     */
    update: XOR<trnTranslationLanguagesUpdateInput, trnTranslationLanguagesUncheckedUpdateInput>
  }


  /**
   * trnTranslationLanguages delete
   */
  export type trnTranslationLanguagesDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the trnTranslationLanguages
     */
    select?: trnTranslationLanguagesSelect<ExtArgs> | null
    /**
     * Filter which trnTranslationLanguages to delete.
     */
    where: trnTranslationLanguagesWhereUniqueInput
  }


  /**
   * trnTranslationLanguages deleteMany
   */
  export type trnTranslationLanguagesDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which trnTranslationLanguages to delete
     */
    where?: trnTranslationLanguagesWhereInput
  }


  /**
   * trnTranslationLanguages without action
   */
  export type trnTranslationLanguagesDefaultArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the trnTranslationLanguages
     */
    select?: trnTranslationLanguagesSelect<ExtArgs> | null
  }



  /**
   * Model trnTranslations
   */

  export type AggregateTrnTranslations = {
    _count: TrnTranslationsCountAggregateOutputType | null
    _avg: TrnTranslationsAvgAggregateOutputType | null
    _sum: TrnTranslationsSumAggregateOutputType | null
    _min: TrnTranslationsMinAggregateOutputType | null
    _max: TrnTranslationsMaxAggregateOutputType | null
  }

  export type TrnTranslationsAvgAggregateOutputType = {
    tcID: number | null
    keyID: number | null
  }

  export type TrnTranslationsSumAggregateOutputType = {
    tcID: number | null
    keyID: number | null
  }

  export type TrnTranslationsMinAggregateOutputType = {
    tcID: number | null
    keyID: number | null
    languageID: string | null
    text: string | null
  }

  export type TrnTranslationsMaxAggregateOutputType = {
    tcID: number | null
    keyID: number | null
    languageID: string | null
    text: string | null
  }

  export type TrnTranslationsCountAggregateOutputType = {
    tcID: number
    keyID: number
    languageID: number
    text: number
    _all: number
  }


  export type TrnTranslationsAvgAggregateInputType = {
    tcID?: true
    keyID?: true
  }

  export type TrnTranslationsSumAggregateInputType = {
    tcID?: true
    keyID?: true
  }

  export type TrnTranslationsMinAggregateInputType = {
    tcID?: true
    keyID?: true
    languageID?: true
    text?: true
  }

  export type TrnTranslationsMaxAggregateInputType = {
    tcID?: true
    keyID?: true
    languageID?: true
    text?: true
  }

  export type TrnTranslationsCountAggregateInputType = {
    tcID?: true
    keyID?: true
    languageID?: true
    text?: true
    _all?: true
  }

  export type TrnTranslationsAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which trnTranslations to aggregate.
     */
    where?: trnTranslationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of trnTranslations to fetch.
     */
    orderBy?: trnTranslationsOrderByWithRelationInput | trnTranslationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: trnTranslationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` trnTranslations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` trnTranslations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned trnTranslations
    **/
    _count?: true | TrnTranslationsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TrnTranslationsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TrnTranslationsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TrnTranslationsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TrnTranslationsMaxAggregateInputType
  }

  export type GetTrnTranslationsAggregateType<T extends TrnTranslationsAggregateArgs> = {
        [P in keyof T & keyof AggregateTrnTranslations]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTrnTranslations[P]>
      : GetScalarType<T[P], AggregateTrnTranslations[P]>
  }




  export type trnTranslationsGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: trnTranslationsWhereInput
    orderBy?: trnTranslationsOrderByWithAggregationInput | trnTranslationsOrderByWithAggregationInput[]
    by: TrnTranslationsScalarFieldEnum[] | TrnTranslationsScalarFieldEnum
    having?: trnTranslationsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TrnTranslationsCountAggregateInputType | true
    _avg?: TrnTranslationsAvgAggregateInputType
    _sum?: TrnTranslationsSumAggregateInputType
    _min?: TrnTranslationsMinAggregateInputType
    _max?: TrnTranslationsMaxAggregateInputType
  }

  export type TrnTranslationsGroupByOutputType = {
    tcID: number
    keyID: number
    languageID: string
    text: string
    _count: TrnTranslationsCountAggregateOutputType | null
    _avg: TrnTranslationsAvgAggregateOutputType | null
    _sum: TrnTranslationsSumAggregateOutputType | null
    _min: TrnTranslationsMinAggregateOutputType | null
    _max: TrnTranslationsMaxAggregateOutputType | null
  }

  type GetTrnTranslationsGroupByPayload<T extends trnTranslationsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TrnTranslationsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TrnTranslationsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TrnTranslationsGroupByOutputType[P]>
            : GetScalarType<T[P], TrnTranslationsGroupByOutputType[P]>
        }
      >
    >


  export type trnTranslationsSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    tcID?: boolean
    keyID?: boolean
    languageID?: boolean
    text?: boolean
  }, ExtArgs["result"]["trnTranslations"]>

  export type trnTranslationsSelectScalar = {
    tcID?: boolean
    keyID?: boolean
    languageID?: boolean
    text?: boolean
  }


  export type $trnTranslationsPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    name: "trnTranslations"
    objects: {}
    scalars: $Extensions.GetResult<{
      tcID: number
      keyID: number
      languageID: string
      text: string
    }, ExtArgs["result"]["trnTranslations"]>
    composites: {}
  }


  type trnTranslationsGetPayload<S extends boolean | null | undefined | trnTranslationsDefaultArgs> = $Result.GetResult<Prisma.$trnTranslationsPayload, S>

  type trnTranslationsCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<trnTranslationsFindManyArgs, 'select' | 'include'> & {
      select?: TrnTranslationsCountAggregateInputType | true
    }

  export interface trnTranslationsDelegate<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['trnTranslations'], meta: { name: 'trnTranslations' } }
    /**
     * Find zero or one TrnTranslations that matches the filter.
     * @param {trnTranslationsFindUniqueArgs} args - Arguments to find a TrnTranslations
     * @example
     * // Get one TrnTranslations
     * const trnTranslations = await prisma.trnTranslations.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends trnTranslationsFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, trnTranslationsFindUniqueArgs<ExtArgs>>
    ): Prisma__trnTranslationsClient<$Result.GetResult<Prisma.$trnTranslationsPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one TrnTranslations that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {trnTranslationsFindUniqueOrThrowArgs} args - Arguments to find a TrnTranslations
     * @example
     * // Get one TrnTranslations
     * const trnTranslations = await prisma.trnTranslations.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends trnTranslationsFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, trnTranslationsFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__trnTranslationsClient<$Result.GetResult<Prisma.$trnTranslationsPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first TrnTranslations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {trnTranslationsFindFirstArgs} args - Arguments to find a TrnTranslations
     * @example
     * // Get one TrnTranslations
     * const trnTranslations = await prisma.trnTranslations.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends trnTranslationsFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, trnTranslationsFindFirstArgs<ExtArgs>>
    ): Prisma__trnTranslationsClient<$Result.GetResult<Prisma.$trnTranslationsPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first TrnTranslations that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {trnTranslationsFindFirstOrThrowArgs} args - Arguments to find a TrnTranslations
     * @example
     * // Get one TrnTranslations
     * const trnTranslations = await prisma.trnTranslations.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends trnTranslationsFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, trnTranslationsFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__trnTranslationsClient<$Result.GetResult<Prisma.$trnTranslationsPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more TrnTranslations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {trnTranslationsFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TrnTranslations
     * const trnTranslations = await prisma.trnTranslations.findMany()
     * 
     * // Get first 10 TrnTranslations
     * const trnTranslations = await prisma.trnTranslations.findMany({ take: 10 })
     * 
     * // Only select the `tcID`
     * const trnTranslationsWithTcIDOnly = await prisma.trnTranslations.findMany({ select: { tcID: true } })
     * 
    **/
    findMany<T extends trnTranslationsFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, trnTranslationsFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$trnTranslationsPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a TrnTranslations.
     * @param {trnTranslationsCreateArgs} args - Arguments to create a TrnTranslations.
     * @example
     * // Create one TrnTranslations
     * const TrnTranslations = await prisma.trnTranslations.create({
     *   data: {
     *     // ... data to create a TrnTranslations
     *   }
     * })
     * 
    **/
    create<T extends trnTranslationsCreateArgs<ExtArgs>>(
      args: SelectSubset<T, trnTranslationsCreateArgs<ExtArgs>>
    ): Prisma__trnTranslationsClient<$Result.GetResult<Prisma.$trnTranslationsPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many TrnTranslations.
     *     @param {trnTranslationsCreateManyArgs} args - Arguments to create many TrnTranslations.
     *     @example
     *     // Create many TrnTranslations
     *     const trnTranslations = await prisma.trnTranslations.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends trnTranslationsCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, trnTranslationsCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a TrnTranslations.
     * @param {trnTranslationsDeleteArgs} args - Arguments to delete one TrnTranslations.
     * @example
     * // Delete one TrnTranslations
     * const TrnTranslations = await prisma.trnTranslations.delete({
     *   where: {
     *     // ... filter to delete one TrnTranslations
     *   }
     * })
     * 
    **/
    delete<T extends trnTranslationsDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, trnTranslationsDeleteArgs<ExtArgs>>
    ): Prisma__trnTranslationsClient<$Result.GetResult<Prisma.$trnTranslationsPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one TrnTranslations.
     * @param {trnTranslationsUpdateArgs} args - Arguments to update one TrnTranslations.
     * @example
     * // Update one TrnTranslations
     * const trnTranslations = await prisma.trnTranslations.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends trnTranslationsUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, trnTranslationsUpdateArgs<ExtArgs>>
    ): Prisma__trnTranslationsClient<$Result.GetResult<Prisma.$trnTranslationsPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more TrnTranslations.
     * @param {trnTranslationsDeleteManyArgs} args - Arguments to filter TrnTranslations to delete.
     * @example
     * // Delete a few TrnTranslations
     * const { count } = await prisma.trnTranslations.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends trnTranslationsDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, trnTranslationsDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TrnTranslations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {trnTranslationsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TrnTranslations
     * const trnTranslations = await prisma.trnTranslations.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends trnTranslationsUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, trnTranslationsUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one TrnTranslations.
     * @param {trnTranslationsUpsertArgs} args - Arguments to update or create a TrnTranslations.
     * @example
     * // Update or create a TrnTranslations
     * const trnTranslations = await prisma.trnTranslations.upsert({
     *   create: {
     *     // ... data to create a TrnTranslations
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TrnTranslations we want to update
     *   }
     * })
    **/
    upsert<T extends trnTranslationsUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, trnTranslationsUpsertArgs<ExtArgs>>
    ): Prisma__trnTranslationsClient<$Result.GetResult<Prisma.$trnTranslationsPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of TrnTranslations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {trnTranslationsCountArgs} args - Arguments to filter TrnTranslations to count.
     * @example
     * // Count the number of TrnTranslations
     * const count = await prisma.trnTranslations.count({
     *   where: {
     *     // ... the filter for the TrnTranslations we want to count
     *   }
     * })
    **/
    count<T extends trnTranslationsCountArgs>(
      args?: Subset<T, trnTranslationsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TrnTranslationsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TrnTranslations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrnTranslationsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TrnTranslationsAggregateArgs>(args: Subset<T, TrnTranslationsAggregateArgs>): Prisma.PrismaPromise<GetTrnTranslationsAggregateType<T>>

    /**
     * Group by TrnTranslations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {trnTranslationsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends trnTranslationsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: trnTranslationsGroupByArgs['orderBy'] }
        : { orderBy?: trnTranslationsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, trnTranslationsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTrnTranslationsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the trnTranslations model
   */
  readonly fields: trnTranslationsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for trnTranslations.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__trnTranslationsClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';


    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the trnTranslations model
   */ 
  interface trnTranslationsFieldRefs {
    readonly tcID: FieldRef<"trnTranslations", 'Int'>
    readonly keyID: FieldRef<"trnTranslations", 'Int'>
    readonly languageID: FieldRef<"trnTranslations", 'String'>
    readonly text: FieldRef<"trnTranslations", 'String'>
  }
    

  // Custom InputTypes

  /**
   * trnTranslations findUnique
   */
  export type trnTranslationsFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the trnTranslations
     */
    select?: trnTranslationsSelect<ExtArgs> | null
    /**
     * Filter, which trnTranslations to fetch.
     */
    where: trnTranslationsWhereUniqueInput
  }


  /**
   * trnTranslations findUniqueOrThrow
   */
  export type trnTranslationsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the trnTranslations
     */
    select?: trnTranslationsSelect<ExtArgs> | null
    /**
     * Filter, which trnTranslations to fetch.
     */
    where: trnTranslationsWhereUniqueInput
  }


  /**
   * trnTranslations findFirst
   */
  export type trnTranslationsFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the trnTranslations
     */
    select?: trnTranslationsSelect<ExtArgs> | null
    /**
     * Filter, which trnTranslations to fetch.
     */
    where?: trnTranslationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of trnTranslations to fetch.
     */
    orderBy?: trnTranslationsOrderByWithRelationInput | trnTranslationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for trnTranslations.
     */
    cursor?: trnTranslationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` trnTranslations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` trnTranslations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of trnTranslations.
     */
    distinct?: TrnTranslationsScalarFieldEnum | TrnTranslationsScalarFieldEnum[]
  }


  /**
   * trnTranslations findFirstOrThrow
   */
  export type trnTranslationsFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the trnTranslations
     */
    select?: trnTranslationsSelect<ExtArgs> | null
    /**
     * Filter, which trnTranslations to fetch.
     */
    where?: trnTranslationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of trnTranslations to fetch.
     */
    orderBy?: trnTranslationsOrderByWithRelationInput | trnTranslationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for trnTranslations.
     */
    cursor?: trnTranslationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` trnTranslations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` trnTranslations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of trnTranslations.
     */
    distinct?: TrnTranslationsScalarFieldEnum | TrnTranslationsScalarFieldEnum[]
  }


  /**
   * trnTranslations findMany
   */
  export type trnTranslationsFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the trnTranslations
     */
    select?: trnTranslationsSelect<ExtArgs> | null
    /**
     * Filter, which trnTranslations to fetch.
     */
    where?: trnTranslationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of trnTranslations to fetch.
     */
    orderBy?: trnTranslationsOrderByWithRelationInput | trnTranslationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing trnTranslations.
     */
    cursor?: trnTranslationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` trnTranslations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` trnTranslations.
     */
    skip?: number
    distinct?: TrnTranslationsScalarFieldEnum | TrnTranslationsScalarFieldEnum[]
  }


  /**
   * trnTranslations create
   */
  export type trnTranslationsCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the trnTranslations
     */
    select?: trnTranslationsSelect<ExtArgs> | null
    /**
     * The data needed to create a trnTranslations.
     */
    data: XOR<trnTranslationsCreateInput, trnTranslationsUncheckedCreateInput>
  }


  /**
   * trnTranslations createMany
   */
  export type trnTranslationsCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many trnTranslations.
     */
    data: trnTranslationsCreateManyInput | trnTranslationsCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * trnTranslations update
   */
  export type trnTranslationsUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the trnTranslations
     */
    select?: trnTranslationsSelect<ExtArgs> | null
    /**
     * The data needed to update a trnTranslations.
     */
    data: XOR<trnTranslationsUpdateInput, trnTranslationsUncheckedUpdateInput>
    /**
     * Choose, which trnTranslations to update.
     */
    where: trnTranslationsWhereUniqueInput
  }


  /**
   * trnTranslations updateMany
   */
  export type trnTranslationsUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update trnTranslations.
     */
    data: XOR<trnTranslationsUpdateManyMutationInput, trnTranslationsUncheckedUpdateManyInput>
    /**
     * Filter which trnTranslations to update
     */
    where?: trnTranslationsWhereInput
  }


  /**
   * trnTranslations upsert
   */
  export type trnTranslationsUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the trnTranslations
     */
    select?: trnTranslationsSelect<ExtArgs> | null
    /**
     * The filter to search for the trnTranslations to update in case it exists.
     */
    where: trnTranslationsWhereUniqueInput
    /**
     * In case the trnTranslations found by the `where` argument doesn't exist, create a new trnTranslations with this data.
     */
    create: XOR<trnTranslationsCreateInput, trnTranslationsUncheckedCreateInput>
    /**
     * In case the trnTranslations was found with the provided `where` argument, update it with this data.
     */
    update: XOR<trnTranslationsUpdateInput, trnTranslationsUncheckedUpdateInput>
  }


  /**
   * trnTranslations delete
   */
  export type trnTranslationsDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the trnTranslations
     */
    select?: trnTranslationsSelect<ExtArgs> | null
    /**
     * Filter which trnTranslations to delete.
     */
    where: trnTranslationsWhereUniqueInput
  }


  /**
   * trnTranslations deleteMany
   */
  export type trnTranslationsDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which trnTranslations to delete
     */
    where?: trnTranslationsWhereInput
  }


  /**
   * trnTranslations without action
   */
  export type trnTranslationsDefaultArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the trnTranslations
     */
    select?: trnTranslationsSelect<ExtArgs> | null
  }



  /**
   * Model warCombatZoneSystems
   */

  export type AggregateWarCombatZoneSystems = {
    _count: WarCombatZoneSystemsCountAggregateOutputType | null
    _avg: WarCombatZoneSystemsAvgAggregateOutputType | null
    _sum: WarCombatZoneSystemsSumAggregateOutputType | null
    _min: WarCombatZoneSystemsMinAggregateOutputType | null
    _max: WarCombatZoneSystemsMaxAggregateOutputType | null
  }

  export type WarCombatZoneSystemsAvgAggregateOutputType = {
    solarSystemID: number | null
    combatZoneID: number | null
  }

  export type WarCombatZoneSystemsSumAggregateOutputType = {
    solarSystemID: number | null
    combatZoneID: number | null
  }

  export type WarCombatZoneSystemsMinAggregateOutputType = {
    solarSystemID: number | null
    combatZoneID: number | null
  }

  export type WarCombatZoneSystemsMaxAggregateOutputType = {
    solarSystemID: number | null
    combatZoneID: number | null
  }

  export type WarCombatZoneSystemsCountAggregateOutputType = {
    solarSystemID: number
    combatZoneID: number
    _all: number
  }


  export type WarCombatZoneSystemsAvgAggregateInputType = {
    solarSystemID?: true
    combatZoneID?: true
  }

  export type WarCombatZoneSystemsSumAggregateInputType = {
    solarSystemID?: true
    combatZoneID?: true
  }

  export type WarCombatZoneSystemsMinAggregateInputType = {
    solarSystemID?: true
    combatZoneID?: true
  }

  export type WarCombatZoneSystemsMaxAggregateInputType = {
    solarSystemID?: true
    combatZoneID?: true
  }

  export type WarCombatZoneSystemsCountAggregateInputType = {
    solarSystemID?: true
    combatZoneID?: true
    _all?: true
  }

  export type WarCombatZoneSystemsAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which warCombatZoneSystems to aggregate.
     */
    where?: warCombatZoneSystemsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of warCombatZoneSystems to fetch.
     */
    orderBy?: warCombatZoneSystemsOrderByWithRelationInput | warCombatZoneSystemsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: warCombatZoneSystemsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` warCombatZoneSystems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` warCombatZoneSystems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned warCombatZoneSystems
    **/
    _count?: true | WarCombatZoneSystemsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: WarCombatZoneSystemsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: WarCombatZoneSystemsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: WarCombatZoneSystemsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: WarCombatZoneSystemsMaxAggregateInputType
  }

  export type GetWarCombatZoneSystemsAggregateType<T extends WarCombatZoneSystemsAggregateArgs> = {
        [P in keyof T & keyof AggregateWarCombatZoneSystems]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWarCombatZoneSystems[P]>
      : GetScalarType<T[P], AggregateWarCombatZoneSystems[P]>
  }




  export type warCombatZoneSystemsGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: warCombatZoneSystemsWhereInput
    orderBy?: warCombatZoneSystemsOrderByWithAggregationInput | warCombatZoneSystemsOrderByWithAggregationInput[]
    by: WarCombatZoneSystemsScalarFieldEnum[] | WarCombatZoneSystemsScalarFieldEnum
    having?: warCombatZoneSystemsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: WarCombatZoneSystemsCountAggregateInputType | true
    _avg?: WarCombatZoneSystemsAvgAggregateInputType
    _sum?: WarCombatZoneSystemsSumAggregateInputType
    _min?: WarCombatZoneSystemsMinAggregateInputType
    _max?: WarCombatZoneSystemsMaxAggregateInputType
  }

  export type WarCombatZoneSystemsGroupByOutputType = {
    solarSystemID: number
    combatZoneID: number | null
    _count: WarCombatZoneSystemsCountAggregateOutputType | null
    _avg: WarCombatZoneSystemsAvgAggregateOutputType | null
    _sum: WarCombatZoneSystemsSumAggregateOutputType | null
    _min: WarCombatZoneSystemsMinAggregateOutputType | null
    _max: WarCombatZoneSystemsMaxAggregateOutputType | null
  }

  type GetWarCombatZoneSystemsGroupByPayload<T extends warCombatZoneSystemsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<WarCombatZoneSystemsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof WarCombatZoneSystemsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], WarCombatZoneSystemsGroupByOutputType[P]>
            : GetScalarType<T[P], WarCombatZoneSystemsGroupByOutputType[P]>
        }
      >
    >


  export type warCombatZoneSystemsSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    solarSystemID?: boolean
    combatZoneID?: boolean
  }, ExtArgs["result"]["warCombatZoneSystems"]>

  export type warCombatZoneSystemsSelectScalar = {
    solarSystemID?: boolean
    combatZoneID?: boolean
  }


  export type $warCombatZoneSystemsPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    name: "warCombatZoneSystems"
    objects: {}
    scalars: $Extensions.GetResult<{
      solarSystemID: number
      combatZoneID: number | null
    }, ExtArgs["result"]["warCombatZoneSystems"]>
    composites: {}
  }


  type warCombatZoneSystemsGetPayload<S extends boolean | null | undefined | warCombatZoneSystemsDefaultArgs> = $Result.GetResult<Prisma.$warCombatZoneSystemsPayload, S>

  type warCombatZoneSystemsCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<warCombatZoneSystemsFindManyArgs, 'select' | 'include'> & {
      select?: WarCombatZoneSystemsCountAggregateInputType | true
    }

  export interface warCombatZoneSystemsDelegate<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['warCombatZoneSystems'], meta: { name: 'warCombatZoneSystems' } }
    /**
     * Find zero or one WarCombatZoneSystems that matches the filter.
     * @param {warCombatZoneSystemsFindUniqueArgs} args - Arguments to find a WarCombatZoneSystems
     * @example
     * // Get one WarCombatZoneSystems
     * const warCombatZoneSystems = await prisma.warCombatZoneSystems.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends warCombatZoneSystemsFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, warCombatZoneSystemsFindUniqueArgs<ExtArgs>>
    ): Prisma__warCombatZoneSystemsClient<$Result.GetResult<Prisma.$warCombatZoneSystemsPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one WarCombatZoneSystems that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {warCombatZoneSystemsFindUniqueOrThrowArgs} args - Arguments to find a WarCombatZoneSystems
     * @example
     * // Get one WarCombatZoneSystems
     * const warCombatZoneSystems = await prisma.warCombatZoneSystems.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends warCombatZoneSystemsFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, warCombatZoneSystemsFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__warCombatZoneSystemsClient<$Result.GetResult<Prisma.$warCombatZoneSystemsPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first WarCombatZoneSystems that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {warCombatZoneSystemsFindFirstArgs} args - Arguments to find a WarCombatZoneSystems
     * @example
     * // Get one WarCombatZoneSystems
     * const warCombatZoneSystems = await prisma.warCombatZoneSystems.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends warCombatZoneSystemsFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, warCombatZoneSystemsFindFirstArgs<ExtArgs>>
    ): Prisma__warCombatZoneSystemsClient<$Result.GetResult<Prisma.$warCombatZoneSystemsPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first WarCombatZoneSystems that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {warCombatZoneSystemsFindFirstOrThrowArgs} args - Arguments to find a WarCombatZoneSystems
     * @example
     * // Get one WarCombatZoneSystems
     * const warCombatZoneSystems = await prisma.warCombatZoneSystems.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends warCombatZoneSystemsFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, warCombatZoneSystemsFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__warCombatZoneSystemsClient<$Result.GetResult<Prisma.$warCombatZoneSystemsPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more WarCombatZoneSystems that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {warCombatZoneSystemsFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all WarCombatZoneSystems
     * const warCombatZoneSystems = await prisma.warCombatZoneSystems.findMany()
     * 
     * // Get first 10 WarCombatZoneSystems
     * const warCombatZoneSystems = await prisma.warCombatZoneSystems.findMany({ take: 10 })
     * 
     * // Only select the `solarSystemID`
     * const warCombatZoneSystemsWithSolarSystemIDOnly = await prisma.warCombatZoneSystems.findMany({ select: { solarSystemID: true } })
     * 
    **/
    findMany<T extends warCombatZoneSystemsFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, warCombatZoneSystemsFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$warCombatZoneSystemsPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a WarCombatZoneSystems.
     * @param {warCombatZoneSystemsCreateArgs} args - Arguments to create a WarCombatZoneSystems.
     * @example
     * // Create one WarCombatZoneSystems
     * const WarCombatZoneSystems = await prisma.warCombatZoneSystems.create({
     *   data: {
     *     // ... data to create a WarCombatZoneSystems
     *   }
     * })
     * 
    **/
    create<T extends warCombatZoneSystemsCreateArgs<ExtArgs>>(
      args: SelectSubset<T, warCombatZoneSystemsCreateArgs<ExtArgs>>
    ): Prisma__warCombatZoneSystemsClient<$Result.GetResult<Prisma.$warCombatZoneSystemsPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many WarCombatZoneSystems.
     *     @param {warCombatZoneSystemsCreateManyArgs} args - Arguments to create many WarCombatZoneSystems.
     *     @example
     *     // Create many WarCombatZoneSystems
     *     const warCombatZoneSystems = await prisma.warCombatZoneSystems.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends warCombatZoneSystemsCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, warCombatZoneSystemsCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a WarCombatZoneSystems.
     * @param {warCombatZoneSystemsDeleteArgs} args - Arguments to delete one WarCombatZoneSystems.
     * @example
     * // Delete one WarCombatZoneSystems
     * const WarCombatZoneSystems = await prisma.warCombatZoneSystems.delete({
     *   where: {
     *     // ... filter to delete one WarCombatZoneSystems
     *   }
     * })
     * 
    **/
    delete<T extends warCombatZoneSystemsDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, warCombatZoneSystemsDeleteArgs<ExtArgs>>
    ): Prisma__warCombatZoneSystemsClient<$Result.GetResult<Prisma.$warCombatZoneSystemsPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one WarCombatZoneSystems.
     * @param {warCombatZoneSystemsUpdateArgs} args - Arguments to update one WarCombatZoneSystems.
     * @example
     * // Update one WarCombatZoneSystems
     * const warCombatZoneSystems = await prisma.warCombatZoneSystems.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends warCombatZoneSystemsUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, warCombatZoneSystemsUpdateArgs<ExtArgs>>
    ): Prisma__warCombatZoneSystemsClient<$Result.GetResult<Prisma.$warCombatZoneSystemsPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more WarCombatZoneSystems.
     * @param {warCombatZoneSystemsDeleteManyArgs} args - Arguments to filter WarCombatZoneSystems to delete.
     * @example
     * // Delete a few WarCombatZoneSystems
     * const { count } = await prisma.warCombatZoneSystems.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends warCombatZoneSystemsDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, warCombatZoneSystemsDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more WarCombatZoneSystems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {warCombatZoneSystemsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many WarCombatZoneSystems
     * const warCombatZoneSystems = await prisma.warCombatZoneSystems.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends warCombatZoneSystemsUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, warCombatZoneSystemsUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one WarCombatZoneSystems.
     * @param {warCombatZoneSystemsUpsertArgs} args - Arguments to update or create a WarCombatZoneSystems.
     * @example
     * // Update or create a WarCombatZoneSystems
     * const warCombatZoneSystems = await prisma.warCombatZoneSystems.upsert({
     *   create: {
     *     // ... data to create a WarCombatZoneSystems
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the WarCombatZoneSystems we want to update
     *   }
     * })
    **/
    upsert<T extends warCombatZoneSystemsUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, warCombatZoneSystemsUpsertArgs<ExtArgs>>
    ): Prisma__warCombatZoneSystemsClient<$Result.GetResult<Prisma.$warCombatZoneSystemsPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of WarCombatZoneSystems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {warCombatZoneSystemsCountArgs} args - Arguments to filter WarCombatZoneSystems to count.
     * @example
     * // Count the number of WarCombatZoneSystems
     * const count = await prisma.warCombatZoneSystems.count({
     *   where: {
     *     // ... the filter for the WarCombatZoneSystems we want to count
     *   }
     * })
    **/
    count<T extends warCombatZoneSystemsCountArgs>(
      args?: Subset<T, warCombatZoneSystemsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], WarCombatZoneSystemsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a WarCombatZoneSystems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WarCombatZoneSystemsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends WarCombatZoneSystemsAggregateArgs>(args: Subset<T, WarCombatZoneSystemsAggregateArgs>): Prisma.PrismaPromise<GetWarCombatZoneSystemsAggregateType<T>>

    /**
     * Group by WarCombatZoneSystems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {warCombatZoneSystemsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends warCombatZoneSystemsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: warCombatZoneSystemsGroupByArgs['orderBy'] }
        : { orderBy?: warCombatZoneSystemsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, warCombatZoneSystemsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWarCombatZoneSystemsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the warCombatZoneSystems model
   */
  readonly fields: warCombatZoneSystemsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for warCombatZoneSystems.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__warCombatZoneSystemsClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';


    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the warCombatZoneSystems model
   */ 
  interface warCombatZoneSystemsFieldRefs {
    readonly solarSystemID: FieldRef<"warCombatZoneSystems", 'Int'>
    readonly combatZoneID: FieldRef<"warCombatZoneSystems", 'Int'>
  }
    

  // Custom InputTypes

  /**
   * warCombatZoneSystems findUnique
   */
  export type warCombatZoneSystemsFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the warCombatZoneSystems
     */
    select?: warCombatZoneSystemsSelect<ExtArgs> | null
    /**
     * Filter, which warCombatZoneSystems to fetch.
     */
    where: warCombatZoneSystemsWhereUniqueInput
  }


  /**
   * warCombatZoneSystems findUniqueOrThrow
   */
  export type warCombatZoneSystemsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the warCombatZoneSystems
     */
    select?: warCombatZoneSystemsSelect<ExtArgs> | null
    /**
     * Filter, which warCombatZoneSystems to fetch.
     */
    where: warCombatZoneSystemsWhereUniqueInput
  }


  /**
   * warCombatZoneSystems findFirst
   */
  export type warCombatZoneSystemsFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the warCombatZoneSystems
     */
    select?: warCombatZoneSystemsSelect<ExtArgs> | null
    /**
     * Filter, which warCombatZoneSystems to fetch.
     */
    where?: warCombatZoneSystemsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of warCombatZoneSystems to fetch.
     */
    orderBy?: warCombatZoneSystemsOrderByWithRelationInput | warCombatZoneSystemsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for warCombatZoneSystems.
     */
    cursor?: warCombatZoneSystemsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` warCombatZoneSystems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` warCombatZoneSystems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of warCombatZoneSystems.
     */
    distinct?: WarCombatZoneSystemsScalarFieldEnum | WarCombatZoneSystemsScalarFieldEnum[]
  }


  /**
   * warCombatZoneSystems findFirstOrThrow
   */
  export type warCombatZoneSystemsFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the warCombatZoneSystems
     */
    select?: warCombatZoneSystemsSelect<ExtArgs> | null
    /**
     * Filter, which warCombatZoneSystems to fetch.
     */
    where?: warCombatZoneSystemsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of warCombatZoneSystems to fetch.
     */
    orderBy?: warCombatZoneSystemsOrderByWithRelationInput | warCombatZoneSystemsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for warCombatZoneSystems.
     */
    cursor?: warCombatZoneSystemsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` warCombatZoneSystems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` warCombatZoneSystems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of warCombatZoneSystems.
     */
    distinct?: WarCombatZoneSystemsScalarFieldEnum | WarCombatZoneSystemsScalarFieldEnum[]
  }


  /**
   * warCombatZoneSystems findMany
   */
  export type warCombatZoneSystemsFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the warCombatZoneSystems
     */
    select?: warCombatZoneSystemsSelect<ExtArgs> | null
    /**
     * Filter, which warCombatZoneSystems to fetch.
     */
    where?: warCombatZoneSystemsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of warCombatZoneSystems to fetch.
     */
    orderBy?: warCombatZoneSystemsOrderByWithRelationInput | warCombatZoneSystemsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing warCombatZoneSystems.
     */
    cursor?: warCombatZoneSystemsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` warCombatZoneSystems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` warCombatZoneSystems.
     */
    skip?: number
    distinct?: WarCombatZoneSystemsScalarFieldEnum | WarCombatZoneSystemsScalarFieldEnum[]
  }


  /**
   * warCombatZoneSystems create
   */
  export type warCombatZoneSystemsCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the warCombatZoneSystems
     */
    select?: warCombatZoneSystemsSelect<ExtArgs> | null
    /**
     * The data needed to create a warCombatZoneSystems.
     */
    data: XOR<warCombatZoneSystemsCreateInput, warCombatZoneSystemsUncheckedCreateInput>
  }


  /**
   * warCombatZoneSystems createMany
   */
  export type warCombatZoneSystemsCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many warCombatZoneSystems.
     */
    data: warCombatZoneSystemsCreateManyInput | warCombatZoneSystemsCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * warCombatZoneSystems update
   */
  export type warCombatZoneSystemsUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the warCombatZoneSystems
     */
    select?: warCombatZoneSystemsSelect<ExtArgs> | null
    /**
     * The data needed to update a warCombatZoneSystems.
     */
    data: XOR<warCombatZoneSystemsUpdateInput, warCombatZoneSystemsUncheckedUpdateInput>
    /**
     * Choose, which warCombatZoneSystems to update.
     */
    where: warCombatZoneSystemsWhereUniqueInput
  }


  /**
   * warCombatZoneSystems updateMany
   */
  export type warCombatZoneSystemsUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update warCombatZoneSystems.
     */
    data: XOR<warCombatZoneSystemsUpdateManyMutationInput, warCombatZoneSystemsUncheckedUpdateManyInput>
    /**
     * Filter which warCombatZoneSystems to update
     */
    where?: warCombatZoneSystemsWhereInput
  }


  /**
   * warCombatZoneSystems upsert
   */
  export type warCombatZoneSystemsUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the warCombatZoneSystems
     */
    select?: warCombatZoneSystemsSelect<ExtArgs> | null
    /**
     * The filter to search for the warCombatZoneSystems to update in case it exists.
     */
    where: warCombatZoneSystemsWhereUniqueInput
    /**
     * In case the warCombatZoneSystems found by the `where` argument doesn't exist, create a new warCombatZoneSystems with this data.
     */
    create: XOR<warCombatZoneSystemsCreateInput, warCombatZoneSystemsUncheckedCreateInput>
    /**
     * In case the warCombatZoneSystems was found with the provided `where` argument, update it with this data.
     */
    update: XOR<warCombatZoneSystemsUpdateInput, warCombatZoneSystemsUncheckedUpdateInput>
  }


  /**
   * warCombatZoneSystems delete
   */
  export type warCombatZoneSystemsDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the warCombatZoneSystems
     */
    select?: warCombatZoneSystemsSelect<ExtArgs> | null
    /**
     * Filter which warCombatZoneSystems to delete.
     */
    where: warCombatZoneSystemsWhereUniqueInput
  }


  /**
   * warCombatZoneSystems deleteMany
   */
  export type warCombatZoneSystemsDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which warCombatZoneSystems to delete
     */
    where?: warCombatZoneSystemsWhereInput
  }


  /**
   * warCombatZoneSystems without action
   */
  export type warCombatZoneSystemsDefaultArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the warCombatZoneSystems
     */
    select?: warCombatZoneSystemsSelect<ExtArgs> | null
  }



  /**
   * Model warCombatZones
   */

  export type AggregateWarCombatZones = {
    _count: WarCombatZonesCountAggregateOutputType | null
    _avg: WarCombatZonesAvgAggregateOutputType | null
    _sum: WarCombatZonesSumAggregateOutputType | null
    _min: WarCombatZonesMinAggregateOutputType | null
    _max: WarCombatZonesMaxAggregateOutputType | null
  }

  export type WarCombatZonesAvgAggregateOutputType = {
    combatZoneID: number | null
    factionID: number | null
    centerSystemID: number | null
  }

  export type WarCombatZonesSumAggregateOutputType = {
    combatZoneID: number | null
    factionID: number | null
    centerSystemID: number | null
  }

  export type WarCombatZonesMinAggregateOutputType = {
    combatZoneID: number | null
    combatZoneName: string | null
    factionID: number | null
    centerSystemID: number | null
    description: string | null
  }

  export type WarCombatZonesMaxAggregateOutputType = {
    combatZoneID: number | null
    combatZoneName: string | null
    factionID: number | null
    centerSystemID: number | null
    description: string | null
  }

  export type WarCombatZonesCountAggregateOutputType = {
    combatZoneID: number
    combatZoneName: number
    factionID: number
    centerSystemID: number
    description: number
    _all: number
  }


  export type WarCombatZonesAvgAggregateInputType = {
    combatZoneID?: true
    factionID?: true
    centerSystemID?: true
  }

  export type WarCombatZonesSumAggregateInputType = {
    combatZoneID?: true
    factionID?: true
    centerSystemID?: true
  }

  export type WarCombatZonesMinAggregateInputType = {
    combatZoneID?: true
    combatZoneName?: true
    factionID?: true
    centerSystemID?: true
    description?: true
  }

  export type WarCombatZonesMaxAggregateInputType = {
    combatZoneID?: true
    combatZoneName?: true
    factionID?: true
    centerSystemID?: true
    description?: true
  }

  export type WarCombatZonesCountAggregateInputType = {
    combatZoneID?: true
    combatZoneName?: true
    factionID?: true
    centerSystemID?: true
    description?: true
    _all?: true
  }

  export type WarCombatZonesAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which warCombatZones to aggregate.
     */
    where?: warCombatZonesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of warCombatZones to fetch.
     */
    orderBy?: warCombatZonesOrderByWithRelationInput | warCombatZonesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: warCombatZonesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` warCombatZones from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` warCombatZones.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned warCombatZones
    **/
    _count?: true | WarCombatZonesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: WarCombatZonesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: WarCombatZonesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: WarCombatZonesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: WarCombatZonesMaxAggregateInputType
  }

  export type GetWarCombatZonesAggregateType<T extends WarCombatZonesAggregateArgs> = {
        [P in keyof T & keyof AggregateWarCombatZones]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWarCombatZones[P]>
      : GetScalarType<T[P], AggregateWarCombatZones[P]>
  }




  export type warCombatZonesGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: warCombatZonesWhereInput
    orderBy?: warCombatZonesOrderByWithAggregationInput | warCombatZonesOrderByWithAggregationInput[]
    by: WarCombatZonesScalarFieldEnum[] | WarCombatZonesScalarFieldEnum
    having?: warCombatZonesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: WarCombatZonesCountAggregateInputType | true
    _avg?: WarCombatZonesAvgAggregateInputType
    _sum?: WarCombatZonesSumAggregateInputType
    _min?: WarCombatZonesMinAggregateInputType
    _max?: WarCombatZonesMaxAggregateInputType
  }

  export type WarCombatZonesGroupByOutputType = {
    combatZoneID: number
    combatZoneName: string | null
    factionID: number | null
    centerSystemID: number | null
    description: string | null
    _count: WarCombatZonesCountAggregateOutputType | null
    _avg: WarCombatZonesAvgAggregateOutputType | null
    _sum: WarCombatZonesSumAggregateOutputType | null
    _min: WarCombatZonesMinAggregateOutputType | null
    _max: WarCombatZonesMaxAggregateOutputType | null
  }

  type GetWarCombatZonesGroupByPayload<T extends warCombatZonesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<WarCombatZonesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof WarCombatZonesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], WarCombatZonesGroupByOutputType[P]>
            : GetScalarType<T[P], WarCombatZonesGroupByOutputType[P]>
        }
      >
    >


  export type warCombatZonesSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    combatZoneID?: boolean
    combatZoneName?: boolean
    factionID?: boolean
    centerSystemID?: boolean
    description?: boolean
  }, ExtArgs["result"]["warCombatZones"]>

  export type warCombatZonesSelectScalar = {
    combatZoneID?: boolean
    combatZoneName?: boolean
    factionID?: boolean
    centerSystemID?: boolean
    description?: boolean
  }


  export type $warCombatZonesPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    name: "warCombatZones"
    objects: {}
    scalars: $Extensions.GetResult<{
      combatZoneID: number
      combatZoneName: string | null
      factionID: number | null
      centerSystemID: number | null
      description: string | null
    }, ExtArgs["result"]["warCombatZones"]>
    composites: {}
  }


  type warCombatZonesGetPayload<S extends boolean | null | undefined | warCombatZonesDefaultArgs> = $Result.GetResult<Prisma.$warCombatZonesPayload, S>

  type warCombatZonesCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<warCombatZonesFindManyArgs, 'select' | 'include'> & {
      select?: WarCombatZonesCountAggregateInputType | true
    }

  export interface warCombatZonesDelegate<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['warCombatZones'], meta: { name: 'warCombatZones' } }
    /**
     * Find zero or one WarCombatZones that matches the filter.
     * @param {warCombatZonesFindUniqueArgs} args - Arguments to find a WarCombatZones
     * @example
     * // Get one WarCombatZones
     * const warCombatZones = await prisma.warCombatZones.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends warCombatZonesFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, warCombatZonesFindUniqueArgs<ExtArgs>>
    ): Prisma__warCombatZonesClient<$Result.GetResult<Prisma.$warCombatZonesPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one WarCombatZones that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {warCombatZonesFindUniqueOrThrowArgs} args - Arguments to find a WarCombatZones
     * @example
     * // Get one WarCombatZones
     * const warCombatZones = await prisma.warCombatZones.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends warCombatZonesFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, warCombatZonesFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__warCombatZonesClient<$Result.GetResult<Prisma.$warCombatZonesPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first WarCombatZones that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {warCombatZonesFindFirstArgs} args - Arguments to find a WarCombatZones
     * @example
     * // Get one WarCombatZones
     * const warCombatZones = await prisma.warCombatZones.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends warCombatZonesFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, warCombatZonesFindFirstArgs<ExtArgs>>
    ): Prisma__warCombatZonesClient<$Result.GetResult<Prisma.$warCombatZonesPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first WarCombatZones that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {warCombatZonesFindFirstOrThrowArgs} args - Arguments to find a WarCombatZones
     * @example
     * // Get one WarCombatZones
     * const warCombatZones = await prisma.warCombatZones.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends warCombatZonesFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, warCombatZonesFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__warCombatZonesClient<$Result.GetResult<Prisma.$warCombatZonesPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more WarCombatZones that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {warCombatZonesFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all WarCombatZones
     * const warCombatZones = await prisma.warCombatZones.findMany()
     * 
     * // Get first 10 WarCombatZones
     * const warCombatZones = await prisma.warCombatZones.findMany({ take: 10 })
     * 
     * // Only select the `combatZoneID`
     * const warCombatZonesWithCombatZoneIDOnly = await prisma.warCombatZones.findMany({ select: { combatZoneID: true } })
     * 
    **/
    findMany<T extends warCombatZonesFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, warCombatZonesFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$warCombatZonesPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a WarCombatZones.
     * @param {warCombatZonesCreateArgs} args - Arguments to create a WarCombatZones.
     * @example
     * // Create one WarCombatZones
     * const WarCombatZones = await prisma.warCombatZones.create({
     *   data: {
     *     // ... data to create a WarCombatZones
     *   }
     * })
     * 
    **/
    create<T extends warCombatZonesCreateArgs<ExtArgs>>(
      args: SelectSubset<T, warCombatZonesCreateArgs<ExtArgs>>
    ): Prisma__warCombatZonesClient<$Result.GetResult<Prisma.$warCombatZonesPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many WarCombatZones.
     *     @param {warCombatZonesCreateManyArgs} args - Arguments to create many WarCombatZones.
     *     @example
     *     // Create many WarCombatZones
     *     const warCombatZones = await prisma.warCombatZones.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends warCombatZonesCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, warCombatZonesCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a WarCombatZones.
     * @param {warCombatZonesDeleteArgs} args - Arguments to delete one WarCombatZones.
     * @example
     * // Delete one WarCombatZones
     * const WarCombatZones = await prisma.warCombatZones.delete({
     *   where: {
     *     // ... filter to delete one WarCombatZones
     *   }
     * })
     * 
    **/
    delete<T extends warCombatZonesDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, warCombatZonesDeleteArgs<ExtArgs>>
    ): Prisma__warCombatZonesClient<$Result.GetResult<Prisma.$warCombatZonesPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one WarCombatZones.
     * @param {warCombatZonesUpdateArgs} args - Arguments to update one WarCombatZones.
     * @example
     * // Update one WarCombatZones
     * const warCombatZones = await prisma.warCombatZones.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends warCombatZonesUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, warCombatZonesUpdateArgs<ExtArgs>>
    ): Prisma__warCombatZonesClient<$Result.GetResult<Prisma.$warCombatZonesPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more WarCombatZones.
     * @param {warCombatZonesDeleteManyArgs} args - Arguments to filter WarCombatZones to delete.
     * @example
     * // Delete a few WarCombatZones
     * const { count } = await prisma.warCombatZones.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends warCombatZonesDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, warCombatZonesDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more WarCombatZones.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {warCombatZonesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many WarCombatZones
     * const warCombatZones = await prisma.warCombatZones.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends warCombatZonesUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, warCombatZonesUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one WarCombatZones.
     * @param {warCombatZonesUpsertArgs} args - Arguments to update or create a WarCombatZones.
     * @example
     * // Update or create a WarCombatZones
     * const warCombatZones = await prisma.warCombatZones.upsert({
     *   create: {
     *     // ... data to create a WarCombatZones
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the WarCombatZones we want to update
     *   }
     * })
    **/
    upsert<T extends warCombatZonesUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, warCombatZonesUpsertArgs<ExtArgs>>
    ): Prisma__warCombatZonesClient<$Result.GetResult<Prisma.$warCombatZonesPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of WarCombatZones.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {warCombatZonesCountArgs} args - Arguments to filter WarCombatZones to count.
     * @example
     * // Count the number of WarCombatZones
     * const count = await prisma.warCombatZones.count({
     *   where: {
     *     // ... the filter for the WarCombatZones we want to count
     *   }
     * })
    **/
    count<T extends warCombatZonesCountArgs>(
      args?: Subset<T, warCombatZonesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], WarCombatZonesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a WarCombatZones.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WarCombatZonesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends WarCombatZonesAggregateArgs>(args: Subset<T, WarCombatZonesAggregateArgs>): Prisma.PrismaPromise<GetWarCombatZonesAggregateType<T>>

    /**
     * Group by WarCombatZones.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {warCombatZonesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends warCombatZonesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: warCombatZonesGroupByArgs['orderBy'] }
        : { orderBy?: warCombatZonesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, warCombatZonesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWarCombatZonesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the warCombatZones model
   */
  readonly fields: warCombatZonesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for warCombatZones.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__warCombatZonesClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';


    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the warCombatZones model
   */ 
  interface warCombatZonesFieldRefs {
    readonly combatZoneID: FieldRef<"warCombatZones", 'Int'>
    readonly combatZoneName: FieldRef<"warCombatZones", 'String'>
    readonly factionID: FieldRef<"warCombatZones", 'Int'>
    readonly centerSystemID: FieldRef<"warCombatZones", 'Int'>
    readonly description: FieldRef<"warCombatZones", 'String'>
  }
    

  // Custom InputTypes

  /**
   * warCombatZones findUnique
   */
  export type warCombatZonesFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the warCombatZones
     */
    select?: warCombatZonesSelect<ExtArgs> | null
    /**
     * Filter, which warCombatZones to fetch.
     */
    where: warCombatZonesWhereUniqueInput
  }


  /**
   * warCombatZones findUniqueOrThrow
   */
  export type warCombatZonesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the warCombatZones
     */
    select?: warCombatZonesSelect<ExtArgs> | null
    /**
     * Filter, which warCombatZones to fetch.
     */
    where: warCombatZonesWhereUniqueInput
  }


  /**
   * warCombatZones findFirst
   */
  export type warCombatZonesFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the warCombatZones
     */
    select?: warCombatZonesSelect<ExtArgs> | null
    /**
     * Filter, which warCombatZones to fetch.
     */
    where?: warCombatZonesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of warCombatZones to fetch.
     */
    orderBy?: warCombatZonesOrderByWithRelationInput | warCombatZonesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for warCombatZones.
     */
    cursor?: warCombatZonesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` warCombatZones from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` warCombatZones.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of warCombatZones.
     */
    distinct?: WarCombatZonesScalarFieldEnum | WarCombatZonesScalarFieldEnum[]
  }


  /**
   * warCombatZones findFirstOrThrow
   */
  export type warCombatZonesFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the warCombatZones
     */
    select?: warCombatZonesSelect<ExtArgs> | null
    /**
     * Filter, which warCombatZones to fetch.
     */
    where?: warCombatZonesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of warCombatZones to fetch.
     */
    orderBy?: warCombatZonesOrderByWithRelationInput | warCombatZonesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for warCombatZones.
     */
    cursor?: warCombatZonesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` warCombatZones from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` warCombatZones.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of warCombatZones.
     */
    distinct?: WarCombatZonesScalarFieldEnum | WarCombatZonesScalarFieldEnum[]
  }


  /**
   * warCombatZones findMany
   */
  export type warCombatZonesFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the warCombatZones
     */
    select?: warCombatZonesSelect<ExtArgs> | null
    /**
     * Filter, which warCombatZones to fetch.
     */
    where?: warCombatZonesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of warCombatZones to fetch.
     */
    orderBy?: warCombatZonesOrderByWithRelationInput | warCombatZonesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing warCombatZones.
     */
    cursor?: warCombatZonesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` warCombatZones from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` warCombatZones.
     */
    skip?: number
    distinct?: WarCombatZonesScalarFieldEnum | WarCombatZonesScalarFieldEnum[]
  }


  /**
   * warCombatZones create
   */
  export type warCombatZonesCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the warCombatZones
     */
    select?: warCombatZonesSelect<ExtArgs> | null
    /**
     * The data needed to create a warCombatZones.
     */
    data: XOR<warCombatZonesCreateInput, warCombatZonesUncheckedCreateInput>
  }


  /**
   * warCombatZones createMany
   */
  export type warCombatZonesCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many warCombatZones.
     */
    data: warCombatZonesCreateManyInput | warCombatZonesCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * warCombatZones update
   */
  export type warCombatZonesUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the warCombatZones
     */
    select?: warCombatZonesSelect<ExtArgs> | null
    /**
     * The data needed to update a warCombatZones.
     */
    data: XOR<warCombatZonesUpdateInput, warCombatZonesUncheckedUpdateInput>
    /**
     * Choose, which warCombatZones to update.
     */
    where: warCombatZonesWhereUniqueInput
  }


  /**
   * warCombatZones updateMany
   */
  export type warCombatZonesUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update warCombatZones.
     */
    data: XOR<warCombatZonesUpdateManyMutationInput, warCombatZonesUncheckedUpdateManyInput>
    /**
     * Filter which warCombatZones to update
     */
    where?: warCombatZonesWhereInput
  }


  /**
   * warCombatZones upsert
   */
  export type warCombatZonesUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the warCombatZones
     */
    select?: warCombatZonesSelect<ExtArgs> | null
    /**
     * The filter to search for the warCombatZones to update in case it exists.
     */
    where: warCombatZonesWhereUniqueInput
    /**
     * In case the warCombatZones found by the `where` argument doesn't exist, create a new warCombatZones with this data.
     */
    create: XOR<warCombatZonesCreateInput, warCombatZonesUncheckedCreateInput>
    /**
     * In case the warCombatZones was found with the provided `where` argument, update it with this data.
     */
    update: XOR<warCombatZonesUpdateInput, warCombatZonesUncheckedUpdateInput>
  }


  /**
   * warCombatZones delete
   */
  export type warCombatZonesDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the warCombatZones
     */
    select?: warCombatZonesSelect<ExtArgs> | null
    /**
     * Filter which warCombatZones to delete.
     */
    where: warCombatZonesWhereUniqueInput
  }


  /**
   * warCombatZones deleteMany
   */
  export type warCombatZonesDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which warCombatZones to delete
     */
    where?: warCombatZonesWhereInput
  }


  /**
   * warCombatZones without action
   */
  export type warCombatZonesDefaultArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the warCombatZones
     */
    select?: warCombatZonesSelect<ExtArgs> | null
  }



  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const AgtAgentTypesScalarFieldEnum: {
    agentTypeID: 'agentTypeID',
    agentType: 'agentType'
  };

  export type AgtAgentTypesScalarFieldEnum = (typeof AgtAgentTypesScalarFieldEnum)[keyof typeof AgtAgentTypesScalarFieldEnum]


  export const AgtAgentsScalarFieldEnum: {
    agentID: 'agentID',
    divisionID: 'divisionID',
    corporationID: 'corporationID',
    locationID: 'locationID',
    level: 'level',
    quality: 'quality',
    agentTypeID: 'agentTypeID',
    isLocator: 'isLocator'
  };

  export type AgtAgentsScalarFieldEnum = (typeof AgtAgentsScalarFieldEnum)[keyof typeof AgtAgentsScalarFieldEnum]


  export const AgtAgentsInSpaceScalarFieldEnum: {
    agentID: 'agentID',
    dungeonID: 'dungeonID',
    solarSystemID: 'solarSystemID',
    spawnPointID: 'spawnPointID',
    typeID: 'typeID'
  };

  export type AgtAgentsInSpaceScalarFieldEnum = (typeof AgtAgentsInSpaceScalarFieldEnum)[keyof typeof AgtAgentsInSpaceScalarFieldEnum]


  export const AgtResearchAgentsScalarFieldEnum: {
    agentID: 'agentID',
    typeID: 'typeID'
  };

  export type AgtResearchAgentsScalarFieldEnum = (typeof AgtResearchAgentsScalarFieldEnum)[keyof typeof AgtResearchAgentsScalarFieldEnum]


  export const CertCertsScalarFieldEnum: {
    certID: 'certID',
    description: 'description',
    groupID: 'groupID',
    name: 'name'
  };

  export type CertCertsScalarFieldEnum = (typeof CertCertsScalarFieldEnum)[keyof typeof CertCertsScalarFieldEnum]


  export const ChrAncestriesScalarFieldEnum: {
    ancestryID: 'ancestryID',
    ancestryName: 'ancestryName',
    bloodlineID: 'bloodlineID',
    description: 'description',
    perception: 'perception',
    willpower: 'willpower',
    charisma: 'charisma',
    memory: 'memory',
    intelligence: 'intelligence',
    iconID: 'iconID',
    shortDescription: 'shortDescription'
  };

  export type ChrAncestriesScalarFieldEnum = (typeof ChrAncestriesScalarFieldEnum)[keyof typeof ChrAncestriesScalarFieldEnum]


  export const ChrAttributesScalarFieldEnum: {
    attributeID: 'attributeID',
    attributeName: 'attributeName',
    description: 'description',
    iconID: 'iconID',
    shortDescription: 'shortDescription',
    notes: 'notes'
  };

  export type ChrAttributesScalarFieldEnum = (typeof ChrAttributesScalarFieldEnum)[keyof typeof ChrAttributesScalarFieldEnum]


  export const ChrBloodlinesScalarFieldEnum: {
    bloodlineID: 'bloodlineID',
    bloodlineName: 'bloodlineName',
    raceID: 'raceID',
    description: 'description',
    maleDescription: 'maleDescription',
    femaleDescription: 'femaleDescription',
    shipTypeID: 'shipTypeID',
    corporationID: 'corporationID',
    perception: 'perception',
    willpower: 'willpower',
    charisma: 'charisma',
    memory: 'memory',
    intelligence: 'intelligence',
    iconID: 'iconID',
    shortDescription: 'shortDescription',
    shortMaleDescription: 'shortMaleDescription',
    shortFemaleDescription: 'shortFemaleDescription'
  };

  export type ChrBloodlinesScalarFieldEnum = (typeof ChrBloodlinesScalarFieldEnum)[keyof typeof ChrBloodlinesScalarFieldEnum]


  export const ChrFactionsScalarFieldEnum: {
    factionID: 'factionID',
    factionName: 'factionName',
    description: 'description',
    raceIDs: 'raceIDs',
    solarSystemID: 'solarSystemID',
    corporationID: 'corporationID',
    sizeFactor: 'sizeFactor',
    stationCount: 'stationCount',
    stationSystemCount: 'stationSystemCount',
    militiaCorporationID: 'militiaCorporationID',
    iconID: 'iconID'
  };

  export type ChrFactionsScalarFieldEnum = (typeof ChrFactionsScalarFieldEnum)[keyof typeof ChrFactionsScalarFieldEnum]


  export const ChrRacesScalarFieldEnum: {
    raceID: 'raceID',
    raceName: 'raceName',
    description: 'description',
    iconID: 'iconID',
    shortDescription: 'shortDescription'
  };

  export type ChrRacesScalarFieldEnum = (typeof ChrRacesScalarFieldEnum)[keyof typeof ChrRacesScalarFieldEnum]


  export const CrpActivitiesScalarFieldEnum: {
    activityID: 'activityID',
    activityName: 'activityName',
    description: 'description'
  };

  export type CrpActivitiesScalarFieldEnum = (typeof CrpActivitiesScalarFieldEnum)[keyof typeof CrpActivitiesScalarFieldEnum]


  export const CrpNPCCorporationDivisionsScalarFieldEnum: {
    corporationID: 'corporationID',
    divisionID: 'divisionID',
    size: 'size'
  };

  export type CrpNPCCorporationDivisionsScalarFieldEnum = (typeof CrpNPCCorporationDivisionsScalarFieldEnum)[keyof typeof CrpNPCCorporationDivisionsScalarFieldEnum]


  export const CrpNPCCorporationResearchFieldsScalarFieldEnum: {
    skillID: 'skillID',
    corporationID: 'corporationID'
  };

  export type CrpNPCCorporationResearchFieldsScalarFieldEnum = (typeof CrpNPCCorporationResearchFieldsScalarFieldEnum)[keyof typeof CrpNPCCorporationResearchFieldsScalarFieldEnum]


  export const CrpNPCCorporationTradesScalarFieldEnum: {
    corporationID: 'corporationID',
    typeID: 'typeID'
  };

  export type CrpNPCCorporationTradesScalarFieldEnum = (typeof CrpNPCCorporationTradesScalarFieldEnum)[keyof typeof CrpNPCCorporationTradesScalarFieldEnum]


  export const CrpNPCCorporationsScalarFieldEnum: {
    corporationID: 'corporationID',
    size: 'size',
    extent: 'extent',
    solarSystemID: 'solarSystemID',
    investorID1: 'investorID1',
    investorShares1: 'investorShares1',
    investorID2: 'investorID2',
    investorShares2: 'investorShares2',
    investorID3: 'investorID3',
    investorShares3: 'investorShares3',
    investorID4: 'investorID4',
    investorShares4: 'investorShares4',
    friendID: 'friendID',
    enemyID: 'enemyID',
    publicShares: 'publicShares',
    initialPrice: 'initialPrice',
    minSecurity: 'minSecurity',
    scattered: 'scattered',
    fringe: 'fringe',
    corridor: 'corridor',
    hub: 'hub',
    border: 'border',
    factionID: 'factionID',
    sizeFactor: 'sizeFactor',
    stationCount: 'stationCount',
    stationSystemCount: 'stationSystemCount',
    description: 'description',
    iconID: 'iconID'
  };

  export type CrpNPCCorporationsScalarFieldEnum = (typeof CrpNPCCorporationsScalarFieldEnum)[keyof typeof CrpNPCCorporationsScalarFieldEnum]


  export const CrpNPCDivisionsScalarFieldEnum: {
    divisionID: 'divisionID',
    divisionName: 'divisionName',
    description: 'description',
    leaderType: 'leaderType'
  };

  export type CrpNPCDivisionsScalarFieldEnum = (typeof CrpNPCDivisionsScalarFieldEnum)[keyof typeof CrpNPCDivisionsScalarFieldEnum]


  export const DgmAttributeCategoriesScalarFieldEnum: {
    categoryID: 'categoryID',
    categoryName: 'categoryName',
    categoryDescription: 'categoryDescription'
  };

  export type DgmAttributeCategoriesScalarFieldEnum = (typeof DgmAttributeCategoriesScalarFieldEnum)[keyof typeof DgmAttributeCategoriesScalarFieldEnum]


  export const DgmAttributeTypesScalarFieldEnum: {
    attributeID: 'attributeID',
    attributeName: 'attributeName',
    description: 'description',
    iconID: 'iconID',
    defaultValue: 'defaultValue',
    published: 'published',
    displayName: 'displayName',
    unitID: 'unitID',
    stackable: 'stackable',
    highIsGood: 'highIsGood',
    categoryID: 'categoryID'
  };

  export type DgmAttributeTypesScalarFieldEnum = (typeof DgmAttributeTypesScalarFieldEnum)[keyof typeof DgmAttributeTypesScalarFieldEnum]


  export const DgmEffectsScalarFieldEnum: {
    effectID: 'effectID',
    effectName: 'effectName',
    effectCategory: 'effectCategory',
    preExpression: 'preExpression',
    postExpression: 'postExpression',
    description: 'description',
    guid: 'guid',
    iconID: 'iconID',
    isOffensive: 'isOffensive',
    isAssistance: 'isAssistance',
    durationAttributeID: 'durationAttributeID',
    trackingSpeedAttributeID: 'trackingSpeedAttributeID',
    dischargeAttributeID: 'dischargeAttributeID',
    rangeAttributeID: 'rangeAttributeID',
    falloffAttributeID: 'falloffAttributeID',
    disallowAutoRepeat: 'disallowAutoRepeat',
    published: 'published',
    displayName: 'displayName',
    isWarpSafe: 'isWarpSafe',
    rangeChance: 'rangeChance',
    electronicChance: 'electronicChance',
    propulsionChance: 'propulsionChance',
    distribution: 'distribution',
    sfxName: 'sfxName',
    npcUsageChanceAttributeID: 'npcUsageChanceAttributeID',
    npcActivationChanceAttributeID: 'npcActivationChanceAttributeID',
    fittingUsageChanceAttributeID: 'fittingUsageChanceAttributeID',
    modifierInfo: 'modifierInfo'
  };

  export type DgmEffectsScalarFieldEnum = (typeof DgmEffectsScalarFieldEnum)[keyof typeof DgmEffectsScalarFieldEnum]


  export const DgmExpressionsScalarFieldEnum: {
    expressionID: 'expressionID',
    operandID: 'operandID',
    arg1: 'arg1',
    arg2: 'arg2',
    expressionValue: 'expressionValue',
    description: 'description',
    expressionName: 'expressionName',
    expressionTypeID: 'expressionTypeID',
    expressionGroupID: 'expressionGroupID',
    expressionAttributeID: 'expressionAttributeID'
  };

  export type DgmExpressionsScalarFieldEnum = (typeof DgmExpressionsScalarFieldEnum)[keyof typeof DgmExpressionsScalarFieldEnum]


  export const DgmTypeAttributesScalarFieldEnum: {
    typeID: 'typeID',
    attributeID: 'attributeID',
    valueInt: 'valueInt',
    valueFloat: 'valueFloat'
  };

  export type DgmTypeAttributesScalarFieldEnum = (typeof DgmTypeAttributesScalarFieldEnum)[keyof typeof DgmTypeAttributesScalarFieldEnum]


  export const DgmTypeEffectsScalarFieldEnum: {
    typeID: 'typeID',
    effectID: 'effectID',
    isDefault: 'isDefault'
  };

  export type DgmTypeEffectsScalarFieldEnum = (typeof DgmTypeEffectsScalarFieldEnum)[keyof typeof DgmTypeEffectsScalarFieldEnum]


  export const EveGraphicsScalarFieldEnum: {
    graphicID: 'graphicID',
    sofFactionName: 'sofFactionName',
    graphicFile: 'graphicFile',
    sofHullName: 'sofHullName',
    sofRaceName: 'sofRaceName',
    description: 'description'
  };

  export type EveGraphicsScalarFieldEnum = (typeof EveGraphicsScalarFieldEnum)[keyof typeof EveGraphicsScalarFieldEnum]


  export const EveIconsScalarFieldEnum: {
    iconID: 'iconID',
    iconFile: 'iconFile',
    description: 'description'
  };

  export type EveIconsScalarFieldEnum = (typeof EveIconsScalarFieldEnum)[keyof typeof EveIconsScalarFieldEnum]


  export const EveUnitsScalarFieldEnum: {
    unitID: 'unitID',
    unitName: 'unitName',
    displayName: 'displayName',
    description: 'description'
  };

  export type EveUnitsScalarFieldEnum = (typeof EveUnitsScalarFieldEnum)[keyof typeof EveUnitsScalarFieldEnum]


  export const IndustryActivityScalarFieldEnum: {
    typeID: 'typeID',
    activityID: 'activityID',
    time: 'time'
  };

  export type IndustryActivityScalarFieldEnum = (typeof IndustryActivityScalarFieldEnum)[keyof typeof IndustryActivityScalarFieldEnum]


  export const IndustryBlueprintsScalarFieldEnum: {
    typeID: 'typeID',
    maxProductionLimit: 'maxProductionLimit'
  };

  export type IndustryBlueprintsScalarFieldEnum = (typeof IndustryBlueprintsScalarFieldEnum)[keyof typeof IndustryBlueprintsScalarFieldEnum]


  export const InvCategoriesScalarFieldEnum: {
    categoryID: 'categoryID',
    categoryName: 'categoryName',
    iconID: 'iconID',
    published: 'published'
  };

  export type InvCategoriesScalarFieldEnum = (typeof InvCategoriesScalarFieldEnum)[keyof typeof InvCategoriesScalarFieldEnum]


  export const InvContrabandTypesScalarFieldEnum: {
    factionID: 'factionID',
    typeID: 'typeID',
    standingLoss: 'standingLoss',
    confiscateMinSec: 'confiscateMinSec',
    fineByValue: 'fineByValue',
    attackMinSec: 'attackMinSec'
  };

  export type InvContrabandTypesScalarFieldEnum = (typeof InvContrabandTypesScalarFieldEnum)[keyof typeof InvContrabandTypesScalarFieldEnum]


  export const InvControlTowerResourcePurposesScalarFieldEnum: {
    purpose: 'purpose',
    purposeText: 'purposeText'
  };

  export type InvControlTowerResourcePurposesScalarFieldEnum = (typeof InvControlTowerResourcePurposesScalarFieldEnum)[keyof typeof InvControlTowerResourcePurposesScalarFieldEnum]


  export const InvControlTowerResourcesScalarFieldEnum: {
    controlTowerTypeID: 'controlTowerTypeID',
    resourceTypeID: 'resourceTypeID',
    purpose: 'purpose',
    quantity: 'quantity',
    minSecurityLevel: 'minSecurityLevel',
    factionID: 'factionID'
  };

  export type InvControlTowerResourcesScalarFieldEnum = (typeof InvControlTowerResourcesScalarFieldEnum)[keyof typeof InvControlTowerResourcesScalarFieldEnum]


  export const InvFlagsScalarFieldEnum: {
    flagID: 'flagID',
    flagName: 'flagName',
    flagText: 'flagText',
    orderID: 'orderID'
  };

  export type InvFlagsScalarFieldEnum = (typeof InvFlagsScalarFieldEnum)[keyof typeof InvFlagsScalarFieldEnum]


  export const InvGroupsScalarFieldEnum: {
    groupID: 'groupID',
    categoryID: 'categoryID',
    groupName: 'groupName',
    iconID: 'iconID',
    useBasePrice: 'useBasePrice',
    anchored: 'anchored',
    anchorable: 'anchorable',
    fittableNonSingleton: 'fittableNonSingleton',
    published: 'published'
  };

  export type InvGroupsScalarFieldEnum = (typeof InvGroupsScalarFieldEnum)[keyof typeof InvGroupsScalarFieldEnum]


  export const InvItemsScalarFieldEnum: {
    itemID: 'itemID',
    typeID: 'typeID',
    ownerID: 'ownerID',
    locationID: 'locationID',
    flagID: 'flagID',
    quantity: 'quantity'
  };

  export type InvItemsScalarFieldEnum = (typeof InvItemsScalarFieldEnum)[keyof typeof InvItemsScalarFieldEnum]


  export const InvMarketGroupsScalarFieldEnum: {
    marketGroupID: 'marketGroupID',
    parentGroupID: 'parentGroupID',
    marketGroupName: 'marketGroupName',
    description: 'description',
    iconID: 'iconID',
    hasTypes: 'hasTypes'
  };

  export type InvMarketGroupsScalarFieldEnum = (typeof InvMarketGroupsScalarFieldEnum)[keyof typeof InvMarketGroupsScalarFieldEnum]


  export const InvMetaGroupsScalarFieldEnum: {
    metaGroupID: 'metaGroupID',
    metaGroupName: 'metaGroupName',
    description: 'description',
    iconID: 'iconID'
  };

  export type InvMetaGroupsScalarFieldEnum = (typeof InvMetaGroupsScalarFieldEnum)[keyof typeof InvMetaGroupsScalarFieldEnum]


  export const InvMetaTypesScalarFieldEnum: {
    typeID: 'typeID',
    parentTypeID: 'parentTypeID',
    metaGroupID: 'metaGroupID'
  };

  export type InvMetaTypesScalarFieldEnum = (typeof InvMetaTypesScalarFieldEnum)[keyof typeof InvMetaTypesScalarFieldEnum]


  export const InvNamesScalarFieldEnum: {
    itemID: 'itemID',
    itemName: 'itemName'
  };

  export type InvNamesScalarFieldEnum = (typeof InvNamesScalarFieldEnum)[keyof typeof InvNamesScalarFieldEnum]


  export const InvPositionsScalarFieldEnum: {
    itemID: 'itemID',
    x: 'x',
    y: 'y',
    z: 'z',
    yaw: 'yaw',
    pitch: 'pitch',
    roll: 'roll'
  };

  export type InvPositionsScalarFieldEnum = (typeof InvPositionsScalarFieldEnum)[keyof typeof InvPositionsScalarFieldEnum]


  export const InvTraitsScalarFieldEnum: {
    traitID: 'traitID',
    typeID: 'typeID',
    skillID: 'skillID',
    bonus: 'bonus',
    bonusText: 'bonusText',
    unitID: 'unitID'
  };

  export type InvTraitsScalarFieldEnum = (typeof InvTraitsScalarFieldEnum)[keyof typeof InvTraitsScalarFieldEnum]


  export const InvTypeMaterialsScalarFieldEnum: {
    typeID: 'typeID',
    materialTypeID: 'materialTypeID',
    quantity: 'quantity'
  };

  export type InvTypeMaterialsScalarFieldEnum = (typeof InvTypeMaterialsScalarFieldEnum)[keyof typeof InvTypeMaterialsScalarFieldEnum]


  export const InvTypeReactionsScalarFieldEnum: {
    reactionTypeID: 'reactionTypeID',
    input: 'input',
    typeID: 'typeID',
    quantity: 'quantity'
  };

  export type InvTypeReactionsScalarFieldEnum = (typeof InvTypeReactionsScalarFieldEnum)[keyof typeof InvTypeReactionsScalarFieldEnum]


  export const InvTypesScalarFieldEnum: {
    typeID: 'typeID',
    groupID: 'groupID',
    typeName: 'typeName',
    description: 'description',
    mass: 'mass',
    volume: 'volume',
    capacity: 'capacity',
    portionSize: 'portionSize',
    raceID: 'raceID',
    basePrice: 'basePrice',
    published: 'published',
    marketGroupID: 'marketGroupID',
    iconID: 'iconID',
    soundID: 'soundID',
    graphicID: 'graphicID'
  };

  export type InvTypesScalarFieldEnum = (typeof InvTypesScalarFieldEnum)[keyof typeof InvTypesScalarFieldEnum]


  export const InvUniqueNamesScalarFieldEnum: {
    itemID: 'itemID',
    itemName: 'itemName',
    groupID: 'groupID'
  };

  export type InvUniqueNamesScalarFieldEnum = (typeof InvUniqueNamesScalarFieldEnum)[keyof typeof InvUniqueNamesScalarFieldEnum]


  export const InvVolumesScalarFieldEnum: {
    typeID: 'typeID',
    volume: 'volume'
  };

  export type InvVolumesScalarFieldEnum = (typeof InvVolumesScalarFieldEnum)[keyof typeof InvVolumesScalarFieldEnum]


  export const MapCelestialGraphicsScalarFieldEnum: {
    celestialID: 'celestialID',
    heightMap1: 'heightMap1',
    heightMap2: 'heightMap2',
    shaderPreset: 'shaderPreset',
    population: 'population'
  };

  export type MapCelestialGraphicsScalarFieldEnum = (typeof MapCelestialGraphicsScalarFieldEnum)[keyof typeof MapCelestialGraphicsScalarFieldEnum]


  export const MapCelestialStatisticsScalarFieldEnum: {
    celestialID: 'celestialID',
    temperature: 'temperature',
    spectralClass: 'spectralClass',
    luminosity: 'luminosity',
    age: 'age',
    life: 'life',
    orbitRadius: 'orbitRadius',
    eccentricity: 'eccentricity',
    massDust: 'massDust',
    massGas: 'massGas',
    fragmented: 'fragmented',
    density: 'density',
    surfaceGravity: 'surfaceGravity',
    escapeVelocity: 'escapeVelocity',
    orbitPeriod: 'orbitPeriod',
    rotationRate: 'rotationRate',
    locked: 'locked',
    pressure: 'pressure',
    radius: 'radius',
    mass: 'mass'
  };

  export type MapCelestialStatisticsScalarFieldEnum = (typeof MapCelestialStatisticsScalarFieldEnum)[keyof typeof MapCelestialStatisticsScalarFieldEnum]


  export const MapConstellationJumpsScalarFieldEnum: {
    fromRegionID: 'fromRegionID',
    fromConstellationID: 'fromConstellationID',
    toConstellationID: 'toConstellationID',
    toRegionID: 'toRegionID'
  };

  export type MapConstellationJumpsScalarFieldEnum = (typeof MapConstellationJumpsScalarFieldEnum)[keyof typeof MapConstellationJumpsScalarFieldEnum]


  export const MapConstellationsScalarFieldEnum: {
    regionID: 'regionID',
    constellationID: 'constellationID',
    constellationName: 'constellationName',
    x: 'x',
    y: 'y',
    z: 'z',
    xMin: 'xMin',
    xMax: 'xMax',
    yMin: 'yMin',
    yMax: 'yMax',
    zMin: 'zMin',
    zMax: 'zMax',
    factionID: 'factionID',
    radius: 'radius'
  };

  export type MapConstellationsScalarFieldEnum = (typeof MapConstellationsScalarFieldEnum)[keyof typeof MapConstellationsScalarFieldEnum]


  export const MapDenormalizeScalarFieldEnum: {
    itemID: 'itemID',
    typeID: 'typeID',
    groupID: 'groupID',
    solarSystemID: 'solarSystemID',
    constellationID: 'constellationID',
    regionID: 'regionID',
    orbitID: 'orbitID',
    x: 'x',
    y: 'y',
    z: 'z',
    radius: 'radius',
    itemName: 'itemName',
    security: 'security',
    celestialIndex: 'celestialIndex',
    orbitIndex: 'orbitIndex'
  };

  export type MapDenormalizeScalarFieldEnum = (typeof MapDenormalizeScalarFieldEnum)[keyof typeof MapDenormalizeScalarFieldEnum]


  export const MapJumpsScalarFieldEnum: {
    stargateID: 'stargateID',
    destinationID: 'destinationID'
  };

  export type MapJumpsScalarFieldEnum = (typeof MapJumpsScalarFieldEnum)[keyof typeof MapJumpsScalarFieldEnum]


  export const MapLandmarksScalarFieldEnum: {
    landmarkID: 'landmarkID',
    landmarkName: 'landmarkName',
    description: 'description',
    locationID: 'locationID',
    x: 'x',
    y: 'y',
    z: 'z',
    iconID: 'iconID'
  };

  export type MapLandmarksScalarFieldEnum = (typeof MapLandmarksScalarFieldEnum)[keyof typeof MapLandmarksScalarFieldEnum]


  export const MapLocationScenesScalarFieldEnum: {
    locationID: 'locationID',
    graphicID: 'graphicID'
  };

  export type MapLocationScenesScalarFieldEnum = (typeof MapLocationScenesScalarFieldEnum)[keyof typeof MapLocationScenesScalarFieldEnum]


  export const MapLocationWormholeClassesScalarFieldEnum: {
    locationID: 'locationID',
    wormholeClassID: 'wormholeClassID'
  };

  export type MapLocationWormholeClassesScalarFieldEnum = (typeof MapLocationWormholeClassesScalarFieldEnum)[keyof typeof MapLocationWormholeClassesScalarFieldEnum]


  export const MapRegionJumpsScalarFieldEnum: {
    fromRegionID: 'fromRegionID',
    toRegionID: 'toRegionID'
  };

  export type MapRegionJumpsScalarFieldEnum = (typeof MapRegionJumpsScalarFieldEnum)[keyof typeof MapRegionJumpsScalarFieldEnum]


  export const MapRegionsScalarFieldEnum: {
    regionID: 'regionID',
    regionName: 'regionName',
    x: 'x',
    y: 'y',
    z: 'z',
    xMin: 'xMin',
    xMax: 'xMax',
    yMin: 'yMin',
    yMax: 'yMax',
    zMin: 'zMin',
    zMax: 'zMax',
    factionID: 'factionID',
    nebula: 'nebula',
    radius: 'radius'
  };

  export type MapRegionsScalarFieldEnum = (typeof MapRegionsScalarFieldEnum)[keyof typeof MapRegionsScalarFieldEnum]


  export const MapSolarSystemJumpsScalarFieldEnum: {
    fromRegionID: 'fromRegionID',
    fromConstellationID: 'fromConstellationID',
    fromSolarSystemID: 'fromSolarSystemID',
    toSolarSystemID: 'toSolarSystemID',
    toConstellationID: 'toConstellationID',
    toRegionID: 'toRegionID'
  };

  export type MapSolarSystemJumpsScalarFieldEnum = (typeof MapSolarSystemJumpsScalarFieldEnum)[keyof typeof MapSolarSystemJumpsScalarFieldEnum]


  export const MapSolarSystemsScalarFieldEnum: {
    regionID: 'regionID',
    constellationID: 'constellationID',
    solarSystemID: 'solarSystemID',
    solarSystemName: 'solarSystemName',
    x: 'x',
    y: 'y',
    z: 'z',
    xMin: 'xMin',
    xMax: 'xMax',
    yMin: 'yMin',
    yMax: 'yMax',
    zMin: 'zMin',
    zMax: 'zMax',
    luminosity: 'luminosity',
    border: 'border',
    fringe: 'fringe',
    corridor: 'corridor',
    hub: 'hub',
    international: 'international',
    regional: 'regional',
    constellation: 'constellation',
    security: 'security',
    factionID: 'factionID',
    radius: 'radius',
    sunTypeID: 'sunTypeID',
    securityClass: 'securityClass'
  };

  export type MapSolarSystemsScalarFieldEnum = (typeof MapSolarSystemsScalarFieldEnum)[keyof typeof MapSolarSystemsScalarFieldEnum]


  export const MapUniverseScalarFieldEnum: {
    universeID: 'universeID',
    universeName: 'universeName',
    x: 'x',
    y: 'y',
    z: 'z',
    xMin: 'xMin',
    xMax: 'xMax',
    yMin: 'yMin',
    yMax: 'yMax',
    zMin: 'zMin',
    zMax: 'zMax',
    radius: 'radius'
  };

  export type MapUniverseScalarFieldEnum = (typeof MapUniverseScalarFieldEnum)[keyof typeof MapUniverseScalarFieldEnum]


  export const PlanetSchematicsScalarFieldEnum: {
    schematicID: 'schematicID',
    schematicName: 'schematicName',
    cycleTime: 'cycleTime'
  };

  export type PlanetSchematicsScalarFieldEnum = (typeof PlanetSchematicsScalarFieldEnum)[keyof typeof PlanetSchematicsScalarFieldEnum]


  export const PlanetSchematicsPinMapScalarFieldEnum: {
    schematicID: 'schematicID',
    pinTypeID: 'pinTypeID'
  };

  export type PlanetSchematicsPinMapScalarFieldEnum = (typeof PlanetSchematicsPinMapScalarFieldEnum)[keyof typeof PlanetSchematicsPinMapScalarFieldEnum]


  export const PlanetSchematicsTypeMapScalarFieldEnum: {
    schematicID: 'schematicID',
    typeID: 'typeID',
    quantity: 'quantity',
    isInput: 'isInput'
  };

  export type PlanetSchematicsTypeMapScalarFieldEnum = (typeof PlanetSchematicsTypeMapScalarFieldEnum)[keyof typeof PlanetSchematicsTypeMapScalarFieldEnum]


  export const RamActivitiesScalarFieldEnum: {
    activityID: 'activityID',
    activityName: 'activityName',
    iconNo: 'iconNo',
    description: 'description',
    published: 'published'
  };

  export type RamActivitiesScalarFieldEnum = (typeof RamActivitiesScalarFieldEnum)[keyof typeof RamActivitiesScalarFieldEnum]


  export const RamAssemblyLineStationsScalarFieldEnum: {
    stationID: 'stationID',
    assemblyLineTypeID: 'assemblyLineTypeID',
    quantity: 'quantity',
    stationTypeID: 'stationTypeID',
    ownerID: 'ownerID',
    solarSystemID: 'solarSystemID',
    regionID: 'regionID'
  };

  export type RamAssemblyLineStationsScalarFieldEnum = (typeof RamAssemblyLineStationsScalarFieldEnum)[keyof typeof RamAssemblyLineStationsScalarFieldEnum]


  export const RamAssemblyLineTypeDetailPerCategoryScalarFieldEnum: {
    assemblyLineTypeID: 'assemblyLineTypeID',
    categoryID: 'categoryID',
    timeMultiplier: 'timeMultiplier',
    materialMultiplier: 'materialMultiplier',
    costMultiplier: 'costMultiplier'
  };

  export type RamAssemblyLineTypeDetailPerCategoryScalarFieldEnum = (typeof RamAssemblyLineTypeDetailPerCategoryScalarFieldEnum)[keyof typeof RamAssemblyLineTypeDetailPerCategoryScalarFieldEnum]


  export const RamAssemblyLineTypeDetailPerGroupScalarFieldEnum: {
    assemblyLineTypeID: 'assemblyLineTypeID',
    groupID: 'groupID',
    timeMultiplier: 'timeMultiplier',
    materialMultiplier: 'materialMultiplier',
    costMultiplier: 'costMultiplier'
  };

  export type RamAssemblyLineTypeDetailPerGroupScalarFieldEnum = (typeof RamAssemblyLineTypeDetailPerGroupScalarFieldEnum)[keyof typeof RamAssemblyLineTypeDetailPerGroupScalarFieldEnum]


  export const RamAssemblyLineTypesScalarFieldEnum: {
    assemblyLineTypeID: 'assemblyLineTypeID',
    assemblyLineTypeName: 'assemblyLineTypeName',
    description: 'description',
    baseTimeMultiplier: 'baseTimeMultiplier',
    baseMaterialMultiplier: 'baseMaterialMultiplier',
    baseCostMultiplier: 'baseCostMultiplier',
    volume: 'volume',
    activityID: 'activityID',
    minCostPerHour: 'minCostPerHour'
  };

  export type RamAssemblyLineTypesScalarFieldEnum = (typeof RamAssemblyLineTypesScalarFieldEnum)[keyof typeof RamAssemblyLineTypesScalarFieldEnum]


  export const RamInstallationTypeContentsScalarFieldEnum: {
    installationTypeID: 'installationTypeID',
    assemblyLineTypeID: 'assemblyLineTypeID',
    quantity: 'quantity'
  };

  export type RamInstallationTypeContentsScalarFieldEnum = (typeof RamInstallationTypeContentsScalarFieldEnum)[keyof typeof RamInstallationTypeContentsScalarFieldEnum]


  export const SkinLicenseScalarFieldEnum: {
    licenseTypeID: 'licenseTypeID',
    duration: 'duration',
    skinID: 'skinID'
  };

  export type SkinLicenseScalarFieldEnum = (typeof SkinLicenseScalarFieldEnum)[keyof typeof SkinLicenseScalarFieldEnum]


  export const SkinMaterialsScalarFieldEnum: {
    skinMaterialID: 'skinMaterialID',
    displayNameID: 'displayNameID',
    materialSetID: 'materialSetID'
  };

  export type SkinMaterialsScalarFieldEnum = (typeof SkinMaterialsScalarFieldEnum)[keyof typeof SkinMaterialsScalarFieldEnum]


  export const SkinsScalarFieldEnum: {
    skinID: 'skinID',
    internalName: 'internalName',
    skinMaterialID: 'skinMaterialID'
  };

  export type SkinsScalarFieldEnum = (typeof SkinsScalarFieldEnum)[keyof typeof SkinsScalarFieldEnum]


  export const StaOperationServicesScalarFieldEnum: {
    operationID: 'operationID',
    serviceID: 'serviceID'
  };

  export type StaOperationServicesScalarFieldEnum = (typeof StaOperationServicesScalarFieldEnum)[keyof typeof StaOperationServicesScalarFieldEnum]


  export const StaOperationsScalarFieldEnum: {
    activityID: 'activityID',
    operationID: 'operationID',
    operationName: 'operationName',
    description: 'description',
    fringe: 'fringe',
    corridor: 'corridor',
    hub: 'hub',
    border: 'border',
    ratio: 'ratio',
    caldariStationTypeID: 'caldariStationTypeID',
    minmatarStationTypeID: 'minmatarStationTypeID',
    amarrStationTypeID: 'amarrStationTypeID',
    gallenteStationTypeID: 'gallenteStationTypeID',
    joveStationTypeID: 'joveStationTypeID'
  };

  export type StaOperationsScalarFieldEnum = (typeof StaOperationsScalarFieldEnum)[keyof typeof StaOperationsScalarFieldEnum]


  export const StaServicesScalarFieldEnum: {
    serviceID: 'serviceID',
    serviceName: 'serviceName',
    description: 'description'
  };

  export type StaServicesScalarFieldEnum = (typeof StaServicesScalarFieldEnum)[keyof typeof StaServicesScalarFieldEnum]


  export const StaStationTypesScalarFieldEnum: {
    stationTypeID: 'stationTypeID',
    dockEntryX: 'dockEntryX',
    dockEntryY: 'dockEntryY',
    dockEntryZ: 'dockEntryZ',
    dockOrientationX: 'dockOrientationX',
    dockOrientationY: 'dockOrientationY',
    dockOrientationZ: 'dockOrientationZ',
    operationID: 'operationID',
    officeSlots: 'officeSlots',
    reprocessingEfficiency: 'reprocessingEfficiency',
    conquerable: 'conquerable'
  };

  export type StaStationTypesScalarFieldEnum = (typeof StaStationTypesScalarFieldEnum)[keyof typeof StaStationTypesScalarFieldEnum]


  export const StaStationsScalarFieldEnum: {
    stationID: 'stationID',
    security: 'security',
    dockingCostPerVolume: 'dockingCostPerVolume',
    maxShipVolumeDockable: 'maxShipVolumeDockable',
    officeRentalCost: 'officeRentalCost',
    operationID: 'operationID',
    stationTypeID: 'stationTypeID',
    corporationID: 'corporationID',
    solarSystemID: 'solarSystemID',
    constellationID: 'constellationID',
    regionID: 'regionID',
    stationName: 'stationName',
    x: 'x',
    y: 'y',
    z: 'z',
    reprocessingEfficiency: 'reprocessingEfficiency',
    reprocessingStationsTake: 'reprocessingStationsTake',
    reprocessingHangarFlag: 'reprocessingHangarFlag'
  };

  export type StaStationsScalarFieldEnum = (typeof StaStationsScalarFieldEnum)[keyof typeof StaStationsScalarFieldEnum]


  export const TranslationTablesScalarFieldEnum: {
    sourceTable: 'sourceTable',
    destinationTable: 'destinationTable',
    translatedKey: 'translatedKey',
    tcGroupID: 'tcGroupID',
    tcID: 'tcID'
  };

  export type TranslationTablesScalarFieldEnum = (typeof TranslationTablesScalarFieldEnum)[keyof typeof TranslationTablesScalarFieldEnum]


  export const TrnTranslationColumnsScalarFieldEnum: {
    tcGroupID: 'tcGroupID',
    tcID: 'tcID',
    tableName: 'tableName',
    columnName: 'columnName',
    masterID: 'masterID'
  };

  export type TrnTranslationColumnsScalarFieldEnum = (typeof TrnTranslationColumnsScalarFieldEnum)[keyof typeof TrnTranslationColumnsScalarFieldEnum]


  export const TrnTranslationLanguagesScalarFieldEnum: {
    numericLanguageID: 'numericLanguageID',
    languageID: 'languageID',
    languageName: 'languageName'
  };

  export type TrnTranslationLanguagesScalarFieldEnum = (typeof TrnTranslationLanguagesScalarFieldEnum)[keyof typeof TrnTranslationLanguagesScalarFieldEnum]


  export const TrnTranslationsScalarFieldEnum: {
    tcID: 'tcID',
    keyID: 'keyID',
    languageID: 'languageID',
    text: 'text'
  };

  export type TrnTranslationsScalarFieldEnum = (typeof TrnTranslationsScalarFieldEnum)[keyof typeof TrnTranslationsScalarFieldEnum]


  export const WarCombatZoneSystemsScalarFieldEnum: {
    solarSystemID: 'solarSystemID',
    combatZoneID: 'combatZoneID'
  };

  export type WarCombatZoneSystemsScalarFieldEnum = (typeof WarCombatZoneSystemsScalarFieldEnum)[keyof typeof WarCombatZoneSystemsScalarFieldEnum]


  export const WarCombatZonesScalarFieldEnum: {
    combatZoneID: 'combatZoneID',
    combatZoneName: 'combatZoneName',
    factionID: 'factionID',
    centerSystemID: 'centerSystemID',
    description: 'description'
  };

  export type WarCombatZonesScalarFieldEnum = (typeof WarCombatZonesScalarFieldEnum)[keyof typeof WarCombatZonesScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Field references 
   */


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Decimal'
   */
  export type DecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal'>
    


  /**
   * Reference to a field of type 'BigInt'
   */
  export type BigIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BigInt'>
    
  /**
   * Deep Input Types
   */


  export type agtAgentTypesWhereInput = {
    AND?: agtAgentTypesWhereInput | agtAgentTypesWhereInput[]
    OR?: agtAgentTypesWhereInput[]
    NOT?: agtAgentTypesWhereInput | agtAgentTypesWhereInput[]
    agentTypeID?: IntFilter<"agtAgentTypes"> | number
    agentType?: StringNullableFilter<"agtAgentTypes"> | string | null
  }

  export type agtAgentTypesOrderByWithRelationInput = {
    agentTypeID?: SortOrder
    agentType?: SortOrderInput | SortOrder
  }

  export type agtAgentTypesWhereUniqueInput = Prisma.AtLeast<{
    agentTypeID?: number
    AND?: agtAgentTypesWhereInput | agtAgentTypesWhereInput[]
    OR?: agtAgentTypesWhereInput[]
    NOT?: agtAgentTypesWhereInput | agtAgentTypesWhereInput[]
    agentType?: StringNullableFilter<"agtAgentTypes"> | string | null
  }, "agentTypeID">

  export type agtAgentTypesOrderByWithAggregationInput = {
    agentTypeID?: SortOrder
    agentType?: SortOrderInput | SortOrder
    _count?: agtAgentTypesCountOrderByAggregateInput
    _avg?: agtAgentTypesAvgOrderByAggregateInput
    _max?: agtAgentTypesMaxOrderByAggregateInput
    _min?: agtAgentTypesMinOrderByAggregateInput
    _sum?: agtAgentTypesSumOrderByAggregateInput
  }

  export type agtAgentTypesScalarWhereWithAggregatesInput = {
    AND?: agtAgentTypesScalarWhereWithAggregatesInput | agtAgentTypesScalarWhereWithAggregatesInput[]
    OR?: agtAgentTypesScalarWhereWithAggregatesInput[]
    NOT?: agtAgentTypesScalarWhereWithAggregatesInput | agtAgentTypesScalarWhereWithAggregatesInput[]
    agentTypeID?: IntWithAggregatesFilter<"agtAgentTypes"> | number
    agentType?: StringNullableWithAggregatesFilter<"agtAgentTypes"> | string | null
  }

  export type agtAgentsWhereInput = {
    AND?: agtAgentsWhereInput | agtAgentsWhereInput[]
    OR?: agtAgentsWhereInput[]
    NOT?: agtAgentsWhereInput | agtAgentsWhereInput[]
    agentID?: IntFilter<"agtAgents"> | number
    divisionID?: IntNullableFilter<"agtAgents"> | number | null
    corporationID?: IntNullableFilter<"agtAgents"> | number | null
    locationID?: IntNullableFilter<"agtAgents"> | number | null
    level?: IntNullableFilter<"agtAgents"> | number | null
    quality?: IntNullableFilter<"agtAgents"> | number | null
    agentTypeID?: IntNullableFilter<"agtAgents"> | number | null
    isLocator?: BoolNullableFilter<"agtAgents"> | boolean | null
  }

  export type agtAgentsOrderByWithRelationInput = {
    agentID?: SortOrder
    divisionID?: SortOrderInput | SortOrder
    corporationID?: SortOrderInput | SortOrder
    locationID?: SortOrderInput | SortOrder
    level?: SortOrderInput | SortOrder
    quality?: SortOrderInput | SortOrder
    agentTypeID?: SortOrderInput | SortOrder
    isLocator?: SortOrderInput | SortOrder
  }

  export type agtAgentsWhereUniqueInput = Prisma.AtLeast<{
    agentID?: number
    AND?: agtAgentsWhereInput | agtAgentsWhereInput[]
    OR?: agtAgentsWhereInput[]
    NOT?: agtAgentsWhereInput | agtAgentsWhereInput[]
    divisionID?: IntNullableFilter<"agtAgents"> | number | null
    corporationID?: IntNullableFilter<"agtAgents"> | number | null
    locationID?: IntNullableFilter<"agtAgents"> | number | null
    level?: IntNullableFilter<"agtAgents"> | number | null
    quality?: IntNullableFilter<"agtAgents"> | number | null
    agentTypeID?: IntNullableFilter<"agtAgents"> | number | null
    isLocator?: BoolNullableFilter<"agtAgents"> | boolean | null
  }, "agentID">

  export type agtAgentsOrderByWithAggregationInput = {
    agentID?: SortOrder
    divisionID?: SortOrderInput | SortOrder
    corporationID?: SortOrderInput | SortOrder
    locationID?: SortOrderInput | SortOrder
    level?: SortOrderInput | SortOrder
    quality?: SortOrderInput | SortOrder
    agentTypeID?: SortOrderInput | SortOrder
    isLocator?: SortOrderInput | SortOrder
    _count?: agtAgentsCountOrderByAggregateInput
    _avg?: agtAgentsAvgOrderByAggregateInput
    _max?: agtAgentsMaxOrderByAggregateInput
    _min?: agtAgentsMinOrderByAggregateInput
    _sum?: agtAgentsSumOrderByAggregateInput
  }

  export type agtAgentsScalarWhereWithAggregatesInput = {
    AND?: agtAgentsScalarWhereWithAggregatesInput | agtAgentsScalarWhereWithAggregatesInput[]
    OR?: agtAgentsScalarWhereWithAggregatesInput[]
    NOT?: agtAgentsScalarWhereWithAggregatesInput | agtAgentsScalarWhereWithAggregatesInput[]
    agentID?: IntWithAggregatesFilter<"agtAgents"> | number
    divisionID?: IntNullableWithAggregatesFilter<"agtAgents"> | number | null
    corporationID?: IntNullableWithAggregatesFilter<"agtAgents"> | number | null
    locationID?: IntNullableWithAggregatesFilter<"agtAgents"> | number | null
    level?: IntNullableWithAggregatesFilter<"agtAgents"> | number | null
    quality?: IntNullableWithAggregatesFilter<"agtAgents"> | number | null
    agentTypeID?: IntNullableWithAggregatesFilter<"agtAgents"> | number | null
    isLocator?: BoolNullableWithAggregatesFilter<"agtAgents"> | boolean | null
  }

  export type agtAgentsInSpaceWhereInput = {
    AND?: agtAgentsInSpaceWhereInput | agtAgentsInSpaceWhereInput[]
    OR?: agtAgentsInSpaceWhereInput[]
    NOT?: agtAgentsInSpaceWhereInput | agtAgentsInSpaceWhereInput[]
    agentID?: IntFilter<"agtAgentsInSpace"> | number
    dungeonID?: IntNullableFilter<"agtAgentsInSpace"> | number | null
    solarSystemID?: IntNullableFilter<"agtAgentsInSpace"> | number | null
    spawnPointID?: IntNullableFilter<"agtAgentsInSpace"> | number | null
    typeID?: IntNullableFilter<"agtAgentsInSpace"> | number | null
  }

  export type agtAgentsInSpaceOrderByWithRelationInput = {
    agentID?: SortOrder
    dungeonID?: SortOrderInput | SortOrder
    solarSystemID?: SortOrderInput | SortOrder
    spawnPointID?: SortOrderInput | SortOrder
    typeID?: SortOrderInput | SortOrder
  }

  export type agtAgentsInSpaceWhereUniqueInput = Prisma.AtLeast<{
    agentID?: number
    AND?: agtAgentsInSpaceWhereInput | agtAgentsInSpaceWhereInput[]
    OR?: agtAgentsInSpaceWhereInput[]
    NOT?: agtAgentsInSpaceWhereInput | agtAgentsInSpaceWhereInput[]
    dungeonID?: IntNullableFilter<"agtAgentsInSpace"> | number | null
    solarSystemID?: IntNullableFilter<"agtAgentsInSpace"> | number | null
    spawnPointID?: IntNullableFilter<"agtAgentsInSpace"> | number | null
    typeID?: IntNullableFilter<"agtAgentsInSpace"> | number | null
  }, "agentID">

  export type agtAgentsInSpaceOrderByWithAggregationInput = {
    agentID?: SortOrder
    dungeonID?: SortOrderInput | SortOrder
    solarSystemID?: SortOrderInput | SortOrder
    spawnPointID?: SortOrderInput | SortOrder
    typeID?: SortOrderInput | SortOrder
    _count?: agtAgentsInSpaceCountOrderByAggregateInput
    _avg?: agtAgentsInSpaceAvgOrderByAggregateInput
    _max?: agtAgentsInSpaceMaxOrderByAggregateInput
    _min?: agtAgentsInSpaceMinOrderByAggregateInput
    _sum?: agtAgentsInSpaceSumOrderByAggregateInput
  }

  export type agtAgentsInSpaceScalarWhereWithAggregatesInput = {
    AND?: agtAgentsInSpaceScalarWhereWithAggregatesInput | agtAgentsInSpaceScalarWhereWithAggregatesInput[]
    OR?: agtAgentsInSpaceScalarWhereWithAggregatesInput[]
    NOT?: agtAgentsInSpaceScalarWhereWithAggregatesInput | agtAgentsInSpaceScalarWhereWithAggregatesInput[]
    agentID?: IntWithAggregatesFilter<"agtAgentsInSpace"> | number
    dungeonID?: IntNullableWithAggregatesFilter<"agtAgentsInSpace"> | number | null
    solarSystemID?: IntNullableWithAggregatesFilter<"agtAgentsInSpace"> | number | null
    spawnPointID?: IntNullableWithAggregatesFilter<"agtAgentsInSpace"> | number | null
    typeID?: IntNullableWithAggregatesFilter<"agtAgentsInSpace"> | number | null
  }

  export type agtResearchAgentsWhereInput = {
    AND?: agtResearchAgentsWhereInput | agtResearchAgentsWhereInput[]
    OR?: agtResearchAgentsWhereInput[]
    NOT?: agtResearchAgentsWhereInput | agtResearchAgentsWhereInput[]
    agentID?: IntFilter<"agtResearchAgents"> | number
    typeID?: IntFilter<"agtResearchAgents"> | number
  }

  export type agtResearchAgentsOrderByWithRelationInput = {
    agentID?: SortOrder
    typeID?: SortOrder
  }

  export type agtResearchAgentsWhereUniqueInput = Prisma.AtLeast<{
    agentID_typeID?: agtResearchAgentsAgentIDTypeIDCompoundUniqueInput
    AND?: agtResearchAgentsWhereInput | agtResearchAgentsWhereInput[]
    OR?: agtResearchAgentsWhereInput[]
    NOT?: agtResearchAgentsWhereInput | agtResearchAgentsWhereInput[]
    agentID?: IntFilter<"agtResearchAgents"> | number
    typeID?: IntFilter<"agtResearchAgents"> | number
  }, "agentID_typeID">

  export type agtResearchAgentsOrderByWithAggregationInput = {
    agentID?: SortOrder
    typeID?: SortOrder
    _count?: agtResearchAgentsCountOrderByAggregateInput
    _avg?: agtResearchAgentsAvgOrderByAggregateInput
    _max?: agtResearchAgentsMaxOrderByAggregateInput
    _min?: agtResearchAgentsMinOrderByAggregateInput
    _sum?: agtResearchAgentsSumOrderByAggregateInput
  }

  export type agtResearchAgentsScalarWhereWithAggregatesInput = {
    AND?: agtResearchAgentsScalarWhereWithAggregatesInput | agtResearchAgentsScalarWhereWithAggregatesInput[]
    OR?: agtResearchAgentsScalarWhereWithAggregatesInput[]
    NOT?: agtResearchAgentsScalarWhereWithAggregatesInput | agtResearchAgentsScalarWhereWithAggregatesInput[]
    agentID?: IntWithAggregatesFilter<"agtResearchAgents"> | number
    typeID?: IntWithAggregatesFilter<"agtResearchAgents"> | number
  }

  export type certCertsWhereInput = {
    AND?: certCertsWhereInput | certCertsWhereInput[]
    OR?: certCertsWhereInput[]
    NOT?: certCertsWhereInput | certCertsWhereInput[]
    certID?: IntFilter<"certCerts"> | number
    description?: StringNullableFilter<"certCerts"> | string | null
    groupID?: IntNullableFilter<"certCerts"> | number | null
    name?: StringNullableFilter<"certCerts"> | string | null
  }

  export type certCertsOrderByWithRelationInput = {
    certID?: SortOrder
    description?: SortOrderInput | SortOrder
    groupID?: SortOrderInput | SortOrder
    name?: SortOrderInput | SortOrder
  }

  export type certCertsWhereUniqueInput = Prisma.AtLeast<{
    certID?: number
    AND?: certCertsWhereInput | certCertsWhereInput[]
    OR?: certCertsWhereInput[]
    NOT?: certCertsWhereInput | certCertsWhereInput[]
    description?: StringNullableFilter<"certCerts"> | string | null
    groupID?: IntNullableFilter<"certCerts"> | number | null
    name?: StringNullableFilter<"certCerts"> | string | null
  }, "certID">

  export type certCertsOrderByWithAggregationInput = {
    certID?: SortOrder
    description?: SortOrderInput | SortOrder
    groupID?: SortOrderInput | SortOrder
    name?: SortOrderInput | SortOrder
    _count?: certCertsCountOrderByAggregateInput
    _avg?: certCertsAvgOrderByAggregateInput
    _max?: certCertsMaxOrderByAggregateInput
    _min?: certCertsMinOrderByAggregateInput
    _sum?: certCertsSumOrderByAggregateInput
  }

  export type certCertsScalarWhereWithAggregatesInput = {
    AND?: certCertsScalarWhereWithAggregatesInput | certCertsScalarWhereWithAggregatesInput[]
    OR?: certCertsScalarWhereWithAggregatesInput[]
    NOT?: certCertsScalarWhereWithAggregatesInput | certCertsScalarWhereWithAggregatesInput[]
    certID?: IntWithAggregatesFilter<"certCerts"> | number
    description?: StringNullableWithAggregatesFilter<"certCerts"> | string | null
    groupID?: IntNullableWithAggregatesFilter<"certCerts"> | number | null
    name?: StringNullableWithAggregatesFilter<"certCerts"> | string | null
  }

  export type chrAncestriesWhereInput = {
    AND?: chrAncestriesWhereInput | chrAncestriesWhereInput[]
    OR?: chrAncestriesWhereInput[]
    NOT?: chrAncestriesWhereInput | chrAncestriesWhereInput[]
    ancestryID?: IntFilter<"chrAncestries"> | number
    ancestryName?: StringNullableFilter<"chrAncestries"> | string | null
    bloodlineID?: IntNullableFilter<"chrAncestries"> | number | null
    description?: StringNullableFilter<"chrAncestries"> | string | null
    perception?: IntNullableFilter<"chrAncestries"> | number | null
    willpower?: IntNullableFilter<"chrAncestries"> | number | null
    charisma?: IntNullableFilter<"chrAncestries"> | number | null
    memory?: IntNullableFilter<"chrAncestries"> | number | null
    intelligence?: IntNullableFilter<"chrAncestries"> | number | null
    iconID?: IntNullableFilter<"chrAncestries"> | number | null
    shortDescription?: StringNullableFilter<"chrAncestries"> | string | null
  }

  export type chrAncestriesOrderByWithRelationInput = {
    ancestryID?: SortOrder
    ancestryName?: SortOrderInput | SortOrder
    bloodlineID?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    perception?: SortOrderInput | SortOrder
    willpower?: SortOrderInput | SortOrder
    charisma?: SortOrderInput | SortOrder
    memory?: SortOrderInput | SortOrder
    intelligence?: SortOrderInput | SortOrder
    iconID?: SortOrderInput | SortOrder
    shortDescription?: SortOrderInput | SortOrder
  }

  export type chrAncestriesWhereUniqueInput = Prisma.AtLeast<{
    ancestryID?: number
    AND?: chrAncestriesWhereInput | chrAncestriesWhereInput[]
    OR?: chrAncestriesWhereInput[]
    NOT?: chrAncestriesWhereInput | chrAncestriesWhereInput[]
    ancestryName?: StringNullableFilter<"chrAncestries"> | string | null
    bloodlineID?: IntNullableFilter<"chrAncestries"> | number | null
    description?: StringNullableFilter<"chrAncestries"> | string | null
    perception?: IntNullableFilter<"chrAncestries"> | number | null
    willpower?: IntNullableFilter<"chrAncestries"> | number | null
    charisma?: IntNullableFilter<"chrAncestries"> | number | null
    memory?: IntNullableFilter<"chrAncestries"> | number | null
    intelligence?: IntNullableFilter<"chrAncestries"> | number | null
    iconID?: IntNullableFilter<"chrAncestries"> | number | null
    shortDescription?: StringNullableFilter<"chrAncestries"> | string | null
  }, "ancestryID">

  export type chrAncestriesOrderByWithAggregationInput = {
    ancestryID?: SortOrder
    ancestryName?: SortOrderInput | SortOrder
    bloodlineID?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    perception?: SortOrderInput | SortOrder
    willpower?: SortOrderInput | SortOrder
    charisma?: SortOrderInput | SortOrder
    memory?: SortOrderInput | SortOrder
    intelligence?: SortOrderInput | SortOrder
    iconID?: SortOrderInput | SortOrder
    shortDescription?: SortOrderInput | SortOrder
    _count?: chrAncestriesCountOrderByAggregateInput
    _avg?: chrAncestriesAvgOrderByAggregateInput
    _max?: chrAncestriesMaxOrderByAggregateInput
    _min?: chrAncestriesMinOrderByAggregateInput
    _sum?: chrAncestriesSumOrderByAggregateInput
  }

  export type chrAncestriesScalarWhereWithAggregatesInput = {
    AND?: chrAncestriesScalarWhereWithAggregatesInput | chrAncestriesScalarWhereWithAggregatesInput[]
    OR?: chrAncestriesScalarWhereWithAggregatesInput[]
    NOT?: chrAncestriesScalarWhereWithAggregatesInput | chrAncestriesScalarWhereWithAggregatesInput[]
    ancestryID?: IntWithAggregatesFilter<"chrAncestries"> | number
    ancestryName?: StringNullableWithAggregatesFilter<"chrAncestries"> | string | null
    bloodlineID?: IntNullableWithAggregatesFilter<"chrAncestries"> | number | null
    description?: StringNullableWithAggregatesFilter<"chrAncestries"> | string | null
    perception?: IntNullableWithAggregatesFilter<"chrAncestries"> | number | null
    willpower?: IntNullableWithAggregatesFilter<"chrAncestries"> | number | null
    charisma?: IntNullableWithAggregatesFilter<"chrAncestries"> | number | null
    memory?: IntNullableWithAggregatesFilter<"chrAncestries"> | number | null
    intelligence?: IntNullableWithAggregatesFilter<"chrAncestries"> | number | null
    iconID?: IntNullableWithAggregatesFilter<"chrAncestries"> | number | null
    shortDescription?: StringNullableWithAggregatesFilter<"chrAncestries"> | string | null
  }

  export type chrAttributesWhereInput = {
    AND?: chrAttributesWhereInput | chrAttributesWhereInput[]
    OR?: chrAttributesWhereInput[]
    NOT?: chrAttributesWhereInput | chrAttributesWhereInput[]
    attributeID?: IntFilter<"chrAttributes"> | number
    attributeName?: StringNullableFilter<"chrAttributes"> | string | null
    description?: StringNullableFilter<"chrAttributes"> | string | null
    iconID?: IntNullableFilter<"chrAttributes"> | number | null
    shortDescription?: StringNullableFilter<"chrAttributes"> | string | null
    notes?: StringNullableFilter<"chrAttributes"> | string | null
  }

  export type chrAttributesOrderByWithRelationInput = {
    attributeID?: SortOrder
    attributeName?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    iconID?: SortOrderInput | SortOrder
    shortDescription?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
  }

  export type chrAttributesWhereUniqueInput = Prisma.AtLeast<{
    attributeID?: number
    AND?: chrAttributesWhereInput | chrAttributesWhereInput[]
    OR?: chrAttributesWhereInput[]
    NOT?: chrAttributesWhereInput | chrAttributesWhereInput[]
    attributeName?: StringNullableFilter<"chrAttributes"> | string | null
    description?: StringNullableFilter<"chrAttributes"> | string | null
    iconID?: IntNullableFilter<"chrAttributes"> | number | null
    shortDescription?: StringNullableFilter<"chrAttributes"> | string | null
    notes?: StringNullableFilter<"chrAttributes"> | string | null
  }, "attributeID">

  export type chrAttributesOrderByWithAggregationInput = {
    attributeID?: SortOrder
    attributeName?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    iconID?: SortOrderInput | SortOrder
    shortDescription?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    _count?: chrAttributesCountOrderByAggregateInput
    _avg?: chrAttributesAvgOrderByAggregateInput
    _max?: chrAttributesMaxOrderByAggregateInput
    _min?: chrAttributesMinOrderByAggregateInput
    _sum?: chrAttributesSumOrderByAggregateInput
  }

  export type chrAttributesScalarWhereWithAggregatesInput = {
    AND?: chrAttributesScalarWhereWithAggregatesInput | chrAttributesScalarWhereWithAggregatesInput[]
    OR?: chrAttributesScalarWhereWithAggregatesInput[]
    NOT?: chrAttributesScalarWhereWithAggregatesInput | chrAttributesScalarWhereWithAggregatesInput[]
    attributeID?: IntWithAggregatesFilter<"chrAttributes"> | number
    attributeName?: StringNullableWithAggregatesFilter<"chrAttributes"> | string | null
    description?: StringNullableWithAggregatesFilter<"chrAttributes"> | string | null
    iconID?: IntNullableWithAggregatesFilter<"chrAttributes"> | number | null
    shortDescription?: StringNullableWithAggregatesFilter<"chrAttributes"> | string | null
    notes?: StringNullableWithAggregatesFilter<"chrAttributes"> | string | null
  }

  export type chrBloodlinesWhereInput = {
    AND?: chrBloodlinesWhereInput | chrBloodlinesWhereInput[]
    OR?: chrBloodlinesWhereInput[]
    NOT?: chrBloodlinesWhereInput | chrBloodlinesWhereInput[]
    bloodlineID?: IntFilter<"chrBloodlines"> | number
    bloodlineName?: StringNullableFilter<"chrBloodlines"> | string | null
    raceID?: IntNullableFilter<"chrBloodlines"> | number | null
    description?: StringNullableFilter<"chrBloodlines"> | string | null
    maleDescription?: StringNullableFilter<"chrBloodlines"> | string | null
    femaleDescription?: StringNullableFilter<"chrBloodlines"> | string | null
    shipTypeID?: IntNullableFilter<"chrBloodlines"> | number | null
    corporationID?: IntNullableFilter<"chrBloodlines"> | number | null
    perception?: IntNullableFilter<"chrBloodlines"> | number | null
    willpower?: IntNullableFilter<"chrBloodlines"> | number | null
    charisma?: IntNullableFilter<"chrBloodlines"> | number | null
    memory?: IntNullableFilter<"chrBloodlines"> | number | null
    intelligence?: IntNullableFilter<"chrBloodlines"> | number | null
    iconID?: IntNullableFilter<"chrBloodlines"> | number | null
    shortDescription?: StringNullableFilter<"chrBloodlines"> | string | null
    shortMaleDescription?: StringNullableFilter<"chrBloodlines"> | string | null
    shortFemaleDescription?: StringNullableFilter<"chrBloodlines"> | string | null
  }

  export type chrBloodlinesOrderByWithRelationInput = {
    bloodlineID?: SortOrder
    bloodlineName?: SortOrderInput | SortOrder
    raceID?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    maleDescription?: SortOrderInput | SortOrder
    femaleDescription?: SortOrderInput | SortOrder
    shipTypeID?: SortOrderInput | SortOrder
    corporationID?: SortOrderInput | SortOrder
    perception?: SortOrderInput | SortOrder
    willpower?: SortOrderInput | SortOrder
    charisma?: SortOrderInput | SortOrder
    memory?: SortOrderInput | SortOrder
    intelligence?: SortOrderInput | SortOrder
    iconID?: SortOrderInput | SortOrder
    shortDescription?: SortOrderInput | SortOrder
    shortMaleDescription?: SortOrderInput | SortOrder
    shortFemaleDescription?: SortOrderInput | SortOrder
  }

  export type chrBloodlinesWhereUniqueInput = Prisma.AtLeast<{
    bloodlineID?: number
    AND?: chrBloodlinesWhereInput | chrBloodlinesWhereInput[]
    OR?: chrBloodlinesWhereInput[]
    NOT?: chrBloodlinesWhereInput | chrBloodlinesWhereInput[]
    bloodlineName?: StringNullableFilter<"chrBloodlines"> | string | null
    raceID?: IntNullableFilter<"chrBloodlines"> | number | null
    description?: StringNullableFilter<"chrBloodlines"> | string | null
    maleDescription?: StringNullableFilter<"chrBloodlines"> | string | null
    femaleDescription?: StringNullableFilter<"chrBloodlines"> | string | null
    shipTypeID?: IntNullableFilter<"chrBloodlines"> | number | null
    corporationID?: IntNullableFilter<"chrBloodlines"> | number | null
    perception?: IntNullableFilter<"chrBloodlines"> | number | null
    willpower?: IntNullableFilter<"chrBloodlines"> | number | null
    charisma?: IntNullableFilter<"chrBloodlines"> | number | null
    memory?: IntNullableFilter<"chrBloodlines"> | number | null
    intelligence?: IntNullableFilter<"chrBloodlines"> | number | null
    iconID?: IntNullableFilter<"chrBloodlines"> | number | null
    shortDescription?: StringNullableFilter<"chrBloodlines"> | string | null
    shortMaleDescription?: StringNullableFilter<"chrBloodlines"> | string | null
    shortFemaleDescription?: StringNullableFilter<"chrBloodlines"> | string | null
  }, "bloodlineID">

  export type chrBloodlinesOrderByWithAggregationInput = {
    bloodlineID?: SortOrder
    bloodlineName?: SortOrderInput | SortOrder
    raceID?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    maleDescription?: SortOrderInput | SortOrder
    femaleDescription?: SortOrderInput | SortOrder
    shipTypeID?: SortOrderInput | SortOrder
    corporationID?: SortOrderInput | SortOrder
    perception?: SortOrderInput | SortOrder
    willpower?: SortOrderInput | SortOrder
    charisma?: SortOrderInput | SortOrder
    memory?: SortOrderInput | SortOrder
    intelligence?: SortOrderInput | SortOrder
    iconID?: SortOrderInput | SortOrder
    shortDescription?: SortOrderInput | SortOrder
    shortMaleDescription?: SortOrderInput | SortOrder
    shortFemaleDescription?: SortOrderInput | SortOrder
    _count?: chrBloodlinesCountOrderByAggregateInput
    _avg?: chrBloodlinesAvgOrderByAggregateInput
    _max?: chrBloodlinesMaxOrderByAggregateInput
    _min?: chrBloodlinesMinOrderByAggregateInput
    _sum?: chrBloodlinesSumOrderByAggregateInput
  }

  export type chrBloodlinesScalarWhereWithAggregatesInput = {
    AND?: chrBloodlinesScalarWhereWithAggregatesInput | chrBloodlinesScalarWhereWithAggregatesInput[]
    OR?: chrBloodlinesScalarWhereWithAggregatesInput[]
    NOT?: chrBloodlinesScalarWhereWithAggregatesInput | chrBloodlinesScalarWhereWithAggregatesInput[]
    bloodlineID?: IntWithAggregatesFilter<"chrBloodlines"> | number
    bloodlineName?: StringNullableWithAggregatesFilter<"chrBloodlines"> | string | null
    raceID?: IntNullableWithAggregatesFilter<"chrBloodlines"> | number | null
    description?: StringNullableWithAggregatesFilter<"chrBloodlines"> | string | null
    maleDescription?: StringNullableWithAggregatesFilter<"chrBloodlines"> | string | null
    femaleDescription?: StringNullableWithAggregatesFilter<"chrBloodlines"> | string | null
    shipTypeID?: IntNullableWithAggregatesFilter<"chrBloodlines"> | number | null
    corporationID?: IntNullableWithAggregatesFilter<"chrBloodlines"> | number | null
    perception?: IntNullableWithAggregatesFilter<"chrBloodlines"> | number | null
    willpower?: IntNullableWithAggregatesFilter<"chrBloodlines"> | number | null
    charisma?: IntNullableWithAggregatesFilter<"chrBloodlines"> | number | null
    memory?: IntNullableWithAggregatesFilter<"chrBloodlines"> | number | null
    intelligence?: IntNullableWithAggregatesFilter<"chrBloodlines"> | number | null
    iconID?: IntNullableWithAggregatesFilter<"chrBloodlines"> | number | null
    shortDescription?: StringNullableWithAggregatesFilter<"chrBloodlines"> | string | null
    shortMaleDescription?: StringNullableWithAggregatesFilter<"chrBloodlines"> | string | null
    shortFemaleDescription?: StringNullableWithAggregatesFilter<"chrBloodlines"> | string | null
  }

  export type chrFactionsWhereInput = {
    AND?: chrFactionsWhereInput | chrFactionsWhereInput[]
    OR?: chrFactionsWhereInput[]
    NOT?: chrFactionsWhereInput | chrFactionsWhereInput[]
    factionID?: IntFilter<"chrFactions"> | number
    factionName?: StringNullableFilter<"chrFactions"> | string | null
    description?: StringNullableFilter<"chrFactions"> | string | null
    raceIDs?: IntNullableFilter<"chrFactions"> | number | null
    solarSystemID?: IntNullableFilter<"chrFactions"> | number | null
    corporationID?: IntNullableFilter<"chrFactions"> | number | null
    sizeFactor?: FloatNullableFilter<"chrFactions"> | number | null
    stationCount?: IntNullableFilter<"chrFactions"> | number | null
    stationSystemCount?: IntNullableFilter<"chrFactions"> | number | null
    militiaCorporationID?: IntNullableFilter<"chrFactions"> | number | null
    iconID?: IntNullableFilter<"chrFactions"> | number | null
  }

  export type chrFactionsOrderByWithRelationInput = {
    factionID?: SortOrder
    factionName?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    raceIDs?: SortOrderInput | SortOrder
    solarSystemID?: SortOrderInput | SortOrder
    corporationID?: SortOrderInput | SortOrder
    sizeFactor?: SortOrderInput | SortOrder
    stationCount?: SortOrderInput | SortOrder
    stationSystemCount?: SortOrderInput | SortOrder
    militiaCorporationID?: SortOrderInput | SortOrder
    iconID?: SortOrderInput | SortOrder
  }

  export type chrFactionsWhereUniqueInput = Prisma.AtLeast<{
    factionID?: number
    AND?: chrFactionsWhereInput | chrFactionsWhereInput[]
    OR?: chrFactionsWhereInput[]
    NOT?: chrFactionsWhereInput | chrFactionsWhereInput[]
    factionName?: StringNullableFilter<"chrFactions"> | string | null
    description?: StringNullableFilter<"chrFactions"> | string | null
    raceIDs?: IntNullableFilter<"chrFactions"> | number | null
    solarSystemID?: IntNullableFilter<"chrFactions"> | number | null
    corporationID?: IntNullableFilter<"chrFactions"> | number | null
    sizeFactor?: FloatNullableFilter<"chrFactions"> | number | null
    stationCount?: IntNullableFilter<"chrFactions"> | number | null
    stationSystemCount?: IntNullableFilter<"chrFactions"> | number | null
    militiaCorporationID?: IntNullableFilter<"chrFactions"> | number | null
    iconID?: IntNullableFilter<"chrFactions"> | number | null
  }, "factionID">

  export type chrFactionsOrderByWithAggregationInput = {
    factionID?: SortOrder
    factionName?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    raceIDs?: SortOrderInput | SortOrder
    solarSystemID?: SortOrderInput | SortOrder
    corporationID?: SortOrderInput | SortOrder
    sizeFactor?: SortOrderInput | SortOrder
    stationCount?: SortOrderInput | SortOrder
    stationSystemCount?: SortOrderInput | SortOrder
    militiaCorporationID?: SortOrderInput | SortOrder
    iconID?: SortOrderInput | SortOrder
    _count?: chrFactionsCountOrderByAggregateInput
    _avg?: chrFactionsAvgOrderByAggregateInput
    _max?: chrFactionsMaxOrderByAggregateInput
    _min?: chrFactionsMinOrderByAggregateInput
    _sum?: chrFactionsSumOrderByAggregateInput
  }

  export type chrFactionsScalarWhereWithAggregatesInput = {
    AND?: chrFactionsScalarWhereWithAggregatesInput | chrFactionsScalarWhereWithAggregatesInput[]
    OR?: chrFactionsScalarWhereWithAggregatesInput[]
    NOT?: chrFactionsScalarWhereWithAggregatesInput | chrFactionsScalarWhereWithAggregatesInput[]
    factionID?: IntWithAggregatesFilter<"chrFactions"> | number
    factionName?: StringNullableWithAggregatesFilter<"chrFactions"> | string | null
    description?: StringNullableWithAggregatesFilter<"chrFactions"> | string | null
    raceIDs?: IntNullableWithAggregatesFilter<"chrFactions"> | number | null
    solarSystemID?: IntNullableWithAggregatesFilter<"chrFactions"> | number | null
    corporationID?: IntNullableWithAggregatesFilter<"chrFactions"> | number | null
    sizeFactor?: FloatNullableWithAggregatesFilter<"chrFactions"> | number | null
    stationCount?: IntNullableWithAggregatesFilter<"chrFactions"> | number | null
    stationSystemCount?: IntNullableWithAggregatesFilter<"chrFactions"> | number | null
    militiaCorporationID?: IntNullableWithAggregatesFilter<"chrFactions"> | number | null
    iconID?: IntNullableWithAggregatesFilter<"chrFactions"> | number | null
  }

  export type chrRacesWhereInput = {
    AND?: chrRacesWhereInput | chrRacesWhereInput[]
    OR?: chrRacesWhereInput[]
    NOT?: chrRacesWhereInput | chrRacesWhereInput[]
    raceID?: IntFilter<"chrRaces"> | number
    raceName?: StringNullableFilter<"chrRaces"> | string | null
    description?: StringNullableFilter<"chrRaces"> | string | null
    iconID?: IntNullableFilter<"chrRaces"> | number | null
    shortDescription?: StringNullableFilter<"chrRaces"> | string | null
  }

  export type chrRacesOrderByWithRelationInput = {
    raceID?: SortOrder
    raceName?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    iconID?: SortOrderInput | SortOrder
    shortDescription?: SortOrderInput | SortOrder
  }

  export type chrRacesWhereUniqueInput = Prisma.AtLeast<{
    raceID?: number
    AND?: chrRacesWhereInput | chrRacesWhereInput[]
    OR?: chrRacesWhereInput[]
    NOT?: chrRacesWhereInput | chrRacesWhereInput[]
    raceName?: StringNullableFilter<"chrRaces"> | string | null
    description?: StringNullableFilter<"chrRaces"> | string | null
    iconID?: IntNullableFilter<"chrRaces"> | number | null
    shortDescription?: StringNullableFilter<"chrRaces"> | string | null
  }, "raceID">

  export type chrRacesOrderByWithAggregationInput = {
    raceID?: SortOrder
    raceName?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    iconID?: SortOrderInput | SortOrder
    shortDescription?: SortOrderInput | SortOrder
    _count?: chrRacesCountOrderByAggregateInput
    _avg?: chrRacesAvgOrderByAggregateInput
    _max?: chrRacesMaxOrderByAggregateInput
    _min?: chrRacesMinOrderByAggregateInput
    _sum?: chrRacesSumOrderByAggregateInput
  }

  export type chrRacesScalarWhereWithAggregatesInput = {
    AND?: chrRacesScalarWhereWithAggregatesInput | chrRacesScalarWhereWithAggregatesInput[]
    OR?: chrRacesScalarWhereWithAggregatesInput[]
    NOT?: chrRacesScalarWhereWithAggregatesInput | chrRacesScalarWhereWithAggregatesInput[]
    raceID?: IntWithAggregatesFilter<"chrRaces"> | number
    raceName?: StringNullableWithAggregatesFilter<"chrRaces"> | string | null
    description?: StringNullableWithAggregatesFilter<"chrRaces"> | string | null
    iconID?: IntNullableWithAggregatesFilter<"chrRaces"> | number | null
    shortDescription?: StringNullableWithAggregatesFilter<"chrRaces"> | string | null
  }

  export type crpActivitiesWhereInput = {
    AND?: crpActivitiesWhereInput | crpActivitiesWhereInput[]
    OR?: crpActivitiesWhereInput[]
    NOT?: crpActivitiesWhereInput | crpActivitiesWhereInput[]
    activityID?: IntFilter<"crpActivities"> | number
    activityName?: StringNullableFilter<"crpActivities"> | string | null
    description?: StringNullableFilter<"crpActivities"> | string | null
  }

  export type crpActivitiesOrderByWithRelationInput = {
    activityID?: SortOrder
    activityName?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
  }

  export type crpActivitiesWhereUniqueInput = Prisma.AtLeast<{
    activityID?: number
    AND?: crpActivitiesWhereInput | crpActivitiesWhereInput[]
    OR?: crpActivitiesWhereInput[]
    NOT?: crpActivitiesWhereInput | crpActivitiesWhereInput[]
    activityName?: StringNullableFilter<"crpActivities"> | string | null
    description?: StringNullableFilter<"crpActivities"> | string | null
  }, "activityID">

  export type crpActivitiesOrderByWithAggregationInput = {
    activityID?: SortOrder
    activityName?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    _count?: crpActivitiesCountOrderByAggregateInput
    _avg?: crpActivitiesAvgOrderByAggregateInput
    _max?: crpActivitiesMaxOrderByAggregateInput
    _min?: crpActivitiesMinOrderByAggregateInput
    _sum?: crpActivitiesSumOrderByAggregateInput
  }

  export type crpActivitiesScalarWhereWithAggregatesInput = {
    AND?: crpActivitiesScalarWhereWithAggregatesInput | crpActivitiesScalarWhereWithAggregatesInput[]
    OR?: crpActivitiesScalarWhereWithAggregatesInput[]
    NOT?: crpActivitiesScalarWhereWithAggregatesInput | crpActivitiesScalarWhereWithAggregatesInput[]
    activityID?: IntWithAggregatesFilter<"crpActivities"> | number
    activityName?: StringNullableWithAggregatesFilter<"crpActivities"> | string | null
    description?: StringNullableWithAggregatesFilter<"crpActivities"> | string | null
  }

  export type crpNPCCorporationDivisionsWhereInput = {
    AND?: crpNPCCorporationDivisionsWhereInput | crpNPCCorporationDivisionsWhereInput[]
    OR?: crpNPCCorporationDivisionsWhereInput[]
    NOT?: crpNPCCorporationDivisionsWhereInput | crpNPCCorporationDivisionsWhereInput[]
    corporationID?: IntFilter<"crpNPCCorporationDivisions"> | number
    divisionID?: IntFilter<"crpNPCCorporationDivisions"> | number
    size?: IntNullableFilter<"crpNPCCorporationDivisions"> | number | null
  }

  export type crpNPCCorporationDivisionsOrderByWithRelationInput = {
    corporationID?: SortOrder
    divisionID?: SortOrder
    size?: SortOrderInput | SortOrder
  }

  export type crpNPCCorporationDivisionsWhereUniqueInput = Prisma.AtLeast<{
    corporationID_divisionID?: crpNPCCorporationDivisionsCorporationIDDivisionIDCompoundUniqueInput
    AND?: crpNPCCorporationDivisionsWhereInput | crpNPCCorporationDivisionsWhereInput[]
    OR?: crpNPCCorporationDivisionsWhereInput[]
    NOT?: crpNPCCorporationDivisionsWhereInput | crpNPCCorporationDivisionsWhereInput[]
    corporationID?: IntFilter<"crpNPCCorporationDivisions"> | number
    divisionID?: IntFilter<"crpNPCCorporationDivisions"> | number
    size?: IntNullableFilter<"crpNPCCorporationDivisions"> | number | null
  }, "corporationID_divisionID">

  export type crpNPCCorporationDivisionsOrderByWithAggregationInput = {
    corporationID?: SortOrder
    divisionID?: SortOrder
    size?: SortOrderInput | SortOrder
    _count?: crpNPCCorporationDivisionsCountOrderByAggregateInput
    _avg?: crpNPCCorporationDivisionsAvgOrderByAggregateInput
    _max?: crpNPCCorporationDivisionsMaxOrderByAggregateInput
    _min?: crpNPCCorporationDivisionsMinOrderByAggregateInput
    _sum?: crpNPCCorporationDivisionsSumOrderByAggregateInput
  }

  export type crpNPCCorporationDivisionsScalarWhereWithAggregatesInput = {
    AND?: crpNPCCorporationDivisionsScalarWhereWithAggregatesInput | crpNPCCorporationDivisionsScalarWhereWithAggregatesInput[]
    OR?: crpNPCCorporationDivisionsScalarWhereWithAggregatesInput[]
    NOT?: crpNPCCorporationDivisionsScalarWhereWithAggregatesInput | crpNPCCorporationDivisionsScalarWhereWithAggregatesInput[]
    corporationID?: IntWithAggregatesFilter<"crpNPCCorporationDivisions"> | number
    divisionID?: IntWithAggregatesFilter<"crpNPCCorporationDivisions"> | number
    size?: IntNullableWithAggregatesFilter<"crpNPCCorporationDivisions"> | number | null
  }

  export type crpNPCCorporationResearchFieldsWhereInput = {
    AND?: crpNPCCorporationResearchFieldsWhereInput | crpNPCCorporationResearchFieldsWhereInput[]
    OR?: crpNPCCorporationResearchFieldsWhereInput[]
    NOT?: crpNPCCorporationResearchFieldsWhereInput | crpNPCCorporationResearchFieldsWhereInput[]
    skillID?: IntFilter<"crpNPCCorporationResearchFields"> | number
    corporationID?: IntFilter<"crpNPCCorporationResearchFields"> | number
  }

  export type crpNPCCorporationResearchFieldsOrderByWithRelationInput = {
    skillID?: SortOrder
    corporationID?: SortOrder
  }

  export type crpNPCCorporationResearchFieldsWhereUniqueInput = Prisma.AtLeast<{
    skillID_corporationID?: crpNPCCorporationResearchFieldsSkillIDCorporationIDCompoundUniqueInput
    AND?: crpNPCCorporationResearchFieldsWhereInput | crpNPCCorporationResearchFieldsWhereInput[]
    OR?: crpNPCCorporationResearchFieldsWhereInput[]
    NOT?: crpNPCCorporationResearchFieldsWhereInput | crpNPCCorporationResearchFieldsWhereInput[]
    skillID?: IntFilter<"crpNPCCorporationResearchFields"> | number
    corporationID?: IntFilter<"crpNPCCorporationResearchFields"> | number
  }, "skillID_corporationID">

  export type crpNPCCorporationResearchFieldsOrderByWithAggregationInput = {
    skillID?: SortOrder
    corporationID?: SortOrder
    _count?: crpNPCCorporationResearchFieldsCountOrderByAggregateInput
    _avg?: crpNPCCorporationResearchFieldsAvgOrderByAggregateInput
    _max?: crpNPCCorporationResearchFieldsMaxOrderByAggregateInput
    _min?: crpNPCCorporationResearchFieldsMinOrderByAggregateInput
    _sum?: crpNPCCorporationResearchFieldsSumOrderByAggregateInput
  }

  export type crpNPCCorporationResearchFieldsScalarWhereWithAggregatesInput = {
    AND?: crpNPCCorporationResearchFieldsScalarWhereWithAggregatesInput | crpNPCCorporationResearchFieldsScalarWhereWithAggregatesInput[]
    OR?: crpNPCCorporationResearchFieldsScalarWhereWithAggregatesInput[]
    NOT?: crpNPCCorporationResearchFieldsScalarWhereWithAggregatesInput | crpNPCCorporationResearchFieldsScalarWhereWithAggregatesInput[]
    skillID?: IntWithAggregatesFilter<"crpNPCCorporationResearchFields"> | number
    corporationID?: IntWithAggregatesFilter<"crpNPCCorporationResearchFields"> | number
  }

  export type crpNPCCorporationTradesWhereInput = {
    AND?: crpNPCCorporationTradesWhereInput | crpNPCCorporationTradesWhereInput[]
    OR?: crpNPCCorporationTradesWhereInput[]
    NOT?: crpNPCCorporationTradesWhereInput | crpNPCCorporationTradesWhereInput[]
    corporationID?: IntFilter<"crpNPCCorporationTrades"> | number
    typeID?: IntFilter<"crpNPCCorporationTrades"> | number
  }

  export type crpNPCCorporationTradesOrderByWithRelationInput = {
    corporationID?: SortOrder
    typeID?: SortOrder
  }

  export type crpNPCCorporationTradesWhereUniqueInput = Prisma.AtLeast<{
    corporationID_typeID?: crpNPCCorporationTradesCorporationIDTypeIDCompoundUniqueInput
    AND?: crpNPCCorporationTradesWhereInput | crpNPCCorporationTradesWhereInput[]
    OR?: crpNPCCorporationTradesWhereInput[]
    NOT?: crpNPCCorporationTradesWhereInput | crpNPCCorporationTradesWhereInput[]
    corporationID?: IntFilter<"crpNPCCorporationTrades"> | number
    typeID?: IntFilter<"crpNPCCorporationTrades"> | number
  }, "corporationID_typeID">

  export type crpNPCCorporationTradesOrderByWithAggregationInput = {
    corporationID?: SortOrder
    typeID?: SortOrder
    _count?: crpNPCCorporationTradesCountOrderByAggregateInput
    _avg?: crpNPCCorporationTradesAvgOrderByAggregateInput
    _max?: crpNPCCorporationTradesMaxOrderByAggregateInput
    _min?: crpNPCCorporationTradesMinOrderByAggregateInput
    _sum?: crpNPCCorporationTradesSumOrderByAggregateInput
  }

  export type crpNPCCorporationTradesScalarWhereWithAggregatesInput = {
    AND?: crpNPCCorporationTradesScalarWhereWithAggregatesInput | crpNPCCorporationTradesScalarWhereWithAggregatesInput[]
    OR?: crpNPCCorporationTradesScalarWhereWithAggregatesInput[]
    NOT?: crpNPCCorporationTradesScalarWhereWithAggregatesInput | crpNPCCorporationTradesScalarWhereWithAggregatesInput[]
    corporationID?: IntWithAggregatesFilter<"crpNPCCorporationTrades"> | number
    typeID?: IntWithAggregatesFilter<"crpNPCCorporationTrades"> | number
  }

  export type crpNPCCorporationsWhereInput = {
    AND?: crpNPCCorporationsWhereInput | crpNPCCorporationsWhereInput[]
    OR?: crpNPCCorporationsWhereInput[]
    NOT?: crpNPCCorporationsWhereInput | crpNPCCorporationsWhereInput[]
    corporationID?: IntFilter<"crpNPCCorporations"> | number
    size?: StringNullableFilter<"crpNPCCorporations"> | string | null
    extent?: StringNullableFilter<"crpNPCCorporations"> | string | null
    solarSystemID?: IntNullableFilter<"crpNPCCorporations"> | number | null
    investorID1?: IntNullableFilter<"crpNPCCorporations"> | number | null
    investorShares1?: IntNullableFilter<"crpNPCCorporations"> | number | null
    investorID2?: IntNullableFilter<"crpNPCCorporations"> | number | null
    investorShares2?: IntNullableFilter<"crpNPCCorporations"> | number | null
    investorID3?: IntNullableFilter<"crpNPCCorporations"> | number | null
    investorShares3?: IntNullableFilter<"crpNPCCorporations"> | number | null
    investorID4?: IntNullableFilter<"crpNPCCorporations"> | number | null
    investorShares4?: IntNullableFilter<"crpNPCCorporations"> | number | null
    friendID?: IntNullableFilter<"crpNPCCorporations"> | number | null
    enemyID?: IntNullableFilter<"crpNPCCorporations"> | number | null
    publicShares?: IntNullableFilter<"crpNPCCorporations"> | number | null
    initialPrice?: IntNullableFilter<"crpNPCCorporations"> | number | null
    minSecurity?: FloatNullableFilter<"crpNPCCorporations"> | number | null
    scattered?: BoolNullableFilter<"crpNPCCorporations"> | boolean | null
    fringe?: IntNullableFilter<"crpNPCCorporations"> | number | null
    corridor?: IntNullableFilter<"crpNPCCorporations"> | number | null
    hub?: IntNullableFilter<"crpNPCCorporations"> | number | null
    border?: IntNullableFilter<"crpNPCCorporations"> | number | null
    factionID?: IntNullableFilter<"crpNPCCorporations"> | number | null
    sizeFactor?: FloatNullableFilter<"crpNPCCorporations"> | number | null
    stationCount?: IntNullableFilter<"crpNPCCorporations"> | number | null
    stationSystemCount?: IntNullableFilter<"crpNPCCorporations"> | number | null
    description?: StringNullableFilter<"crpNPCCorporations"> | string | null
    iconID?: IntNullableFilter<"crpNPCCorporations"> | number | null
  }

  export type crpNPCCorporationsOrderByWithRelationInput = {
    corporationID?: SortOrder
    size?: SortOrderInput | SortOrder
    extent?: SortOrderInput | SortOrder
    solarSystemID?: SortOrderInput | SortOrder
    investorID1?: SortOrderInput | SortOrder
    investorShares1?: SortOrderInput | SortOrder
    investorID2?: SortOrderInput | SortOrder
    investorShares2?: SortOrderInput | SortOrder
    investorID3?: SortOrderInput | SortOrder
    investorShares3?: SortOrderInput | SortOrder
    investorID4?: SortOrderInput | SortOrder
    investorShares4?: SortOrderInput | SortOrder
    friendID?: SortOrderInput | SortOrder
    enemyID?: SortOrderInput | SortOrder
    publicShares?: SortOrderInput | SortOrder
    initialPrice?: SortOrderInput | SortOrder
    minSecurity?: SortOrderInput | SortOrder
    scattered?: SortOrderInput | SortOrder
    fringe?: SortOrderInput | SortOrder
    corridor?: SortOrderInput | SortOrder
    hub?: SortOrderInput | SortOrder
    border?: SortOrderInput | SortOrder
    factionID?: SortOrderInput | SortOrder
    sizeFactor?: SortOrderInput | SortOrder
    stationCount?: SortOrderInput | SortOrder
    stationSystemCount?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    iconID?: SortOrderInput | SortOrder
  }

  export type crpNPCCorporationsWhereUniqueInput = Prisma.AtLeast<{
    corporationID?: number
    AND?: crpNPCCorporationsWhereInput | crpNPCCorporationsWhereInput[]
    OR?: crpNPCCorporationsWhereInput[]
    NOT?: crpNPCCorporationsWhereInput | crpNPCCorporationsWhereInput[]
    size?: StringNullableFilter<"crpNPCCorporations"> | string | null
    extent?: StringNullableFilter<"crpNPCCorporations"> | string | null
    solarSystemID?: IntNullableFilter<"crpNPCCorporations"> | number | null
    investorID1?: IntNullableFilter<"crpNPCCorporations"> | number | null
    investorShares1?: IntNullableFilter<"crpNPCCorporations"> | number | null
    investorID2?: IntNullableFilter<"crpNPCCorporations"> | number | null
    investorShares2?: IntNullableFilter<"crpNPCCorporations"> | number | null
    investorID3?: IntNullableFilter<"crpNPCCorporations"> | number | null
    investorShares3?: IntNullableFilter<"crpNPCCorporations"> | number | null
    investorID4?: IntNullableFilter<"crpNPCCorporations"> | number | null
    investorShares4?: IntNullableFilter<"crpNPCCorporations"> | number | null
    friendID?: IntNullableFilter<"crpNPCCorporations"> | number | null
    enemyID?: IntNullableFilter<"crpNPCCorporations"> | number | null
    publicShares?: IntNullableFilter<"crpNPCCorporations"> | number | null
    initialPrice?: IntNullableFilter<"crpNPCCorporations"> | number | null
    minSecurity?: FloatNullableFilter<"crpNPCCorporations"> | number | null
    scattered?: BoolNullableFilter<"crpNPCCorporations"> | boolean | null
    fringe?: IntNullableFilter<"crpNPCCorporations"> | number | null
    corridor?: IntNullableFilter<"crpNPCCorporations"> | number | null
    hub?: IntNullableFilter<"crpNPCCorporations"> | number | null
    border?: IntNullableFilter<"crpNPCCorporations"> | number | null
    factionID?: IntNullableFilter<"crpNPCCorporations"> | number | null
    sizeFactor?: FloatNullableFilter<"crpNPCCorporations"> | number | null
    stationCount?: IntNullableFilter<"crpNPCCorporations"> | number | null
    stationSystemCount?: IntNullableFilter<"crpNPCCorporations"> | number | null
    description?: StringNullableFilter<"crpNPCCorporations"> | string | null
    iconID?: IntNullableFilter<"crpNPCCorporations"> | number | null
  }, "corporationID">

  export type crpNPCCorporationsOrderByWithAggregationInput = {
    corporationID?: SortOrder
    size?: SortOrderInput | SortOrder
    extent?: SortOrderInput | SortOrder
    solarSystemID?: SortOrderInput | SortOrder
    investorID1?: SortOrderInput | SortOrder
    investorShares1?: SortOrderInput | SortOrder
    investorID2?: SortOrderInput | SortOrder
    investorShares2?: SortOrderInput | SortOrder
    investorID3?: SortOrderInput | SortOrder
    investorShares3?: SortOrderInput | SortOrder
    investorID4?: SortOrderInput | SortOrder
    investorShares4?: SortOrderInput | SortOrder
    friendID?: SortOrderInput | SortOrder
    enemyID?: SortOrderInput | SortOrder
    publicShares?: SortOrderInput | SortOrder
    initialPrice?: SortOrderInput | SortOrder
    minSecurity?: SortOrderInput | SortOrder
    scattered?: SortOrderInput | SortOrder
    fringe?: SortOrderInput | SortOrder
    corridor?: SortOrderInput | SortOrder
    hub?: SortOrderInput | SortOrder
    border?: SortOrderInput | SortOrder
    factionID?: SortOrderInput | SortOrder
    sizeFactor?: SortOrderInput | SortOrder
    stationCount?: SortOrderInput | SortOrder
    stationSystemCount?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    iconID?: SortOrderInput | SortOrder
    _count?: crpNPCCorporationsCountOrderByAggregateInput
    _avg?: crpNPCCorporationsAvgOrderByAggregateInput
    _max?: crpNPCCorporationsMaxOrderByAggregateInput
    _min?: crpNPCCorporationsMinOrderByAggregateInput
    _sum?: crpNPCCorporationsSumOrderByAggregateInput
  }

  export type crpNPCCorporationsScalarWhereWithAggregatesInput = {
    AND?: crpNPCCorporationsScalarWhereWithAggregatesInput | crpNPCCorporationsScalarWhereWithAggregatesInput[]
    OR?: crpNPCCorporationsScalarWhereWithAggregatesInput[]
    NOT?: crpNPCCorporationsScalarWhereWithAggregatesInput | crpNPCCorporationsScalarWhereWithAggregatesInput[]
    corporationID?: IntWithAggregatesFilter<"crpNPCCorporations"> | number
    size?: StringNullableWithAggregatesFilter<"crpNPCCorporations"> | string | null
    extent?: StringNullableWithAggregatesFilter<"crpNPCCorporations"> | string | null
    solarSystemID?: IntNullableWithAggregatesFilter<"crpNPCCorporations"> | number | null
    investorID1?: IntNullableWithAggregatesFilter<"crpNPCCorporations"> | number | null
    investorShares1?: IntNullableWithAggregatesFilter<"crpNPCCorporations"> | number | null
    investorID2?: IntNullableWithAggregatesFilter<"crpNPCCorporations"> | number | null
    investorShares2?: IntNullableWithAggregatesFilter<"crpNPCCorporations"> | number | null
    investorID3?: IntNullableWithAggregatesFilter<"crpNPCCorporations"> | number | null
    investorShares3?: IntNullableWithAggregatesFilter<"crpNPCCorporations"> | number | null
    investorID4?: IntNullableWithAggregatesFilter<"crpNPCCorporations"> | number | null
    investorShares4?: IntNullableWithAggregatesFilter<"crpNPCCorporations"> | number | null
    friendID?: IntNullableWithAggregatesFilter<"crpNPCCorporations"> | number | null
    enemyID?: IntNullableWithAggregatesFilter<"crpNPCCorporations"> | number | null
    publicShares?: IntNullableWithAggregatesFilter<"crpNPCCorporations"> | number | null
    initialPrice?: IntNullableWithAggregatesFilter<"crpNPCCorporations"> | number | null
    minSecurity?: FloatNullableWithAggregatesFilter<"crpNPCCorporations"> | number | null
    scattered?: BoolNullableWithAggregatesFilter<"crpNPCCorporations"> | boolean | null
    fringe?: IntNullableWithAggregatesFilter<"crpNPCCorporations"> | number | null
    corridor?: IntNullableWithAggregatesFilter<"crpNPCCorporations"> | number | null
    hub?: IntNullableWithAggregatesFilter<"crpNPCCorporations"> | number | null
    border?: IntNullableWithAggregatesFilter<"crpNPCCorporations"> | number | null
    factionID?: IntNullableWithAggregatesFilter<"crpNPCCorporations"> | number | null
    sizeFactor?: FloatNullableWithAggregatesFilter<"crpNPCCorporations"> | number | null
    stationCount?: IntNullableWithAggregatesFilter<"crpNPCCorporations"> | number | null
    stationSystemCount?: IntNullableWithAggregatesFilter<"crpNPCCorporations"> | number | null
    description?: StringNullableWithAggregatesFilter<"crpNPCCorporations"> | string | null
    iconID?: IntNullableWithAggregatesFilter<"crpNPCCorporations"> | number | null
  }

  export type crpNPCDivisionsWhereInput = {
    AND?: crpNPCDivisionsWhereInput | crpNPCDivisionsWhereInput[]
    OR?: crpNPCDivisionsWhereInput[]
    NOT?: crpNPCDivisionsWhereInput | crpNPCDivisionsWhereInput[]
    divisionID?: IntFilter<"crpNPCDivisions"> | number
    divisionName?: StringNullableFilter<"crpNPCDivisions"> | string | null
    description?: StringNullableFilter<"crpNPCDivisions"> | string | null
    leaderType?: StringNullableFilter<"crpNPCDivisions"> | string | null
  }

  export type crpNPCDivisionsOrderByWithRelationInput = {
    divisionID?: SortOrder
    divisionName?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    leaderType?: SortOrderInput | SortOrder
  }

  export type crpNPCDivisionsWhereUniqueInput = Prisma.AtLeast<{
    divisionID?: number
    AND?: crpNPCDivisionsWhereInput | crpNPCDivisionsWhereInput[]
    OR?: crpNPCDivisionsWhereInput[]
    NOT?: crpNPCDivisionsWhereInput | crpNPCDivisionsWhereInput[]
    divisionName?: StringNullableFilter<"crpNPCDivisions"> | string | null
    description?: StringNullableFilter<"crpNPCDivisions"> | string | null
    leaderType?: StringNullableFilter<"crpNPCDivisions"> | string | null
  }, "divisionID">

  export type crpNPCDivisionsOrderByWithAggregationInput = {
    divisionID?: SortOrder
    divisionName?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    leaderType?: SortOrderInput | SortOrder
    _count?: crpNPCDivisionsCountOrderByAggregateInput
    _avg?: crpNPCDivisionsAvgOrderByAggregateInput
    _max?: crpNPCDivisionsMaxOrderByAggregateInput
    _min?: crpNPCDivisionsMinOrderByAggregateInput
    _sum?: crpNPCDivisionsSumOrderByAggregateInput
  }

  export type crpNPCDivisionsScalarWhereWithAggregatesInput = {
    AND?: crpNPCDivisionsScalarWhereWithAggregatesInput | crpNPCDivisionsScalarWhereWithAggregatesInput[]
    OR?: crpNPCDivisionsScalarWhereWithAggregatesInput[]
    NOT?: crpNPCDivisionsScalarWhereWithAggregatesInput | crpNPCDivisionsScalarWhereWithAggregatesInput[]
    divisionID?: IntWithAggregatesFilter<"crpNPCDivisions"> | number
    divisionName?: StringNullableWithAggregatesFilter<"crpNPCDivisions"> | string | null
    description?: StringNullableWithAggregatesFilter<"crpNPCDivisions"> | string | null
    leaderType?: StringNullableWithAggregatesFilter<"crpNPCDivisions"> | string | null
  }

  export type dgmAttributeCategoriesWhereInput = {
    AND?: dgmAttributeCategoriesWhereInput | dgmAttributeCategoriesWhereInput[]
    OR?: dgmAttributeCategoriesWhereInput[]
    NOT?: dgmAttributeCategoriesWhereInput | dgmAttributeCategoriesWhereInput[]
    categoryID?: IntFilter<"dgmAttributeCategories"> | number
    categoryName?: StringNullableFilter<"dgmAttributeCategories"> | string | null
    categoryDescription?: StringNullableFilter<"dgmAttributeCategories"> | string | null
  }

  export type dgmAttributeCategoriesOrderByWithRelationInput = {
    categoryID?: SortOrder
    categoryName?: SortOrderInput | SortOrder
    categoryDescription?: SortOrderInput | SortOrder
  }

  export type dgmAttributeCategoriesWhereUniqueInput = Prisma.AtLeast<{
    categoryID?: number
    AND?: dgmAttributeCategoriesWhereInput | dgmAttributeCategoriesWhereInput[]
    OR?: dgmAttributeCategoriesWhereInput[]
    NOT?: dgmAttributeCategoriesWhereInput | dgmAttributeCategoriesWhereInput[]
    categoryName?: StringNullableFilter<"dgmAttributeCategories"> | string | null
    categoryDescription?: StringNullableFilter<"dgmAttributeCategories"> | string | null
  }, "categoryID">

  export type dgmAttributeCategoriesOrderByWithAggregationInput = {
    categoryID?: SortOrder
    categoryName?: SortOrderInput | SortOrder
    categoryDescription?: SortOrderInput | SortOrder
    _count?: dgmAttributeCategoriesCountOrderByAggregateInput
    _avg?: dgmAttributeCategoriesAvgOrderByAggregateInput
    _max?: dgmAttributeCategoriesMaxOrderByAggregateInput
    _min?: dgmAttributeCategoriesMinOrderByAggregateInput
    _sum?: dgmAttributeCategoriesSumOrderByAggregateInput
  }

  export type dgmAttributeCategoriesScalarWhereWithAggregatesInput = {
    AND?: dgmAttributeCategoriesScalarWhereWithAggregatesInput | dgmAttributeCategoriesScalarWhereWithAggregatesInput[]
    OR?: dgmAttributeCategoriesScalarWhereWithAggregatesInput[]
    NOT?: dgmAttributeCategoriesScalarWhereWithAggregatesInput | dgmAttributeCategoriesScalarWhereWithAggregatesInput[]
    categoryID?: IntWithAggregatesFilter<"dgmAttributeCategories"> | number
    categoryName?: StringNullableWithAggregatesFilter<"dgmAttributeCategories"> | string | null
    categoryDescription?: StringNullableWithAggregatesFilter<"dgmAttributeCategories"> | string | null
  }

  export type dgmAttributeTypesWhereInput = {
    AND?: dgmAttributeTypesWhereInput | dgmAttributeTypesWhereInput[]
    OR?: dgmAttributeTypesWhereInput[]
    NOT?: dgmAttributeTypesWhereInput | dgmAttributeTypesWhereInput[]
    attributeID?: IntFilter<"dgmAttributeTypes"> | number
    attributeName?: StringNullableFilter<"dgmAttributeTypes"> | string | null
    description?: StringNullableFilter<"dgmAttributeTypes"> | string | null
    iconID?: IntNullableFilter<"dgmAttributeTypes"> | number | null
    defaultValue?: FloatNullableFilter<"dgmAttributeTypes"> | number | null
    published?: BoolNullableFilter<"dgmAttributeTypes"> | boolean | null
    displayName?: StringNullableFilter<"dgmAttributeTypes"> | string | null
    unitID?: IntNullableFilter<"dgmAttributeTypes"> | number | null
    stackable?: BoolNullableFilter<"dgmAttributeTypes"> | boolean | null
    highIsGood?: BoolNullableFilter<"dgmAttributeTypes"> | boolean | null
    categoryID?: IntNullableFilter<"dgmAttributeTypes"> | number | null
  }

  export type dgmAttributeTypesOrderByWithRelationInput = {
    attributeID?: SortOrder
    attributeName?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    iconID?: SortOrderInput | SortOrder
    defaultValue?: SortOrderInput | SortOrder
    published?: SortOrderInput | SortOrder
    displayName?: SortOrderInput | SortOrder
    unitID?: SortOrderInput | SortOrder
    stackable?: SortOrderInput | SortOrder
    highIsGood?: SortOrderInput | SortOrder
    categoryID?: SortOrderInput | SortOrder
  }

  export type dgmAttributeTypesWhereUniqueInput = Prisma.AtLeast<{
    attributeID?: number
    AND?: dgmAttributeTypesWhereInput | dgmAttributeTypesWhereInput[]
    OR?: dgmAttributeTypesWhereInput[]
    NOT?: dgmAttributeTypesWhereInput | dgmAttributeTypesWhereInput[]
    attributeName?: StringNullableFilter<"dgmAttributeTypes"> | string | null
    description?: StringNullableFilter<"dgmAttributeTypes"> | string | null
    iconID?: IntNullableFilter<"dgmAttributeTypes"> | number | null
    defaultValue?: FloatNullableFilter<"dgmAttributeTypes"> | number | null
    published?: BoolNullableFilter<"dgmAttributeTypes"> | boolean | null
    displayName?: StringNullableFilter<"dgmAttributeTypes"> | string | null
    unitID?: IntNullableFilter<"dgmAttributeTypes"> | number | null
    stackable?: BoolNullableFilter<"dgmAttributeTypes"> | boolean | null
    highIsGood?: BoolNullableFilter<"dgmAttributeTypes"> | boolean | null
    categoryID?: IntNullableFilter<"dgmAttributeTypes"> | number | null
  }, "attributeID">

  export type dgmAttributeTypesOrderByWithAggregationInput = {
    attributeID?: SortOrder
    attributeName?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    iconID?: SortOrderInput | SortOrder
    defaultValue?: SortOrderInput | SortOrder
    published?: SortOrderInput | SortOrder
    displayName?: SortOrderInput | SortOrder
    unitID?: SortOrderInput | SortOrder
    stackable?: SortOrderInput | SortOrder
    highIsGood?: SortOrderInput | SortOrder
    categoryID?: SortOrderInput | SortOrder
    _count?: dgmAttributeTypesCountOrderByAggregateInput
    _avg?: dgmAttributeTypesAvgOrderByAggregateInput
    _max?: dgmAttributeTypesMaxOrderByAggregateInput
    _min?: dgmAttributeTypesMinOrderByAggregateInput
    _sum?: dgmAttributeTypesSumOrderByAggregateInput
  }

  export type dgmAttributeTypesScalarWhereWithAggregatesInput = {
    AND?: dgmAttributeTypesScalarWhereWithAggregatesInput | dgmAttributeTypesScalarWhereWithAggregatesInput[]
    OR?: dgmAttributeTypesScalarWhereWithAggregatesInput[]
    NOT?: dgmAttributeTypesScalarWhereWithAggregatesInput | dgmAttributeTypesScalarWhereWithAggregatesInput[]
    attributeID?: IntWithAggregatesFilter<"dgmAttributeTypes"> | number
    attributeName?: StringNullableWithAggregatesFilter<"dgmAttributeTypes"> | string | null
    description?: StringNullableWithAggregatesFilter<"dgmAttributeTypes"> | string | null
    iconID?: IntNullableWithAggregatesFilter<"dgmAttributeTypes"> | number | null
    defaultValue?: FloatNullableWithAggregatesFilter<"dgmAttributeTypes"> | number | null
    published?: BoolNullableWithAggregatesFilter<"dgmAttributeTypes"> | boolean | null
    displayName?: StringNullableWithAggregatesFilter<"dgmAttributeTypes"> | string | null
    unitID?: IntNullableWithAggregatesFilter<"dgmAttributeTypes"> | number | null
    stackable?: BoolNullableWithAggregatesFilter<"dgmAttributeTypes"> | boolean | null
    highIsGood?: BoolNullableWithAggregatesFilter<"dgmAttributeTypes"> | boolean | null
    categoryID?: IntNullableWithAggregatesFilter<"dgmAttributeTypes"> | number | null
  }

  export type dgmEffectsWhereInput = {
    AND?: dgmEffectsWhereInput | dgmEffectsWhereInput[]
    OR?: dgmEffectsWhereInput[]
    NOT?: dgmEffectsWhereInput | dgmEffectsWhereInput[]
    effectID?: IntFilter<"dgmEffects"> | number
    effectName?: StringNullableFilter<"dgmEffects"> | string | null
    effectCategory?: IntNullableFilter<"dgmEffects"> | number | null
    preExpression?: IntNullableFilter<"dgmEffects"> | number | null
    postExpression?: IntNullableFilter<"dgmEffects"> | number | null
    description?: StringNullableFilter<"dgmEffects"> | string | null
    guid?: StringNullableFilter<"dgmEffects"> | string | null
    iconID?: IntNullableFilter<"dgmEffects"> | number | null
    isOffensive?: BoolNullableFilter<"dgmEffects"> | boolean | null
    isAssistance?: BoolNullableFilter<"dgmEffects"> | boolean | null
    durationAttributeID?: IntNullableFilter<"dgmEffects"> | number | null
    trackingSpeedAttributeID?: IntNullableFilter<"dgmEffects"> | number | null
    dischargeAttributeID?: IntNullableFilter<"dgmEffects"> | number | null
    rangeAttributeID?: IntNullableFilter<"dgmEffects"> | number | null
    falloffAttributeID?: IntNullableFilter<"dgmEffects"> | number | null
    disallowAutoRepeat?: BoolNullableFilter<"dgmEffects"> | boolean | null
    published?: BoolNullableFilter<"dgmEffects"> | boolean | null
    displayName?: StringNullableFilter<"dgmEffects"> | string | null
    isWarpSafe?: BoolNullableFilter<"dgmEffects"> | boolean | null
    rangeChance?: BoolNullableFilter<"dgmEffects"> | boolean | null
    electronicChance?: BoolNullableFilter<"dgmEffects"> | boolean | null
    propulsionChance?: BoolNullableFilter<"dgmEffects"> | boolean | null
    distribution?: IntNullableFilter<"dgmEffects"> | number | null
    sfxName?: StringNullableFilter<"dgmEffects"> | string | null
    npcUsageChanceAttributeID?: IntNullableFilter<"dgmEffects"> | number | null
    npcActivationChanceAttributeID?: IntNullableFilter<"dgmEffects"> | number | null
    fittingUsageChanceAttributeID?: IntNullableFilter<"dgmEffects"> | number | null
    modifierInfo?: StringNullableFilter<"dgmEffects"> | string | null
  }

  export type dgmEffectsOrderByWithRelationInput = {
    effectID?: SortOrder
    effectName?: SortOrderInput | SortOrder
    effectCategory?: SortOrderInput | SortOrder
    preExpression?: SortOrderInput | SortOrder
    postExpression?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    guid?: SortOrderInput | SortOrder
    iconID?: SortOrderInput | SortOrder
    isOffensive?: SortOrderInput | SortOrder
    isAssistance?: SortOrderInput | SortOrder
    durationAttributeID?: SortOrderInput | SortOrder
    trackingSpeedAttributeID?: SortOrderInput | SortOrder
    dischargeAttributeID?: SortOrderInput | SortOrder
    rangeAttributeID?: SortOrderInput | SortOrder
    falloffAttributeID?: SortOrderInput | SortOrder
    disallowAutoRepeat?: SortOrderInput | SortOrder
    published?: SortOrderInput | SortOrder
    displayName?: SortOrderInput | SortOrder
    isWarpSafe?: SortOrderInput | SortOrder
    rangeChance?: SortOrderInput | SortOrder
    electronicChance?: SortOrderInput | SortOrder
    propulsionChance?: SortOrderInput | SortOrder
    distribution?: SortOrderInput | SortOrder
    sfxName?: SortOrderInput | SortOrder
    npcUsageChanceAttributeID?: SortOrderInput | SortOrder
    npcActivationChanceAttributeID?: SortOrderInput | SortOrder
    fittingUsageChanceAttributeID?: SortOrderInput | SortOrder
    modifierInfo?: SortOrderInput | SortOrder
  }

  export type dgmEffectsWhereUniqueInput = Prisma.AtLeast<{
    effectID?: number
    AND?: dgmEffectsWhereInput | dgmEffectsWhereInput[]
    OR?: dgmEffectsWhereInput[]
    NOT?: dgmEffectsWhereInput | dgmEffectsWhereInput[]
    effectName?: StringNullableFilter<"dgmEffects"> | string | null
    effectCategory?: IntNullableFilter<"dgmEffects"> | number | null
    preExpression?: IntNullableFilter<"dgmEffects"> | number | null
    postExpression?: IntNullableFilter<"dgmEffects"> | number | null
    description?: StringNullableFilter<"dgmEffects"> | string | null
    guid?: StringNullableFilter<"dgmEffects"> | string | null
    iconID?: IntNullableFilter<"dgmEffects"> | number | null
    isOffensive?: BoolNullableFilter<"dgmEffects"> | boolean | null
    isAssistance?: BoolNullableFilter<"dgmEffects"> | boolean | null
    durationAttributeID?: IntNullableFilter<"dgmEffects"> | number | null
    trackingSpeedAttributeID?: IntNullableFilter<"dgmEffects"> | number | null
    dischargeAttributeID?: IntNullableFilter<"dgmEffects"> | number | null
    rangeAttributeID?: IntNullableFilter<"dgmEffects"> | number | null
    falloffAttributeID?: IntNullableFilter<"dgmEffects"> | number | null
    disallowAutoRepeat?: BoolNullableFilter<"dgmEffects"> | boolean | null
    published?: BoolNullableFilter<"dgmEffects"> | boolean | null
    displayName?: StringNullableFilter<"dgmEffects"> | string | null
    isWarpSafe?: BoolNullableFilter<"dgmEffects"> | boolean | null
    rangeChance?: BoolNullableFilter<"dgmEffects"> | boolean | null
    electronicChance?: BoolNullableFilter<"dgmEffects"> | boolean | null
    propulsionChance?: BoolNullableFilter<"dgmEffects"> | boolean | null
    distribution?: IntNullableFilter<"dgmEffects"> | number | null
    sfxName?: StringNullableFilter<"dgmEffects"> | string | null
    npcUsageChanceAttributeID?: IntNullableFilter<"dgmEffects"> | number | null
    npcActivationChanceAttributeID?: IntNullableFilter<"dgmEffects"> | number | null
    fittingUsageChanceAttributeID?: IntNullableFilter<"dgmEffects"> | number | null
    modifierInfo?: StringNullableFilter<"dgmEffects"> | string | null
  }, "effectID">

  export type dgmEffectsOrderByWithAggregationInput = {
    effectID?: SortOrder
    effectName?: SortOrderInput | SortOrder
    effectCategory?: SortOrderInput | SortOrder
    preExpression?: SortOrderInput | SortOrder
    postExpression?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    guid?: SortOrderInput | SortOrder
    iconID?: SortOrderInput | SortOrder
    isOffensive?: SortOrderInput | SortOrder
    isAssistance?: SortOrderInput | SortOrder
    durationAttributeID?: SortOrderInput | SortOrder
    trackingSpeedAttributeID?: SortOrderInput | SortOrder
    dischargeAttributeID?: SortOrderInput | SortOrder
    rangeAttributeID?: SortOrderInput | SortOrder
    falloffAttributeID?: SortOrderInput | SortOrder
    disallowAutoRepeat?: SortOrderInput | SortOrder
    published?: SortOrderInput | SortOrder
    displayName?: SortOrderInput | SortOrder
    isWarpSafe?: SortOrderInput | SortOrder
    rangeChance?: SortOrderInput | SortOrder
    electronicChance?: SortOrderInput | SortOrder
    propulsionChance?: SortOrderInput | SortOrder
    distribution?: SortOrderInput | SortOrder
    sfxName?: SortOrderInput | SortOrder
    npcUsageChanceAttributeID?: SortOrderInput | SortOrder
    npcActivationChanceAttributeID?: SortOrderInput | SortOrder
    fittingUsageChanceAttributeID?: SortOrderInput | SortOrder
    modifierInfo?: SortOrderInput | SortOrder
    _count?: dgmEffectsCountOrderByAggregateInput
    _avg?: dgmEffectsAvgOrderByAggregateInput
    _max?: dgmEffectsMaxOrderByAggregateInput
    _min?: dgmEffectsMinOrderByAggregateInput
    _sum?: dgmEffectsSumOrderByAggregateInput
  }

  export type dgmEffectsScalarWhereWithAggregatesInput = {
    AND?: dgmEffectsScalarWhereWithAggregatesInput | dgmEffectsScalarWhereWithAggregatesInput[]
    OR?: dgmEffectsScalarWhereWithAggregatesInput[]
    NOT?: dgmEffectsScalarWhereWithAggregatesInput | dgmEffectsScalarWhereWithAggregatesInput[]
    effectID?: IntWithAggregatesFilter<"dgmEffects"> | number
    effectName?: StringNullableWithAggregatesFilter<"dgmEffects"> | string | null
    effectCategory?: IntNullableWithAggregatesFilter<"dgmEffects"> | number | null
    preExpression?: IntNullableWithAggregatesFilter<"dgmEffects"> | number | null
    postExpression?: IntNullableWithAggregatesFilter<"dgmEffects"> | number | null
    description?: StringNullableWithAggregatesFilter<"dgmEffects"> | string | null
    guid?: StringNullableWithAggregatesFilter<"dgmEffects"> | string | null
    iconID?: IntNullableWithAggregatesFilter<"dgmEffects"> | number | null
    isOffensive?: BoolNullableWithAggregatesFilter<"dgmEffects"> | boolean | null
    isAssistance?: BoolNullableWithAggregatesFilter<"dgmEffects"> | boolean | null
    durationAttributeID?: IntNullableWithAggregatesFilter<"dgmEffects"> | number | null
    trackingSpeedAttributeID?: IntNullableWithAggregatesFilter<"dgmEffects"> | number | null
    dischargeAttributeID?: IntNullableWithAggregatesFilter<"dgmEffects"> | number | null
    rangeAttributeID?: IntNullableWithAggregatesFilter<"dgmEffects"> | number | null
    falloffAttributeID?: IntNullableWithAggregatesFilter<"dgmEffects"> | number | null
    disallowAutoRepeat?: BoolNullableWithAggregatesFilter<"dgmEffects"> | boolean | null
    published?: BoolNullableWithAggregatesFilter<"dgmEffects"> | boolean | null
    displayName?: StringNullableWithAggregatesFilter<"dgmEffects"> | string | null
    isWarpSafe?: BoolNullableWithAggregatesFilter<"dgmEffects"> | boolean | null
    rangeChance?: BoolNullableWithAggregatesFilter<"dgmEffects"> | boolean | null
    electronicChance?: BoolNullableWithAggregatesFilter<"dgmEffects"> | boolean | null
    propulsionChance?: BoolNullableWithAggregatesFilter<"dgmEffects"> | boolean | null
    distribution?: IntNullableWithAggregatesFilter<"dgmEffects"> | number | null
    sfxName?: StringNullableWithAggregatesFilter<"dgmEffects"> | string | null
    npcUsageChanceAttributeID?: IntNullableWithAggregatesFilter<"dgmEffects"> | number | null
    npcActivationChanceAttributeID?: IntNullableWithAggregatesFilter<"dgmEffects"> | number | null
    fittingUsageChanceAttributeID?: IntNullableWithAggregatesFilter<"dgmEffects"> | number | null
    modifierInfo?: StringNullableWithAggregatesFilter<"dgmEffects"> | string | null
  }

  export type dgmExpressionsWhereInput = {
    AND?: dgmExpressionsWhereInput | dgmExpressionsWhereInput[]
    OR?: dgmExpressionsWhereInput[]
    NOT?: dgmExpressionsWhereInput | dgmExpressionsWhereInput[]
    expressionID?: IntFilter<"dgmExpressions"> | number
    operandID?: IntNullableFilter<"dgmExpressions"> | number | null
    arg1?: IntNullableFilter<"dgmExpressions"> | number | null
    arg2?: IntNullableFilter<"dgmExpressions"> | number | null
    expressionValue?: StringNullableFilter<"dgmExpressions"> | string | null
    description?: StringNullableFilter<"dgmExpressions"> | string | null
    expressionName?: StringNullableFilter<"dgmExpressions"> | string | null
    expressionTypeID?: IntNullableFilter<"dgmExpressions"> | number | null
    expressionGroupID?: IntNullableFilter<"dgmExpressions"> | number | null
    expressionAttributeID?: IntNullableFilter<"dgmExpressions"> | number | null
  }

  export type dgmExpressionsOrderByWithRelationInput = {
    expressionID?: SortOrder
    operandID?: SortOrderInput | SortOrder
    arg1?: SortOrderInput | SortOrder
    arg2?: SortOrderInput | SortOrder
    expressionValue?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    expressionName?: SortOrderInput | SortOrder
    expressionTypeID?: SortOrderInput | SortOrder
    expressionGroupID?: SortOrderInput | SortOrder
    expressionAttributeID?: SortOrderInput | SortOrder
  }

  export type dgmExpressionsWhereUniqueInput = Prisma.AtLeast<{
    expressionID?: number
    AND?: dgmExpressionsWhereInput | dgmExpressionsWhereInput[]
    OR?: dgmExpressionsWhereInput[]
    NOT?: dgmExpressionsWhereInput | dgmExpressionsWhereInput[]
    operandID?: IntNullableFilter<"dgmExpressions"> | number | null
    arg1?: IntNullableFilter<"dgmExpressions"> | number | null
    arg2?: IntNullableFilter<"dgmExpressions"> | number | null
    expressionValue?: StringNullableFilter<"dgmExpressions"> | string | null
    description?: StringNullableFilter<"dgmExpressions"> | string | null
    expressionName?: StringNullableFilter<"dgmExpressions"> | string | null
    expressionTypeID?: IntNullableFilter<"dgmExpressions"> | number | null
    expressionGroupID?: IntNullableFilter<"dgmExpressions"> | number | null
    expressionAttributeID?: IntNullableFilter<"dgmExpressions"> | number | null
  }, "expressionID">

  export type dgmExpressionsOrderByWithAggregationInput = {
    expressionID?: SortOrder
    operandID?: SortOrderInput | SortOrder
    arg1?: SortOrderInput | SortOrder
    arg2?: SortOrderInput | SortOrder
    expressionValue?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    expressionName?: SortOrderInput | SortOrder
    expressionTypeID?: SortOrderInput | SortOrder
    expressionGroupID?: SortOrderInput | SortOrder
    expressionAttributeID?: SortOrderInput | SortOrder
    _count?: dgmExpressionsCountOrderByAggregateInput
    _avg?: dgmExpressionsAvgOrderByAggregateInput
    _max?: dgmExpressionsMaxOrderByAggregateInput
    _min?: dgmExpressionsMinOrderByAggregateInput
    _sum?: dgmExpressionsSumOrderByAggregateInput
  }

  export type dgmExpressionsScalarWhereWithAggregatesInput = {
    AND?: dgmExpressionsScalarWhereWithAggregatesInput | dgmExpressionsScalarWhereWithAggregatesInput[]
    OR?: dgmExpressionsScalarWhereWithAggregatesInput[]
    NOT?: dgmExpressionsScalarWhereWithAggregatesInput | dgmExpressionsScalarWhereWithAggregatesInput[]
    expressionID?: IntWithAggregatesFilter<"dgmExpressions"> | number
    operandID?: IntNullableWithAggregatesFilter<"dgmExpressions"> | number | null
    arg1?: IntNullableWithAggregatesFilter<"dgmExpressions"> | number | null
    arg2?: IntNullableWithAggregatesFilter<"dgmExpressions"> | number | null
    expressionValue?: StringNullableWithAggregatesFilter<"dgmExpressions"> | string | null
    description?: StringNullableWithAggregatesFilter<"dgmExpressions"> | string | null
    expressionName?: StringNullableWithAggregatesFilter<"dgmExpressions"> | string | null
    expressionTypeID?: IntNullableWithAggregatesFilter<"dgmExpressions"> | number | null
    expressionGroupID?: IntNullableWithAggregatesFilter<"dgmExpressions"> | number | null
    expressionAttributeID?: IntNullableWithAggregatesFilter<"dgmExpressions"> | number | null
  }

  export type dgmTypeAttributesWhereInput = {
    AND?: dgmTypeAttributesWhereInput | dgmTypeAttributesWhereInput[]
    OR?: dgmTypeAttributesWhereInput[]
    NOT?: dgmTypeAttributesWhereInput | dgmTypeAttributesWhereInput[]
    typeID?: IntFilter<"dgmTypeAttributes"> | number
    attributeID?: IntFilter<"dgmTypeAttributes"> | number
    valueInt?: IntNullableFilter<"dgmTypeAttributes"> | number | null
    valueFloat?: FloatNullableFilter<"dgmTypeAttributes"> | number | null
  }

  export type dgmTypeAttributesOrderByWithRelationInput = {
    typeID?: SortOrder
    attributeID?: SortOrder
    valueInt?: SortOrderInput | SortOrder
    valueFloat?: SortOrderInput | SortOrder
  }

  export type dgmTypeAttributesWhereUniqueInput = Prisma.AtLeast<{
    typeID_attributeID?: dgmTypeAttributesTypeIDAttributeIDCompoundUniqueInput
    AND?: dgmTypeAttributesWhereInput | dgmTypeAttributesWhereInput[]
    OR?: dgmTypeAttributesWhereInput[]
    NOT?: dgmTypeAttributesWhereInput | dgmTypeAttributesWhereInput[]
    typeID?: IntFilter<"dgmTypeAttributes"> | number
    attributeID?: IntFilter<"dgmTypeAttributes"> | number
    valueInt?: IntNullableFilter<"dgmTypeAttributes"> | number | null
    valueFloat?: FloatNullableFilter<"dgmTypeAttributes"> | number | null
  }, "typeID_attributeID">

  export type dgmTypeAttributesOrderByWithAggregationInput = {
    typeID?: SortOrder
    attributeID?: SortOrder
    valueInt?: SortOrderInput | SortOrder
    valueFloat?: SortOrderInput | SortOrder
    _count?: dgmTypeAttributesCountOrderByAggregateInput
    _avg?: dgmTypeAttributesAvgOrderByAggregateInput
    _max?: dgmTypeAttributesMaxOrderByAggregateInput
    _min?: dgmTypeAttributesMinOrderByAggregateInput
    _sum?: dgmTypeAttributesSumOrderByAggregateInput
  }

  export type dgmTypeAttributesScalarWhereWithAggregatesInput = {
    AND?: dgmTypeAttributesScalarWhereWithAggregatesInput | dgmTypeAttributesScalarWhereWithAggregatesInput[]
    OR?: dgmTypeAttributesScalarWhereWithAggregatesInput[]
    NOT?: dgmTypeAttributesScalarWhereWithAggregatesInput | dgmTypeAttributesScalarWhereWithAggregatesInput[]
    typeID?: IntWithAggregatesFilter<"dgmTypeAttributes"> | number
    attributeID?: IntWithAggregatesFilter<"dgmTypeAttributes"> | number
    valueInt?: IntNullableWithAggregatesFilter<"dgmTypeAttributes"> | number | null
    valueFloat?: FloatNullableWithAggregatesFilter<"dgmTypeAttributes"> | number | null
  }

  export type dgmTypeEffectsWhereInput = {
    AND?: dgmTypeEffectsWhereInput | dgmTypeEffectsWhereInput[]
    OR?: dgmTypeEffectsWhereInput[]
    NOT?: dgmTypeEffectsWhereInput | dgmTypeEffectsWhereInput[]
    typeID?: IntFilter<"dgmTypeEffects"> | number
    effectID?: IntFilter<"dgmTypeEffects"> | number
    isDefault?: BoolNullableFilter<"dgmTypeEffects"> | boolean | null
  }

  export type dgmTypeEffectsOrderByWithRelationInput = {
    typeID?: SortOrder
    effectID?: SortOrder
    isDefault?: SortOrderInput | SortOrder
  }

  export type dgmTypeEffectsWhereUniqueInput = Prisma.AtLeast<{
    typeID_effectID?: dgmTypeEffectsTypeIDEffectIDCompoundUniqueInput
    AND?: dgmTypeEffectsWhereInput | dgmTypeEffectsWhereInput[]
    OR?: dgmTypeEffectsWhereInput[]
    NOT?: dgmTypeEffectsWhereInput | dgmTypeEffectsWhereInput[]
    typeID?: IntFilter<"dgmTypeEffects"> | number
    effectID?: IntFilter<"dgmTypeEffects"> | number
    isDefault?: BoolNullableFilter<"dgmTypeEffects"> | boolean | null
  }, "typeID_effectID">

  export type dgmTypeEffectsOrderByWithAggregationInput = {
    typeID?: SortOrder
    effectID?: SortOrder
    isDefault?: SortOrderInput | SortOrder
    _count?: dgmTypeEffectsCountOrderByAggregateInput
    _avg?: dgmTypeEffectsAvgOrderByAggregateInput
    _max?: dgmTypeEffectsMaxOrderByAggregateInput
    _min?: dgmTypeEffectsMinOrderByAggregateInput
    _sum?: dgmTypeEffectsSumOrderByAggregateInput
  }

  export type dgmTypeEffectsScalarWhereWithAggregatesInput = {
    AND?: dgmTypeEffectsScalarWhereWithAggregatesInput | dgmTypeEffectsScalarWhereWithAggregatesInput[]
    OR?: dgmTypeEffectsScalarWhereWithAggregatesInput[]
    NOT?: dgmTypeEffectsScalarWhereWithAggregatesInput | dgmTypeEffectsScalarWhereWithAggregatesInput[]
    typeID?: IntWithAggregatesFilter<"dgmTypeEffects"> | number
    effectID?: IntWithAggregatesFilter<"dgmTypeEffects"> | number
    isDefault?: BoolNullableWithAggregatesFilter<"dgmTypeEffects"> | boolean | null
  }

  export type eveGraphicsWhereInput = {
    AND?: eveGraphicsWhereInput | eveGraphicsWhereInput[]
    OR?: eveGraphicsWhereInput[]
    NOT?: eveGraphicsWhereInput | eveGraphicsWhereInput[]
    graphicID?: IntFilter<"eveGraphics"> | number
    sofFactionName?: StringNullableFilter<"eveGraphics"> | string | null
    graphicFile?: StringNullableFilter<"eveGraphics"> | string | null
    sofHullName?: StringNullableFilter<"eveGraphics"> | string | null
    sofRaceName?: StringNullableFilter<"eveGraphics"> | string | null
    description?: StringNullableFilter<"eveGraphics"> | string | null
  }

  export type eveGraphicsOrderByWithRelationInput = {
    graphicID?: SortOrder
    sofFactionName?: SortOrderInput | SortOrder
    graphicFile?: SortOrderInput | SortOrder
    sofHullName?: SortOrderInput | SortOrder
    sofRaceName?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
  }

  export type eveGraphicsWhereUniqueInput = Prisma.AtLeast<{
    graphicID?: number
    AND?: eveGraphicsWhereInput | eveGraphicsWhereInput[]
    OR?: eveGraphicsWhereInput[]
    NOT?: eveGraphicsWhereInput | eveGraphicsWhereInput[]
    sofFactionName?: StringNullableFilter<"eveGraphics"> | string | null
    graphicFile?: StringNullableFilter<"eveGraphics"> | string | null
    sofHullName?: StringNullableFilter<"eveGraphics"> | string | null
    sofRaceName?: StringNullableFilter<"eveGraphics"> | string | null
    description?: StringNullableFilter<"eveGraphics"> | string | null
  }, "graphicID">

  export type eveGraphicsOrderByWithAggregationInput = {
    graphicID?: SortOrder
    sofFactionName?: SortOrderInput | SortOrder
    graphicFile?: SortOrderInput | SortOrder
    sofHullName?: SortOrderInput | SortOrder
    sofRaceName?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    _count?: eveGraphicsCountOrderByAggregateInput
    _avg?: eveGraphicsAvgOrderByAggregateInput
    _max?: eveGraphicsMaxOrderByAggregateInput
    _min?: eveGraphicsMinOrderByAggregateInput
    _sum?: eveGraphicsSumOrderByAggregateInput
  }

  export type eveGraphicsScalarWhereWithAggregatesInput = {
    AND?: eveGraphicsScalarWhereWithAggregatesInput | eveGraphicsScalarWhereWithAggregatesInput[]
    OR?: eveGraphicsScalarWhereWithAggregatesInput[]
    NOT?: eveGraphicsScalarWhereWithAggregatesInput | eveGraphicsScalarWhereWithAggregatesInput[]
    graphicID?: IntWithAggregatesFilter<"eveGraphics"> | number
    sofFactionName?: StringNullableWithAggregatesFilter<"eveGraphics"> | string | null
    graphicFile?: StringNullableWithAggregatesFilter<"eveGraphics"> | string | null
    sofHullName?: StringNullableWithAggregatesFilter<"eveGraphics"> | string | null
    sofRaceName?: StringNullableWithAggregatesFilter<"eveGraphics"> | string | null
    description?: StringNullableWithAggregatesFilter<"eveGraphics"> | string | null
  }

  export type eveIconsWhereInput = {
    AND?: eveIconsWhereInput | eveIconsWhereInput[]
    OR?: eveIconsWhereInput[]
    NOT?: eveIconsWhereInput | eveIconsWhereInput[]
    iconID?: IntFilter<"eveIcons"> | number
    iconFile?: StringNullableFilter<"eveIcons"> | string | null
    description?: StringNullableFilter<"eveIcons"> | string | null
  }

  export type eveIconsOrderByWithRelationInput = {
    iconID?: SortOrder
    iconFile?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
  }

  export type eveIconsWhereUniqueInput = Prisma.AtLeast<{
    iconID?: number
    AND?: eveIconsWhereInput | eveIconsWhereInput[]
    OR?: eveIconsWhereInput[]
    NOT?: eveIconsWhereInput | eveIconsWhereInput[]
    iconFile?: StringNullableFilter<"eveIcons"> | string | null
    description?: StringNullableFilter<"eveIcons"> | string | null
  }, "iconID">

  export type eveIconsOrderByWithAggregationInput = {
    iconID?: SortOrder
    iconFile?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    _count?: eveIconsCountOrderByAggregateInput
    _avg?: eveIconsAvgOrderByAggregateInput
    _max?: eveIconsMaxOrderByAggregateInput
    _min?: eveIconsMinOrderByAggregateInput
    _sum?: eveIconsSumOrderByAggregateInput
  }

  export type eveIconsScalarWhereWithAggregatesInput = {
    AND?: eveIconsScalarWhereWithAggregatesInput | eveIconsScalarWhereWithAggregatesInput[]
    OR?: eveIconsScalarWhereWithAggregatesInput[]
    NOT?: eveIconsScalarWhereWithAggregatesInput | eveIconsScalarWhereWithAggregatesInput[]
    iconID?: IntWithAggregatesFilter<"eveIcons"> | number
    iconFile?: StringNullableWithAggregatesFilter<"eveIcons"> | string | null
    description?: StringNullableWithAggregatesFilter<"eveIcons"> | string | null
  }

  export type eveUnitsWhereInput = {
    AND?: eveUnitsWhereInput | eveUnitsWhereInput[]
    OR?: eveUnitsWhereInput[]
    NOT?: eveUnitsWhereInput | eveUnitsWhereInput[]
    unitID?: IntFilter<"eveUnits"> | number
    unitName?: StringNullableFilter<"eveUnits"> | string | null
    displayName?: StringNullableFilter<"eveUnits"> | string | null
    description?: StringNullableFilter<"eveUnits"> | string | null
  }

  export type eveUnitsOrderByWithRelationInput = {
    unitID?: SortOrder
    unitName?: SortOrderInput | SortOrder
    displayName?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
  }

  export type eveUnitsWhereUniqueInput = Prisma.AtLeast<{
    unitID?: number
    AND?: eveUnitsWhereInput | eveUnitsWhereInput[]
    OR?: eveUnitsWhereInput[]
    NOT?: eveUnitsWhereInput | eveUnitsWhereInput[]
    unitName?: StringNullableFilter<"eveUnits"> | string | null
    displayName?: StringNullableFilter<"eveUnits"> | string | null
    description?: StringNullableFilter<"eveUnits"> | string | null
  }, "unitID">

  export type eveUnitsOrderByWithAggregationInput = {
    unitID?: SortOrder
    unitName?: SortOrderInput | SortOrder
    displayName?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    _count?: eveUnitsCountOrderByAggregateInput
    _avg?: eveUnitsAvgOrderByAggregateInput
    _max?: eveUnitsMaxOrderByAggregateInput
    _min?: eveUnitsMinOrderByAggregateInput
    _sum?: eveUnitsSumOrderByAggregateInput
  }

  export type eveUnitsScalarWhereWithAggregatesInput = {
    AND?: eveUnitsScalarWhereWithAggregatesInput | eveUnitsScalarWhereWithAggregatesInput[]
    OR?: eveUnitsScalarWhereWithAggregatesInput[]
    NOT?: eveUnitsScalarWhereWithAggregatesInput | eveUnitsScalarWhereWithAggregatesInput[]
    unitID?: IntWithAggregatesFilter<"eveUnits"> | number
    unitName?: StringNullableWithAggregatesFilter<"eveUnits"> | string | null
    displayName?: StringNullableWithAggregatesFilter<"eveUnits"> | string | null
    description?: StringNullableWithAggregatesFilter<"eveUnits"> | string | null
  }

  export type industryActivityWhereInput = {
    AND?: industryActivityWhereInput | industryActivityWhereInput[]
    OR?: industryActivityWhereInput[]
    NOT?: industryActivityWhereInput | industryActivityWhereInput[]
    typeID?: IntFilter<"industryActivity"> | number
    activityID?: IntFilter<"industryActivity"> | number
    time?: IntNullableFilter<"industryActivity"> | number | null
  }

  export type industryActivityOrderByWithRelationInput = {
    typeID?: SortOrder
    activityID?: SortOrder
    time?: SortOrderInput | SortOrder
  }

  export type industryActivityWhereUniqueInput = Prisma.AtLeast<{
    typeID_activityID?: industryActivityTypeIDActivityIDCompoundUniqueInput
    AND?: industryActivityWhereInput | industryActivityWhereInput[]
    OR?: industryActivityWhereInput[]
    NOT?: industryActivityWhereInput | industryActivityWhereInput[]
    typeID?: IntFilter<"industryActivity"> | number
    activityID?: IntFilter<"industryActivity"> | number
    time?: IntNullableFilter<"industryActivity"> | number | null
  }, "typeID_activityID">

  export type industryActivityOrderByWithAggregationInput = {
    typeID?: SortOrder
    activityID?: SortOrder
    time?: SortOrderInput | SortOrder
    _count?: industryActivityCountOrderByAggregateInput
    _avg?: industryActivityAvgOrderByAggregateInput
    _max?: industryActivityMaxOrderByAggregateInput
    _min?: industryActivityMinOrderByAggregateInput
    _sum?: industryActivitySumOrderByAggregateInput
  }

  export type industryActivityScalarWhereWithAggregatesInput = {
    AND?: industryActivityScalarWhereWithAggregatesInput | industryActivityScalarWhereWithAggregatesInput[]
    OR?: industryActivityScalarWhereWithAggregatesInput[]
    NOT?: industryActivityScalarWhereWithAggregatesInput | industryActivityScalarWhereWithAggregatesInput[]
    typeID?: IntWithAggregatesFilter<"industryActivity"> | number
    activityID?: IntWithAggregatesFilter<"industryActivity"> | number
    time?: IntNullableWithAggregatesFilter<"industryActivity"> | number | null
  }

  export type industryBlueprintsWhereInput = {
    AND?: industryBlueprintsWhereInput | industryBlueprintsWhereInput[]
    OR?: industryBlueprintsWhereInput[]
    NOT?: industryBlueprintsWhereInput | industryBlueprintsWhereInput[]
    typeID?: IntFilter<"industryBlueprints"> | number
    maxProductionLimit?: IntNullableFilter<"industryBlueprints"> | number | null
  }

  export type industryBlueprintsOrderByWithRelationInput = {
    typeID?: SortOrder
    maxProductionLimit?: SortOrderInput | SortOrder
  }

  export type industryBlueprintsWhereUniqueInput = Prisma.AtLeast<{
    typeID?: number
    AND?: industryBlueprintsWhereInput | industryBlueprintsWhereInput[]
    OR?: industryBlueprintsWhereInput[]
    NOT?: industryBlueprintsWhereInput | industryBlueprintsWhereInput[]
    maxProductionLimit?: IntNullableFilter<"industryBlueprints"> | number | null
  }, "typeID">

  export type industryBlueprintsOrderByWithAggregationInput = {
    typeID?: SortOrder
    maxProductionLimit?: SortOrderInput | SortOrder
    _count?: industryBlueprintsCountOrderByAggregateInput
    _avg?: industryBlueprintsAvgOrderByAggregateInput
    _max?: industryBlueprintsMaxOrderByAggregateInput
    _min?: industryBlueprintsMinOrderByAggregateInput
    _sum?: industryBlueprintsSumOrderByAggregateInput
  }

  export type industryBlueprintsScalarWhereWithAggregatesInput = {
    AND?: industryBlueprintsScalarWhereWithAggregatesInput | industryBlueprintsScalarWhereWithAggregatesInput[]
    OR?: industryBlueprintsScalarWhereWithAggregatesInput[]
    NOT?: industryBlueprintsScalarWhereWithAggregatesInput | industryBlueprintsScalarWhereWithAggregatesInput[]
    typeID?: IntWithAggregatesFilter<"industryBlueprints"> | number
    maxProductionLimit?: IntNullableWithAggregatesFilter<"industryBlueprints"> | number | null
  }

  export type invCategoriesWhereInput = {
    AND?: invCategoriesWhereInput | invCategoriesWhereInput[]
    OR?: invCategoriesWhereInput[]
    NOT?: invCategoriesWhereInput | invCategoriesWhereInput[]
    categoryID?: IntFilter<"invCategories"> | number
    categoryName?: StringNullableFilter<"invCategories"> | string | null
    iconID?: IntNullableFilter<"invCategories"> | number | null
    published?: BoolNullableFilter<"invCategories"> | boolean | null
  }

  export type invCategoriesOrderByWithRelationInput = {
    categoryID?: SortOrder
    categoryName?: SortOrderInput | SortOrder
    iconID?: SortOrderInput | SortOrder
    published?: SortOrderInput | SortOrder
  }

  export type invCategoriesWhereUniqueInput = Prisma.AtLeast<{
    categoryID?: number
    AND?: invCategoriesWhereInput | invCategoriesWhereInput[]
    OR?: invCategoriesWhereInput[]
    NOT?: invCategoriesWhereInput | invCategoriesWhereInput[]
    categoryName?: StringNullableFilter<"invCategories"> | string | null
    iconID?: IntNullableFilter<"invCategories"> | number | null
    published?: BoolNullableFilter<"invCategories"> | boolean | null
  }, "categoryID">

  export type invCategoriesOrderByWithAggregationInput = {
    categoryID?: SortOrder
    categoryName?: SortOrderInput | SortOrder
    iconID?: SortOrderInput | SortOrder
    published?: SortOrderInput | SortOrder
    _count?: invCategoriesCountOrderByAggregateInput
    _avg?: invCategoriesAvgOrderByAggregateInput
    _max?: invCategoriesMaxOrderByAggregateInput
    _min?: invCategoriesMinOrderByAggregateInput
    _sum?: invCategoriesSumOrderByAggregateInput
  }

  export type invCategoriesScalarWhereWithAggregatesInput = {
    AND?: invCategoriesScalarWhereWithAggregatesInput | invCategoriesScalarWhereWithAggregatesInput[]
    OR?: invCategoriesScalarWhereWithAggregatesInput[]
    NOT?: invCategoriesScalarWhereWithAggregatesInput | invCategoriesScalarWhereWithAggregatesInput[]
    categoryID?: IntWithAggregatesFilter<"invCategories"> | number
    categoryName?: StringNullableWithAggregatesFilter<"invCategories"> | string | null
    iconID?: IntNullableWithAggregatesFilter<"invCategories"> | number | null
    published?: BoolNullableWithAggregatesFilter<"invCategories"> | boolean | null
  }

  export type invContrabandTypesWhereInput = {
    AND?: invContrabandTypesWhereInput | invContrabandTypesWhereInput[]
    OR?: invContrabandTypesWhereInput[]
    NOT?: invContrabandTypesWhereInput | invContrabandTypesWhereInput[]
    factionID?: IntFilter<"invContrabandTypes"> | number
    typeID?: IntFilter<"invContrabandTypes"> | number
    standingLoss?: FloatNullableFilter<"invContrabandTypes"> | number | null
    confiscateMinSec?: FloatNullableFilter<"invContrabandTypes"> | number | null
    fineByValue?: FloatNullableFilter<"invContrabandTypes"> | number | null
    attackMinSec?: FloatNullableFilter<"invContrabandTypes"> | number | null
  }

  export type invContrabandTypesOrderByWithRelationInput = {
    factionID?: SortOrder
    typeID?: SortOrder
    standingLoss?: SortOrderInput | SortOrder
    confiscateMinSec?: SortOrderInput | SortOrder
    fineByValue?: SortOrderInput | SortOrder
    attackMinSec?: SortOrderInput | SortOrder
  }

  export type invContrabandTypesWhereUniqueInput = Prisma.AtLeast<{
    factionID_typeID?: invContrabandTypesFactionIDTypeIDCompoundUniqueInput
    AND?: invContrabandTypesWhereInput | invContrabandTypesWhereInput[]
    OR?: invContrabandTypesWhereInput[]
    NOT?: invContrabandTypesWhereInput | invContrabandTypesWhereInput[]
    factionID?: IntFilter<"invContrabandTypes"> | number
    typeID?: IntFilter<"invContrabandTypes"> | number
    standingLoss?: FloatNullableFilter<"invContrabandTypes"> | number | null
    confiscateMinSec?: FloatNullableFilter<"invContrabandTypes"> | number | null
    fineByValue?: FloatNullableFilter<"invContrabandTypes"> | number | null
    attackMinSec?: FloatNullableFilter<"invContrabandTypes"> | number | null
  }, "factionID_typeID">

  export type invContrabandTypesOrderByWithAggregationInput = {
    factionID?: SortOrder
    typeID?: SortOrder
    standingLoss?: SortOrderInput | SortOrder
    confiscateMinSec?: SortOrderInput | SortOrder
    fineByValue?: SortOrderInput | SortOrder
    attackMinSec?: SortOrderInput | SortOrder
    _count?: invContrabandTypesCountOrderByAggregateInput
    _avg?: invContrabandTypesAvgOrderByAggregateInput
    _max?: invContrabandTypesMaxOrderByAggregateInput
    _min?: invContrabandTypesMinOrderByAggregateInput
    _sum?: invContrabandTypesSumOrderByAggregateInput
  }

  export type invContrabandTypesScalarWhereWithAggregatesInput = {
    AND?: invContrabandTypesScalarWhereWithAggregatesInput | invContrabandTypesScalarWhereWithAggregatesInput[]
    OR?: invContrabandTypesScalarWhereWithAggregatesInput[]
    NOT?: invContrabandTypesScalarWhereWithAggregatesInput | invContrabandTypesScalarWhereWithAggregatesInput[]
    factionID?: IntWithAggregatesFilter<"invContrabandTypes"> | number
    typeID?: IntWithAggregatesFilter<"invContrabandTypes"> | number
    standingLoss?: FloatNullableWithAggregatesFilter<"invContrabandTypes"> | number | null
    confiscateMinSec?: FloatNullableWithAggregatesFilter<"invContrabandTypes"> | number | null
    fineByValue?: FloatNullableWithAggregatesFilter<"invContrabandTypes"> | number | null
    attackMinSec?: FloatNullableWithAggregatesFilter<"invContrabandTypes"> | number | null
  }

  export type invControlTowerResourcePurposesWhereInput = {
    AND?: invControlTowerResourcePurposesWhereInput | invControlTowerResourcePurposesWhereInput[]
    OR?: invControlTowerResourcePurposesWhereInput[]
    NOT?: invControlTowerResourcePurposesWhereInput | invControlTowerResourcePurposesWhereInput[]
    purpose?: IntFilter<"invControlTowerResourcePurposes"> | number
    purposeText?: StringNullableFilter<"invControlTowerResourcePurposes"> | string | null
  }

  export type invControlTowerResourcePurposesOrderByWithRelationInput = {
    purpose?: SortOrder
    purposeText?: SortOrderInput | SortOrder
  }

  export type invControlTowerResourcePurposesWhereUniqueInput = Prisma.AtLeast<{
    purpose?: number
    AND?: invControlTowerResourcePurposesWhereInput | invControlTowerResourcePurposesWhereInput[]
    OR?: invControlTowerResourcePurposesWhereInput[]
    NOT?: invControlTowerResourcePurposesWhereInput | invControlTowerResourcePurposesWhereInput[]
    purposeText?: StringNullableFilter<"invControlTowerResourcePurposes"> | string | null
  }, "purpose">

  export type invControlTowerResourcePurposesOrderByWithAggregationInput = {
    purpose?: SortOrder
    purposeText?: SortOrderInput | SortOrder
    _count?: invControlTowerResourcePurposesCountOrderByAggregateInput
    _avg?: invControlTowerResourcePurposesAvgOrderByAggregateInput
    _max?: invControlTowerResourcePurposesMaxOrderByAggregateInput
    _min?: invControlTowerResourcePurposesMinOrderByAggregateInput
    _sum?: invControlTowerResourcePurposesSumOrderByAggregateInput
  }

  export type invControlTowerResourcePurposesScalarWhereWithAggregatesInput = {
    AND?: invControlTowerResourcePurposesScalarWhereWithAggregatesInput | invControlTowerResourcePurposesScalarWhereWithAggregatesInput[]
    OR?: invControlTowerResourcePurposesScalarWhereWithAggregatesInput[]
    NOT?: invControlTowerResourcePurposesScalarWhereWithAggregatesInput | invControlTowerResourcePurposesScalarWhereWithAggregatesInput[]
    purpose?: IntWithAggregatesFilter<"invControlTowerResourcePurposes"> | number
    purposeText?: StringNullableWithAggregatesFilter<"invControlTowerResourcePurposes"> | string | null
  }

  export type invControlTowerResourcesWhereInput = {
    AND?: invControlTowerResourcesWhereInput | invControlTowerResourcesWhereInput[]
    OR?: invControlTowerResourcesWhereInput[]
    NOT?: invControlTowerResourcesWhereInput | invControlTowerResourcesWhereInput[]
    controlTowerTypeID?: IntFilter<"invControlTowerResources"> | number
    resourceTypeID?: IntFilter<"invControlTowerResources"> | number
    purpose?: IntNullableFilter<"invControlTowerResources"> | number | null
    quantity?: IntNullableFilter<"invControlTowerResources"> | number | null
    minSecurityLevel?: FloatNullableFilter<"invControlTowerResources"> | number | null
    factionID?: IntNullableFilter<"invControlTowerResources"> | number | null
  }

  export type invControlTowerResourcesOrderByWithRelationInput = {
    controlTowerTypeID?: SortOrder
    resourceTypeID?: SortOrder
    purpose?: SortOrderInput | SortOrder
    quantity?: SortOrderInput | SortOrder
    minSecurityLevel?: SortOrderInput | SortOrder
    factionID?: SortOrderInput | SortOrder
  }

  export type invControlTowerResourcesWhereUniqueInput = Prisma.AtLeast<{
    controlTowerTypeID_resourceTypeID?: invControlTowerResourcesControlTowerTypeIDResourceTypeIDCompoundUniqueInput
    AND?: invControlTowerResourcesWhereInput | invControlTowerResourcesWhereInput[]
    OR?: invControlTowerResourcesWhereInput[]
    NOT?: invControlTowerResourcesWhereInput | invControlTowerResourcesWhereInput[]
    controlTowerTypeID?: IntFilter<"invControlTowerResources"> | number
    resourceTypeID?: IntFilter<"invControlTowerResources"> | number
    purpose?: IntNullableFilter<"invControlTowerResources"> | number | null
    quantity?: IntNullableFilter<"invControlTowerResources"> | number | null
    minSecurityLevel?: FloatNullableFilter<"invControlTowerResources"> | number | null
    factionID?: IntNullableFilter<"invControlTowerResources"> | number | null
  }, "controlTowerTypeID_resourceTypeID">

  export type invControlTowerResourcesOrderByWithAggregationInput = {
    controlTowerTypeID?: SortOrder
    resourceTypeID?: SortOrder
    purpose?: SortOrderInput | SortOrder
    quantity?: SortOrderInput | SortOrder
    minSecurityLevel?: SortOrderInput | SortOrder
    factionID?: SortOrderInput | SortOrder
    _count?: invControlTowerResourcesCountOrderByAggregateInput
    _avg?: invControlTowerResourcesAvgOrderByAggregateInput
    _max?: invControlTowerResourcesMaxOrderByAggregateInput
    _min?: invControlTowerResourcesMinOrderByAggregateInput
    _sum?: invControlTowerResourcesSumOrderByAggregateInput
  }

  export type invControlTowerResourcesScalarWhereWithAggregatesInput = {
    AND?: invControlTowerResourcesScalarWhereWithAggregatesInput | invControlTowerResourcesScalarWhereWithAggregatesInput[]
    OR?: invControlTowerResourcesScalarWhereWithAggregatesInput[]
    NOT?: invControlTowerResourcesScalarWhereWithAggregatesInput | invControlTowerResourcesScalarWhereWithAggregatesInput[]
    controlTowerTypeID?: IntWithAggregatesFilter<"invControlTowerResources"> | number
    resourceTypeID?: IntWithAggregatesFilter<"invControlTowerResources"> | number
    purpose?: IntNullableWithAggregatesFilter<"invControlTowerResources"> | number | null
    quantity?: IntNullableWithAggregatesFilter<"invControlTowerResources"> | number | null
    minSecurityLevel?: FloatNullableWithAggregatesFilter<"invControlTowerResources"> | number | null
    factionID?: IntNullableWithAggregatesFilter<"invControlTowerResources"> | number | null
  }

  export type invFlagsWhereInput = {
    AND?: invFlagsWhereInput | invFlagsWhereInput[]
    OR?: invFlagsWhereInput[]
    NOT?: invFlagsWhereInput | invFlagsWhereInput[]
    flagID?: IntFilter<"invFlags"> | number
    flagName?: StringNullableFilter<"invFlags"> | string | null
    flagText?: StringNullableFilter<"invFlags"> | string | null
    orderID?: IntNullableFilter<"invFlags"> | number | null
  }

  export type invFlagsOrderByWithRelationInput = {
    flagID?: SortOrder
    flagName?: SortOrderInput | SortOrder
    flagText?: SortOrderInput | SortOrder
    orderID?: SortOrderInput | SortOrder
  }

  export type invFlagsWhereUniqueInput = Prisma.AtLeast<{
    flagID?: number
    AND?: invFlagsWhereInput | invFlagsWhereInput[]
    OR?: invFlagsWhereInput[]
    NOT?: invFlagsWhereInput | invFlagsWhereInput[]
    flagName?: StringNullableFilter<"invFlags"> | string | null
    flagText?: StringNullableFilter<"invFlags"> | string | null
    orderID?: IntNullableFilter<"invFlags"> | number | null
  }, "flagID">

  export type invFlagsOrderByWithAggregationInput = {
    flagID?: SortOrder
    flagName?: SortOrderInput | SortOrder
    flagText?: SortOrderInput | SortOrder
    orderID?: SortOrderInput | SortOrder
    _count?: invFlagsCountOrderByAggregateInput
    _avg?: invFlagsAvgOrderByAggregateInput
    _max?: invFlagsMaxOrderByAggregateInput
    _min?: invFlagsMinOrderByAggregateInput
    _sum?: invFlagsSumOrderByAggregateInput
  }

  export type invFlagsScalarWhereWithAggregatesInput = {
    AND?: invFlagsScalarWhereWithAggregatesInput | invFlagsScalarWhereWithAggregatesInput[]
    OR?: invFlagsScalarWhereWithAggregatesInput[]
    NOT?: invFlagsScalarWhereWithAggregatesInput | invFlagsScalarWhereWithAggregatesInput[]
    flagID?: IntWithAggregatesFilter<"invFlags"> | number
    flagName?: StringNullableWithAggregatesFilter<"invFlags"> | string | null
    flagText?: StringNullableWithAggregatesFilter<"invFlags"> | string | null
    orderID?: IntNullableWithAggregatesFilter<"invFlags"> | number | null
  }

  export type invGroupsWhereInput = {
    AND?: invGroupsWhereInput | invGroupsWhereInput[]
    OR?: invGroupsWhereInput[]
    NOT?: invGroupsWhereInput | invGroupsWhereInput[]
    groupID?: IntFilter<"invGroups"> | number
    categoryID?: IntNullableFilter<"invGroups"> | number | null
    groupName?: StringNullableFilter<"invGroups"> | string | null
    iconID?: IntNullableFilter<"invGroups"> | number | null
    useBasePrice?: BoolNullableFilter<"invGroups"> | boolean | null
    anchored?: BoolNullableFilter<"invGroups"> | boolean | null
    anchorable?: BoolNullableFilter<"invGroups"> | boolean | null
    fittableNonSingleton?: BoolNullableFilter<"invGroups"> | boolean | null
    published?: BoolNullableFilter<"invGroups"> | boolean | null
  }

  export type invGroupsOrderByWithRelationInput = {
    groupID?: SortOrder
    categoryID?: SortOrderInput | SortOrder
    groupName?: SortOrderInput | SortOrder
    iconID?: SortOrderInput | SortOrder
    useBasePrice?: SortOrderInput | SortOrder
    anchored?: SortOrderInput | SortOrder
    anchorable?: SortOrderInput | SortOrder
    fittableNonSingleton?: SortOrderInput | SortOrder
    published?: SortOrderInput | SortOrder
  }

  export type invGroupsWhereUniqueInput = Prisma.AtLeast<{
    groupID?: number
    AND?: invGroupsWhereInput | invGroupsWhereInput[]
    OR?: invGroupsWhereInput[]
    NOT?: invGroupsWhereInput | invGroupsWhereInput[]
    categoryID?: IntNullableFilter<"invGroups"> | number | null
    groupName?: StringNullableFilter<"invGroups"> | string | null
    iconID?: IntNullableFilter<"invGroups"> | number | null
    useBasePrice?: BoolNullableFilter<"invGroups"> | boolean | null
    anchored?: BoolNullableFilter<"invGroups"> | boolean | null
    anchorable?: BoolNullableFilter<"invGroups"> | boolean | null
    fittableNonSingleton?: BoolNullableFilter<"invGroups"> | boolean | null
    published?: BoolNullableFilter<"invGroups"> | boolean | null
  }, "groupID">

  export type invGroupsOrderByWithAggregationInput = {
    groupID?: SortOrder
    categoryID?: SortOrderInput | SortOrder
    groupName?: SortOrderInput | SortOrder
    iconID?: SortOrderInput | SortOrder
    useBasePrice?: SortOrderInput | SortOrder
    anchored?: SortOrderInput | SortOrder
    anchorable?: SortOrderInput | SortOrder
    fittableNonSingleton?: SortOrderInput | SortOrder
    published?: SortOrderInput | SortOrder
    _count?: invGroupsCountOrderByAggregateInput
    _avg?: invGroupsAvgOrderByAggregateInput
    _max?: invGroupsMaxOrderByAggregateInput
    _min?: invGroupsMinOrderByAggregateInput
    _sum?: invGroupsSumOrderByAggregateInput
  }

  export type invGroupsScalarWhereWithAggregatesInput = {
    AND?: invGroupsScalarWhereWithAggregatesInput | invGroupsScalarWhereWithAggregatesInput[]
    OR?: invGroupsScalarWhereWithAggregatesInput[]
    NOT?: invGroupsScalarWhereWithAggregatesInput | invGroupsScalarWhereWithAggregatesInput[]
    groupID?: IntWithAggregatesFilter<"invGroups"> | number
    categoryID?: IntNullableWithAggregatesFilter<"invGroups"> | number | null
    groupName?: StringNullableWithAggregatesFilter<"invGroups"> | string | null
    iconID?: IntNullableWithAggregatesFilter<"invGroups"> | number | null
    useBasePrice?: BoolNullableWithAggregatesFilter<"invGroups"> | boolean | null
    anchored?: BoolNullableWithAggregatesFilter<"invGroups"> | boolean | null
    anchorable?: BoolNullableWithAggregatesFilter<"invGroups"> | boolean | null
    fittableNonSingleton?: BoolNullableWithAggregatesFilter<"invGroups"> | boolean | null
    published?: BoolNullableWithAggregatesFilter<"invGroups"> | boolean | null
  }

  export type invItemsWhereInput = {
    AND?: invItemsWhereInput | invItemsWhereInput[]
    OR?: invItemsWhereInput[]
    NOT?: invItemsWhereInput | invItemsWhereInput[]
    itemID?: IntFilter<"invItems"> | number
    typeID?: IntFilter<"invItems"> | number
    ownerID?: IntFilter<"invItems"> | number
    locationID?: IntFilter<"invItems"> | number
    flagID?: IntFilter<"invItems"> | number
    quantity?: IntFilter<"invItems"> | number
  }

  export type invItemsOrderByWithRelationInput = {
    itemID?: SortOrder
    typeID?: SortOrder
    ownerID?: SortOrder
    locationID?: SortOrder
    flagID?: SortOrder
    quantity?: SortOrder
  }

  export type invItemsWhereUniqueInput = Prisma.AtLeast<{
    itemID?: number
    AND?: invItemsWhereInput | invItemsWhereInput[]
    OR?: invItemsWhereInput[]
    NOT?: invItemsWhereInput | invItemsWhereInput[]
    typeID?: IntFilter<"invItems"> | number
    ownerID?: IntFilter<"invItems"> | number
    locationID?: IntFilter<"invItems"> | number
    flagID?: IntFilter<"invItems"> | number
    quantity?: IntFilter<"invItems"> | number
  }, "itemID">

  export type invItemsOrderByWithAggregationInput = {
    itemID?: SortOrder
    typeID?: SortOrder
    ownerID?: SortOrder
    locationID?: SortOrder
    flagID?: SortOrder
    quantity?: SortOrder
    _count?: invItemsCountOrderByAggregateInput
    _avg?: invItemsAvgOrderByAggregateInput
    _max?: invItemsMaxOrderByAggregateInput
    _min?: invItemsMinOrderByAggregateInput
    _sum?: invItemsSumOrderByAggregateInput
  }

  export type invItemsScalarWhereWithAggregatesInput = {
    AND?: invItemsScalarWhereWithAggregatesInput | invItemsScalarWhereWithAggregatesInput[]
    OR?: invItemsScalarWhereWithAggregatesInput[]
    NOT?: invItemsScalarWhereWithAggregatesInput | invItemsScalarWhereWithAggregatesInput[]
    itemID?: IntWithAggregatesFilter<"invItems"> | number
    typeID?: IntWithAggregatesFilter<"invItems"> | number
    ownerID?: IntWithAggregatesFilter<"invItems"> | number
    locationID?: IntWithAggregatesFilter<"invItems"> | number
    flagID?: IntWithAggregatesFilter<"invItems"> | number
    quantity?: IntWithAggregatesFilter<"invItems"> | number
  }

  export type invMarketGroupsWhereInput = {
    AND?: invMarketGroupsWhereInput | invMarketGroupsWhereInput[]
    OR?: invMarketGroupsWhereInput[]
    NOT?: invMarketGroupsWhereInput | invMarketGroupsWhereInput[]
    marketGroupID?: IntFilter<"invMarketGroups"> | number
    parentGroupID?: IntNullableFilter<"invMarketGroups"> | number | null
    marketGroupName?: StringNullableFilter<"invMarketGroups"> | string | null
    description?: StringNullableFilter<"invMarketGroups"> | string | null
    iconID?: IntNullableFilter<"invMarketGroups"> | number | null
    hasTypes?: BoolNullableFilter<"invMarketGroups"> | boolean | null
  }

  export type invMarketGroupsOrderByWithRelationInput = {
    marketGroupID?: SortOrder
    parentGroupID?: SortOrderInput | SortOrder
    marketGroupName?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    iconID?: SortOrderInput | SortOrder
    hasTypes?: SortOrderInput | SortOrder
  }

  export type invMarketGroupsWhereUniqueInput = Prisma.AtLeast<{
    marketGroupID?: number
    AND?: invMarketGroupsWhereInput | invMarketGroupsWhereInput[]
    OR?: invMarketGroupsWhereInput[]
    NOT?: invMarketGroupsWhereInput | invMarketGroupsWhereInput[]
    parentGroupID?: IntNullableFilter<"invMarketGroups"> | number | null
    marketGroupName?: StringNullableFilter<"invMarketGroups"> | string | null
    description?: StringNullableFilter<"invMarketGroups"> | string | null
    iconID?: IntNullableFilter<"invMarketGroups"> | number | null
    hasTypes?: BoolNullableFilter<"invMarketGroups"> | boolean | null
  }, "marketGroupID">

  export type invMarketGroupsOrderByWithAggregationInput = {
    marketGroupID?: SortOrder
    parentGroupID?: SortOrderInput | SortOrder
    marketGroupName?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    iconID?: SortOrderInput | SortOrder
    hasTypes?: SortOrderInput | SortOrder
    _count?: invMarketGroupsCountOrderByAggregateInput
    _avg?: invMarketGroupsAvgOrderByAggregateInput
    _max?: invMarketGroupsMaxOrderByAggregateInput
    _min?: invMarketGroupsMinOrderByAggregateInput
    _sum?: invMarketGroupsSumOrderByAggregateInput
  }

  export type invMarketGroupsScalarWhereWithAggregatesInput = {
    AND?: invMarketGroupsScalarWhereWithAggregatesInput | invMarketGroupsScalarWhereWithAggregatesInput[]
    OR?: invMarketGroupsScalarWhereWithAggregatesInput[]
    NOT?: invMarketGroupsScalarWhereWithAggregatesInput | invMarketGroupsScalarWhereWithAggregatesInput[]
    marketGroupID?: IntWithAggregatesFilter<"invMarketGroups"> | number
    parentGroupID?: IntNullableWithAggregatesFilter<"invMarketGroups"> | number | null
    marketGroupName?: StringNullableWithAggregatesFilter<"invMarketGroups"> | string | null
    description?: StringNullableWithAggregatesFilter<"invMarketGroups"> | string | null
    iconID?: IntNullableWithAggregatesFilter<"invMarketGroups"> | number | null
    hasTypes?: BoolNullableWithAggregatesFilter<"invMarketGroups"> | boolean | null
  }

  export type invMetaGroupsWhereInput = {
    AND?: invMetaGroupsWhereInput | invMetaGroupsWhereInput[]
    OR?: invMetaGroupsWhereInput[]
    NOT?: invMetaGroupsWhereInput | invMetaGroupsWhereInput[]
    metaGroupID?: IntFilter<"invMetaGroups"> | number
    metaGroupName?: StringNullableFilter<"invMetaGroups"> | string | null
    description?: StringNullableFilter<"invMetaGroups"> | string | null
    iconID?: IntNullableFilter<"invMetaGroups"> | number | null
  }

  export type invMetaGroupsOrderByWithRelationInput = {
    metaGroupID?: SortOrder
    metaGroupName?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    iconID?: SortOrderInput | SortOrder
  }

  export type invMetaGroupsWhereUniqueInput = Prisma.AtLeast<{
    metaGroupID?: number
    AND?: invMetaGroupsWhereInput | invMetaGroupsWhereInput[]
    OR?: invMetaGroupsWhereInput[]
    NOT?: invMetaGroupsWhereInput | invMetaGroupsWhereInput[]
    metaGroupName?: StringNullableFilter<"invMetaGroups"> | string | null
    description?: StringNullableFilter<"invMetaGroups"> | string | null
    iconID?: IntNullableFilter<"invMetaGroups"> | number | null
  }, "metaGroupID">

  export type invMetaGroupsOrderByWithAggregationInput = {
    metaGroupID?: SortOrder
    metaGroupName?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    iconID?: SortOrderInput | SortOrder
    _count?: invMetaGroupsCountOrderByAggregateInput
    _avg?: invMetaGroupsAvgOrderByAggregateInput
    _max?: invMetaGroupsMaxOrderByAggregateInput
    _min?: invMetaGroupsMinOrderByAggregateInput
    _sum?: invMetaGroupsSumOrderByAggregateInput
  }

  export type invMetaGroupsScalarWhereWithAggregatesInput = {
    AND?: invMetaGroupsScalarWhereWithAggregatesInput | invMetaGroupsScalarWhereWithAggregatesInput[]
    OR?: invMetaGroupsScalarWhereWithAggregatesInput[]
    NOT?: invMetaGroupsScalarWhereWithAggregatesInput | invMetaGroupsScalarWhereWithAggregatesInput[]
    metaGroupID?: IntWithAggregatesFilter<"invMetaGroups"> | number
    metaGroupName?: StringNullableWithAggregatesFilter<"invMetaGroups"> | string | null
    description?: StringNullableWithAggregatesFilter<"invMetaGroups"> | string | null
    iconID?: IntNullableWithAggregatesFilter<"invMetaGroups"> | number | null
  }

  export type invMetaTypesWhereInput = {
    AND?: invMetaTypesWhereInput | invMetaTypesWhereInput[]
    OR?: invMetaTypesWhereInput[]
    NOT?: invMetaTypesWhereInput | invMetaTypesWhereInput[]
    typeID?: IntFilter<"invMetaTypes"> | number
    parentTypeID?: IntNullableFilter<"invMetaTypes"> | number | null
    metaGroupID?: IntNullableFilter<"invMetaTypes"> | number | null
  }

  export type invMetaTypesOrderByWithRelationInput = {
    typeID?: SortOrder
    parentTypeID?: SortOrderInput | SortOrder
    metaGroupID?: SortOrderInput | SortOrder
  }

  export type invMetaTypesWhereUniqueInput = Prisma.AtLeast<{
    typeID?: number
    AND?: invMetaTypesWhereInput | invMetaTypesWhereInput[]
    OR?: invMetaTypesWhereInput[]
    NOT?: invMetaTypesWhereInput | invMetaTypesWhereInput[]
    parentTypeID?: IntNullableFilter<"invMetaTypes"> | number | null
    metaGroupID?: IntNullableFilter<"invMetaTypes"> | number | null
  }, "typeID">

  export type invMetaTypesOrderByWithAggregationInput = {
    typeID?: SortOrder
    parentTypeID?: SortOrderInput | SortOrder
    metaGroupID?: SortOrderInput | SortOrder
    _count?: invMetaTypesCountOrderByAggregateInput
    _avg?: invMetaTypesAvgOrderByAggregateInput
    _max?: invMetaTypesMaxOrderByAggregateInput
    _min?: invMetaTypesMinOrderByAggregateInput
    _sum?: invMetaTypesSumOrderByAggregateInput
  }

  export type invMetaTypesScalarWhereWithAggregatesInput = {
    AND?: invMetaTypesScalarWhereWithAggregatesInput | invMetaTypesScalarWhereWithAggregatesInput[]
    OR?: invMetaTypesScalarWhereWithAggregatesInput[]
    NOT?: invMetaTypesScalarWhereWithAggregatesInput | invMetaTypesScalarWhereWithAggregatesInput[]
    typeID?: IntWithAggregatesFilter<"invMetaTypes"> | number
    parentTypeID?: IntNullableWithAggregatesFilter<"invMetaTypes"> | number | null
    metaGroupID?: IntNullableWithAggregatesFilter<"invMetaTypes"> | number | null
  }

  export type invNamesWhereInput = {
    AND?: invNamesWhereInput | invNamesWhereInput[]
    OR?: invNamesWhereInput[]
    NOT?: invNamesWhereInput | invNamesWhereInput[]
    itemID?: IntFilter<"invNames"> | number
    itemName?: StringFilter<"invNames"> | string
  }

  export type invNamesOrderByWithRelationInput = {
    itemID?: SortOrder
    itemName?: SortOrder
  }

  export type invNamesWhereUniqueInput = Prisma.AtLeast<{
    itemID?: number
    AND?: invNamesWhereInput | invNamesWhereInput[]
    OR?: invNamesWhereInput[]
    NOT?: invNamesWhereInput | invNamesWhereInput[]
    itemName?: StringFilter<"invNames"> | string
  }, "itemID">

  export type invNamesOrderByWithAggregationInput = {
    itemID?: SortOrder
    itemName?: SortOrder
    _count?: invNamesCountOrderByAggregateInput
    _avg?: invNamesAvgOrderByAggregateInput
    _max?: invNamesMaxOrderByAggregateInput
    _min?: invNamesMinOrderByAggregateInput
    _sum?: invNamesSumOrderByAggregateInput
  }

  export type invNamesScalarWhereWithAggregatesInput = {
    AND?: invNamesScalarWhereWithAggregatesInput | invNamesScalarWhereWithAggregatesInput[]
    OR?: invNamesScalarWhereWithAggregatesInput[]
    NOT?: invNamesScalarWhereWithAggregatesInput | invNamesScalarWhereWithAggregatesInput[]
    itemID?: IntWithAggregatesFilter<"invNames"> | number
    itemName?: StringWithAggregatesFilter<"invNames"> | string
  }

  export type invPositionsWhereInput = {
    AND?: invPositionsWhereInput | invPositionsWhereInput[]
    OR?: invPositionsWhereInput[]
    NOT?: invPositionsWhereInput | invPositionsWhereInput[]
    itemID?: IntFilter<"invPositions"> | number
    x?: FloatFilter<"invPositions"> | number
    y?: FloatFilter<"invPositions"> | number
    z?: FloatFilter<"invPositions"> | number
    yaw?: FloatNullableFilter<"invPositions"> | number | null
    pitch?: FloatNullableFilter<"invPositions"> | number | null
    roll?: FloatNullableFilter<"invPositions"> | number | null
  }

  export type invPositionsOrderByWithRelationInput = {
    itemID?: SortOrder
    x?: SortOrder
    y?: SortOrder
    z?: SortOrder
    yaw?: SortOrderInput | SortOrder
    pitch?: SortOrderInput | SortOrder
    roll?: SortOrderInput | SortOrder
  }

  export type invPositionsWhereUniqueInput = Prisma.AtLeast<{
    itemID?: number
    AND?: invPositionsWhereInput | invPositionsWhereInput[]
    OR?: invPositionsWhereInput[]
    NOT?: invPositionsWhereInput | invPositionsWhereInput[]
    x?: FloatFilter<"invPositions"> | number
    y?: FloatFilter<"invPositions"> | number
    z?: FloatFilter<"invPositions"> | number
    yaw?: FloatNullableFilter<"invPositions"> | number | null
    pitch?: FloatNullableFilter<"invPositions"> | number | null
    roll?: FloatNullableFilter<"invPositions"> | number | null
  }, "itemID">

  export type invPositionsOrderByWithAggregationInput = {
    itemID?: SortOrder
    x?: SortOrder
    y?: SortOrder
    z?: SortOrder
    yaw?: SortOrderInput | SortOrder
    pitch?: SortOrderInput | SortOrder
    roll?: SortOrderInput | SortOrder
    _count?: invPositionsCountOrderByAggregateInput
    _avg?: invPositionsAvgOrderByAggregateInput
    _max?: invPositionsMaxOrderByAggregateInput
    _min?: invPositionsMinOrderByAggregateInput
    _sum?: invPositionsSumOrderByAggregateInput
  }

  export type invPositionsScalarWhereWithAggregatesInput = {
    AND?: invPositionsScalarWhereWithAggregatesInput | invPositionsScalarWhereWithAggregatesInput[]
    OR?: invPositionsScalarWhereWithAggregatesInput[]
    NOT?: invPositionsScalarWhereWithAggregatesInput | invPositionsScalarWhereWithAggregatesInput[]
    itemID?: IntWithAggregatesFilter<"invPositions"> | number
    x?: FloatWithAggregatesFilter<"invPositions"> | number
    y?: FloatWithAggregatesFilter<"invPositions"> | number
    z?: FloatWithAggregatesFilter<"invPositions"> | number
    yaw?: FloatNullableWithAggregatesFilter<"invPositions"> | number | null
    pitch?: FloatNullableWithAggregatesFilter<"invPositions"> | number | null
    roll?: FloatNullableWithAggregatesFilter<"invPositions"> | number | null
  }

  export type invTraitsWhereInput = {
    AND?: invTraitsWhereInput | invTraitsWhereInput[]
    OR?: invTraitsWhereInput[]
    NOT?: invTraitsWhereInput | invTraitsWhereInput[]
    traitID?: IntFilter<"invTraits"> | number
    typeID?: IntNullableFilter<"invTraits"> | number | null
    skillID?: IntNullableFilter<"invTraits"> | number | null
    bonus?: FloatNullableFilter<"invTraits"> | number | null
    bonusText?: StringNullableFilter<"invTraits"> | string | null
    unitID?: IntNullableFilter<"invTraits"> | number | null
  }

  export type invTraitsOrderByWithRelationInput = {
    traitID?: SortOrder
    typeID?: SortOrderInput | SortOrder
    skillID?: SortOrderInput | SortOrder
    bonus?: SortOrderInput | SortOrder
    bonusText?: SortOrderInput | SortOrder
    unitID?: SortOrderInput | SortOrder
  }

  export type invTraitsWhereUniqueInput = Prisma.AtLeast<{
    traitID?: number
    AND?: invTraitsWhereInput | invTraitsWhereInput[]
    OR?: invTraitsWhereInput[]
    NOT?: invTraitsWhereInput | invTraitsWhereInput[]
    typeID?: IntNullableFilter<"invTraits"> | number | null
    skillID?: IntNullableFilter<"invTraits"> | number | null
    bonus?: FloatNullableFilter<"invTraits"> | number | null
    bonusText?: StringNullableFilter<"invTraits"> | string | null
    unitID?: IntNullableFilter<"invTraits"> | number | null
  }, "traitID">

  export type invTraitsOrderByWithAggregationInput = {
    traitID?: SortOrder
    typeID?: SortOrderInput | SortOrder
    skillID?: SortOrderInput | SortOrder
    bonus?: SortOrderInput | SortOrder
    bonusText?: SortOrderInput | SortOrder
    unitID?: SortOrderInput | SortOrder
    _count?: invTraitsCountOrderByAggregateInput
    _avg?: invTraitsAvgOrderByAggregateInput
    _max?: invTraitsMaxOrderByAggregateInput
    _min?: invTraitsMinOrderByAggregateInput
    _sum?: invTraitsSumOrderByAggregateInput
  }

  export type invTraitsScalarWhereWithAggregatesInput = {
    AND?: invTraitsScalarWhereWithAggregatesInput | invTraitsScalarWhereWithAggregatesInput[]
    OR?: invTraitsScalarWhereWithAggregatesInput[]
    NOT?: invTraitsScalarWhereWithAggregatesInput | invTraitsScalarWhereWithAggregatesInput[]
    traitID?: IntWithAggregatesFilter<"invTraits"> | number
    typeID?: IntNullableWithAggregatesFilter<"invTraits"> | number | null
    skillID?: IntNullableWithAggregatesFilter<"invTraits"> | number | null
    bonus?: FloatNullableWithAggregatesFilter<"invTraits"> | number | null
    bonusText?: StringNullableWithAggregatesFilter<"invTraits"> | string | null
    unitID?: IntNullableWithAggregatesFilter<"invTraits"> | number | null
  }

  export type invTypeMaterialsWhereInput = {
    AND?: invTypeMaterialsWhereInput | invTypeMaterialsWhereInput[]
    OR?: invTypeMaterialsWhereInput[]
    NOT?: invTypeMaterialsWhereInput | invTypeMaterialsWhereInput[]
    typeID?: IntFilter<"invTypeMaterials"> | number
    materialTypeID?: IntFilter<"invTypeMaterials"> | number
    quantity?: IntFilter<"invTypeMaterials"> | number
  }

  export type invTypeMaterialsOrderByWithRelationInput = {
    typeID?: SortOrder
    materialTypeID?: SortOrder
    quantity?: SortOrder
  }

  export type invTypeMaterialsWhereUniqueInput = Prisma.AtLeast<{
    typeID_materialTypeID?: invTypeMaterialsTypeIDMaterialTypeIDCompoundUniqueInput
    AND?: invTypeMaterialsWhereInput | invTypeMaterialsWhereInput[]
    OR?: invTypeMaterialsWhereInput[]
    NOT?: invTypeMaterialsWhereInput | invTypeMaterialsWhereInput[]
    typeID?: IntFilter<"invTypeMaterials"> | number
    materialTypeID?: IntFilter<"invTypeMaterials"> | number
    quantity?: IntFilter<"invTypeMaterials"> | number
  }, "typeID_materialTypeID">

  export type invTypeMaterialsOrderByWithAggregationInput = {
    typeID?: SortOrder
    materialTypeID?: SortOrder
    quantity?: SortOrder
    _count?: invTypeMaterialsCountOrderByAggregateInput
    _avg?: invTypeMaterialsAvgOrderByAggregateInput
    _max?: invTypeMaterialsMaxOrderByAggregateInput
    _min?: invTypeMaterialsMinOrderByAggregateInput
    _sum?: invTypeMaterialsSumOrderByAggregateInput
  }

  export type invTypeMaterialsScalarWhereWithAggregatesInput = {
    AND?: invTypeMaterialsScalarWhereWithAggregatesInput | invTypeMaterialsScalarWhereWithAggregatesInput[]
    OR?: invTypeMaterialsScalarWhereWithAggregatesInput[]
    NOT?: invTypeMaterialsScalarWhereWithAggregatesInput | invTypeMaterialsScalarWhereWithAggregatesInput[]
    typeID?: IntWithAggregatesFilter<"invTypeMaterials"> | number
    materialTypeID?: IntWithAggregatesFilter<"invTypeMaterials"> | number
    quantity?: IntWithAggregatesFilter<"invTypeMaterials"> | number
  }

  export type invTypeReactionsWhereInput = {
    AND?: invTypeReactionsWhereInput | invTypeReactionsWhereInput[]
    OR?: invTypeReactionsWhereInput[]
    NOT?: invTypeReactionsWhereInput | invTypeReactionsWhereInput[]
    reactionTypeID?: IntFilter<"invTypeReactions"> | number
    input?: BoolFilter<"invTypeReactions"> | boolean
    typeID?: IntFilter<"invTypeReactions"> | number
    quantity?: IntNullableFilter<"invTypeReactions"> | number | null
  }

  export type invTypeReactionsOrderByWithRelationInput = {
    reactionTypeID?: SortOrder
    input?: SortOrder
    typeID?: SortOrder
    quantity?: SortOrderInput | SortOrder
  }

  export type invTypeReactionsWhereUniqueInput = Prisma.AtLeast<{
    reactionTypeID_input_typeID?: invTypeReactionsReactionTypeIDInputTypeIDCompoundUniqueInput
    AND?: invTypeReactionsWhereInput | invTypeReactionsWhereInput[]
    OR?: invTypeReactionsWhereInput[]
    NOT?: invTypeReactionsWhereInput | invTypeReactionsWhereInput[]
    reactionTypeID?: IntFilter<"invTypeReactions"> | number
    input?: BoolFilter<"invTypeReactions"> | boolean
    typeID?: IntFilter<"invTypeReactions"> | number
    quantity?: IntNullableFilter<"invTypeReactions"> | number | null
  }, "reactionTypeID_input_typeID">

  export type invTypeReactionsOrderByWithAggregationInput = {
    reactionTypeID?: SortOrder
    input?: SortOrder
    typeID?: SortOrder
    quantity?: SortOrderInput | SortOrder
    _count?: invTypeReactionsCountOrderByAggregateInput
    _avg?: invTypeReactionsAvgOrderByAggregateInput
    _max?: invTypeReactionsMaxOrderByAggregateInput
    _min?: invTypeReactionsMinOrderByAggregateInput
    _sum?: invTypeReactionsSumOrderByAggregateInput
  }

  export type invTypeReactionsScalarWhereWithAggregatesInput = {
    AND?: invTypeReactionsScalarWhereWithAggregatesInput | invTypeReactionsScalarWhereWithAggregatesInput[]
    OR?: invTypeReactionsScalarWhereWithAggregatesInput[]
    NOT?: invTypeReactionsScalarWhereWithAggregatesInput | invTypeReactionsScalarWhereWithAggregatesInput[]
    reactionTypeID?: IntWithAggregatesFilter<"invTypeReactions"> | number
    input?: BoolWithAggregatesFilter<"invTypeReactions"> | boolean
    typeID?: IntWithAggregatesFilter<"invTypeReactions"> | number
    quantity?: IntNullableWithAggregatesFilter<"invTypeReactions"> | number | null
  }

  export type invTypesWhereInput = {
    AND?: invTypesWhereInput | invTypesWhereInput[]
    OR?: invTypesWhereInput[]
    NOT?: invTypesWhereInput | invTypesWhereInput[]
    typeID?: IntFilter<"invTypes"> | number
    groupID?: IntNullableFilter<"invTypes"> | number | null
    typeName?: StringNullableFilter<"invTypes"> | string | null
    description?: StringNullableFilter<"invTypes"> | string | null
    mass?: FloatNullableFilter<"invTypes"> | number | null
    volume?: FloatNullableFilter<"invTypes"> | number | null
    capacity?: FloatNullableFilter<"invTypes"> | number | null
    portionSize?: IntNullableFilter<"invTypes"> | number | null
    raceID?: IntNullableFilter<"invTypes"> | number | null
    basePrice?: DecimalNullableFilter<"invTypes"> | Decimal | DecimalJsLike | number | string | null
    published?: BoolNullableFilter<"invTypes"> | boolean | null
    marketGroupID?: IntNullableFilter<"invTypes"> | number | null
    iconID?: IntNullableFilter<"invTypes"> | number | null
    soundID?: IntNullableFilter<"invTypes"> | number | null
    graphicID?: IntNullableFilter<"invTypes"> | number | null
  }

  export type invTypesOrderByWithRelationInput = {
    typeID?: SortOrder
    groupID?: SortOrderInput | SortOrder
    typeName?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    mass?: SortOrderInput | SortOrder
    volume?: SortOrderInput | SortOrder
    capacity?: SortOrderInput | SortOrder
    portionSize?: SortOrderInput | SortOrder
    raceID?: SortOrderInput | SortOrder
    basePrice?: SortOrderInput | SortOrder
    published?: SortOrderInput | SortOrder
    marketGroupID?: SortOrderInput | SortOrder
    iconID?: SortOrderInput | SortOrder
    soundID?: SortOrderInput | SortOrder
    graphicID?: SortOrderInput | SortOrder
  }

  export type invTypesWhereUniqueInput = Prisma.AtLeast<{
    typeID?: number
    AND?: invTypesWhereInput | invTypesWhereInput[]
    OR?: invTypesWhereInput[]
    NOT?: invTypesWhereInput | invTypesWhereInput[]
    groupID?: IntNullableFilter<"invTypes"> | number | null
    typeName?: StringNullableFilter<"invTypes"> | string | null
    description?: StringNullableFilter<"invTypes"> | string | null
    mass?: FloatNullableFilter<"invTypes"> | number | null
    volume?: FloatNullableFilter<"invTypes"> | number | null
    capacity?: FloatNullableFilter<"invTypes"> | number | null
    portionSize?: IntNullableFilter<"invTypes"> | number | null
    raceID?: IntNullableFilter<"invTypes"> | number | null
    basePrice?: DecimalNullableFilter<"invTypes"> | Decimal | DecimalJsLike | number | string | null
    published?: BoolNullableFilter<"invTypes"> | boolean | null
    marketGroupID?: IntNullableFilter<"invTypes"> | number | null
    iconID?: IntNullableFilter<"invTypes"> | number | null
    soundID?: IntNullableFilter<"invTypes"> | number | null
    graphicID?: IntNullableFilter<"invTypes"> | number | null
  }, "typeID">

  export type invTypesOrderByWithAggregationInput = {
    typeID?: SortOrder
    groupID?: SortOrderInput | SortOrder
    typeName?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    mass?: SortOrderInput | SortOrder
    volume?: SortOrderInput | SortOrder
    capacity?: SortOrderInput | SortOrder
    portionSize?: SortOrderInput | SortOrder
    raceID?: SortOrderInput | SortOrder
    basePrice?: SortOrderInput | SortOrder
    published?: SortOrderInput | SortOrder
    marketGroupID?: SortOrderInput | SortOrder
    iconID?: SortOrderInput | SortOrder
    soundID?: SortOrderInput | SortOrder
    graphicID?: SortOrderInput | SortOrder
    _count?: invTypesCountOrderByAggregateInput
    _avg?: invTypesAvgOrderByAggregateInput
    _max?: invTypesMaxOrderByAggregateInput
    _min?: invTypesMinOrderByAggregateInput
    _sum?: invTypesSumOrderByAggregateInput
  }

  export type invTypesScalarWhereWithAggregatesInput = {
    AND?: invTypesScalarWhereWithAggregatesInput | invTypesScalarWhereWithAggregatesInput[]
    OR?: invTypesScalarWhereWithAggregatesInput[]
    NOT?: invTypesScalarWhereWithAggregatesInput | invTypesScalarWhereWithAggregatesInput[]
    typeID?: IntWithAggregatesFilter<"invTypes"> | number
    groupID?: IntNullableWithAggregatesFilter<"invTypes"> | number | null
    typeName?: StringNullableWithAggregatesFilter<"invTypes"> | string | null
    description?: StringNullableWithAggregatesFilter<"invTypes"> | string | null
    mass?: FloatNullableWithAggregatesFilter<"invTypes"> | number | null
    volume?: FloatNullableWithAggregatesFilter<"invTypes"> | number | null
    capacity?: FloatNullableWithAggregatesFilter<"invTypes"> | number | null
    portionSize?: IntNullableWithAggregatesFilter<"invTypes"> | number | null
    raceID?: IntNullableWithAggregatesFilter<"invTypes"> | number | null
    basePrice?: DecimalNullableWithAggregatesFilter<"invTypes"> | Decimal | DecimalJsLike | number | string | null
    published?: BoolNullableWithAggregatesFilter<"invTypes"> | boolean | null
    marketGroupID?: IntNullableWithAggregatesFilter<"invTypes"> | number | null
    iconID?: IntNullableWithAggregatesFilter<"invTypes"> | number | null
    soundID?: IntNullableWithAggregatesFilter<"invTypes"> | number | null
    graphicID?: IntNullableWithAggregatesFilter<"invTypes"> | number | null
  }

  export type invUniqueNamesWhereInput = {
    AND?: invUniqueNamesWhereInput | invUniqueNamesWhereInput[]
    OR?: invUniqueNamesWhereInput[]
    NOT?: invUniqueNamesWhereInput | invUniqueNamesWhereInput[]
    itemID?: IntFilter<"invUniqueNames"> | number
    itemName?: StringFilter<"invUniqueNames"> | string
    groupID?: IntNullableFilter<"invUniqueNames"> | number | null
  }

  export type invUniqueNamesOrderByWithRelationInput = {
    itemID?: SortOrder
    itemName?: SortOrder
    groupID?: SortOrderInput | SortOrder
  }

  export type invUniqueNamesWhereUniqueInput = Prisma.AtLeast<{
    itemID?: number
    itemName?: string
    AND?: invUniqueNamesWhereInput | invUniqueNamesWhereInput[]
    OR?: invUniqueNamesWhereInput[]
    NOT?: invUniqueNamesWhereInput | invUniqueNamesWhereInput[]
    groupID?: IntNullableFilter<"invUniqueNames"> | number | null
  }, "itemID" | "itemName">

  export type invUniqueNamesOrderByWithAggregationInput = {
    itemID?: SortOrder
    itemName?: SortOrder
    groupID?: SortOrderInput | SortOrder
    _count?: invUniqueNamesCountOrderByAggregateInput
    _avg?: invUniqueNamesAvgOrderByAggregateInput
    _max?: invUniqueNamesMaxOrderByAggregateInput
    _min?: invUniqueNamesMinOrderByAggregateInput
    _sum?: invUniqueNamesSumOrderByAggregateInput
  }

  export type invUniqueNamesScalarWhereWithAggregatesInput = {
    AND?: invUniqueNamesScalarWhereWithAggregatesInput | invUniqueNamesScalarWhereWithAggregatesInput[]
    OR?: invUniqueNamesScalarWhereWithAggregatesInput[]
    NOT?: invUniqueNamesScalarWhereWithAggregatesInput | invUniqueNamesScalarWhereWithAggregatesInput[]
    itemID?: IntWithAggregatesFilter<"invUniqueNames"> | number
    itemName?: StringWithAggregatesFilter<"invUniqueNames"> | string
    groupID?: IntNullableWithAggregatesFilter<"invUniqueNames"> | number | null
  }

  export type invVolumesWhereInput = {
    AND?: invVolumesWhereInput | invVolumesWhereInput[]
    OR?: invVolumesWhereInput[]
    NOT?: invVolumesWhereInput | invVolumesWhereInput[]
    typeID?: IntFilter<"invVolumes"> | number
    volume?: IntNullableFilter<"invVolumes"> | number | null
  }

  export type invVolumesOrderByWithRelationInput = {
    typeID?: SortOrder
    volume?: SortOrderInput | SortOrder
  }

  export type invVolumesWhereUniqueInput = Prisma.AtLeast<{
    typeID?: number
    AND?: invVolumesWhereInput | invVolumesWhereInput[]
    OR?: invVolumesWhereInput[]
    NOT?: invVolumesWhereInput | invVolumesWhereInput[]
    volume?: IntNullableFilter<"invVolumes"> | number | null
  }, "typeID">

  export type invVolumesOrderByWithAggregationInput = {
    typeID?: SortOrder
    volume?: SortOrderInput | SortOrder
    _count?: invVolumesCountOrderByAggregateInput
    _avg?: invVolumesAvgOrderByAggregateInput
    _max?: invVolumesMaxOrderByAggregateInput
    _min?: invVolumesMinOrderByAggregateInput
    _sum?: invVolumesSumOrderByAggregateInput
  }

  export type invVolumesScalarWhereWithAggregatesInput = {
    AND?: invVolumesScalarWhereWithAggregatesInput | invVolumesScalarWhereWithAggregatesInput[]
    OR?: invVolumesScalarWhereWithAggregatesInput[]
    NOT?: invVolumesScalarWhereWithAggregatesInput | invVolumesScalarWhereWithAggregatesInput[]
    typeID?: IntWithAggregatesFilter<"invVolumes"> | number
    volume?: IntNullableWithAggregatesFilter<"invVolumes"> | number | null
  }

  export type mapCelestialGraphicsWhereInput = {
    AND?: mapCelestialGraphicsWhereInput | mapCelestialGraphicsWhereInput[]
    OR?: mapCelestialGraphicsWhereInput[]
    NOT?: mapCelestialGraphicsWhereInput | mapCelestialGraphicsWhereInput[]
    celestialID?: IntFilter<"mapCelestialGraphics"> | number
    heightMap1?: IntNullableFilter<"mapCelestialGraphics"> | number | null
    heightMap2?: IntNullableFilter<"mapCelestialGraphics"> | number | null
    shaderPreset?: IntNullableFilter<"mapCelestialGraphics"> | number | null
    population?: BoolNullableFilter<"mapCelestialGraphics"> | boolean | null
  }

  export type mapCelestialGraphicsOrderByWithRelationInput = {
    celestialID?: SortOrder
    heightMap1?: SortOrderInput | SortOrder
    heightMap2?: SortOrderInput | SortOrder
    shaderPreset?: SortOrderInput | SortOrder
    population?: SortOrderInput | SortOrder
  }

  export type mapCelestialGraphicsWhereUniqueInput = Prisma.AtLeast<{
    celestialID?: number
    AND?: mapCelestialGraphicsWhereInput | mapCelestialGraphicsWhereInput[]
    OR?: mapCelestialGraphicsWhereInput[]
    NOT?: mapCelestialGraphicsWhereInput | mapCelestialGraphicsWhereInput[]
    heightMap1?: IntNullableFilter<"mapCelestialGraphics"> | number | null
    heightMap2?: IntNullableFilter<"mapCelestialGraphics"> | number | null
    shaderPreset?: IntNullableFilter<"mapCelestialGraphics"> | number | null
    population?: BoolNullableFilter<"mapCelestialGraphics"> | boolean | null
  }, "celestialID">

  export type mapCelestialGraphicsOrderByWithAggregationInput = {
    celestialID?: SortOrder
    heightMap1?: SortOrderInput | SortOrder
    heightMap2?: SortOrderInput | SortOrder
    shaderPreset?: SortOrderInput | SortOrder
    population?: SortOrderInput | SortOrder
    _count?: mapCelestialGraphicsCountOrderByAggregateInput
    _avg?: mapCelestialGraphicsAvgOrderByAggregateInput
    _max?: mapCelestialGraphicsMaxOrderByAggregateInput
    _min?: mapCelestialGraphicsMinOrderByAggregateInput
    _sum?: mapCelestialGraphicsSumOrderByAggregateInput
  }

  export type mapCelestialGraphicsScalarWhereWithAggregatesInput = {
    AND?: mapCelestialGraphicsScalarWhereWithAggregatesInput | mapCelestialGraphicsScalarWhereWithAggregatesInput[]
    OR?: mapCelestialGraphicsScalarWhereWithAggregatesInput[]
    NOT?: mapCelestialGraphicsScalarWhereWithAggregatesInput | mapCelestialGraphicsScalarWhereWithAggregatesInput[]
    celestialID?: IntWithAggregatesFilter<"mapCelestialGraphics"> | number
    heightMap1?: IntNullableWithAggregatesFilter<"mapCelestialGraphics"> | number | null
    heightMap2?: IntNullableWithAggregatesFilter<"mapCelestialGraphics"> | number | null
    shaderPreset?: IntNullableWithAggregatesFilter<"mapCelestialGraphics"> | number | null
    population?: BoolNullableWithAggregatesFilter<"mapCelestialGraphics"> | boolean | null
  }

  export type mapCelestialStatisticsWhereInput = {
    AND?: mapCelestialStatisticsWhereInput | mapCelestialStatisticsWhereInput[]
    OR?: mapCelestialStatisticsWhereInput[]
    NOT?: mapCelestialStatisticsWhereInput | mapCelestialStatisticsWhereInput[]
    celestialID?: IntFilter<"mapCelestialStatistics"> | number
    temperature?: FloatNullableFilter<"mapCelestialStatistics"> | number | null
    spectralClass?: StringNullableFilter<"mapCelestialStatistics"> | string | null
    luminosity?: FloatNullableFilter<"mapCelestialStatistics"> | number | null
    age?: FloatNullableFilter<"mapCelestialStatistics"> | number | null
    life?: FloatNullableFilter<"mapCelestialStatistics"> | number | null
    orbitRadius?: FloatNullableFilter<"mapCelestialStatistics"> | number | null
    eccentricity?: FloatNullableFilter<"mapCelestialStatistics"> | number | null
    massDust?: FloatNullableFilter<"mapCelestialStatistics"> | number | null
    massGas?: FloatNullableFilter<"mapCelestialStatistics"> | number | null
    fragmented?: BoolNullableFilter<"mapCelestialStatistics"> | boolean | null
    density?: FloatNullableFilter<"mapCelestialStatistics"> | number | null
    surfaceGravity?: FloatNullableFilter<"mapCelestialStatistics"> | number | null
    escapeVelocity?: FloatNullableFilter<"mapCelestialStatistics"> | number | null
    orbitPeriod?: FloatNullableFilter<"mapCelestialStatistics"> | number | null
    rotationRate?: FloatNullableFilter<"mapCelestialStatistics"> | number | null
    locked?: BoolNullableFilter<"mapCelestialStatistics"> | boolean | null
    pressure?: FloatNullableFilter<"mapCelestialStatistics"> | number | null
    radius?: FloatNullableFilter<"mapCelestialStatistics"> | number | null
    mass?: IntNullableFilter<"mapCelestialStatistics"> | number | null
  }

  export type mapCelestialStatisticsOrderByWithRelationInput = {
    celestialID?: SortOrder
    temperature?: SortOrderInput | SortOrder
    spectralClass?: SortOrderInput | SortOrder
    luminosity?: SortOrderInput | SortOrder
    age?: SortOrderInput | SortOrder
    life?: SortOrderInput | SortOrder
    orbitRadius?: SortOrderInput | SortOrder
    eccentricity?: SortOrderInput | SortOrder
    massDust?: SortOrderInput | SortOrder
    massGas?: SortOrderInput | SortOrder
    fragmented?: SortOrderInput | SortOrder
    density?: SortOrderInput | SortOrder
    surfaceGravity?: SortOrderInput | SortOrder
    escapeVelocity?: SortOrderInput | SortOrder
    orbitPeriod?: SortOrderInput | SortOrder
    rotationRate?: SortOrderInput | SortOrder
    locked?: SortOrderInput | SortOrder
    pressure?: SortOrderInput | SortOrder
    radius?: SortOrderInput | SortOrder
    mass?: SortOrderInput | SortOrder
  }

  export type mapCelestialStatisticsWhereUniqueInput = Prisma.AtLeast<{
    celestialID?: number
    AND?: mapCelestialStatisticsWhereInput | mapCelestialStatisticsWhereInput[]
    OR?: mapCelestialStatisticsWhereInput[]
    NOT?: mapCelestialStatisticsWhereInput | mapCelestialStatisticsWhereInput[]
    temperature?: FloatNullableFilter<"mapCelestialStatistics"> | number | null
    spectralClass?: StringNullableFilter<"mapCelestialStatistics"> | string | null
    luminosity?: FloatNullableFilter<"mapCelestialStatistics"> | number | null
    age?: FloatNullableFilter<"mapCelestialStatistics"> | number | null
    life?: FloatNullableFilter<"mapCelestialStatistics"> | number | null
    orbitRadius?: FloatNullableFilter<"mapCelestialStatistics"> | number | null
    eccentricity?: FloatNullableFilter<"mapCelestialStatistics"> | number | null
    massDust?: FloatNullableFilter<"mapCelestialStatistics"> | number | null
    massGas?: FloatNullableFilter<"mapCelestialStatistics"> | number | null
    fragmented?: BoolNullableFilter<"mapCelestialStatistics"> | boolean | null
    density?: FloatNullableFilter<"mapCelestialStatistics"> | number | null
    surfaceGravity?: FloatNullableFilter<"mapCelestialStatistics"> | number | null
    escapeVelocity?: FloatNullableFilter<"mapCelestialStatistics"> | number | null
    orbitPeriod?: FloatNullableFilter<"mapCelestialStatistics"> | number | null
    rotationRate?: FloatNullableFilter<"mapCelestialStatistics"> | number | null
    locked?: BoolNullableFilter<"mapCelestialStatistics"> | boolean | null
    pressure?: FloatNullableFilter<"mapCelestialStatistics"> | number | null
    radius?: FloatNullableFilter<"mapCelestialStatistics"> | number | null
    mass?: IntNullableFilter<"mapCelestialStatistics"> | number | null
  }, "celestialID">

  export type mapCelestialStatisticsOrderByWithAggregationInput = {
    celestialID?: SortOrder
    temperature?: SortOrderInput | SortOrder
    spectralClass?: SortOrderInput | SortOrder
    luminosity?: SortOrderInput | SortOrder
    age?: SortOrderInput | SortOrder
    life?: SortOrderInput | SortOrder
    orbitRadius?: SortOrderInput | SortOrder
    eccentricity?: SortOrderInput | SortOrder
    massDust?: SortOrderInput | SortOrder
    massGas?: SortOrderInput | SortOrder
    fragmented?: SortOrderInput | SortOrder
    density?: SortOrderInput | SortOrder
    surfaceGravity?: SortOrderInput | SortOrder
    escapeVelocity?: SortOrderInput | SortOrder
    orbitPeriod?: SortOrderInput | SortOrder
    rotationRate?: SortOrderInput | SortOrder
    locked?: SortOrderInput | SortOrder
    pressure?: SortOrderInput | SortOrder
    radius?: SortOrderInput | SortOrder
    mass?: SortOrderInput | SortOrder
    _count?: mapCelestialStatisticsCountOrderByAggregateInput
    _avg?: mapCelestialStatisticsAvgOrderByAggregateInput
    _max?: mapCelestialStatisticsMaxOrderByAggregateInput
    _min?: mapCelestialStatisticsMinOrderByAggregateInput
    _sum?: mapCelestialStatisticsSumOrderByAggregateInput
  }

  export type mapCelestialStatisticsScalarWhereWithAggregatesInput = {
    AND?: mapCelestialStatisticsScalarWhereWithAggregatesInput | mapCelestialStatisticsScalarWhereWithAggregatesInput[]
    OR?: mapCelestialStatisticsScalarWhereWithAggregatesInput[]
    NOT?: mapCelestialStatisticsScalarWhereWithAggregatesInput | mapCelestialStatisticsScalarWhereWithAggregatesInput[]
    celestialID?: IntWithAggregatesFilter<"mapCelestialStatistics"> | number
    temperature?: FloatNullableWithAggregatesFilter<"mapCelestialStatistics"> | number | null
    spectralClass?: StringNullableWithAggregatesFilter<"mapCelestialStatistics"> | string | null
    luminosity?: FloatNullableWithAggregatesFilter<"mapCelestialStatistics"> | number | null
    age?: FloatNullableWithAggregatesFilter<"mapCelestialStatistics"> | number | null
    life?: FloatNullableWithAggregatesFilter<"mapCelestialStatistics"> | number | null
    orbitRadius?: FloatNullableWithAggregatesFilter<"mapCelestialStatistics"> | number | null
    eccentricity?: FloatNullableWithAggregatesFilter<"mapCelestialStatistics"> | number | null
    massDust?: FloatNullableWithAggregatesFilter<"mapCelestialStatistics"> | number | null
    massGas?: FloatNullableWithAggregatesFilter<"mapCelestialStatistics"> | number | null
    fragmented?: BoolNullableWithAggregatesFilter<"mapCelestialStatistics"> | boolean | null
    density?: FloatNullableWithAggregatesFilter<"mapCelestialStatistics"> | number | null
    surfaceGravity?: FloatNullableWithAggregatesFilter<"mapCelestialStatistics"> | number | null
    escapeVelocity?: FloatNullableWithAggregatesFilter<"mapCelestialStatistics"> | number | null
    orbitPeriod?: FloatNullableWithAggregatesFilter<"mapCelestialStatistics"> | number | null
    rotationRate?: FloatNullableWithAggregatesFilter<"mapCelestialStatistics"> | number | null
    locked?: BoolNullableWithAggregatesFilter<"mapCelestialStatistics"> | boolean | null
    pressure?: FloatNullableWithAggregatesFilter<"mapCelestialStatistics"> | number | null
    radius?: FloatNullableWithAggregatesFilter<"mapCelestialStatistics"> | number | null
    mass?: IntNullableWithAggregatesFilter<"mapCelestialStatistics"> | number | null
  }

  export type mapConstellationJumpsWhereInput = {
    AND?: mapConstellationJumpsWhereInput | mapConstellationJumpsWhereInput[]
    OR?: mapConstellationJumpsWhereInput[]
    NOT?: mapConstellationJumpsWhereInput | mapConstellationJumpsWhereInput[]
    fromRegionID?: IntNullableFilter<"mapConstellationJumps"> | number | null
    fromConstellationID?: IntFilter<"mapConstellationJumps"> | number
    toConstellationID?: IntFilter<"mapConstellationJumps"> | number
    toRegionID?: IntNullableFilter<"mapConstellationJumps"> | number | null
  }

  export type mapConstellationJumpsOrderByWithRelationInput = {
    fromRegionID?: SortOrderInput | SortOrder
    fromConstellationID?: SortOrder
    toConstellationID?: SortOrder
    toRegionID?: SortOrderInput | SortOrder
  }

  export type mapConstellationJumpsWhereUniqueInput = Prisma.AtLeast<{
    fromConstellationID_toConstellationID?: mapConstellationJumpsFromConstellationIDToConstellationIDCompoundUniqueInput
    AND?: mapConstellationJumpsWhereInput | mapConstellationJumpsWhereInput[]
    OR?: mapConstellationJumpsWhereInput[]
    NOT?: mapConstellationJumpsWhereInput | mapConstellationJumpsWhereInput[]
    fromRegionID?: IntNullableFilter<"mapConstellationJumps"> | number | null
    fromConstellationID?: IntFilter<"mapConstellationJumps"> | number
    toConstellationID?: IntFilter<"mapConstellationJumps"> | number
    toRegionID?: IntNullableFilter<"mapConstellationJumps"> | number | null
  }, "fromConstellationID_toConstellationID">

  export type mapConstellationJumpsOrderByWithAggregationInput = {
    fromRegionID?: SortOrderInput | SortOrder
    fromConstellationID?: SortOrder
    toConstellationID?: SortOrder
    toRegionID?: SortOrderInput | SortOrder
    _count?: mapConstellationJumpsCountOrderByAggregateInput
    _avg?: mapConstellationJumpsAvgOrderByAggregateInput
    _max?: mapConstellationJumpsMaxOrderByAggregateInput
    _min?: mapConstellationJumpsMinOrderByAggregateInput
    _sum?: mapConstellationJumpsSumOrderByAggregateInput
  }

  export type mapConstellationJumpsScalarWhereWithAggregatesInput = {
    AND?: mapConstellationJumpsScalarWhereWithAggregatesInput | mapConstellationJumpsScalarWhereWithAggregatesInput[]
    OR?: mapConstellationJumpsScalarWhereWithAggregatesInput[]
    NOT?: mapConstellationJumpsScalarWhereWithAggregatesInput | mapConstellationJumpsScalarWhereWithAggregatesInput[]
    fromRegionID?: IntNullableWithAggregatesFilter<"mapConstellationJumps"> | number | null
    fromConstellationID?: IntWithAggregatesFilter<"mapConstellationJumps"> | number
    toConstellationID?: IntWithAggregatesFilter<"mapConstellationJumps"> | number
    toRegionID?: IntNullableWithAggregatesFilter<"mapConstellationJumps"> | number | null
  }

  export type mapConstellationsWhereInput = {
    AND?: mapConstellationsWhereInput | mapConstellationsWhereInput[]
    OR?: mapConstellationsWhereInput[]
    NOT?: mapConstellationsWhereInput | mapConstellationsWhereInput[]
    regionID?: IntNullableFilter<"mapConstellations"> | number | null
    constellationID?: IntFilter<"mapConstellations"> | number
    constellationName?: StringNullableFilter<"mapConstellations"> | string | null
    x?: FloatNullableFilter<"mapConstellations"> | number | null
    y?: FloatNullableFilter<"mapConstellations"> | number | null
    z?: FloatNullableFilter<"mapConstellations"> | number | null
    xMin?: FloatNullableFilter<"mapConstellations"> | number | null
    xMax?: FloatNullableFilter<"mapConstellations"> | number | null
    yMin?: FloatNullableFilter<"mapConstellations"> | number | null
    yMax?: FloatNullableFilter<"mapConstellations"> | number | null
    zMin?: FloatNullableFilter<"mapConstellations"> | number | null
    zMax?: FloatNullableFilter<"mapConstellations"> | number | null
    factionID?: IntNullableFilter<"mapConstellations"> | number | null
    radius?: FloatNullableFilter<"mapConstellations"> | number | null
  }

  export type mapConstellationsOrderByWithRelationInput = {
    regionID?: SortOrderInput | SortOrder
    constellationID?: SortOrder
    constellationName?: SortOrderInput | SortOrder
    x?: SortOrderInput | SortOrder
    y?: SortOrderInput | SortOrder
    z?: SortOrderInput | SortOrder
    xMin?: SortOrderInput | SortOrder
    xMax?: SortOrderInput | SortOrder
    yMin?: SortOrderInput | SortOrder
    yMax?: SortOrderInput | SortOrder
    zMin?: SortOrderInput | SortOrder
    zMax?: SortOrderInput | SortOrder
    factionID?: SortOrderInput | SortOrder
    radius?: SortOrderInput | SortOrder
  }

  export type mapConstellationsWhereUniqueInput = Prisma.AtLeast<{
    constellationID?: number
    AND?: mapConstellationsWhereInput | mapConstellationsWhereInput[]
    OR?: mapConstellationsWhereInput[]
    NOT?: mapConstellationsWhereInput | mapConstellationsWhereInput[]
    regionID?: IntNullableFilter<"mapConstellations"> | number | null
    constellationName?: StringNullableFilter<"mapConstellations"> | string | null
    x?: FloatNullableFilter<"mapConstellations"> | number | null
    y?: FloatNullableFilter<"mapConstellations"> | number | null
    z?: FloatNullableFilter<"mapConstellations"> | number | null
    xMin?: FloatNullableFilter<"mapConstellations"> | number | null
    xMax?: FloatNullableFilter<"mapConstellations"> | number | null
    yMin?: FloatNullableFilter<"mapConstellations"> | number | null
    yMax?: FloatNullableFilter<"mapConstellations"> | number | null
    zMin?: FloatNullableFilter<"mapConstellations"> | number | null
    zMax?: FloatNullableFilter<"mapConstellations"> | number | null
    factionID?: IntNullableFilter<"mapConstellations"> | number | null
    radius?: FloatNullableFilter<"mapConstellations"> | number | null
  }, "constellationID">

  export type mapConstellationsOrderByWithAggregationInput = {
    regionID?: SortOrderInput | SortOrder
    constellationID?: SortOrder
    constellationName?: SortOrderInput | SortOrder
    x?: SortOrderInput | SortOrder
    y?: SortOrderInput | SortOrder
    z?: SortOrderInput | SortOrder
    xMin?: SortOrderInput | SortOrder
    xMax?: SortOrderInput | SortOrder
    yMin?: SortOrderInput | SortOrder
    yMax?: SortOrderInput | SortOrder
    zMin?: SortOrderInput | SortOrder
    zMax?: SortOrderInput | SortOrder
    factionID?: SortOrderInput | SortOrder
    radius?: SortOrderInput | SortOrder
    _count?: mapConstellationsCountOrderByAggregateInput
    _avg?: mapConstellationsAvgOrderByAggregateInput
    _max?: mapConstellationsMaxOrderByAggregateInput
    _min?: mapConstellationsMinOrderByAggregateInput
    _sum?: mapConstellationsSumOrderByAggregateInput
  }

  export type mapConstellationsScalarWhereWithAggregatesInput = {
    AND?: mapConstellationsScalarWhereWithAggregatesInput | mapConstellationsScalarWhereWithAggregatesInput[]
    OR?: mapConstellationsScalarWhereWithAggregatesInput[]
    NOT?: mapConstellationsScalarWhereWithAggregatesInput | mapConstellationsScalarWhereWithAggregatesInput[]
    regionID?: IntNullableWithAggregatesFilter<"mapConstellations"> | number | null
    constellationID?: IntWithAggregatesFilter<"mapConstellations"> | number
    constellationName?: StringNullableWithAggregatesFilter<"mapConstellations"> | string | null
    x?: FloatNullableWithAggregatesFilter<"mapConstellations"> | number | null
    y?: FloatNullableWithAggregatesFilter<"mapConstellations"> | number | null
    z?: FloatNullableWithAggregatesFilter<"mapConstellations"> | number | null
    xMin?: FloatNullableWithAggregatesFilter<"mapConstellations"> | number | null
    xMax?: FloatNullableWithAggregatesFilter<"mapConstellations"> | number | null
    yMin?: FloatNullableWithAggregatesFilter<"mapConstellations"> | number | null
    yMax?: FloatNullableWithAggregatesFilter<"mapConstellations"> | number | null
    zMin?: FloatNullableWithAggregatesFilter<"mapConstellations"> | number | null
    zMax?: FloatNullableWithAggregatesFilter<"mapConstellations"> | number | null
    factionID?: IntNullableWithAggregatesFilter<"mapConstellations"> | number | null
    radius?: FloatNullableWithAggregatesFilter<"mapConstellations"> | number | null
  }

  export type mapDenormalizeWhereInput = {
    AND?: mapDenormalizeWhereInput | mapDenormalizeWhereInput[]
    OR?: mapDenormalizeWhereInput[]
    NOT?: mapDenormalizeWhereInput | mapDenormalizeWhereInput[]
    itemID?: IntFilter<"mapDenormalize"> | number
    typeID?: IntNullableFilter<"mapDenormalize"> | number | null
    groupID?: IntNullableFilter<"mapDenormalize"> | number | null
    solarSystemID?: IntNullableFilter<"mapDenormalize"> | number | null
    constellationID?: IntNullableFilter<"mapDenormalize"> | number | null
    regionID?: IntNullableFilter<"mapDenormalize"> | number | null
    orbitID?: IntNullableFilter<"mapDenormalize"> | number | null
    x?: FloatNullableFilter<"mapDenormalize"> | number | null
    y?: FloatNullableFilter<"mapDenormalize"> | number | null
    z?: FloatNullableFilter<"mapDenormalize"> | number | null
    radius?: FloatNullableFilter<"mapDenormalize"> | number | null
    itemName?: StringNullableFilter<"mapDenormalize"> | string | null
    security?: FloatNullableFilter<"mapDenormalize"> | number | null
    celestialIndex?: IntNullableFilter<"mapDenormalize"> | number | null
    orbitIndex?: IntNullableFilter<"mapDenormalize"> | number | null
  }

  export type mapDenormalizeOrderByWithRelationInput = {
    itemID?: SortOrder
    typeID?: SortOrderInput | SortOrder
    groupID?: SortOrderInput | SortOrder
    solarSystemID?: SortOrderInput | SortOrder
    constellationID?: SortOrderInput | SortOrder
    regionID?: SortOrderInput | SortOrder
    orbitID?: SortOrderInput | SortOrder
    x?: SortOrderInput | SortOrder
    y?: SortOrderInput | SortOrder
    z?: SortOrderInput | SortOrder
    radius?: SortOrderInput | SortOrder
    itemName?: SortOrderInput | SortOrder
    security?: SortOrderInput | SortOrder
    celestialIndex?: SortOrderInput | SortOrder
    orbitIndex?: SortOrderInput | SortOrder
  }

  export type mapDenormalizeWhereUniqueInput = Prisma.AtLeast<{
    itemID?: number
    AND?: mapDenormalizeWhereInput | mapDenormalizeWhereInput[]
    OR?: mapDenormalizeWhereInput[]
    NOT?: mapDenormalizeWhereInput | mapDenormalizeWhereInput[]
    typeID?: IntNullableFilter<"mapDenormalize"> | number | null
    groupID?: IntNullableFilter<"mapDenormalize"> | number | null
    solarSystemID?: IntNullableFilter<"mapDenormalize"> | number | null
    constellationID?: IntNullableFilter<"mapDenormalize"> | number | null
    regionID?: IntNullableFilter<"mapDenormalize"> | number | null
    orbitID?: IntNullableFilter<"mapDenormalize"> | number | null
    x?: FloatNullableFilter<"mapDenormalize"> | number | null
    y?: FloatNullableFilter<"mapDenormalize"> | number | null
    z?: FloatNullableFilter<"mapDenormalize"> | number | null
    radius?: FloatNullableFilter<"mapDenormalize"> | number | null
    itemName?: StringNullableFilter<"mapDenormalize"> | string | null
    security?: FloatNullableFilter<"mapDenormalize"> | number | null
    celestialIndex?: IntNullableFilter<"mapDenormalize"> | number | null
    orbitIndex?: IntNullableFilter<"mapDenormalize"> | number | null
  }, "itemID">

  export type mapDenormalizeOrderByWithAggregationInput = {
    itemID?: SortOrder
    typeID?: SortOrderInput | SortOrder
    groupID?: SortOrderInput | SortOrder
    solarSystemID?: SortOrderInput | SortOrder
    constellationID?: SortOrderInput | SortOrder
    regionID?: SortOrderInput | SortOrder
    orbitID?: SortOrderInput | SortOrder
    x?: SortOrderInput | SortOrder
    y?: SortOrderInput | SortOrder
    z?: SortOrderInput | SortOrder
    radius?: SortOrderInput | SortOrder
    itemName?: SortOrderInput | SortOrder
    security?: SortOrderInput | SortOrder
    celestialIndex?: SortOrderInput | SortOrder
    orbitIndex?: SortOrderInput | SortOrder
    _count?: mapDenormalizeCountOrderByAggregateInput
    _avg?: mapDenormalizeAvgOrderByAggregateInput
    _max?: mapDenormalizeMaxOrderByAggregateInput
    _min?: mapDenormalizeMinOrderByAggregateInput
    _sum?: mapDenormalizeSumOrderByAggregateInput
  }

  export type mapDenormalizeScalarWhereWithAggregatesInput = {
    AND?: mapDenormalizeScalarWhereWithAggregatesInput | mapDenormalizeScalarWhereWithAggregatesInput[]
    OR?: mapDenormalizeScalarWhereWithAggregatesInput[]
    NOT?: mapDenormalizeScalarWhereWithAggregatesInput | mapDenormalizeScalarWhereWithAggregatesInput[]
    itemID?: IntWithAggregatesFilter<"mapDenormalize"> | number
    typeID?: IntNullableWithAggregatesFilter<"mapDenormalize"> | number | null
    groupID?: IntNullableWithAggregatesFilter<"mapDenormalize"> | number | null
    solarSystemID?: IntNullableWithAggregatesFilter<"mapDenormalize"> | number | null
    constellationID?: IntNullableWithAggregatesFilter<"mapDenormalize"> | number | null
    regionID?: IntNullableWithAggregatesFilter<"mapDenormalize"> | number | null
    orbitID?: IntNullableWithAggregatesFilter<"mapDenormalize"> | number | null
    x?: FloatNullableWithAggregatesFilter<"mapDenormalize"> | number | null
    y?: FloatNullableWithAggregatesFilter<"mapDenormalize"> | number | null
    z?: FloatNullableWithAggregatesFilter<"mapDenormalize"> | number | null
    radius?: FloatNullableWithAggregatesFilter<"mapDenormalize"> | number | null
    itemName?: StringNullableWithAggregatesFilter<"mapDenormalize"> | string | null
    security?: FloatNullableWithAggregatesFilter<"mapDenormalize"> | number | null
    celestialIndex?: IntNullableWithAggregatesFilter<"mapDenormalize"> | number | null
    orbitIndex?: IntNullableWithAggregatesFilter<"mapDenormalize"> | number | null
  }

  export type mapJumpsWhereInput = {
    AND?: mapJumpsWhereInput | mapJumpsWhereInput[]
    OR?: mapJumpsWhereInput[]
    NOT?: mapJumpsWhereInput | mapJumpsWhereInput[]
    stargateID?: IntFilter<"mapJumps"> | number
    destinationID?: IntNullableFilter<"mapJumps"> | number | null
  }

  export type mapJumpsOrderByWithRelationInput = {
    stargateID?: SortOrder
    destinationID?: SortOrderInput | SortOrder
  }

  export type mapJumpsWhereUniqueInput = Prisma.AtLeast<{
    stargateID?: number
    AND?: mapJumpsWhereInput | mapJumpsWhereInput[]
    OR?: mapJumpsWhereInput[]
    NOT?: mapJumpsWhereInput | mapJumpsWhereInput[]
    destinationID?: IntNullableFilter<"mapJumps"> | number | null
  }, "stargateID">

  export type mapJumpsOrderByWithAggregationInput = {
    stargateID?: SortOrder
    destinationID?: SortOrderInput | SortOrder
    _count?: mapJumpsCountOrderByAggregateInput
    _avg?: mapJumpsAvgOrderByAggregateInput
    _max?: mapJumpsMaxOrderByAggregateInput
    _min?: mapJumpsMinOrderByAggregateInput
    _sum?: mapJumpsSumOrderByAggregateInput
  }

  export type mapJumpsScalarWhereWithAggregatesInput = {
    AND?: mapJumpsScalarWhereWithAggregatesInput | mapJumpsScalarWhereWithAggregatesInput[]
    OR?: mapJumpsScalarWhereWithAggregatesInput[]
    NOT?: mapJumpsScalarWhereWithAggregatesInput | mapJumpsScalarWhereWithAggregatesInput[]
    stargateID?: IntWithAggregatesFilter<"mapJumps"> | number
    destinationID?: IntNullableWithAggregatesFilter<"mapJumps"> | number | null
  }

  export type mapLandmarksWhereInput = {
    AND?: mapLandmarksWhereInput | mapLandmarksWhereInput[]
    OR?: mapLandmarksWhereInput[]
    NOT?: mapLandmarksWhereInput | mapLandmarksWhereInput[]
    landmarkID?: IntFilter<"mapLandmarks"> | number
    landmarkName?: StringNullableFilter<"mapLandmarks"> | string | null
    description?: StringNullableFilter<"mapLandmarks"> | string | null
    locationID?: IntNullableFilter<"mapLandmarks"> | number | null
    x?: FloatNullableFilter<"mapLandmarks"> | number | null
    y?: FloatNullableFilter<"mapLandmarks"> | number | null
    z?: FloatNullableFilter<"mapLandmarks"> | number | null
    iconID?: IntNullableFilter<"mapLandmarks"> | number | null
  }

  export type mapLandmarksOrderByWithRelationInput = {
    landmarkID?: SortOrder
    landmarkName?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    locationID?: SortOrderInput | SortOrder
    x?: SortOrderInput | SortOrder
    y?: SortOrderInput | SortOrder
    z?: SortOrderInput | SortOrder
    iconID?: SortOrderInput | SortOrder
  }

  export type mapLandmarksWhereUniqueInput = Prisma.AtLeast<{
    landmarkID?: number
    AND?: mapLandmarksWhereInput | mapLandmarksWhereInput[]
    OR?: mapLandmarksWhereInput[]
    NOT?: mapLandmarksWhereInput | mapLandmarksWhereInput[]
    landmarkName?: StringNullableFilter<"mapLandmarks"> | string | null
    description?: StringNullableFilter<"mapLandmarks"> | string | null
    locationID?: IntNullableFilter<"mapLandmarks"> | number | null
    x?: FloatNullableFilter<"mapLandmarks"> | number | null
    y?: FloatNullableFilter<"mapLandmarks"> | number | null
    z?: FloatNullableFilter<"mapLandmarks"> | number | null
    iconID?: IntNullableFilter<"mapLandmarks"> | number | null
  }, "landmarkID">

  export type mapLandmarksOrderByWithAggregationInput = {
    landmarkID?: SortOrder
    landmarkName?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    locationID?: SortOrderInput | SortOrder
    x?: SortOrderInput | SortOrder
    y?: SortOrderInput | SortOrder
    z?: SortOrderInput | SortOrder
    iconID?: SortOrderInput | SortOrder
    _count?: mapLandmarksCountOrderByAggregateInput
    _avg?: mapLandmarksAvgOrderByAggregateInput
    _max?: mapLandmarksMaxOrderByAggregateInput
    _min?: mapLandmarksMinOrderByAggregateInput
    _sum?: mapLandmarksSumOrderByAggregateInput
  }

  export type mapLandmarksScalarWhereWithAggregatesInput = {
    AND?: mapLandmarksScalarWhereWithAggregatesInput | mapLandmarksScalarWhereWithAggregatesInput[]
    OR?: mapLandmarksScalarWhereWithAggregatesInput[]
    NOT?: mapLandmarksScalarWhereWithAggregatesInput | mapLandmarksScalarWhereWithAggregatesInput[]
    landmarkID?: IntWithAggregatesFilter<"mapLandmarks"> | number
    landmarkName?: StringNullableWithAggregatesFilter<"mapLandmarks"> | string | null
    description?: StringNullableWithAggregatesFilter<"mapLandmarks"> | string | null
    locationID?: IntNullableWithAggregatesFilter<"mapLandmarks"> | number | null
    x?: FloatNullableWithAggregatesFilter<"mapLandmarks"> | number | null
    y?: FloatNullableWithAggregatesFilter<"mapLandmarks"> | number | null
    z?: FloatNullableWithAggregatesFilter<"mapLandmarks"> | number | null
    iconID?: IntNullableWithAggregatesFilter<"mapLandmarks"> | number | null
  }

  export type mapLocationScenesWhereInput = {
    AND?: mapLocationScenesWhereInput | mapLocationScenesWhereInput[]
    OR?: mapLocationScenesWhereInput[]
    NOT?: mapLocationScenesWhereInput | mapLocationScenesWhereInput[]
    locationID?: IntFilter<"mapLocationScenes"> | number
    graphicID?: IntNullableFilter<"mapLocationScenes"> | number | null
  }

  export type mapLocationScenesOrderByWithRelationInput = {
    locationID?: SortOrder
    graphicID?: SortOrderInput | SortOrder
  }

  export type mapLocationScenesWhereUniqueInput = Prisma.AtLeast<{
    locationID?: number
    AND?: mapLocationScenesWhereInput | mapLocationScenesWhereInput[]
    OR?: mapLocationScenesWhereInput[]
    NOT?: mapLocationScenesWhereInput | mapLocationScenesWhereInput[]
    graphicID?: IntNullableFilter<"mapLocationScenes"> | number | null
  }, "locationID">

  export type mapLocationScenesOrderByWithAggregationInput = {
    locationID?: SortOrder
    graphicID?: SortOrderInput | SortOrder
    _count?: mapLocationScenesCountOrderByAggregateInput
    _avg?: mapLocationScenesAvgOrderByAggregateInput
    _max?: mapLocationScenesMaxOrderByAggregateInput
    _min?: mapLocationScenesMinOrderByAggregateInput
    _sum?: mapLocationScenesSumOrderByAggregateInput
  }

  export type mapLocationScenesScalarWhereWithAggregatesInput = {
    AND?: mapLocationScenesScalarWhereWithAggregatesInput | mapLocationScenesScalarWhereWithAggregatesInput[]
    OR?: mapLocationScenesScalarWhereWithAggregatesInput[]
    NOT?: mapLocationScenesScalarWhereWithAggregatesInput | mapLocationScenesScalarWhereWithAggregatesInput[]
    locationID?: IntWithAggregatesFilter<"mapLocationScenes"> | number
    graphicID?: IntNullableWithAggregatesFilter<"mapLocationScenes"> | number | null
  }

  export type mapLocationWormholeClassesWhereInput = {
    AND?: mapLocationWormholeClassesWhereInput | mapLocationWormholeClassesWhereInput[]
    OR?: mapLocationWormholeClassesWhereInput[]
    NOT?: mapLocationWormholeClassesWhereInput | mapLocationWormholeClassesWhereInput[]
    locationID?: IntFilter<"mapLocationWormholeClasses"> | number
    wormholeClassID?: IntNullableFilter<"mapLocationWormholeClasses"> | number | null
  }

  export type mapLocationWormholeClassesOrderByWithRelationInput = {
    locationID?: SortOrder
    wormholeClassID?: SortOrderInput | SortOrder
  }

  export type mapLocationWormholeClassesWhereUniqueInput = Prisma.AtLeast<{
    locationID?: number
    AND?: mapLocationWormholeClassesWhereInput | mapLocationWormholeClassesWhereInput[]
    OR?: mapLocationWormholeClassesWhereInput[]
    NOT?: mapLocationWormholeClassesWhereInput | mapLocationWormholeClassesWhereInput[]
    wormholeClassID?: IntNullableFilter<"mapLocationWormholeClasses"> | number | null
  }, "locationID">

  export type mapLocationWormholeClassesOrderByWithAggregationInput = {
    locationID?: SortOrder
    wormholeClassID?: SortOrderInput | SortOrder
    _count?: mapLocationWormholeClassesCountOrderByAggregateInput
    _avg?: mapLocationWormholeClassesAvgOrderByAggregateInput
    _max?: mapLocationWormholeClassesMaxOrderByAggregateInput
    _min?: mapLocationWormholeClassesMinOrderByAggregateInput
    _sum?: mapLocationWormholeClassesSumOrderByAggregateInput
  }

  export type mapLocationWormholeClassesScalarWhereWithAggregatesInput = {
    AND?: mapLocationWormholeClassesScalarWhereWithAggregatesInput | mapLocationWormholeClassesScalarWhereWithAggregatesInput[]
    OR?: mapLocationWormholeClassesScalarWhereWithAggregatesInput[]
    NOT?: mapLocationWormholeClassesScalarWhereWithAggregatesInput | mapLocationWormholeClassesScalarWhereWithAggregatesInput[]
    locationID?: IntWithAggregatesFilter<"mapLocationWormholeClasses"> | number
    wormholeClassID?: IntNullableWithAggregatesFilter<"mapLocationWormholeClasses"> | number | null
  }

  export type mapRegionJumpsWhereInput = {
    AND?: mapRegionJumpsWhereInput | mapRegionJumpsWhereInput[]
    OR?: mapRegionJumpsWhereInput[]
    NOT?: mapRegionJumpsWhereInput | mapRegionJumpsWhereInput[]
    fromRegionID?: IntFilter<"mapRegionJumps"> | number
    toRegionID?: IntFilter<"mapRegionJumps"> | number
  }

  export type mapRegionJumpsOrderByWithRelationInput = {
    fromRegionID?: SortOrder
    toRegionID?: SortOrder
  }

  export type mapRegionJumpsWhereUniqueInput = Prisma.AtLeast<{
    fromRegionID_toRegionID?: mapRegionJumpsFromRegionIDToRegionIDCompoundUniqueInput
    AND?: mapRegionJumpsWhereInput | mapRegionJumpsWhereInput[]
    OR?: mapRegionJumpsWhereInput[]
    NOT?: mapRegionJumpsWhereInput | mapRegionJumpsWhereInput[]
    fromRegionID?: IntFilter<"mapRegionJumps"> | number
    toRegionID?: IntFilter<"mapRegionJumps"> | number
  }, "fromRegionID_toRegionID">

  export type mapRegionJumpsOrderByWithAggregationInput = {
    fromRegionID?: SortOrder
    toRegionID?: SortOrder
    _count?: mapRegionJumpsCountOrderByAggregateInput
    _avg?: mapRegionJumpsAvgOrderByAggregateInput
    _max?: mapRegionJumpsMaxOrderByAggregateInput
    _min?: mapRegionJumpsMinOrderByAggregateInput
    _sum?: mapRegionJumpsSumOrderByAggregateInput
  }

  export type mapRegionJumpsScalarWhereWithAggregatesInput = {
    AND?: mapRegionJumpsScalarWhereWithAggregatesInput | mapRegionJumpsScalarWhereWithAggregatesInput[]
    OR?: mapRegionJumpsScalarWhereWithAggregatesInput[]
    NOT?: mapRegionJumpsScalarWhereWithAggregatesInput | mapRegionJumpsScalarWhereWithAggregatesInput[]
    fromRegionID?: IntWithAggregatesFilter<"mapRegionJumps"> | number
    toRegionID?: IntWithAggregatesFilter<"mapRegionJumps"> | number
  }

  export type mapRegionsWhereInput = {
    AND?: mapRegionsWhereInput | mapRegionsWhereInput[]
    OR?: mapRegionsWhereInput[]
    NOT?: mapRegionsWhereInput | mapRegionsWhereInput[]
    regionID?: IntFilter<"mapRegions"> | number
    regionName?: StringNullableFilter<"mapRegions"> | string | null
    x?: FloatNullableFilter<"mapRegions"> | number | null
    y?: FloatNullableFilter<"mapRegions"> | number | null
    z?: FloatNullableFilter<"mapRegions"> | number | null
    xMin?: FloatNullableFilter<"mapRegions"> | number | null
    xMax?: FloatNullableFilter<"mapRegions"> | number | null
    yMin?: FloatNullableFilter<"mapRegions"> | number | null
    yMax?: FloatNullableFilter<"mapRegions"> | number | null
    zMin?: FloatNullableFilter<"mapRegions"> | number | null
    zMax?: FloatNullableFilter<"mapRegions"> | number | null
    factionID?: IntNullableFilter<"mapRegions"> | number | null
    nebula?: IntNullableFilter<"mapRegions"> | number | null
    radius?: FloatNullableFilter<"mapRegions"> | number | null
  }

  export type mapRegionsOrderByWithRelationInput = {
    regionID?: SortOrder
    regionName?: SortOrderInput | SortOrder
    x?: SortOrderInput | SortOrder
    y?: SortOrderInput | SortOrder
    z?: SortOrderInput | SortOrder
    xMin?: SortOrderInput | SortOrder
    xMax?: SortOrderInput | SortOrder
    yMin?: SortOrderInput | SortOrder
    yMax?: SortOrderInput | SortOrder
    zMin?: SortOrderInput | SortOrder
    zMax?: SortOrderInput | SortOrder
    factionID?: SortOrderInput | SortOrder
    nebula?: SortOrderInput | SortOrder
    radius?: SortOrderInput | SortOrder
  }

  export type mapRegionsWhereUniqueInput = Prisma.AtLeast<{
    regionID?: number
    AND?: mapRegionsWhereInput | mapRegionsWhereInput[]
    OR?: mapRegionsWhereInput[]
    NOT?: mapRegionsWhereInput | mapRegionsWhereInput[]
    regionName?: StringNullableFilter<"mapRegions"> | string | null
    x?: FloatNullableFilter<"mapRegions"> | number | null
    y?: FloatNullableFilter<"mapRegions"> | number | null
    z?: FloatNullableFilter<"mapRegions"> | number | null
    xMin?: FloatNullableFilter<"mapRegions"> | number | null
    xMax?: FloatNullableFilter<"mapRegions"> | number | null
    yMin?: FloatNullableFilter<"mapRegions"> | number | null
    yMax?: FloatNullableFilter<"mapRegions"> | number | null
    zMin?: FloatNullableFilter<"mapRegions"> | number | null
    zMax?: FloatNullableFilter<"mapRegions"> | number | null
    factionID?: IntNullableFilter<"mapRegions"> | number | null
    nebula?: IntNullableFilter<"mapRegions"> | number | null
    radius?: FloatNullableFilter<"mapRegions"> | number | null
  }, "regionID">

  export type mapRegionsOrderByWithAggregationInput = {
    regionID?: SortOrder
    regionName?: SortOrderInput | SortOrder
    x?: SortOrderInput | SortOrder
    y?: SortOrderInput | SortOrder
    z?: SortOrderInput | SortOrder
    xMin?: SortOrderInput | SortOrder
    xMax?: SortOrderInput | SortOrder
    yMin?: SortOrderInput | SortOrder
    yMax?: SortOrderInput | SortOrder
    zMin?: SortOrderInput | SortOrder
    zMax?: SortOrderInput | SortOrder
    factionID?: SortOrderInput | SortOrder
    nebula?: SortOrderInput | SortOrder
    radius?: SortOrderInput | SortOrder
    _count?: mapRegionsCountOrderByAggregateInput
    _avg?: mapRegionsAvgOrderByAggregateInput
    _max?: mapRegionsMaxOrderByAggregateInput
    _min?: mapRegionsMinOrderByAggregateInput
    _sum?: mapRegionsSumOrderByAggregateInput
  }

  export type mapRegionsScalarWhereWithAggregatesInput = {
    AND?: mapRegionsScalarWhereWithAggregatesInput | mapRegionsScalarWhereWithAggregatesInput[]
    OR?: mapRegionsScalarWhereWithAggregatesInput[]
    NOT?: mapRegionsScalarWhereWithAggregatesInput | mapRegionsScalarWhereWithAggregatesInput[]
    regionID?: IntWithAggregatesFilter<"mapRegions"> | number
    regionName?: StringNullableWithAggregatesFilter<"mapRegions"> | string | null
    x?: FloatNullableWithAggregatesFilter<"mapRegions"> | number | null
    y?: FloatNullableWithAggregatesFilter<"mapRegions"> | number | null
    z?: FloatNullableWithAggregatesFilter<"mapRegions"> | number | null
    xMin?: FloatNullableWithAggregatesFilter<"mapRegions"> | number | null
    xMax?: FloatNullableWithAggregatesFilter<"mapRegions"> | number | null
    yMin?: FloatNullableWithAggregatesFilter<"mapRegions"> | number | null
    yMax?: FloatNullableWithAggregatesFilter<"mapRegions"> | number | null
    zMin?: FloatNullableWithAggregatesFilter<"mapRegions"> | number | null
    zMax?: FloatNullableWithAggregatesFilter<"mapRegions"> | number | null
    factionID?: IntNullableWithAggregatesFilter<"mapRegions"> | number | null
    nebula?: IntNullableWithAggregatesFilter<"mapRegions"> | number | null
    radius?: FloatNullableWithAggregatesFilter<"mapRegions"> | number | null
  }

  export type mapSolarSystemJumpsWhereInput = {
    AND?: mapSolarSystemJumpsWhereInput | mapSolarSystemJumpsWhereInput[]
    OR?: mapSolarSystemJumpsWhereInput[]
    NOT?: mapSolarSystemJumpsWhereInput | mapSolarSystemJumpsWhereInput[]
    fromRegionID?: IntNullableFilter<"mapSolarSystemJumps"> | number | null
    fromConstellationID?: IntNullableFilter<"mapSolarSystemJumps"> | number | null
    fromSolarSystemID?: IntFilter<"mapSolarSystemJumps"> | number
    toSolarSystemID?: IntFilter<"mapSolarSystemJumps"> | number
    toConstellationID?: IntNullableFilter<"mapSolarSystemJumps"> | number | null
    toRegionID?: IntNullableFilter<"mapSolarSystemJumps"> | number | null
  }

  export type mapSolarSystemJumpsOrderByWithRelationInput = {
    fromRegionID?: SortOrderInput | SortOrder
    fromConstellationID?: SortOrderInput | SortOrder
    fromSolarSystemID?: SortOrder
    toSolarSystemID?: SortOrder
    toConstellationID?: SortOrderInput | SortOrder
    toRegionID?: SortOrderInput | SortOrder
  }

  export type mapSolarSystemJumpsWhereUniqueInput = Prisma.AtLeast<{
    fromSolarSystemID_toSolarSystemID?: mapSolarSystemJumpsFromSolarSystemIDToSolarSystemIDCompoundUniqueInput
    AND?: mapSolarSystemJumpsWhereInput | mapSolarSystemJumpsWhereInput[]
    OR?: mapSolarSystemJumpsWhereInput[]
    NOT?: mapSolarSystemJumpsWhereInput | mapSolarSystemJumpsWhereInput[]
    fromRegionID?: IntNullableFilter<"mapSolarSystemJumps"> | number | null
    fromConstellationID?: IntNullableFilter<"mapSolarSystemJumps"> | number | null
    fromSolarSystemID?: IntFilter<"mapSolarSystemJumps"> | number
    toSolarSystemID?: IntFilter<"mapSolarSystemJumps"> | number
    toConstellationID?: IntNullableFilter<"mapSolarSystemJumps"> | number | null
    toRegionID?: IntNullableFilter<"mapSolarSystemJumps"> | number | null
  }, "fromSolarSystemID_toSolarSystemID">

  export type mapSolarSystemJumpsOrderByWithAggregationInput = {
    fromRegionID?: SortOrderInput | SortOrder
    fromConstellationID?: SortOrderInput | SortOrder
    fromSolarSystemID?: SortOrder
    toSolarSystemID?: SortOrder
    toConstellationID?: SortOrderInput | SortOrder
    toRegionID?: SortOrderInput | SortOrder
    _count?: mapSolarSystemJumpsCountOrderByAggregateInput
    _avg?: mapSolarSystemJumpsAvgOrderByAggregateInput
    _max?: mapSolarSystemJumpsMaxOrderByAggregateInput
    _min?: mapSolarSystemJumpsMinOrderByAggregateInput
    _sum?: mapSolarSystemJumpsSumOrderByAggregateInput
  }

  export type mapSolarSystemJumpsScalarWhereWithAggregatesInput = {
    AND?: mapSolarSystemJumpsScalarWhereWithAggregatesInput | mapSolarSystemJumpsScalarWhereWithAggregatesInput[]
    OR?: mapSolarSystemJumpsScalarWhereWithAggregatesInput[]
    NOT?: mapSolarSystemJumpsScalarWhereWithAggregatesInput | mapSolarSystemJumpsScalarWhereWithAggregatesInput[]
    fromRegionID?: IntNullableWithAggregatesFilter<"mapSolarSystemJumps"> | number | null
    fromConstellationID?: IntNullableWithAggregatesFilter<"mapSolarSystemJumps"> | number | null
    fromSolarSystemID?: IntWithAggregatesFilter<"mapSolarSystemJumps"> | number
    toSolarSystemID?: IntWithAggregatesFilter<"mapSolarSystemJumps"> | number
    toConstellationID?: IntNullableWithAggregatesFilter<"mapSolarSystemJumps"> | number | null
    toRegionID?: IntNullableWithAggregatesFilter<"mapSolarSystemJumps"> | number | null
  }

  export type mapSolarSystemsWhereInput = {
    AND?: mapSolarSystemsWhereInput | mapSolarSystemsWhereInput[]
    OR?: mapSolarSystemsWhereInput[]
    NOT?: mapSolarSystemsWhereInput | mapSolarSystemsWhereInput[]
    regionID?: IntNullableFilter<"mapSolarSystems"> | number | null
    constellationID?: IntNullableFilter<"mapSolarSystems"> | number | null
    solarSystemID?: IntFilter<"mapSolarSystems"> | number
    solarSystemName?: StringNullableFilter<"mapSolarSystems"> | string | null
    x?: FloatNullableFilter<"mapSolarSystems"> | number | null
    y?: FloatNullableFilter<"mapSolarSystems"> | number | null
    z?: FloatNullableFilter<"mapSolarSystems"> | number | null
    xMin?: FloatNullableFilter<"mapSolarSystems"> | number | null
    xMax?: FloatNullableFilter<"mapSolarSystems"> | number | null
    yMin?: FloatNullableFilter<"mapSolarSystems"> | number | null
    yMax?: FloatNullableFilter<"mapSolarSystems"> | number | null
    zMin?: FloatNullableFilter<"mapSolarSystems"> | number | null
    zMax?: FloatNullableFilter<"mapSolarSystems"> | number | null
    luminosity?: FloatNullableFilter<"mapSolarSystems"> | number | null
    border?: BoolNullableFilter<"mapSolarSystems"> | boolean | null
    fringe?: BoolNullableFilter<"mapSolarSystems"> | boolean | null
    corridor?: BoolNullableFilter<"mapSolarSystems"> | boolean | null
    hub?: BoolNullableFilter<"mapSolarSystems"> | boolean | null
    international?: BoolNullableFilter<"mapSolarSystems"> | boolean | null
    regional?: BoolNullableFilter<"mapSolarSystems"> | boolean | null
    constellation?: BoolNullableFilter<"mapSolarSystems"> | boolean | null
    security?: FloatNullableFilter<"mapSolarSystems"> | number | null
    factionID?: IntNullableFilter<"mapSolarSystems"> | number | null
    radius?: FloatNullableFilter<"mapSolarSystems"> | number | null
    sunTypeID?: IntNullableFilter<"mapSolarSystems"> | number | null
    securityClass?: StringNullableFilter<"mapSolarSystems"> | string | null
  }

  export type mapSolarSystemsOrderByWithRelationInput = {
    regionID?: SortOrderInput | SortOrder
    constellationID?: SortOrderInput | SortOrder
    solarSystemID?: SortOrder
    solarSystemName?: SortOrderInput | SortOrder
    x?: SortOrderInput | SortOrder
    y?: SortOrderInput | SortOrder
    z?: SortOrderInput | SortOrder
    xMin?: SortOrderInput | SortOrder
    xMax?: SortOrderInput | SortOrder
    yMin?: SortOrderInput | SortOrder
    yMax?: SortOrderInput | SortOrder
    zMin?: SortOrderInput | SortOrder
    zMax?: SortOrderInput | SortOrder
    luminosity?: SortOrderInput | SortOrder
    border?: SortOrderInput | SortOrder
    fringe?: SortOrderInput | SortOrder
    corridor?: SortOrderInput | SortOrder
    hub?: SortOrderInput | SortOrder
    international?: SortOrderInput | SortOrder
    regional?: SortOrderInput | SortOrder
    constellation?: SortOrderInput | SortOrder
    security?: SortOrderInput | SortOrder
    factionID?: SortOrderInput | SortOrder
    radius?: SortOrderInput | SortOrder
    sunTypeID?: SortOrderInput | SortOrder
    securityClass?: SortOrderInput | SortOrder
  }

  export type mapSolarSystemsWhereUniqueInput = Prisma.AtLeast<{
    solarSystemID?: number
    AND?: mapSolarSystemsWhereInput | mapSolarSystemsWhereInput[]
    OR?: mapSolarSystemsWhereInput[]
    NOT?: mapSolarSystemsWhereInput | mapSolarSystemsWhereInput[]
    regionID?: IntNullableFilter<"mapSolarSystems"> | number | null
    constellationID?: IntNullableFilter<"mapSolarSystems"> | number | null
    solarSystemName?: StringNullableFilter<"mapSolarSystems"> | string | null
    x?: FloatNullableFilter<"mapSolarSystems"> | number | null
    y?: FloatNullableFilter<"mapSolarSystems"> | number | null
    z?: FloatNullableFilter<"mapSolarSystems"> | number | null
    xMin?: FloatNullableFilter<"mapSolarSystems"> | number | null
    xMax?: FloatNullableFilter<"mapSolarSystems"> | number | null
    yMin?: FloatNullableFilter<"mapSolarSystems"> | number | null
    yMax?: FloatNullableFilter<"mapSolarSystems"> | number | null
    zMin?: FloatNullableFilter<"mapSolarSystems"> | number | null
    zMax?: FloatNullableFilter<"mapSolarSystems"> | number | null
    luminosity?: FloatNullableFilter<"mapSolarSystems"> | number | null
    border?: BoolNullableFilter<"mapSolarSystems"> | boolean | null
    fringe?: BoolNullableFilter<"mapSolarSystems"> | boolean | null
    corridor?: BoolNullableFilter<"mapSolarSystems"> | boolean | null
    hub?: BoolNullableFilter<"mapSolarSystems"> | boolean | null
    international?: BoolNullableFilter<"mapSolarSystems"> | boolean | null
    regional?: BoolNullableFilter<"mapSolarSystems"> | boolean | null
    constellation?: BoolNullableFilter<"mapSolarSystems"> | boolean | null
    security?: FloatNullableFilter<"mapSolarSystems"> | number | null
    factionID?: IntNullableFilter<"mapSolarSystems"> | number | null
    radius?: FloatNullableFilter<"mapSolarSystems"> | number | null
    sunTypeID?: IntNullableFilter<"mapSolarSystems"> | number | null
    securityClass?: StringNullableFilter<"mapSolarSystems"> | string | null
  }, "solarSystemID">

  export type mapSolarSystemsOrderByWithAggregationInput = {
    regionID?: SortOrderInput | SortOrder
    constellationID?: SortOrderInput | SortOrder
    solarSystemID?: SortOrder
    solarSystemName?: SortOrderInput | SortOrder
    x?: SortOrderInput | SortOrder
    y?: SortOrderInput | SortOrder
    z?: SortOrderInput | SortOrder
    xMin?: SortOrderInput | SortOrder
    xMax?: SortOrderInput | SortOrder
    yMin?: SortOrderInput | SortOrder
    yMax?: SortOrderInput | SortOrder
    zMin?: SortOrderInput | SortOrder
    zMax?: SortOrderInput | SortOrder
    luminosity?: SortOrderInput | SortOrder
    border?: SortOrderInput | SortOrder
    fringe?: SortOrderInput | SortOrder
    corridor?: SortOrderInput | SortOrder
    hub?: SortOrderInput | SortOrder
    international?: SortOrderInput | SortOrder
    regional?: SortOrderInput | SortOrder
    constellation?: SortOrderInput | SortOrder
    security?: SortOrderInput | SortOrder
    factionID?: SortOrderInput | SortOrder
    radius?: SortOrderInput | SortOrder
    sunTypeID?: SortOrderInput | SortOrder
    securityClass?: SortOrderInput | SortOrder
    _count?: mapSolarSystemsCountOrderByAggregateInput
    _avg?: mapSolarSystemsAvgOrderByAggregateInput
    _max?: mapSolarSystemsMaxOrderByAggregateInput
    _min?: mapSolarSystemsMinOrderByAggregateInput
    _sum?: mapSolarSystemsSumOrderByAggregateInput
  }

  export type mapSolarSystemsScalarWhereWithAggregatesInput = {
    AND?: mapSolarSystemsScalarWhereWithAggregatesInput | mapSolarSystemsScalarWhereWithAggregatesInput[]
    OR?: mapSolarSystemsScalarWhereWithAggregatesInput[]
    NOT?: mapSolarSystemsScalarWhereWithAggregatesInput | mapSolarSystemsScalarWhereWithAggregatesInput[]
    regionID?: IntNullableWithAggregatesFilter<"mapSolarSystems"> | number | null
    constellationID?: IntNullableWithAggregatesFilter<"mapSolarSystems"> | number | null
    solarSystemID?: IntWithAggregatesFilter<"mapSolarSystems"> | number
    solarSystemName?: StringNullableWithAggregatesFilter<"mapSolarSystems"> | string | null
    x?: FloatNullableWithAggregatesFilter<"mapSolarSystems"> | number | null
    y?: FloatNullableWithAggregatesFilter<"mapSolarSystems"> | number | null
    z?: FloatNullableWithAggregatesFilter<"mapSolarSystems"> | number | null
    xMin?: FloatNullableWithAggregatesFilter<"mapSolarSystems"> | number | null
    xMax?: FloatNullableWithAggregatesFilter<"mapSolarSystems"> | number | null
    yMin?: FloatNullableWithAggregatesFilter<"mapSolarSystems"> | number | null
    yMax?: FloatNullableWithAggregatesFilter<"mapSolarSystems"> | number | null
    zMin?: FloatNullableWithAggregatesFilter<"mapSolarSystems"> | number | null
    zMax?: FloatNullableWithAggregatesFilter<"mapSolarSystems"> | number | null
    luminosity?: FloatNullableWithAggregatesFilter<"mapSolarSystems"> | number | null
    border?: BoolNullableWithAggregatesFilter<"mapSolarSystems"> | boolean | null
    fringe?: BoolNullableWithAggregatesFilter<"mapSolarSystems"> | boolean | null
    corridor?: BoolNullableWithAggregatesFilter<"mapSolarSystems"> | boolean | null
    hub?: BoolNullableWithAggregatesFilter<"mapSolarSystems"> | boolean | null
    international?: BoolNullableWithAggregatesFilter<"mapSolarSystems"> | boolean | null
    regional?: BoolNullableWithAggregatesFilter<"mapSolarSystems"> | boolean | null
    constellation?: BoolNullableWithAggregatesFilter<"mapSolarSystems"> | boolean | null
    security?: FloatNullableWithAggregatesFilter<"mapSolarSystems"> | number | null
    factionID?: IntNullableWithAggregatesFilter<"mapSolarSystems"> | number | null
    radius?: FloatNullableWithAggregatesFilter<"mapSolarSystems"> | number | null
    sunTypeID?: IntNullableWithAggregatesFilter<"mapSolarSystems"> | number | null
    securityClass?: StringNullableWithAggregatesFilter<"mapSolarSystems"> | string | null
  }

  export type mapUniverseWhereInput = {
    AND?: mapUniverseWhereInput | mapUniverseWhereInput[]
    OR?: mapUniverseWhereInput[]
    NOT?: mapUniverseWhereInput | mapUniverseWhereInput[]
    universeID?: IntFilter<"mapUniverse"> | number
    universeName?: StringNullableFilter<"mapUniverse"> | string | null
    x?: FloatNullableFilter<"mapUniverse"> | number | null
    y?: FloatNullableFilter<"mapUniverse"> | number | null
    z?: FloatNullableFilter<"mapUniverse"> | number | null
    xMin?: FloatNullableFilter<"mapUniverse"> | number | null
    xMax?: FloatNullableFilter<"mapUniverse"> | number | null
    yMin?: FloatNullableFilter<"mapUniverse"> | number | null
    yMax?: FloatNullableFilter<"mapUniverse"> | number | null
    zMin?: FloatNullableFilter<"mapUniverse"> | number | null
    zMax?: FloatNullableFilter<"mapUniverse"> | number | null
    radius?: FloatNullableFilter<"mapUniverse"> | number | null
  }

  export type mapUniverseOrderByWithRelationInput = {
    universeID?: SortOrder
    universeName?: SortOrderInput | SortOrder
    x?: SortOrderInput | SortOrder
    y?: SortOrderInput | SortOrder
    z?: SortOrderInput | SortOrder
    xMin?: SortOrderInput | SortOrder
    xMax?: SortOrderInput | SortOrder
    yMin?: SortOrderInput | SortOrder
    yMax?: SortOrderInput | SortOrder
    zMin?: SortOrderInput | SortOrder
    zMax?: SortOrderInput | SortOrder
    radius?: SortOrderInput | SortOrder
  }

  export type mapUniverseWhereUniqueInput = Prisma.AtLeast<{
    universeID?: number
    AND?: mapUniverseWhereInput | mapUniverseWhereInput[]
    OR?: mapUniverseWhereInput[]
    NOT?: mapUniverseWhereInput | mapUniverseWhereInput[]
    universeName?: StringNullableFilter<"mapUniverse"> | string | null
    x?: FloatNullableFilter<"mapUniverse"> | number | null
    y?: FloatNullableFilter<"mapUniverse"> | number | null
    z?: FloatNullableFilter<"mapUniverse"> | number | null
    xMin?: FloatNullableFilter<"mapUniverse"> | number | null
    xMax?: FloatNullableFilter<"mapUniverse"> | number | null
    yMin?: FloatNullableFilter<"mapUniverse"> | number | null
    yMax?: FloatNullableFilter<"mapUniverse"> | number | null
    zMin?: FloatNullableFilter<"mapUniverse"> | number | null
    zMax?: FloatNullableFilter<"mapUniverse"> | number | null
    radius?: FloatNullableFilter<"mapUniverse"> | number | null
  }, "universeID">

  export type mapUniverseOrderByWithAggregationInput = {
    universeID?: SortOrder
    universeName?: SortOrderInput | SortOrder
    x?: SortOrderInput | SortOrder
    y?: SortOrderInput | SortOrder
    z?: SortOrderInput | SortOrder
    xMin?: SortOrderInput | SortOrder
    xMax?: SortOrderInput | SortOrder
    yMin?: SortOrderInput | SortOrder
    yMax?: SortOrderInput | SortOrder
    zMin?: SortOrderInput | SortOrder
    zMax?: SortOrderInput | SortOrder
    radius?: SortOrderInput | SortOrder
    _count?: mapUniverseCountOrderByAggregateInput
    _avg?: mapUniverseAvgOrderByAggregateInput
    _max?: mapUniverseMaxOrderByAggregateInput
    _min?: mapUniverseMinOrderByAggregateInput
    _sum?: mapUniverseSumOrderByAggregateInput
  }

  export type mapUniverseScalarWhereWithAggregatesInput = {
    AND?: mapUniverseScalarWhereWithAggregatesInput | mapUniverseScalarWhereWithAggregatesInput[]
    OR?: mapUniverseScalarWhereWithAggregatesInput[]
    NOT?: mapUniverseScalarWhereWithAggregatesInput | mapUniverseScalarWhereWithAggregatesInput[]
    universeID?: IntWithAggregatesFilter<"mapUniverse"> | number
    universeName?: StringNullableWithAggregatesFilter<"mapUniverse"> | string | null
    x?: FloatNullableWithAggregatesFilter<"mapUniverse"> | number | null
    y?: FloatNullableWithAggregatesFilter<"mapUniverse"> | number | null
    z?: FloatNullableWithAggregatesFilter<"mapUniverse"> | number | null
    xMin?: FloatNullableWithAggregatesFilter<"mapUniverse"> | number | null
    xMax?: FloatNullableWithAggregatesFilter<"mapUniverse"> | number | null
    yMin?: FloatNullableWithAggregatesFilter<"mapUniverse"> | number | null
    yMax?: FloatNullableWithAggregatesFilter<"mapUniverse"> | number | null
    zMin?: FloatNullableWithAggregatesFilter<"mapUniverse"> | number | null
    zMax?: FloatNullableWithAggregatesFilter<"mapUniverse"> | number | null
    radius?: FloatNullableWithAggregatesFilter<"mapUniverse"> | number | null
  }

  export type planetSchematicsWhereInput = {
    AND?: planetSchematicsWhereInput | planetSchematicsWhereInput[]
    OR?: planetSchematicsWhereInput[]
    NOT?: planetSchematicsWhereInput | planetSchematicsWhereInput[]
    schematicID?: IntFilter<"planetSchematics"> | number
    schematicName?: StringNullableFilter<"planetSchematics"> | string | null
    cycleTime?: IntNullableFilter<"planetSchematics"> | number | null
  }

  export type planetSchematicsOrderByWithRelationInput = {
    schematicID?: SortOrder
    schematicName?: SortOrderInput | SortOrder
    cycleTime?: SortOrderInput | SortOrder
  }

  export type planetSchematicsWhereUniqueInput = Prisma.AtLeast<{
    schematicID?: number
    AND?: planetSchematicsWhereInput | planetSchematicsWhereInput[]
    OR?: planetSchematicsWhereInput[]
    NOT?: planetSchematicsWhereInput | planetSchematicsWhereInput[]
    schematicName?: StringNullableFilter<"planetSchematics"> | string | null
    cycleTime?: IntNullableFilter<"planetSchematics"> | number | null
  }, "schematicID">

  export type planetSchematicsOrderByWithAggregationInput = {
    schematicID?: SortOrder
    schematicName?: SortOrderInput | SortOrder
    cycleTime?: SortOrderInput | SortOrder
    _count?: planetSchematicsCountOrderByAggregateInput
    _avg?: planetSchematicsAvgOrderByAggregateInput
    _max?: planetSchematicsMaxOrderByAggregateInput
    _min?: planetSchematicsMinOrderByAggregateInput
    _sum?: planetSchematicsSumOrderByAggregateInput
  }

  export type planetSchematicsScalarWhereWithAggregatesInput = {
    AND?: planetSchematicsScalarWhereWithAggregatesInput | planetSchematicsScalarWhereWithAggregatesInput[]
    OR?: planetSchematicsScalarWhereWithAggregatesInput[]
    NOT?: planetSchematicsScalarWhereWithAggregatesInput | planetSchematicsScalarWhereWithAggregatesInput[]
    schematicID?: IntWithAggregatesFilter<"planetSchematics"> | number
    schematicName?: StringNullableWithAggregatesFilter<"planetSchematics"> | string | null
    cycleTime?: IntNullableWithAggregatesFilter<"planetSchematics"> | number | null
  }

  export type planetSchematicsPinMapWhereInput = {
    AND?: planetSchematicsPinMapWhereInput | planetSchematicsPinMapWhereInput[]
    OR?: planetSchematicsPinMapWhereInput[]
    NOT?: planetSchematicsPinMapWhereInput | planetSchematicsPinMapWhereInput[]
    schematicID?: IntFilter<"planetSchematicsPinMap"> | number
    pinTypeID?: IntFilter<"planetSchematicsPinMap"> | number
  }

  export type planetSchematicsPinMapOrderByWithRelationInput = {
    schematicID?: SortOrder
    pinTypeID?: SortOrder
  }

  export type planetSchematicsPinMapWhereUniqueInput = Prisma.AtLeast<{
    schematicID_pinTypeID?: planetSchematicsPinMapSchematicIDPinTypeIDCompoundUniqueInput
    AND?: planetSchematicsPinMapWhereInput | planetSchematicsPinMapWhereInput[]
    OR?: planetSchematicsPinMapWhereInput[]
    NOT?: planetSchematicsPinMapWhereInput | planetSchematicsPinMapWhereInput[]
    schematicID?: IntFilter<"planetSchematicsPinMap"> | number
    pinTypeID?: IntFilter<"planetSchematicsPinMap"> | number
  }, "schematicID_pinTypeID">

  export type planetSchematicsPinMapOrderByWithAggregationInput = {
    schematicID?: SortOrder
    pinTypeID?: SortOrder
    _count?: planetSchematicsPinMapCountOrderByAggregateInput
    _avg?: planetSchematicsPinMapAvgOrderByAggregateInput
    _max?: planetSchematicsPinMapMaxOrderByAggregateInput
    _min?: planetSchematicsPinMapMinOrderByAggregateInput
    _sum?: planetSchematicsPinMapSumOrderByAggregateInput
  }

  export type planetSchematicsPinMapScalarWhereWithAggregatesInput = {
    AND?: planetSchematicsPinMapScalarWhereWithAggregatesInput | planetSchematicsPinMapScalarWhereWithAggregatesInput[]
    OR?: planetSchematicsPinMapScalarWhereWithAggregatesInput[]
    NOT?: planetSchematicsPinMapScalarWhereWithAggregatesInput | planetSchematicsPinMapScalarWhereWithAggregatesInput[]
    schematicID?: IntWithAggregatesFilter<"planetSchematicsPinMap"> | number
    pinTypeID?: IntWithAggregatesFilter<"planetSchematicsPinMap"> | number
  }

  export type planetSchematicsTypeMapWhereInput = {
    AND?: planetSchematicsTypeMapWhereInput | planetSchematicsTypeMapWhereInput[]
    OR?: planetSchematicsTypeMapWhereInput[]
    NOT?: planetSchematicsTypeMapWhereInput | planetSchematicsTypeMapWhereInput[]
    schematicID?: IntFilter<"planetSchematicsTypeMap"> | number
    typeID?: IntFilter<"planetSchematicsTypeMap"> | number
    quantity?: IntNullableFilter<"planetSchematicsTypeMap"> | number | null
    isInput?: BoolNullableFilter<"planetSchematicsTypeMap"> | boolean | null
  }

  export type planetSchematicsTypeMapOrderByWithRelationInput = {
    schematicID?: SortOrder
    typeID?: SortOrder
    quantity?: SortOrderInput | SortOrder
    isInput?: SortOrderInput | SortOrder
  }

  export type planetSchematicsTypeMapWhereUniqueInput = Prisma.AtLeast<{
    schematicID_typeID?: planetSchematicsTypeMapSchematicIDTypeIDCompoundUniqueInput
    AND?: planetSchematicsTypeMapWhereInput | planetSchematicsTypeMapWhereInput[]
    OR?: planetSchematicsTypeMapWhereInput[]
    NOT?: planetSchematicsTypeMapWhereInput | planetSchematicsTypeMapWhereInput[]
    schematicID?: IntFilter<"planetSchematicsTypeMap"> | number
    typeID?: IntFilter<"planetSchematicsTypeMap"> | number
    quantity?: IntNullableFilter<"planetSchematicsTypeMap"> | number | null
    isInput?: BoolNullableFilter<"planetSchematicsTypeMap"> | boolean | null
  }, "schematicID_typeID">

  export type planetSchematicsTypeMapOrderByWithAggregationInput = {
    schematicID?: SortOrder
    typeID?: SortOrder
    quantity?: SortOrderInput | SortOrder
    isInput?: SortOrderInput | SortOrder
    _count?: planetSchematicsTypeMapCountOrderByAggregateInput
    _avg?: planetSchematicsTypeMapAvgOrderByAggregateInput
    _max?: planetSchematicsTypeMapMaxOrderByAggregateInput
    _min?: planetSchematicsTypeMapMinOrderByAggregateInput
    _sum?: planetSchematicsTypeMapSumOrderByAggregateInput
  }

  export type planetSchematicsTypeMapScalarWhereWithAggregatesInput = {
    AND?: planetSchematicsTypeMapScalarWhereWithAggregatesInput | planetSchematicsTypeMapScalarWhereWithAggregatesInput[]
    OR?: planetSchematicsTypeMapScalarWhereWithAggregatesInput[]
    NOT?: planetSchematicsTypeMapScalarWhereWithAggregatesInput | planetSchematicsTypeMapScalarWhereWithAggregatesInput[]
    schematicID?: IntWithAggregatesFilter<"planetSchematicsTypeMap"> | number
    typeID?: IntWithAggregatesFilter<"planetSchematicsTypeMap"> | number
    quantity?: IntNullableWithAggregatesFilter<"planetSchematicsTypeMap"> | number | null
    isInput?: BoolNullableWithAggregatesFilter<"planetSchematicsTypeMap"> | boolean | null
  }

  export type ramActivitiesWhereInput = {
    AND?: ramActivitiesWhereInput | ramActivitiesWhereInput[]
    OR?: ramActivitiesWhereInput[]
    NOT?: ramActivitiesWhereInput | ramActivitiesWhereInput[]
    activityID?: IntFilter<"ramActivities"> | number
    activityName?: StringNullableFilter<"ramActivities"> | string | null
    iconNo?: StringNullableFilter<"ramActivities"> | string | null
    description?: StringNullableFilter<"ramActivities"> | string | null
    published?: BoolNullableFilter<"ramActivities"> | boolean | null
  }

  export type ramActivitiesOrderByWithRelationInput = {
    activityID?: SortOrder
    activityName?: SortOrderInput | SortOrder
    iconNo?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    published?: SortOrderInput | SortOrder
  }

  export type ramActivitiesWhereUniqueInput = Prisma.AtLeast<{
    activityID?: number
    AND?: ramActivitiesWhereInput | ramActivitiesWhereInput[]
    OR?: ramActivitiesWhereInput[]
    NOT?: ramActivitiesWhereInput | ramActivitiesWhereInput[]
    activityName?: StringNullableFilter<"ramActivities"> | string | null
    iconNo?: StringNullableFilter<"ramActivities"> | string | null
    description?: StringNullableFilter<"ramActivities"> | string | null
    published?: BoolNullableFilter<"ramActivities"> | boolean | null
  }, "activityID">

  export type ramActivitiesOrderByWithAggregationInput = {
    activityID?: SortOrder
    activityName?: SortOrderInput | SortOrder
    iconNo?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    published?: SortOrderInput | SortOrder
    _count?: ramActivitiesCountOrderByAggregateInput
    _avg?: ramActivitiesAvgOrderByAggregateInput
    _max?: ramActivitiesMaxOrderByAggregateInput
    _min?: ramActivitiesMinOrderByAggregateInput
    _sum?: ramActivitiesSumOrderByAggregateInput
  }

  export type ramActivitiesScalarWhereWithAggregatesInput = {
    AND?: ramActivitiesScalarWhereWithAggregatesInput | ramActivitiesScalarWhereWithAggregatesInput[]
    OR?: ramActivitiesScalarWhereWithAggregatesInput[]
    NOT?: ramActivitiesScalarWhereWithAggregatesInput | ramActivitiesScalarWhereWithAggregatesInput[]
    activityID?: IntWithAggregatesFilter<"ramActivities"> | number
    activityName?: StringNullableWithAggregatesFilter<"ramActivities"> | string | null
    iconNo?: StringNullableWithAggregatesFilter<"ramActivities"> | string | null
    description?: StringNullableWithAggregatesFilter<"ramActivities"> | string | null
    published?: BoolNullableWithAggregatesFilter<"ramActivities"> | boolean | null
  }

  export type ramAssemblyLineStationsWhereInput = {
    AND?: ramAssemblyLineStationsWhereInput | ramAssemblyLineStationsWhereInput[]
    OR?: ramAssemblyLineStationsWhereInput[]
    NOT?: ramAssemblyLineStationsWhereInput | ramAssemblyLineStationsWhereInput[]
    stationID?: IntFilter<"ramAssemblyLineStations"> | number
    assemblyLineTypeID?: IntFilter<"ramAssemblyLineStations"> | number
    quantity?: IntNullableFilter<"ramAssemblyLineStations"> | number | null
    stationTypeID?: IntNullableFilter<"ramAssemblyLineStations"> | number | null
    ownerID?: IntNullableFilter<"ramAssemblyLineStations"> | number | null
    solarSystemID?: IntNullableFilter<"ramAssemblyLineStations"> | number | null
    regionID?: IntNullableFilter<"ramAssemblyLineStations"> | number | null
  }

  export type ramAssemblyLineStationsOrderByWithRelationInput = {
    stationID?: SortOrder
    assemblyLineTypeID?: SortOrder
    quantity?: SortOrderInput | SortOrder
    stationTypeID?: SortOrderInput | SortOrder
    ownerID?: SortOrderInput | SortOrder
    solarSystemID?: SortOrderInput | SortOrder
    regionID?: SortOrderInput | SortOrder
  }

  export type ramAssemblyLineStationsWhereUniqueInput = Prisma.AtLeast<{
    stationID_assemblyLineTypeID?: ramAssemblyLineStationsStationIDAssemblyLineTypeIDCompoundUniqueInput
    AND?: ramAssemblyLineStationsWhereInput | ramAssemblyLineStationsWhereInput[]
    OR?: ramAssemblyLineStationsWhereInput[]
    NOT?: ramAssemblyLineStationsWhereInput | ramAssemblyLineStationsWhereInput[]
    stationID?: IntFilter<"ramAssemblyLineStations"> | number
    assemblyLineTypeID?: IntFilter<"ramAssemblyLineStations"> | number
    quantity?: IntNullableFilter<"ramAssemblyLineStations"> | number | null
    stationTypeID?: IntNullableFilter<"ramAssemblyLineStations"> | number | null
    ownerID?: IntNullableFilter<"ramAssemblyLineStations"> | number | null
    solarSystemID?: IntNullableFilter<"ramAssemblyLineStations"> | number | null
    regionID?: IntNullableFilter<"ramAssemblyLineStations"> | number | null
  }, "stationID_assemblyLineTypeID">

  export type ramAssemblyLineStationsOrderByWithAggregationInput = {
    stationID?: SortOrder
    assemblyLineTypeID?: SortOrder
    quantity?: SortOrderInput | SortOrder
    stationTypeID?: SortOrderInput | SortOrder
    ownerID?: SortOrderInput | SortOrder
    solarSystemID?: SortOrderInput | SortOrder
    regionID?: SortOrderInput | SortOrder
    _count?: ramAssemblyLineStationsCountOrderByAggregateInput
    _avg?: ramAssemblyLineStationsAvgOrderByAggregateInput
    _max?: ramAssemblyLineStationsMaxOrderByAggregateInput
    _min?: ramAssemblyLineStationsMinOrderByAggregateInput
    _sum?: ramAssemblyLineStationsSumOrderByAggregateInput
  }

  export type ramAssemblyLineStationsScalarWhereWithAggregatesInput = {
    AND?: ramAssemblyLineStationsScalarWhereWithAggregatesInput | ramAssemblyLineStationsScalarWhereWithAggregatesInput[]
    OR?: ramAssemblyLineStationsScalarWhereWithAggregatesInput[]
    NOT?: ramAssemblyLineStationsScalarWhereWithAggregatesInput | ramAssemblyLineStationsScalarWhereWithAggregatesInput[]
    stationID?: IntWithAggregatesFilter<"ramAssemblyLineStations"> | number
    assemblyLineTypeID?: IntWithAggregatesFilter<"ramAssemblyLineStations"> | number
    quantity?: IntNullableWithAggregatesFilter<"ramAssemblyLineStations"> | number | null
    stationTypeID?: IntNullableWithAggregatesFilter<"ramAssemblyLineStations"> | number | null
    ownerID?: IntNullableWithAggregatesFilter<"ramAssemblyLineStations"> | number | null
    solarSystemID?: IntNullableWithAggregatesFilter<"ramAssemblyLineStations"> | number | null
    regionID?: IntNullableWithAggregatesFilter<"ramAssemblyLineStations"> | number | null
  }

  export type ramAssemblyLineTypeDetailPerCategoryWhereInput = {
    AND?: ramAssemblyLineTypeDetailPerCategoryWhereInput | ramAssemblyLineTypeDetailPerCategoryWhereInput[]
    OR?: ramAssemblyLineTypeDetailPerCategoryWhereInput[]
    NOT?: ramAssemblyLineTypeDetailPerCategoryWhereInput | ramAssemblyLineTypeDetailPerCategoryWhereInput[]
    assemblyLineTypeID?: IntFilter<"ramAssemblyLineTypeDetailPerCategory"> | number
    categoryID?: IntFilter<"ramAssemblyLineTypeDetailPerCategory"> | number
    timeMultiplier?: FloatNullableFilter<"ramAssemblyLineTypeDetailPerCategory"> | number | null
    materialMultiplier?: FloatNullableFilter<"ramAssemblyLineTypeDetailPerCategory"> | number | null
    costMultiplier?: FloatNullableFilter<"ramAssemblyLineTypeDetailPerCategory"> | number | null
  }

  export type ramAssemblyLineTypeDetailPerCategoryOrderByWithRelationInput = {
    assemblyLineTypeID?: SortOrder
    categoryID?: SortOrder
    timeMultiplier?: SortOrderInput | SortOrder
    materialMultiplier?: SortOrderInput | SortOrder
    costMultiplier?: SortOrderInput | SortOrder
  }

  export type ramAssemblyLineTypeDetailPerCategoryWhereUniqueInput = Prisma.AtLeast<{
    assemblyLineTypeID_categoryID?: ramAssemblyLineTypeDetailPerCategoryAssemblyLineTypeIDCategoryIDCompoundUniqueInput
    AND?: ramAssemblyLineTypeDetailPerCategoryWhereInput | ramAssemblyLineTypeDetailPerCategoryWhereInput[]
    OR?: ramAssemblyLineTypeDetailPerCategoryWhereInput[]
    NOT?: ramAssemblyLineTypeDetailPerCategoryWhereInput | ramAssemblyLineTypeDetailPerCategoryWhereInput[]
    assemblyLineTypeID?: IntFilter<"ramAssemblyLineTypeDetailPerCategory"> | number
    categoryID?: IntFilter<"ramAssemblyLineTypeDetailPerCategory"> | number
    timeMultiplier?: FloatNullableFilter<"ramAssemblyLineTypeDetailPerCategory"> | number | null
    materialMultiplier?: FloatNullableFilter<"ramAssemblyLineTypeDetailPerCategory"> | number | null
    costMultiplier?: FloatNullableFilter<"ramAssemblyLineTypeDetailPerCategory"> | number | null
  }, "assemblyLineTypeID_categoryID">

  export type ramAssemblyLineTypeDetailPerCategoryOrderByWithAggregationInput = {
    assemblyLineTypeID?: SortOrder
    categoryID?: SortOrder
    timeMultiplier?: SortOrderInput | SortOrder
    materialMultiplier?: SortOrderInput | SortOrder
    costMultiplier?: SortOrderInput | SortOrder
    _count?: ramAssemblyLineTypeDetailPerCategoryCountOrderByAggregateInput
    _avg?: ramAssemblyLineTypeDetailPerCategoryAvgOrderByAggregateInput
    _max?: ramAssemblyLineTypeDetailPerCategoryMaxOrderByAggregateInput
    _min?: ramAssemblyLineTypeDetailPerCategoryMinOrderByAggregateInput
    _sum?: ramAssemblyLineTypeDetailPerCategorySumOrderByAggregateInput
  }

  export type ramAssemblyLineTypeDetailPerCategoryScalarWhereWithAggregatesInput = {
    AND?: ramAssemblyLineTypeDetailPerCategoryScalarWhereWithAggregatesInput | ramAssemblyLineTypeDetailPerCategoryScalarWhereWithAggregatesInput[]
    OR?: ramAssemblyLineTypeDetailPerCategoryScalarWhereWithAggregatesInput[]
    NOT?: ramAssemblyLineTypeDetailPerCategoryScalarWhereWithAggregatesInput | ramAssemblyLineTypeDetailPerCategoryScalarWhereWithAggregatesInput[]
    assemblyLineTypeID?: IntWithAggregatesFilter<"ramAssemblyLineTypeDetailPerCategory"> | number
    categoryID?: IntWithAggregatesFilter<"ramAssemblyLineTypeDetailPerCategory"> | number
    timeMultiplier?: FloatNullableWithAggregatesFilter<"ramAssemblyLineTypeDetailPerCategory"> | number | null
    materialMultiplier?: FloatNullableWithAggregatesFilter<"ramAssemblyLineTypeDetailPerCategory"> | number | null
    costMultiplier?: FloatNullableWithAggregatesFilter<"ramAssemblyLineTypeDetailPerCategory"> | number | null
  }

  export type ramAssemblyLineTypeDetailPerGroupWhereInput = {
    AND?: ramAssemblyLineTypeDetailPerGroupWhereInput | ramAssemblyLineTypeDetailPerGroupWhereInput[]
    OR?: ramAssemblyLineTypeDetailPerGroupWhereInput[]
    NOT?: ramAssemblyLineTypeDetailPerGroupWhereInput | ramAssemblyLineTypeDetailPerGroupWhereInput[]
    assemblyLineTypeID?: IntFilter<"ramAssemblyLineTypeDetailPerGroup"> | number
    groupID?: IntFilter<"ramAssemblyLineTypeDetailPerGroup"> | number
    timeMultiplier?: FloatNullableFilter<"ramAssemblyLineTypeDetailPerGroup"> | number | null
    materialMultiplier?: FloatNullableFilter<"ramAssemblyLineTypeDetailPerGroup"> | number | null
    costMultiplier?: FloatNullableFilter<"ramAssemblyLineTypeDetailPerGroup"> | number | null
  }

  export type ramAssemblyLineTypeDetailPerGroupOrderByWithRelationInput = {
    assemblyLineTypeID?: SortOrder
    groupID?: SortOrder
    timeMultiplier?: SortOrderInput | SortOrder
    materialMultiplier?: SortOrderInput | SortOrder
    costMultiplier?: SortOrderInput | SortOrder
  }

  export type ramAssemblyLineTypeDetailPerGroupWhereUniqueInput = Prisma.AtLeast<{
    assemblyLineTypeID_groupID?: ramAssemblyLineTypeDetailPerGroupAssemblyLineTypeIDGroupIDCompoundUniqueInput
    AND?: ramAssemblyLineTypeDetailPerGroupWhereInput | ramAssemblyLineTypeDetailPerGroupWhereInput[]
    OR?: ramAssemblyLineTypeDetailPerGroupWhereInput[]
    NOT?: ramAssemblyLineTypeDetailPerGroupWhereInput | ramAssemblyLineTypeDetailPerGroupWhereInput[]
    assemblyLineTypeID?: IntFilter<"ramAssemblyLineTypeDetailPerGroup"> | number
    groupID?: IntFilter<"ramAssemblyLineTypeDetailPerGroup"> | number
    timeMultiplier?: FloatNullableFilter<"ramAssemblyLineTypeDetailPerGroup"> | number | null
    materialMultiplier?: FloatNullableFilter<"ramAssemblyLineTypeDetailPerGroup"> | number | null
    costMultiplier?: FloatNullableFilter<"ramAssemblyLineTypeDetailPerGroup"> | number | null
  }, "assemblyLineTypeID_groupID">

  export type ramAssemblyLineTypeDetailPerGroupOrderByWithAggregationInput = {
    assemblyLineTypeID?: SortOrder
    groupID?: SortOrder
    timeMultiplier?: SortOrderInput | SortOrder
    materialMultiplier?: SortOrderInput | SortOrder
    costMultiplier?: SortOrderInput | SortOrder
    _count?: ramAssemblyLineTypeDetailPerGroupCountOrderByAggregateInput
    _avg?: ramAssemblyLineTypeDetailPerGroupAvgOrderByAggregateInput
    _max?: ramAssemblyLineTypeDetailPerGroupMaxOrderByAggregateInput
    _min?: ramAssemblyLineTypeDetailPerGroupMinOrderByAggregateInput
    _sum?: ramAssemblyLineTypeDetailPerGroupSumOrderByAggregateInput
  }

  export type ramAssemblyLineTypeDetailPerGroupScalarWhereWithAggregatesInput = {
    AND?: ramAssemblyLineTypeDetailPerGroupScalarWhereWithAggregatesInput | ramAssemblyLineTypeDetailPerGroupScalarWhereWithAggregatesInput[]
    OR?: ramAssemblyLineTypeDetailPerGroupScalarWhereWithAggregatesInput[]
    NOT?: ramAssemblyLineTypeDetailPerGroupScalarWhereWithAggregatesInput | ramAssemblyLineTypeDetailPerGroupScalarWhereWithAggregatesInput[]
    assemblyLineTypeID?: IntWithAggregatesFilter<"ramAssemblyLineTypeDetailPerGroup"> | number
    groupID?: IntWithAggregatesFilter<"ramAssemblyLineTypeDetailPerGroup"> | number
    timeMultiplier?: FloatNullableWithAggregatesFilter<"ramAssemblyLineTypeDetailPerGroup"> | number | null
    materialMultiplier?: FloatNullableWithAggregatesFilter<"ramAssemblyLineTypeDetailPerGroup"> | number | null
    costMultiplier?: FloatNullableWithAggregatesFilter<"ramAssemblyLineTypeDetailPerGroup"> | number | null
  }

  export type ramAssemblyLineTypesWhereInput = {
    AND?: ramAssemblyLineTypesWhereInput | ramAssemblyLineTypesWhereInput[]
    OR?: ramAssemblyLineTypesWhereInput[]
    NOT?: ramAssemblyLineTypesWhereInput | ramAssemblyLineTypesWhereInput[]
    assemblyLineTypeID?: IntFilter<"ramAssemblyLineTypes"> | number
    assemblyLineTypeName?: StringNullableFilter<"ramAssemblyLineTypes"> | string | null
    description?: StringNullableFilter<"ramAssemblyLineTypes"> | string | null
    baseTimeMultiplier?: FloatNullableFilter<"ramAssemblyLineTypes"> | number | null
    baseMaterialMultiplier?: FloatNullableFilter<"ramAssemblyLineTypes"> | number | null
    baseCostMultiplier?: FloatNullableFilter<"ramAssemblyLineTypes"> | number | null
    volume?: FloatNullableFilter<"ramAssemblyLineTypes"> | number | null
    activityID?: IntNullableFilter<"ramAssemblyLineTypes"> | number | null
    minCostPerHour?: FloatNullableFilter<"ramAssemblyLineTypes"> | number | null
  }

  export type ramAssemblyLineTypesOrderByWithRelationInput = {
    assemblyLineTypeID?: SortOrder
    assemblyLineTypeName?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    baseTimeMultiplier?: SortOrderInput | SortOrder
    baseMaterialMultiplier?: SortOrderInput | SortOrder
    baseCostMultiplier?: SortOrderInput | SortOrder
    volume?: SortOrderInput | SortOrder
    activityID?: SortOrderInput | SortOrder
    minCostPerHour?: SortOrderInput | SortOrder
  }

  export type ramAssemblyLineTypesWhereUniqueInput = Prisma.AtLeast<{
    assemblyLineTypeID?: number
    AND?: ramAssemblyLineTypesWhereInput | ramAssemblyLineTypesWhereInput[]
    OR?: ramAssemblyLineTypesWhereInput[]
    NOT?: ramAssemblyLineTypesWhereInput | ramAssemblyLineTypesWhereInput[]
    assemblyLineTypeName?: StringNullableFilter<"ramAssemblyLineTypes"> | string | null
    description?: StringNullableFilter<"ramAssemblyLineTypes"> | string | null
    baseTimeMultiplier?: FloatNullableFilter<"ramAssemblyLineTypes"> | number | null
    baseMaterialMultiplier?: FloatNullableFilter<"ramAssemblyLineTypes"> | number | null
    baseCostMultiplier?: FloatNullableFilter<"ramAssemblyLineTypes"> | number | null
    volume?: FloatNullableFilter<"ramAssemblyLineTypes"> | number | null
    activityID?: IntNullableFilter<"ramAssemblyLineTypes"> | number | null
    minCostPerHour?: FloatNullableFilter<"ramAssemblyLineTypes"> | number | null
  }, "assemblyLineTypeID">

  export type ramAssemblyLineTypesOrderByWithAggregationInput = {
    assemblyLineTypeID?: SortOrder
    assemblyLineTypeName?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    baseTimeMultiplier?: SortOrderInput | SortOrder
    baseMaterialMultiplier?: SortOrderInput | SortOrder
    baseCostMultiplier?: SortOrderInput | SortOrder
    volume?: SortOrderInput | SortOrder
    activityID?: SortOrderInput | SortOrder
    minCostPerHour?: SortOrderInput | SortOrder
    _count?: ramAssemblyLineTypesCountOrderByAggregateInput
    _avg?: ramAssemblyLineTypesAvgOrderByAggregateInput
    _max?: ramAssemblyLineTypesMaxOrderByAggregateInput
    _min?: ramAssemblyLineTypesMinOrderByAggregateInput
    _sum?: ramAssemblyLineTypesSumOrderByAggregateInput
  }

  export type ramAssemblyLineTypesScalarWhereWithAggregatesInput = {
    AND?: ramAssemblyLineTypesScalarWhereWithAggregatesInput | ramAssemblyLineTypesScalarWhereWithAggregatesInput[]
    OR?: ramAssemblyLineTypesScalarWhereWithAggregatesInput[]
    NOT?: ramAssemblyLineTypesScalarWhereWithAggregatesInput | ramAssemblyLineTypesScalarWhereWithAggregatesInput[]
    assemblyLineTypeID?: IntWithAggregatesFilter<"ramAssemblyLineTypes"> | number
    assemblyLineTypeName?: StringNullableWithAggregatesFilter<"ramAssemblyLineTypes"> | string | null
    description?: StringNullableWithAggregatesFilter<"ramAssemblyLineTypes"> | string | null
    baseTimeMultiplier?: FloatNullableWithAggregatesFilter<"ramAssemblyLineTypes"> | number | null
    baseMaterialMultiplier?: FloatNullableWithAggregatesFilter<"ramAssemblyLineTypes"> | number | null
    baseCostMultiplier?: FloatNullableWithAggregatesFilter<"ramAssemblyLineTypes"> | number | null
    volume?: FloatNullableWithAggregatesFilter<"ramAssemblyLineTypes"> | number | null
    activityID?: IntNullableWithAggregatesFilter<"ramAssemblyLineTypes"> | number | null
    minCostPerHour?: FloatNullableWithAggregatesFilter<"ramAssemblyLineTypes"> | number | null
  }

  export type ramInstallationTypeContentsWhereInput = {
    AND?: ramInstallationTypeContentsWhereInput | ramInstallationTypeContentsWhereInput[]
    OR?: ramInstallationTypeContentsWhereInput[]
    NOT?: ramInstallationTypeContentsWhereInput | ramInstallationTypeContentsWhereInput[]
    installationTypeID?: IntFilter<"ramInstallationTypeContents"> | number
    assemblyLineTypeID?: IntFilter<"ramInstallationTypeContents"> | number
    quantity?: IntNullableFilter<"ramInstallationTypeContents"> | number | null
  }

  export type ramInstallationTypeContentsOrderByWithRelationInput = {
    installationTypeID?: SortOrder
    assemblyLineTypeID?: SortOrder
    quantity?: SortOrderInput | SortOrder
  }

  export type ramInstallationTypeContentsWhereUniqueInput = Prisma.AtLeast<{
    installationTypeID_assemblyLineTypeID?: ramInstallationTypeContentsInstallationTypeIDAssemblyLineTypeIDCompoundUniqueInput
    AND?: ramInstallationTypeContentsWhereInput | ramInstallationTypeContentsWhereInput[]
    OR?: ramInstallationTypeContentsWhereInput[]
    NOT?: ramInstallationTypeContentsWhereInput | ramInstallationTypeContentsWhereInput[]
    installationTypeID?: IntFilter<"ramInstallationTypeContents"> | number
    assemblyLineTypeID?: IntFilter<"ramInstallationTypeContents"> | number
    quantity?: IntNullableFilter<"ramInstallationTypeContents"> | number | null
  }, "installationTypeID_assemblyLineTypeID">

  export type ramInstallationTypeContentsOrderByWithAggregationInput = {
    installationTypeID?: SortOrder
    assemblyLineTypeID?: SortOrder
    quantity?: SortOrderInput | SortOrder
    _count?: ramInstallationTypeContentsCountOrderByAggregateInput
    _avg?: ramInstallationTypeContentsAvgOrderByAggregateInput
    _max?: ramInstallationTypeContentsMaxOrderByAggregateInput
    _min?: ramInstallationTypeContentsMinOrderByAggregateInput
    _sum?: ramInstallationTypeContentsSumOrderByAggregateInput
  }

  export type ramInstallationTypeContentsScalarWhereWithAggregatesInput = {
    AND?: ramInstallationTypeContentsScalarWhereWithAggregatesInput | ramInstallationTypeContentsScalarWhereWithAggregatesInput[]
    OR?: ramInstallationTypeContentsScalarWhereWithAggregatesInput[]
    NOT?: ramInstallationTypeContentsScalarWhereWithAggregatesInput | ramInstallationTypeContentsScalarWhereWithAggregatesInput[]
    installationTypeID?: IntWithAggregatesFilter<"ramInstallationTypeContents"> | number
    assemblyLineTypeID?: IntWithAggregatesFilter<"ramInstallationTypeContents"> | number
    quantity?: IntNullableWithAggregatesFilter<"ramInstallationTypeContents"> | number | null
  }

  export type skinLicenseWhereInput = {
    AND?: skinLicenseWhereInput | skinLicenseWhereInput[]
    OR?: skinLicenseWhereInput[]
    NOT?: skinLicenseWhereInput | skinLicenseWhereInput[]
    licenseTypeID?: IntFilter<"skinLicense"> | number
    duration?: IntNullableFilter<"skinLicense"> | number | null
    skinID?: IntNullableFilter<"skinLicense"> | number | null
  }

  export type skinLicenseOrderByWithRelationInput = {
    licenseTypeID?: SortOrder
    duration?: SortOrderInput | SortOrder
    skinID?: SortOrderInput | SortOrder
  }

  export type skinLicenseWhereUniqueInput = Prisma.AtLeast<{
    licenseTypeID?: number
    AND?: skinLicenseWhereInput | skinLicenseWhereInput[]
    OR?: skinLicenseWhereInput[]
    NOT?: skinLicenseWhereInput | skinLicenseWhereInput[]
    duration?: IntNullableFilter<"skinLicense"> | number | null
    skinID?: IntNullableFilter<"skinLicense"> | number | null
  }, "licenseTypeID">

  export type skinLicenseOrderByWithAggregationInput = {
    licenseTypeID?: SortOrder
    duration?: SortOrderInput | SortOrder
    skinID?: SortOrderInput | SortOrder
    _count?: skinLicenseCountOrderByAggregateInput
    _avg?: skinLicenseAvgOrderByAggregateInput
    _max?: skinLicenseMaxOrderByAggregateInput
    _min?: skinLicenseMinOrderByAggregateInput
    _sum?: skinLicenseSumOrderByAggregateInput
  }

  export type skinLicenseScalarWhereWithAggregatesInput = {
    AND?: skinLicenseScalarWhereWithAggregatesInput | skinLicenseScalarWhereWithAggregatesInput[]
    OR?: skinLicenseScalarWhereWithAggregatesInput[]
    NOT?: skinLicenseScalarWhereWithAggregatesInput | skinLicenseScalarWhereWithAggregatesInput[]
    licenseTypeID?: IntWithAggregatesFilter<"skinLicense"> | number
    duration?: IntNullableWithAggregatesFilter<"skinLicense"> | number | null
    skinID?: IntNullableWithAggregatesFilter<"skinLicense"> | number | null
  }

  export type skinMaterialsWhereInput = {
    AND?: skinMaterialsWhereInput | skinMaterialsWhereInput[]
    OR?: skinMaterialsWhereInput[]
    NOT?: skinMaterialsWhereInput | skinMaterialsWhereInput[]
    skinMaterialID?: IntFilter<"skinMaterials"> | number
    displayNameID?: IntNullableFilter<"skinMaterials"> | number | null
    materialSetID?: IntNullableFilter<"skinMaterials"> | number | null
  }

  export type skinMaterialsOrderByWithRelationInput = {
    skinMaterialID?: SortOrder
    displayNameID?: SortOrderInput | SortOrder
    materialSetID?: SortOrderInput | SortOrder
  }

  export type skinMaterialsWhereUniqueInput = Prisma.AtLeast<{
    skinMaterialID?: number
    AND?: skinMaterialsWhereInput | skinMaterialsWhereInput[]
    OR?: skinMaterialsWhereInput[]
    NOT?: skinMaterialsWhereInput | skinMaterialsWhereInput[]
    displayNameID?: IntNullableFilter<"skinMaterials"> | number | null
    materialSetID?: IntNullableFilter<"skinMaterials"> | number | null
  }, "skinMaterialID">

  export type skinMaterialsOrderByWithAggregationInput = {
    skinMaterialID?: SortOrder
    displayNameID?: SortOrderInput | SortOrder
    materialSetID?: SortOrderInput | SortOrder
    _count?: skinMaterialsCountOrderByAggregateInput
    _avg?: skinMaterialsAvgOrderByAggregateInput
    _max?: skinMaterialsMaxOrderByAggregateInput
    _min?: skinMaterialsMinOrderByAggregateInput
    _sum?: skinMaterialsSumOrderByAggregateInput
  }

  export type skinMaterialsScalarWhereWithAggregatesInput = {
    AND?: skinMaterialsScalarWhereWithAggregatesInput | skinMaterialsScalarWhereWithAggregatesInput[]
    OR?: skinMaterialsScalarWhereWithAggregatesInput[]
    NOT?: skinMaterialsScalarWhereWithAggregatesInput | skinMaterialsScalarWhereWithAggregatesInput[]
    skinMaterialID?: IntWithAggregatesFilter<"skinMaterials"> | number
    displayNameID?: IntNullableWithAggregatesFilter<"skinMaterials"> | number | null
    materialSetID?: IntNullableWithAggregatesFilter<"skinMaterials"> | number | null
  }

  export type skinsWhereInput = {
    AND?: skinsWhereInput | skinsWhereInput[]
    OR?: skinsWhereInput[]
    NOT?: skinsWhereInput | skinsWhereInput[]
    skinID?: IntFilter<"skins"> | number
    internalName?: StringNullableFilter<"skins"> | string | null
    skinMaterialID?: IntNullableFilter<"skins"> | number | null
  }

  export type skinsOrderByWithRelationInput = {
    skinID?: SortOrder
    internalName?: SortOrderInput | SortOrder
    skinMaterialID?: SortOrderInput | SortOrder
  }

  export type skinsWhereUniqueInput = Prisma.AtLeast<{
    skinID?: number
    AND?: skinsWhereInput | skinsWhereInput[]
    OR?: skinsWhereInput[]
    NOT?: skinsWhereInput | skinsWhereInput[]
    internalName?: StringNullableFilter<"skins"> | string | null
    skinMaterialID?: IntNullableFilter<"skins"> | number | null
  }, "skinID">

  export type skinsOrderByWithAggregationInput = {
    skinID?: SortOrder
    internalName?: SortOrderInput | SortOrder
    skinMaterialID?: SortOrderInput | SortOrder
    _count?: skinsCountOrderByAggregateInput
    _avg?: skinsAvgOrderByAggregateInput
    _max?: skinsMaxOrderByAggregateInput
    _min?: skinsMinOrderByAggregateInput
    _sum?: skinsSumOrderByAggregateInput
  }

  export type skinsScalarWhereWithAggregatesInput = {
    AND?: skinsScalarWhereWithAggregatesInput | skinsScalarWhereWithAggregatesInput[]
    OR?: skinsScalarWhereWithAggregatesInput[]
    NOT?: skinsScalarWhereWithAggregatesInput | skinsScalarWhereWithAggregatesInput[]
    skinID?: IntWithAggregatesFilter<"skins"> | number
    internalName?: StringNullableWithAggregatesFilter<"skins"> | string | null
    skinMaterialID?: IntNullableWithAggregatesFilter<"skins"> | number | null
  }

  export type staOperationServicesWhereInput = {
    AND?: staOperationServicesWhereInput | staOperationServicesWhereInput[]
    OR?: staOperationServicesWhereInput[]
    NOT?: staOperationServicesWhereInput | staOperationServicesWhereInput[]
    operationID?: IntFilter<"staOperationServices"> | number
    serviceID?: IntFilter<"staOperationServices"> | number
  }

  export type staOperationServicesOrderByWithRelationInput = {
    operationID?: SortOrder
    serviceID?: SortOrder
  }

  export type staOperationServicesWhereUniqueInput = Prisma.AtLeast<{
    operationID_serviceID?: staOperationServicesOperationIDServiceIDCompoundUniqueInput
    AND?: staOperationServicesWhereInput | staOperationServicesWhereInput[]
    OR?: staOperationServicesWhereInput[]
    NOT?: staOperationServicesWhereInput | staOperationServicesWhereInput[]
    operationID?: IntFilter<"staOperationServices"> | number
    serviceID?: IntFilter<"staOperationServices"> | number
  }, "operationID_serviceID">

  export type staOperationServicesOrderByWithAggregationInput = {
    operationID?: SortOrder
    serviceID?: SortOrder
    _count?: staOperationServicesCountOrderByAggregateInput
    _avg?: staOperationServicesAvgOrderByAggregateInput
    _max?: staOperationServicesMaxOrderByAggregateInput
    _min?: staOperationServicesMinOrderByAggregateInput
    _sum?: staOperationServicesSumOrderByAggregateInput
  }

  export type staOperationServicesScalarWhereWithAggregatesInput = {
    AND?: staOperationServicesScalarWhereWithAggregatesInput | staOperationServicesScalarWhereWithAggregatesInput[]
    OR?: staOperationServicesScalarWhereWithAggregatesInput[]
    NOT?: staOperationServicesScalarWhereWithAggregatesInput | staOperationServicesScalarWhereWithAggregatesInput[]
    operationID?: IntWithAggregatesFilter<"staOperationServices"> | number
    serviceID?: IntWithAggregatesFilter<"staOperationServices"> | number
  }

  export type staOperationsWhereInput = {
    AND?: staOperationsWhereInput | staOperationsWhereInput[]
    OR?: staOperationsWhereInput[]
    NOT?: staOperationsWhereInput | staOperationsWhereInput[]
    activityID?: IntNullableFilter<"staOperations"> | number | null
    operationID?: IntFilter<"staOperations"> | number
    operationName?: StringNullableFilter<"staOperations"> | string | null
    description?: StringNullableFilter<"staOperations"> | string | null
    fringe?: IntNullableFilter<"staOperations"> | number | null
    corridor?: IntNullableFilter<"staOperations"> | number | null
    hub?: IntNullableFilter<"staOperations"> | number | null
    border?: IntNullableFilter<"staOperations"> | number | null
    ratio?: IntNullableFilter<"staOperations"> | number | null
    caldariStationTypeID?: IntNullableFilter<"staOperations"> | number | null
    minmatarStationTypeID?: IntNullableFilter<"staOperations"> | number | null
    amarrStationTypeID?: IntNullableFilter<"staOperations"> | number | null
    gallenteStationTypeID?: IntNullableFilter<"staOperations"> | number | null
    joveStationTypeID?: IntNullableFilter<"staOperations"> | number | null
  }

  export type staOperationsOrderByWithRelationInput = {
    activityID?: SortOrderInput | SortOrder
    operationID?: SortOrder
    operationName?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    fringe?: SortOrderInput | SortOrder
    corridor?: SortOrderInput | SortOrder
    hub?: SortOrderInput | SortOrder
    border?: SortOrderInput | SortOrder
    ratio?: SortOrderInput | SortOrder
    caldariStationTypeID?: SortOrderInput | SortOrder
    minmatarStationTypeID?: SortOrderInput | SortOrder
    amarrStationTypeID?: SortOrderInput | SortOrder
    gallenteStationTypeID?: SortOrderInput | SortOrder
    joveStationTypeID?: SortOrderInput | SortOrder
  }

  export type staOperationsWhereUniqueInput = Prisma.AtLeast<{
    operationID?: number
    AND?: staOperationsWhereInput | staOperationsWhereInput[]
    OR?: staOperationsWhereInput[]
    NOT?: staOperationsWhereInput | staOperationsWhereInput[]
    activityID?: IntNullableFilter<"staOperations"> | number | null
    operationName?: StringNullableFilter<"staOperations"> | string | null
    description?: StringNullableFilter<"staOperations"> | string | null
    fringe?: IntNullableFilter<"staOperations"> | number | null
    corridor?: IntNullableFilter<"staOperations"> | number | null
    hub?: IntNullableFilter<"staOperations"> | number | null
    border?: IntNullableFilter<"staOperations"> | number | null
    ratio?: IntNullableFilter<"staOperations"> | number | null
    caldariStationTypeID?: IntNullableFilter<"staOperations"> | number | null
    minmatarStationTypeID?: IntNullableFilter<"staOperations"> | number | null
    amarrStationTypeID?: IntNullableFilter<"staOperations"> | number | null
    gallenteStationTypeID?: IntNullableFilter<"staOperations"> | number | null
    joveStationTypeID?: IntNullableFilter<"staOperations"> | number | null
  }, "operationID">

  export type staOperationsOrderByWithAggregationInput = {
    activityID?: SortOrderInput | SortOrder
    operationID?: SortOrder
    operationName?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    fringe?: SortOrderInput | SortOrder
    corridor?: SortOrderInput | SortOrder
    hub?: SortOrderInput | SortOrder
    border?: SortOrderInput | SortOrder
    ratio?: SortOrderInput | SortOrder
    caldariStationTypeID?: SortOrderInput | SortOrder
    minmatarStationTypeID?: SortOrderInput | SortOrder
    amarrStationTypeID?: SortOrderInput | SortOrder
    gallenteStationTypeID?: SortOrderInput | SortOrder
    joveStationTypeID?: SortOrderInput | SortOrder
    _count?: staOperationsCountOrderByAggregateInput
    _avg?: staOperationsAvgOrderByAggregateInput
    _max?: staOperationsMaxOrderByAggregateInput
    _min?: staOperationsMinOrderByAggregateInput
    _sum?: staOperationsSumOrderByAggregateInput
  }

  export type staOperationsScalarWhereWithAggregatesInput = {
    AND?: staOperationsScalarWhereWithAggregatesInput | staOperationsScalarWhereWithAggregatesInput[]
    OR?: staOperationsScalarWhereWithAggregatesInput[]
    NOT?: staOperationsScalarWhereWithAggregatesInput | staOperationsScalarWhereWithAggregatesInput[]
    activityID?: IntNullableWithAggregatesFilter<"staOperations"> | number | null
    operationID?: IntWithAggregatesFilter<"staOperations"> | number
    operationName?: StringNullableWithAggregatesFilter<"staOperations"> | string | null
    description?: StringNullableWithAggregatesFilter<"staOperations"> | string | null
    fringe?: IntNullableWithAggregatesFilter<"staOperations"> | number | null
    corridor?: IntNullableWithAggregatesFilter<"staOperations"> | number | null
    hub?: IntNullableWithAggregatesFilter<"staOperations"> | number | null
    border?: IntNullableWithAggregatesFilter<"staOperations"> | number | null
    ratio?: IntNullableWithAggregatesFilter<"staOperations"> | number | null
    caldariStationTypeID?: IntNullableWithAggregatesFilter<"staOperations"> | number | null
    minmatarStationTypeID?: IntNullableWithAggregatesFilter<"staOperations"> | number | null
    amarrStationTypeID?: IntNullableWithAggregatesFilter<"staOperations"> | number | null
    gallenteStationTypeID?: IntNullableWithAggregatesFilter<"staOperations"> | number | null
    joveStationTypeID?: IntNullableWithAggregatesFilter<"staOperations"> | number | null
  }

  export type staServicesWhereInput = {
    AND?: staServicesWhereInput | staServicesWhereInput[]
    OR?: staServicesWhereInput[]
    NOT?: staServicesWhereInput | staServicesWhereInput[]
    serviceID?: IntFilter<"staServices"> | number
    serviceName?: StringNullableFilter<"staServices"> | string | null
    description?: StringNullableFilter<"staServices"> | string | null
  }

  export type staServicesOrderByWithRelationInput = {
    serviceID?: SortOrder
    serviceName?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
  }

  export type staServicesWhereUniqueInput = Prisma.AtLeast<{
    serviceID?: number
    AND?: staServicesWhereInput | staServicesWhereInput[]
    OR?: staServicesWhereInput[]
    NOT?: staServicesWhereInput | staServicesWhereInput[]
    serviceName?: StringNullableFilter<"staServices"> | string | null
    description?: StringNullableFilter<"staServices"> | string | null
  }, "serviceID">

  export type staServicesOrderByWithAggregationInput = {
    serviceID?: SortOrder
    serviceName?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    _count?: staServicesCountOrderByAggregateInput
    _avg?: staServicesAvgOrderByAggregateInput
    _max?: staServicesMaxOrderByAggregateInput
    _min?: staServicesMinOrderByAggregateInput
    _sum?: staServicesSumOrderByAggregateInput
  }

  export type staServicesScalarWhereWithAggregatesInput = {
    AND?: staServicesScalarWhereWithAggregatesInput | staServicesScalarWhereWithAggregatesInput[]
    OR?: staServicesScalarWhereWithAggregatesInput[]
    NOT?: staServicesScalarWhereWithAggregatesInput | staServicesScalarWhereWithAggregatesInput[]
    serviceID?: IntWithAggregatesFilter<"staServices"> | number
    serviceName?: StringNullableWithAggregatesFilter<"staServices"> | string | null
    description?: StringNullableWithAggregatesFilter<"staServices"> | string | null
  }

  export type staStationTypesWhereInput = {
    AND?: staStationTypesWhereInput | staStationTypesWhereInput[]
    OR?: staStationTypesWhereInput[]
    NOT?: staStationTypesWhereInput | staStationTypesWhereInput[]
    stationTypeID?: IntFilter<"staStationTypes"> | number
    dockEntryX?: FloatNullableFilter<"staStationTypes"> | number | null
    dockEntryY?: FloatNullableFilter<"staStationTypes"> | number | null
    dockEntryZ?: FloatNullableFilter<"staStationTypes"> | number | null
    dockOrientationX?: FloatNullableFilter<"staStationTypes"> | number | null
    dockOrientationY?: FloatNullableFilter<"staStationTypes"> | number | null
    dockOrientationZ?: FloatNullableFilter<"staStationTypes"> | number | null
    operationID?: IntNullableFilter<"staStationTypes"> | number | null
    officeSlots?: IntNullableFilter<"staStationTypes"> | number | null
    reprocessingEfficiency?: FloatNullableFilter<"staStationTypes"> | number | null
    conquerable?: BoolNullableFilter<"staStationTypes"> | boolean | null
  }

  export type staStationTypesOrderByWithRelationInput = {
    stationTypeID?: SortOrder
    dockEntryX?: SortOrderInput | SortOrder
    dockEntryY?: SortOrderInput | SortOrder
    dockEntryZ?: SortOrderInput | SortOrder
    dockOrientationX?: SortOrderInput | SortOrder
    dockOrientationY?: SortOrderInput | SortOrder
    dockOrientationZ?: SortOrderInput | SortOrder
    operationID?: SortOrderInput | SortOrder
    officeSlots?: SortOrderInput | SortOrder
    reprocessingEfficiency?: SortOrderInput | SortOrder
    conquerable?: SortOrderInput | SortOrder
  }

  export type staStationTypesWhereUniqueInput = Prisma.AtLeast<{
    stationTypeID?: number
    AND?: staStationTypesWhereInput | staStationTypesWhereInput[]
    OR?: staStationTypesWhereInput[]
    NOT?: staStationTypesWhereInput | staStationTypesWhereInput[]
    dockEntryX?: FloatNullableFilter<"staStationTypes"> | number | null
    dockEntryY?: FloatNullableFilter<"staStationTypes"> | number | null
    dockEntryZ?: FloatNullableFilter<"staStationTypes"> | number | null
    dockOrientationX?: FloatNullableFilter<"staStationTypes"> | number | null
    dockOrientationY?: FloatNullableFilter<"staStationTypes"> | number | null
    dockOrientationZ?: FloatNullableFilter<"staStationTypes"> | number | null
    operationID?: IntNullableFilter<"staStationTypes"> | number | null
    officeSlots?: IntNullableFilter<"staStationTypes"> | number | null
    reprocessingEfficiency?: FloatNullableFilter<"staStationTypes"> | number | null
    conquerable?: BoolNullableFilter<"staStationTypes"> | boolean | null
  }, "stationTypeID">

  export type staStationTypesOrderByWithAggregationInput = {
    stationTypeID?: SortOrder
    dockEntryX?: SortOrderInput | SortOrder
    dockEntryY?: SortOrderInput | SortOrder
    dockEntryZ?: SortOrderInput | SortOrder
    dockOrientationX?: SortOrderInput | SortOrder
    dockOrientationY?: SortOrderInput | SortOrder
    dockOrientationZ?: SortOrderInput | SortOrder
    operationID?: SortOrderInput | SortOrder
    officeSlots?: SortOrderInput | SortOrder
    reprocessingEfficiency?: SortOrderInput | SortOrder
    conquerable?: SortOrderInput | SortOrder
    _count?: staStationTypesCountOrderByAggregateInput
    _avg?: staStationTypesAvgOrderByAggregateInput
    _max?: staStationTypesMaxOrderByAggregateInput
    _min?: staStationTypesMinOrderByAggregateInput
    _sum?: staStationTypesSumOrderByAggregateInput
  }

  export type staStationTypesScalarWhereWithAggregatesInput = {
    AND?: staStationTypesScalarWhereWithAggregatesInput | staStationTypesScalarWhereWithAggregatesInput[]
    OR?: staStationTypesScalarWhereWithAggregatesInput[]
    NOT?: staStationTypesScalarWhereWithAggregatesInput | staStationTypesScalarWhereWithAggregatesInput[]
    stationTypeID?: IntWithAggregatesFilter<"staStationTypes"> | number
    dockEntryX?: FloatNullableWithAggregatesFilter<"staStationTypes"> | number | null
    dockEntryY?: FloatNullableWithAggregatesFilter<"staStationTypes"> | number | null
    dockEntryZ?: FloatNullableWithAggregatesFilter<"staStationTypes"> | number | null
    dockOrientationX?: FloatNullableWithAggregatesFilter<"staStationTypes"> | number | null
    dockOrientationY?: FloatNullableWithAggregatesFilter<"staStationTypes"> | number | null
    dockOrientationZ?: FloatNullableWithAggregatesFilter<"staStationTypes"> | number | null
    operationID?: IntNullableWithAggregatesFilter<"staStationTypes"> | number | null
    officeSlots?: IntNullableWithAggregatesFilter<"staStationTypes"> | number | null
    reprocessingEfficiency?: FloatNullableWithAggregatesFilter<"staStationTypes"> | number | null
    conquerable?: BoolNullableWithAggregatesFilter<"staStationTypes"> | boolean | null
  }

  export type staStationsWhereInput = {
    AND?: staStationsWhereInput | staStationsWhereInput[]
    OR?: staStationsWhereInput[]
    NOT?: staStationsWhereInput | staStationsWhereInput[]
    stationID?: BigIntFilter<"staStations"> | bigint | number
    security?: FloatNullableFilter<"staStations"> | number | null
    dockingCostPerVolume?: FloatNullableFilter<"staStations"> | number | null
    maxShipVolumeDockable?: FloatNullableFilter<"staStations"> | number | null
    officeRentalCost?: IntNullableFilter<"staStations"> | number | null
    operationID?: IntNullableFilter<"staStations"> | number | null
    stationTypeID?: IntNullableFilter<"staStations"> | number | null
    corporationID?: IntNullableFilter<"staStations"> | number | null
    solarSystemID?: IntNullableFilter<"staStations"> | number | null
    constellationID?: IntNullableFilter<"staStations"> | number | null
    regionID?: IntNullableFilter<"staStations"> | number | null
    stationName?: StringNullableFilter<"staStations"> | string | null
    x?: FloatNullableFilter<"staStations"> | number | null
    y?: FloatNullableFilter<"staStations"> | number | null
    z?: FloatNullableFilter<"staStations"> | number | null
    reprocessingEfficiency?: FloatNullableFilter<"staStations"> | number | null
    reprocessingStationsTake?: FloatNullableFilter<"staStations"> | number | null
    reprocessingHangarFlag?: IntNullableFilter<"staStations"> | number | null
  }

  export type staStationsOrderByWithRelationInput = {
    stationID?: SortOrder
    security?: SortOrderInput | SortOrder
    dockingCostPerVolume?: SortOrderInput | SortOrder
    maxShipVolumeDockable?: SortOrderInput | SortOrder
    officeRentalCost?: SortOrderInput | SortOrder
    operationID?: SortOrderInput | SortOrder
    stationTypeID?: SortOrderInput | SortOrder
    corporationID?: SortOrderInput | SortOrder
    solarSystemID?: SortOrderInput | SortOrder
    constellationID?: SortOrderInput | SortOrder
    regionID?: SortOrderInput | SortOrder
    stationName?: SortOrderInput | SortOrder
    x?: SortOrderInput | SortOrder
    y?: SortOrderInput | SortOrder
    z?: SortOrderInput | SortOrder
    reprocessingEfficiency?: SortOrderInput | SortOrder
    reprocessingStationsTake?: SortOrderInput | SortOrder
    reprocessingHangarFlag?: SortOrderInput | SortOrder
  }

  export type staStationsWhereUniqueInput = Prisma.AtLeast<{
    stationID?: bigint | number
    AND?: staStationsWhereInput | staStationsWhereInput[]
    OR?: staStationsWhereInput[]
    NOT?: staStationsWhereInput | staStationsWhereInput[]
    security?: FloatNullableFilter<"staStations"> | number | null
    dockingCostPerVolume?: FloatNullableFilter<"staStations"> | number | null
    maxShipVolumeDockable?: FloatNullableFilter<"staStations"> | number | null
    officeRentalCost?: IntNullableFilter<"staStations"> | number | null
    operationID?: IntNullableFilter<"staStations"> | number | null
    stationTypeID?: IntNullableFilter<"staStations"> | number | null
    corporationID?: IntNullableFilter<"staStations"> | number | null
    solarSystemID?: IntNullableFilter<"staStations"> | number | null
    constellationID?: IntNullableFilter<"staStations"> | number | null
    regionID?: IntNullableFilter<"staStations"> | number | null
    stationName?: StringNullableFilter<"staStations"> | string | null
    x?: FloatNullableFilter<"staStations"> | number | null
    y?: FloatNullableFilter<"staStations"> | number | null
    z?: FloatNullableFilter<"staStations"> | number | null
    reprocessingEfficiency?: FloatNullableFilter<"staStations"> | number | null
    reprocessingStationsTake?: FloatNullableFilter<"staStations"> | number | null
    reprocessingHangarFlag?: IntNullableFilter<"staStations"> | number | null
  }, "stationID">

  export type staStationsOrderByWithAggregationInput = {
    stationID?: SortOrder
    security?: SortOrderInput | SortOrder
    dockingCostPerVolume?: SortOrderInput | SortOrder
    maxShipVolumeDockable?: SortOrderInput | SortOrder
    officeRentalCost?: SortOrderInput | SortOrder
    operationID?: SortOrderInput | SortOrder
    stationTypeID?: SortOrderInput | SortOrder
    corporationID?: SortOrderInput | SortOrder
    solarSystemID?: SortOrderInput | SortOrder
    constellationID?: SortOrderInput | SortOrder
    regionID?: SortOrderInput | SortOrder
    stationName?: SortOrderInput | SortOrder
    x?: SortOrderInput | SortOrder
    y?: SortOrderInput | SortOrder
    z?: SortOrderInput | SortOrder
    reprocessingEfficiency?: SortOrderInput | SortOrder
    reprocessingStationsTake?: SortOrderInput | SortOrder
    reprocessingHangarFlag?: SortOrderInput | SortOrder
    _count?: staStationsCountOrderByAggregateInput
    _avg?: staStationsAvgOrderByAggregateInput
    _max?: staStationsMaxOrderByAggregateInput
    _min?: staStationsMinOrderByAggregateInput
    _sum?: staStationsSumOrderByAggregateInput
  }

  export type staStationsScalarWhereWithAggregatesInput = {
    AND?: staStationsScalarWhereWithAggregatesInput | staStationsScalarWhereWithAggregatesInput[]
    OR?: staStationsScalarWhereWithAggregatesInput[]
    NOT?: staStationsScalarWhereWithAggregatesInput | staStationsScalarWhereWithAggregatesInput[]
    stationID?: BigIntWithAggregatesFilter<"staStations"> | bigint | number
    security?: FloatNullableWithAggregatesFilter<"staStations"> | number | null
    dockingCostPerVolume?: FloatNullableWithAggregatesFilter<"staStations"> | number | null
    maxShipVolumeDockable?: FloatNullableWithAggregatesFilter<"staStations"> | number | null
    officeRentalCost?: IntNullableWithAggregatesFilter<"staStations"> | number | null
    operationID?: IntNullableWithAggregatesFilter<"staStations"> | number | null
    stationTypeID?: IntNullableWithAggregatesFilter<"staStations"> | number | null
    corporationID?: IntNullableWithAggregatesFilter<"staStations"> | number | null
    solarSystemID?: IntNullableWithAggregatesFilter<"staStations"> | number | null
    constellationID?: IntNullableWithAggregatesFilter<"staStations"> | number | null
    regionID?: IntNullableWithAggregatesFilter<"staStations"> | number | null
    stationName?: StringNullableWithAggregatesFilter<"staStations"> | string | null
    x?: FloatNullableWithAggregatesFilter<"staStations"> | number | null
    y?: FloatNullableWithAggregatesFilter<"staStations"> | number | null
    z?: FloatNullableWithAggregatesFilter<"staStations"> | number | null
    reprocessingEfficiency?: FloatNullableWithAggregatesFilter<"staStations"> | number | null
    reprocessingStationsTake?: FloatNullableWithAggregatesFilter<"staStations"> | number | null
    reprocessingHangarFlag?: IntNullableWithAggregatesFilter<"staStations"> | number | null
  }

  export type translationTablesWhereInput = {
    AND?: translationTablesWhereInput | translationTablesWhereInput[]
    OR?: translationTablesWhereInput[]
    NOT?: translationTablesWhereInput | translationTablesWhereInput[]
    sourceTable?: StringFilter<"translationTables"> | string
    destinationTable?: StringNullableFilter<"translationTables"> | string | null
    translatedKey?: StringFilter<"translationTables"> | string
    tcGroupID?: IntNullableFilter<"translationTables"> | number | null
    tcID?: IntNullableFilter<"translationTables"> | number | null
  }

  export type translationTablesOrderByWithRelationInput = {
    sourceTable?: SortOrder
    destinationTable?: SortOrderInput | SortOrder
    translatedKey?: SortOrder
    tcGroupID?: SortOrderInput | SortOrder
    tcID?: SortOrderInput | SortOrder
  }

  export type translationTablesWhereUniqueInput = Prisma.AtLeast<{
    sourceTable_translatedKey?: translationTablesSourceTableTranslatedKeyCompoundUniqueInput
    AND?: translationTablesWhereInput | translationTablesWhereInput[]
    OR?: translationTablesWhereInput[]
    NOT?: translationTablesWhereInput | translationTablesWhereInput[]
    sourceTable?: StringFilter<"translationTables"> | string
    destinationTable?: StringNullableFilter<"translationTables"> | string | null
    translatedKey?: StringFilter<"translationTables"> | string
    tcGroupID?: IntNullableFilter<"translationTables"> | number | null
    tcID?: IntNullableFilter<"translationTables"> | number | null
  }, "sourceTable_translatedKey">

  export type translationTablesOrderByWithAggregationInput = {
    sourceTable?: SortOrder
    destinationTable?: SortOrderInput | SortOrder
    translatedKey?: SortOrder
    tcGroupID?: SortOrderInput | SortOrder
    tcID?: SortOrderInput | SortOrder
    _count?: translationTablesCountOrderByAggregateInput
    _avg?: translationTablesAvgOrderByAggregateInput
    _max?: translationTablesMaxOrderByAggregateInput
    _min?: translationTablesMinOrderByAggregateInput
    _sum?: translationTablesSumOrderByAggregateInput
  }

  export type translationTablesScalarWhereWithAggregatesInput = {
    AND?: translationTablesScalarWhereWithAggregatesInput | translationTablesScalarWhereWithAggregatesInput[]
    OR?: translationTablesScalarWhereWithAggregatesInput[]
    NOT?: translationTablesScalarWhereWithAggregatesInput | translationTablesScalarWhereWithAggregatesInput[]
    sourceTable?: StringWithAggregatesFilter<"translationTables"> | string
    destinationTable?: StringNullableWithAggregatesFilter<"translationTables"> | string | null
    translatedKey?: StringWithAggregatesFilter<"translationTables"> | string
    tcGroupID?: IntNullableWithAggregatesFilter<"translationTables"> | number | null
    tcID?: IntNullableWithAggregatesFilter<"translationTables"> | number | null
  }

  export type trnTranslationColumnsWhereInput = {
    AND?: trnTranslationColumnsWhereInput | trnTranslationColumnsWhereInput[]
    OR?: trnTranslationColumnsWhereInput[]
    NOT?: trnTranslationColumnsWhereInput | trnTranslationColumnsWhereInput[]
    tcGroupID?: IntNullableFilter<"trnTranslationColumns"> | number | null
    tcID?: IntFilter<"trnTranslationColumns"> | number
    tableName?: StringFilter<"trnTranslationColumns"> | string
    columnName?: StringFilter<"trnTranslationColumns"> | string
    masterID?: StringNullableFilter<"trnTranslationColumns"> | string | null
  }

  export type trnTranslationColumnsOrderByWithRelationInput = {
    tcGroupID?: SortOrderInput | SortOrder
    tcID?: SortOrder
    tableName?: SortOrder
    columnName?: SortOrder
    masterID?: SortOrderInput | SortOrder
  }

  export type trnTranslationColumnsWhereUniqueInput = Prisma.AtLeast<{
    tcID?: number
    AND?: trnTranslationColumnsWhereInput | trnTranslationColumnsWhereInput[]
    OR?: trnTranslationColumnsWhereInput[]
    NOT?: trnTranslationColumnsWhereInput | trnTranslationColumnsWhereInput[]
    tcGroupID?: IntNullableFilter<"trnTranslationColumns"> | number | null
    tableName?: StringFilter<"trnTranslationColumns"> | string
    columnName?: StringFilter<"trnTranslationColumns"> | string
    masterID?: StringNullableFilter<"trnTranslationColumns"> | string | null
  }, "tcID">

  export type trnTranslationColumnsOrderByWithAggregationInput = {
    tcGroupID?: SortOrderInput | SortOrder
    tcID?: SortOrder
    tableName?: SortOrder
    columnName?: SortOrder
    masterID?: SortOrderInput | SortOrder
    _count?: trnTranslationColumnsCountOrderByAggregateInput
    _avg?: trnTranslationColumnsAvgOrderByAggregateInput
    _max?: trnTranslationColumnsMaxOrderByAggregateInput
    _min?: trnTranslationColumnsMinOrderByAggregateInput
    _sum?: trnTranslationColumnsSumOrderByAggregateInput
  }

  export type trnTranslationColumnsScalarWhereWithAggregatesInput = {
    AND?: trnTranslationColumnsScalarWhereWithAggregatesInput | trnTranslationColumnsScalarWhereWithAggregatesInput[]
    OR?: trnTranslationColumnsScalarWhereWithAggregatesInput[]
    NOT?: trnTranslationColumnsScalarWhereWithAggregatesInput | trnTranslationColumnsScalarWhereWithAggregatesInput[]
    tcGroupID?: IntNullableWithAggregatesFilter<"trnTranslationColumns"> | number | null
    tcID?: IntWithAggregatesFilter<"trnTranslationColumns"> | number
    tableName?: StringWithAggregatesFilter<"trnTranslationColumns"> | string
    columnName?: StringWithAggregatesFilter<"trnTranslationColumns"> | string
    masterID?: StringNullableWithAggregatesFilter<"trnTranslationColumns"> | string | null
  }

  export type trnTranslationLanguagesWhereInput = {
    AND?: trnTranslationLanguagesWhereInput | trnTranslationLanguagesWhereInput[]
    OR?: trnTranslationLanguagesWhereInput[]
    NOT?: trnTranslationLanguagesWhereInput | trnTranslationLanguagesWhereInput[]
    numericLanguageID?: IntFilter<"trnTranslationLanguages"> | number
    languageID?: StringNullableFilter<"trnTranslationLanguages"> | string | null
    languageName?: StringNullableFilter<"trnTranslationLanguages"> | string | null
  }

  export type trnTranslationLanguagesOrderByWithRelationInput = {
    numericLanguageID?: SortOrder
    languageID?: SortOrderInput | SortOrder
    languageName?: SortOrderInput | SortOrder
  }

  export type trnTranslationLanguagesWhereUniqueInput = Prisma.AtLeast<{
    numericLanguageID?: number
    AND?: trnTranslationLanguagesWhereInput | trnTranslationLanguagesWhereInput[]
    OR?: trnTranslationLanguagesWhereInput[]
    NOT?: trnTranslationLanguagesWhereInput | trnTranslationLanguagesWhereInput[]
    languageID?: StringNullableFilter<"trnTranslationLanguages"> | string | null
    languageName?: StringNullableFilter<"trnTranslationLanguages"> | string | null
  }, "numericLanguageID">

  export type trnTranslationLanguagesOrderByWithAggregationInput = {
    numericLanguageID?: SortOrder
    languageID?: SortOrderInput | SortOrder
    languageName?: SortOrderInput | SortOrder
    _count?: trnTranslationLanguagesCountOrderByAggregateInput
    _avg?: trnTranslationLanguagesAvgOrderByAggregateInput
    _max?: trnTranslationLanguagesMaxOrderByAggregateInput
    _min?: trnTranslationLanguagesMinOrderByAggregateInput
    _sum?: trnTranslationLanguagesSumOrderByAggregateInput
  }

  export type trnTranslationLanguagesScalarWhereWithAggregatesInput = {
    AND?: trnTranslationLanguagesScalarWhereWithAggregatesInput | trnTranslationLanguagesScalarWhereWithAggregatesInput[]
    OR?: trnTranslationLanguagesScalarWhereWithAggregatesInput[]
    NOT?: trnTranslationLanguagesScalarWhereWithAggregatesInput | trnTranslationLanguagesScalarWhereWithAggregatesInput[]
    numericLanguageID?: IntWithAggregatesFilter<"trnTranslationLanguages"> | number
    languageID?: StringNullableWithAggregatesFilter<"trnTranslationLanguages"> | string | null
    languageName?: StringNullableWithAggregatesFilter<"trnTranslationLanguages"> | string | null
  }

  export type trnTranslationsWhereInput = {
    AND?: trnTranslationsWhereInput | trnTranslationsWhereInput[]
    OR?: trnTranslationsWhereInput[]
    NOT?: trnTranslationsWhereInput | trnTranslationsWhereInput[]
    tcID?: IntFilter<"trnTranslations"> | number
    keyID?: IntFilter<"trnTranslations"> | number
    languageID?: StringFilter<"trnTranslations"> | string
    text?: StringFilter<"trnTranslations"> | string
  }

  export type trnTranslationsOrderByWithRelationInput = {
    tcID?: SortOrder
    keyID?: SortOrder
    languageID?: SortOrder
    text?: SortOrder
  }

  export type trnTranslationsWhereUniqueInput = Prisma.AtLeast<{
    tcID_keyID_languageID?: trnTranslationsTcIDKeyIDLanguageIDCompoundUniqueInput
    AND?: trnTranslationsWhereInput | trnTranslationsWhereInput[]
    OR?: trnTranslationsWhereInput[]
    NOT?: trnTranslationsWhereInput | trnTranslationsWhereInput[]
    tcID?: IntFilter<"trnTranslations"> | number
    keyID?: IntFilter<"trnTranslations"> | number
    languageID?: StringFilter<"trnTranslations"> | string
    text?: StringFilter<"trnTranslations"> | string
  }, "tcID_keyID_languageID">

  export type trnTranslationsOrderByWithAggregationInput = {
    tcID?: SortOrder
    keyID?: SortOrder
    languageID?: SortOrder
    text?: SortOrder
    _count?: trnTranslationsCountOrderByAggregateInput
    _avg?: trnTranslationsAvgOrderByAggregateInput
    _max?: trnTranslationsMaxOrderByAggregateInput
    _min?: trnTranslationsMinOrderByAggregateInput
    _sum?: trnTranslationsSumOrderByAggregateInput
  }

  export type trnTranslationsScalarWhereWithAggregatesInput = {
    AND?: trnTranslationsScalarWhereWithAggregatesInput | trnTranslationsScalarWhereWithAggregatesInput[]
    OR?: trnTranslationsScalarWhereWithAggregatesInput[]
    NOT?: trnTranslationsScalarWhereWithAggregatesInput | trnTranslationsScalarWhereWithAggregatesInput[]
    tcID?: IntWithAggregatesFilter<"trnTranslations"> | number
    keyID?: IntWithAggregatesFilter<"trnTranslations"> | number
    languageID?: StringWithAggregatesFilter<"trnTranslations"> | string
    text?: StringWithAggregatesFilter<"trnTranslations"> | string
  }

  export type warCombatZoneSystemsWhereInput = {
    AND?: warCombatZoneSystemsWhereInput | warCombatZoneSystemsWhereInput[]
    OR?: warCombatZoneSystemsWhereInput[]
    NOT?: warCombatZoneSystemsWhereInput | warCombatZoneSystemsWhereInput[]
    solarSystemID?: IntFilter<"warCombatZoneSystems"> | number
    combatZoneID?: IntNullableFilter<"warCombatZoneSystems"> | number | null
  }

  export type warCombatZoneSystemsOrderByWithRelationInput = {
    solarSystemID?: SortOrder
    combatZoneID?: SortOrderInput | SortOrder
  }

  export type warCombatZoneSystemsWhereUniqueInput = Prisma.AtLeast<{
    solarSystemID?: number
    AND?: warCombatZoneSystemsWhereInput | warCombatZoneSystemsWhereInput[]
    OR?: warCombatZoneSystemsWhereInput[]
    NOT?: warCombatZoneSystemsWhereInput | warCombatZoneSystemsWhereInput[]
    combatZoneID?: IntNullableFilter<"warCombatZoneSystems"> | number | null
  }, "solarSystemID">

  export type warCombatZoneSystemsOrderByWithAggregationInput = {
    solarSystemID?: SortOrder
    combatZoneID?: SortOrderInput | SortOrder
    _count?: warCombatZoneSystemsCountOrderByAggregateInput
    _avg?: warCombatZoneSystemsAvgOrderByAggregateInput
    _max?: warCombatZoneSystemsMaxOrderByAggregateInput
    _min?: warCombatZoneSystemsMinOrderByAggregateInput
    _sum?: warCombatZoneSystemsSumOrderByAggregateInput
  }

  export type warCombatZoneSystemsScalarWhereWithAggregatesInput = {
    AND?: warCombatZoneSystemsScalarWhereWithAggregatesInput | warCombatZoneSystemsScalarWhereWithAggregatesInput[]
    OR?: warCombatZoneSystemsScalarWhereWithAggregatesInput[]
    NOT?: warCombatZoneSystemsScalarWhereWithAggregatesInput | warCombatZoneSystemsScalarWhereWithAggregatesInput[]
    solarSystemID?: IntWithAggregatesFilter<"warCombatZoneSystems"> | number
    combatZoneID?: IntNullableWithAggregatesFilter<"warCombatZoneSystems"> | number | null
  }

  export type warCombatZonesWhereInput = {
    AND?: warCombatZonesWhereInput | warCombatZonesWhereInput[]
    OR?: warCombatZonesWhereInput[]
    NOT?: warCombatZonesWhereInput | warCombatZonesWhereInput[]
    combatZoneID?: IntFilter<"warCombatZones"> | number
    combatZoneName?: StringNullableFilter<"warCombatZones"> | string | null
    factionID?: IntNullableFilter<"warCombatZones"> | number | null
    centerSystemID?: IntNullableFilter<"warCombatZones"> | number | null
    description?: StringNullableFilter<"warCombatZones"> | string | null
  }

  export type warCombatZonesOrderByWithRelationInput = {
    combatZoneID?: SortOrder
    combatZoneName?: SortOrderInput | SortOrder
    factionID?: SortOrderInput | SortOrder
    centerSystemID?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
  }

  export type warCombatZonesWhereUniqueInput = Prisma.AtLeast<{
    combatZoneID?: number
    AND?: warCombatZonesWhereInput | warCombatZonesWhereInput[]
    OR?: warCombatZonesWhereInput[]
    NOT?: warCombatZonesWhereInput | warCombatZonesWhereInput[]
    combatZoneName?: StringNullableFilter<"warCombatZones"> | string | null
    factionID?: IntNullableFilter<"warCombatZones"> | number | null
    centerSystemID?: IntNullableFilter<"warCombatZones"> | number | null
    description?: StringNullableFilter<"warCombatZones"> | string | null
  }, "combatZoneID">

  export type warCombatZonesOrderByWithAggregationInput = {
    combatZoneID?: SortOrder
    combatZoneName?: SortOrderInput | SortOrder
    factionID?: SortOrderInput | SortOrder
    centerSystemID?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    _count?: warCombatZonesCountOrderByAggregateInput
    _avg?: warCombatZonesAvgOrderByAggregateInput
    _max?: warCombatZonesMaxOrderByAggregateInput
    _min?: warCombatZonesMinOrderByAggregateInput
    _sum?: warCombatZonesSumOrderByAggregateInput
  }

  export type warCombatZonesScalarWhereWithAggregatesInput = {
    AND?: warCombatZonesScalarWhereWithAggregatesInput | warCombatZonesScalarWhereWithAggregatesInput[]
    OR?: warCombatZonesScalarWhereWithAggregatesInput[]
    NOT?: warCombatZonesScalarWhereWithAggregatesInput | warCombatZonesScalarWhereWithAggregatesInput[]
    combatZoneID?: IntWithAggregatesFilter<"warCombatZones"> | number
    combatZoneName?: StringNullableWithAggregatesFilter<"warCombatZones"> | string | null
    factionID?: IntNullableWithAggregatesFilter<"warCombatZones"> | number | null
    centerSystemID?: IntNullableWithAggregatesFilter<"warCombatZones"> | number | null
    description?: StringNullableWithAggregatesFilter<"warCombatZones"> | string | null
  }

  export type agtAgentTypesCreateInput = {
    agentTypeID: number
    agentType?: string | null
  }

  export type agtAgentTypesUncheckedCreateInput = {
    agentTypeID: number
    agentType?: string | null
  }

  export type agtAgentTypesUpdateInput = {
    agentTypeID?: IntFieldUpdateOperationsInput | number
    agentType?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type agtAgentTypesUncheckedUpdateInput = {
    agentTypeID?: IntFieldUpdateOperationsInput | number
    agentType?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type agtAgentTypesCreateManyInput = {
    agentTypeID: number
    agentType?: string | null
  }

  export type agtAgentTypesUpdateManyMutationInput = {
    agentTypeID?: IntFieldUpdateOperationsInput | number
    agentType?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type agtAgentTypesUncheckedUpdateManyInput = {
    agentTypeID?: IntFieldUpdateOperationsInput | number
    agentType?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type agtAgentsCreateInput = {
    agentID: number
    divisionID?: number | null
    corporationID?: number | null
    locationID?: number | null
    level?: number | null
    quality?: number | null
    agentTypeID?: number | null
    isLocator?: boolean | null
  }

  export type agtAgentsUncheckedCreateInput = {
    agentID: number
    divisionID?: number | null
    corporationID?: number | null
    locationID?: number | null
    level?: number | null
    quality?: number | null
    agentTypeID?: number | null
    isLocator?: boolean | null
  }

  export type agtAgentsUpdateInput = {
    agentID?: IntFieldUpdateOperationsInput | number
    divisionID?: NullableIntFieldUpdateOperationsInput | number | null
    corporationID?: NullableIntFieldUpdateOperationsInput | number | null
    locationID?: NullableIntFieldUpdateOperationsInput | number | null
    level?: NullableIntFieldUpdateOperationsInput | number | null
    quality?: NullableIntFieldUpdateOperationsInput | number | null
    agentTypeID?: NullableIntFieldUpdateOperationsInput | number | null
    isLocator?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type agtAgentsUncheckedUpdateInput = {
    agentID?: IntFieldUpdateOperationsInput | number
    divisionID?: NullableIntFieldUpdateOperationsInput | number | null
    corporationID?: NullableIntFieldUpdateOperationsInput | number | null
    locationID?: NullableIntFieldUpdateOperationsInput | number | null
    level?: NullableIntFieldUpdateOperationsInput | number | null
    quality?: NullableIntFieldUpdateOperationsInput | number | null
    agentTypeID?: NullableIntFieldUpdateOperationsInput | number | null
    isLocator?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type agtAgentsCreateManyInput = {
    agentID: number
    divisionID?: number | null
    corporationID?: number | null
    locationID?: number | null
    level?: number | null
    quality?: number | null
    agentTypeID?: number | null
    isLocator?: boolean | null
  }

  export type agtAgentsUpdateManyMutationInput = {
    agentID?: IntFieldUpdateOperationsInput | number
    divisionID?: NullableIntFieldUpdateOperationsInput | number | null
    corporationID?: NullableIntFieldUpdateOperationsInput | number | null
    locationID?: NullableIntFieldUpdateOperationsInput | number | null
    level?: NullableIntFieldUpdateOperationsInput | number | null
    quality?: NullableIntFieldUpdateOperationsInput | number | null
    agentTypeID?: NullableIntFieldUpdateOperationsInput | number | null
    isLocator?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type agtAgentsUncheckedUpdateManyInput = {
    agentID?: IntFieldUpdateOperationsInput | number
    divisionID?: NullableIntFieldUpdateOperationsInput | number | null
    corporationID?: NullableIntFieldUpdateOperationsInput | number | null
    locationID?: NullableIntFieldUpdateOperationsInput | number | null
    level?: NullableIntFieldUpdateOperationsInput | number | null
    quality?: NullableIntFieldUpdateOperationsInput | number | null
    agentTypeID?: NullableIntFieldUpdateOperationsInput | number | null
    isLocator?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type agtAgentsInSpaceCreateInput = {
    agentID: number
    dungeonID?: number | null
    solarSystemID?: number | null
    spawnPointID?: number | null
    typeID?: number | null
  }

  export type agtAgentsInSpaceUncheckedCreateInput = {
    agentID: number
    dungeonID?: number | null
    solarSystemID?: number | null
    spawnPointID?: number | null
    typeID?: number | null
  }

  export type agtAgentsInSpaceUpdateInput = {
    agentID?: IntFieldUpdateOperationsInput | number
    dungeonID?: NullableIntFieldUpdateOperationsInput | number | null
    solarSystemID?: NullableIntFieldUpdateOperationsInput | number | null
    spawnPointID?: NullableIntFieldUpdateOperationsInput | number | null
    typeID?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type agtAgentsInSpaceUncheckedUpdateInput = {
    agentID?: IntFieldUpdateOperationsInput | number
    dungeonID?: NullableIntFieldUpdateOperationsInput | number | null
    solarSystemID?: NullableIntFieldUpdateOperationsInput | number | null
    spawnPointID?: NullableIntFieldUpdateOperationsInput | number | null
    typeID?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type agtAgentsInSpaceCreateManyInput = {
    agentID: number
    dungeonID?: number | null
    solarSystemID?: number | null
    spawnPointID?: number | null
    typeID?: number | null
  }

  export type agtAgentsInSpaceUpdateManyMutationInput = {
    agentID?: IntFieldUpdateOperationsInput | number
    dungeonID?: NullableIntFieldUpdateOperationsInput | number | null
    solarSystemID?: NullableIntFieldUpdateOperationsInput | number | null
    spawnPointID?: NullableIntFieldUpdateOperationsInput | number | null
    typeID?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type agtAgentsInSpaceUncheckedUpdateManyInput = {
    agentID?: IntFieldUpdateOperationsInput | number
    dungeonID?: NullableIntFieldUpdateOperationsInput | number | null
    solarSystemID?: NullableIntFieldUpdateOperationsInput | number | null
    spawnPointID?: NullableIntFieldUpdateOperationsInput | number | null
    typeID?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type agtResearchAgentsCreateInput = {
    agentID: number
    typeID: number
  }

  export type agtResearchAgentsUncheckedCreateInput = {
    agentID: number
    typeID: number
  }

  export type agtResearchAgentsUpdateInput = {
    agentID?: IntFieldUpdateOperationsInput | number
    typeID?: IntFieldUpdateOperationsInput | number
  }

  export type agtResearchAgentsUncheckedUpdateInput = {
    agentID?: IntFieldUpdateOperationsInput | number
    typeID?: IntFieldUpdateOperationsInput | number
  }

  export type agtResearchAgentsCreateManyInput = {
    agentID: number
    typeID: number
  }

  export type agtResearchAgentsUpdateManyMutationInput = {
    agentID?: IntFieldUpdateOperationsInput | number
    typeID?: IntFieldUpdateOperationsInput | number
  }

  export type agtResearchAgentsUncheckedUpdateManyInput = {
    agentID?: IntFieldUpdateOperationsInput | number
    typeID?: IntFieldUpdateOperationsInput | number
  }

  export type certCertsCreateInput = {
    certID: number
    description?: string | null
    groupID?: number | null
    name?: string | null
  }

  export type certCertsUncheckedCreateInput = {
    certID: number
    description?: string | null
    groupID?: number | null
    name?: string | null
  }

  export type certCertsUpdateInput = {
    certID?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    groupID?: NullableIntFieldUpdateOperationsInput | number | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type certCertsUncheckedUpdateInput = {
    certID?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    groupID?: NullableIntFieldUpdateOperationsInput | number | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type certCertsCreateManyInput = {
    certID: number
    description?: string | null
    groupID?: number | null
    name?: string | null
  }

  export type certCertsUpdateManyMutationInput = {
    certID?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    groupID?: NullableIntFieldUpdateOperationsInput | number | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type certCertsUncheckedUpdateManyInput = {
    certID?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    groupID?: NullableIntFieldUpdateOperationsInput | number | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type chrAncestriesCreateInput = {
    ancestryID: number
    ancestryName?: string | null
    bloodlineID?: number | null
    description?: string | null
    perception?: number | null
    willpower?: number | null
    charisma?: number | null
    memory?: number | null
    intelligence?: number | null
    iconID?: number | null
    shortDescription?: string | null
  }

  export type chrAncestriesUncheckedCreateInput = {
    ancestryID: number
    ancestryName?: string | null
    bloodlineID?: number | null
    description?: string | null
    perception?: number | null
    willpower?: number | null
    charisma?: number | null
    memory?: number | null
    intelligence?: number | null
    iconID?: number | null
    shortDescription?: string | null
  }

  export type chrAncestriesUpdateInput = {
    ancestryID?: IntFieldUpdateOperationsInput | number
    ancestryName?: NullableStringFieldUpdateOperationsInput | string | null
    bloodlineID?: NullableIntFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    perception?: NullableIntFieldUpdateOperationsInput | number | null
    willpower?: NullableIntFieldUpdateOperationsInput | number | null
    charisma?: NullableIntFieldUpdateOperationsInput | number | null
    memory?: NullableIntFieldUpdateOperationsInput | number | null
    intelligence?: NullableIntFieldUpdateOperationsInput | number | null
    iconID?: NullableIntFieldUpdateOperationsInput | number | null
    shortDescription?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type chrAncestriesUncheckedUpdateInput = {
    ancestryID?: IntFieldUpdateOperationsInput | number
    ancestryName?: NullableStringFieldUpdateOperationsInput | string | null
    bloodlineID?: NullableIntFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    perception?: NullableIntFieldUpdateOperationsInput | number | null
    willpower?: NullableIntFieldUpdateOperationsInput | number | null
    charisma?: NullableIntFieldUpdateOperationsInput | number | null
    memory?: NullableIntFieldUpdateOperationsInput | number | null
    intelligence?: NullableIntFieldUpdateOperationsInput | number | null
    iconID?: NullableIntFieldUpdateOperationsInput | number | null
    shortDescription?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type chrAncestriesCreateManyInput = {
    ancestryID: number
    ancestryName?: string | null
    bloodlineID?: number | null
    description?: string | null
    perception?: number | null
    willpower?: number | null
    charisma?: number | null
    memory?: number | null
    intelligence?: number | null
    iconID?: number | null
    shortDescription?: string | null
  }

  export type chrAncestriesUpdateManyMutationInput = {
    ancestryID?: IntFieldUpdateOperationsInput | number
    ancestryName?: NullableStringFieldUpdateOperationsInput | string | null
    bloodlineID?: NullableIntFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    perception?: NullableIntFieldUpdateOperationsInput | number | null
    willpower?: NullableIntFieldUpdateOperationsInput | number | null
    charisma?: NullableIntFieldUpdateOperationsInput | number | null
    memory?: NullableIntFieldUpdateOperationsInput | number | null
    intelligence?: NullableIntFieldUpdateOperationsInput | number | null
    iconID?: NullableIntFieldUpdateOperationsInput | number | null
    shortDescription?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type chrAncestriesUncheckedUpdateManyInput = {
    ancestryID?: IntFieldUpdateOperationsInput | number
    ancestryName?: NullableStringFieldUpdateOperationsInput | string | null
    bloodlineID?: NullableIntFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    perception?: NullableIntFieldUpdateOperationsInput | number | null
    willpower?: NullableIntFieldUpdateOperationsInput | number | null
    charisma?: NullableIntFieldUpdateOperationsInput | number | null
    memory?: NullableIntFieldUpdateOperationsInput | number | null
    intelligence?: NullableIntFieldUpdateOperationsInput | number | null
    iconID?: NullableIntFieldUpdateOperationsInput | number | null
    shortDescription?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type chrAttributesCreateInput = {
    attributeID: number
    attributeName?: string | null
    description?: string | null
    iconID?: number | null
    shortDescription?: string | null
    notes?: string | null
  }

  export type chrAttributesUncheckedCreateInput = {
    attributeID: number
    attributeName?: string | null
    description?: string | null
    iconID?: number | null
    shortDescription?: string | null
    notes?: string | null
  }

  export type chrAttributesUpdateInput = {
    attributeID?: IntFieldUpdateOperationsInput | number
    attributeName?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    iconID?: NullableIntFieldUpdateOperationsInput | number | null
    shortDescription?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type chrAttributesUncheckedUpdateInput = {
    attributeID?: IntFieldUpdateOperationsInput | number
    attributeName?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    iconID?: NullableIntFieldUpdateOperationsInput | number | null
    shortDescription?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type chrAttributesCreateManyInput = {
    attributeID: number
    attributeName?: string | null
    description?: string | null
    iconID?: number | null
    shortDescription?: string | null
    notes?: string | null
  }

  export type chrAttributesUpdateManyMutationInput = {
    attributeID?: IntFieldUpdateOperationsInput | number
    attributeName?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    iconID?: NullableIntFieldUpdateOperationsInput | number | null
    shortDescription?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type chrAttributesUncheckedUpdateManyInput = {
    attributeID?: IntFieldUpdateOperationsInput | number
    attributeName?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    iconID?: NullableIntFieldUpdateOperationsInput | number | null
    shortDescription?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type chrBloodlinesCreateInput = {
    bloodlineID: number
    bloodlineName?: string | null
    raceID?: number | null
    description?: string | null
    maleDescription?: string | null
    femaleDescription?: string | null
    shipTypeID?: number | null
    corporationID?: number | null
    perception?: number | null
    willpower?: number | null
    charisma?: number | null
    memory?: number | null
    intelligence?: number | null
    iconID?: number | null
    shortDescription?: string | null
    shortMaleDescription?: string | null
    shortFemaleDescription?: string | null
  }

  export type chrBloodlinesUncheckedCreateInput = {
    bloodlineID: number
    bloodlineName?: string | null
    raceID?: number | null
    description?: string | null
    maleDescription?: string | null
    femaleDescription?: string | null
    shipTypeID?: number | null
    corporationID?: number | null
    perception?: number | null
    willpower?: number | null
    charisma?: number | null
    memory?: number | null
    intelligence?: number | null
    iconID?: number | null
    shortDescription?: string | null
    shortMaleDescription?: string | null
    shortFemaleDescription?: string | null
  }

  export type chrBloodlinesUpdateInput = {
    bloodlineID?: IntFieldUpdateOperationsInput | number
    bloodlineName?: NullableStringFieldUpdateOperationsInput | string | null
    raceID?: NullableIntFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    maleDescription?: NullableStringFieldUpdateOperationsInput | string | null
    femaleDescription?: NullableStringFieldUpdateOperationsInput | string | null
    shipTypeID?: NullableIntFieldUpdateOperationsInput | number | null
    corporationID?: NullableIntFieldUpdateOperationsInput | number | null
    perception?: NullableIntFieldUpdateOperationsInput | number | null
    willpower?: NullableIntFieldUpdateOperationsInput | number | null
    charisma?: NullableIntFieldUpdateOperationsInput | number | null
    memory?: NullableIntFieldUpdateOperationsInput | number | null
    intelligence?: NullableIntFieldUpdateOperationsInput | number | null
    iconID?: NullableIntFieldUpdateOperationsInput | number | null
    shortDescription?: NullableStringFieldUpdateOperationsInput | string | null
    shortMaleDescription?: NullableStringFieldUpdateOperationsInput | string | null
    shortFemaleDescription?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type chrBloodlinesUncheckedUpdateInput = {
    bloodlineID?: IntFieldUpdateOperationsInput | number
    bloodlineName?: NullableStringFieldUpdateOperationsInput | string | null
    raceID?: NullableIntFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    maleDescription?: NullableStringFieldUpdateOperationsInput | string | null
    femaleDescription?: NullableStringFieldUpdateOperationsInput | string | null
    shipTypeID?: NullableIntFieldUpdateOperationsInput | number | null
    corporationID?: NullableIntFieldUpdateOperationsInput | number | null
    perception?: NullableIntFieldUpdateOperationsInput | number | null
    willpower?: NullableIntFieldUpdateOperationsInput | number | null
    charisma?: NullableIntFieldUpdateOperationsInput | number | null
    memory?: NullableIntFieldUpdateOperationsInput | number | null
    intelligence?: NullableIntFieldUpdateOperationsInput | number | null
    iconID?: NullableIntFieldUpdateOperationsInput | number | null
    shortDescription?: NullableStringFieldUpdateOperationsInput | string | null
    shortMaleDescription?: NullableStringFieldUpdateOperationsInput | string | null
    shortFemaleDescription?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type chrBloodlinesCreateManyInput = {
    bloodlineID: number
    bloodlineName?: string | null
    raceID?: number | null
    description?: string | null
    maleDescription?: string | null
    femaleDescription?: string | null
    shipTypeID?: number | null
    corporationID?: number | null
    perception?: number | null
    willpower?: number | null
    charisma?: number | null
    memory?: number | null
    intelligence?: number | null
    iconID?: number | null
    shortDescription?: string | null
    shortMaleDescription?: string | null
    shortFemaleDescription?: string | null
  }

  export type chrBloodlinesUpdateManyMutationInput = {
    bloodlineID?: IntFieldUpdateOperationsInput | number
    bloodlineName?: NullableStringFieldUpdateOperationsInput | string | null
    raceID?: NullableIntFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    maleDescription?: NullableStringFieldUpdateOperationsInput | string | null
    femaleDescription?: NullableStringFieldUpdateOperationsInput | string | null
    shipTypeID?: NullableIntFieldUpdateOperationsInput | number | null
    corporationID?: NullableIntFieldUpdateOperationsInput | number | null
    perception?: NullableIntFieldUpdateOperationsInput | number | null
    willpower?: NullableIntFieldUpdateOperationsInput | number | null
    charisma?: NullableIntFieldUpdateOperationsInput | number | null
    memory?: NullableIntFieldUpdateOperationsInput | number | null
    intelligence?: NullableIntFieldUpdateOperationsInput | number | null
    iconID?: NullableIntFieldUpdateOperationsInput | number | null
    shortDescription?: NullableStringFieldUpdateOperationsInput | string | null
    shortMaleDescription?: NullableStringFieldUpdateOperationsInput | string | null
    shortFemaleDescription?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type chrBloodlinesUncheckedUpdateManyInput = {
    bloodlineID?: IntFieldUpdateOperationsInput | number
    bloodlineName?: NullableStringFieldUpdateOperationsInput | string | null
    raceID?: NullableIntFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    maleDescription?: NullableStringFieldUpdateOperationsInput | string | null
    femaleDescription?: NullableStringFieldUpdateOperationsInput | string | null
    shipTypeID?: NullableIntFieldUpdateOperationsInput | number | null
    corporationID?: NullableIntFieldUpdateOperationsInput | number | null
    perception?: NullableIntFieldUpdateOperationsInput | number | null
    willpower?: NullableIntFieldUpdateOperationsInput | number | null
    charisma?: NullableIntFieldUpdateOperationsInput | number | null
    memory?: NullableIntFieldUpdateOperationsInput | number | null
    intelligence?: NullableIntFieldUpdateOperationsInput | number | null
    iconID?: NullableIntFieldUpdateOperationsInput | number | null
    shortDescription?: NullableStringFieldUpdateOperationsInput | string | null
    shortMaleDescription?: NullableStringFieldUpdateOperationsInput | string | null
    shortFemaleDescription?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type chrFactionsCreateInput = {
    factionID: number
    factionName?: string | null
    description?: string | null
    raceIDs?: number | null
    solarSystemID?: number | null
    corporationID?: number | null
    sizeFactor?: number | null
    stationCount?: number | null
    stationSystemCount?: number | null
    militiaCorporationID?: number | null
    iconID?: number | null
  }

  export type chrFactionsUncheckedCreateInput = {
    factionID: number
    factionName?: string | null
    description?: string | null
    raceIDs?: number | null
    solarSystemID?: number | null
    corporationID?: number | null
    sizeFactor?: number | null
    stationCount?: number | null
    stationSystemCount?: number | null
    militiaCorporationID?: number | null
    iconID?: number | null
  }

  export type chrFactionsUpdateInput = {
    factionID?: IntFieldUpdateOperationsInput | number
    factionName?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    raceIDs?: NullableIntFieldUpdateOperationsInput | number | null
    solarSystemID?: NullableIntFieldUpdateOperationsInput | number | null
    corporationID?: NullableIntFieldUpdateOperationsInput | number | null
    sizeFactor?: NullableFloatFieldUpdateOperationsInput | number | null
    stationCount?: NullableIntFieldUpdateOperationsInput | number | null
    stationSystemCount?: NullableIntFieldUpdateOperationsInput | number | null
    militiaCorporationID?: NullableIntFieldUpdateOperationsInput | number | null
    iconID?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type chrFactionsUncheckedUpdateInput = {
    factionID?: IntFieldUpdateOperationsInput | number
    factionName?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    raceIDs?: NullableIntFieldUpdateOperationsInput | number | null
    solarSystemID?: NullableIntFieldUpdateOperationsInput | number | null
    corporationID?: NullableIntFieldUpdateOperationsInput | number | null
    sizeFactor?: NullableFloatFieldUpdateOperationsInput | number | null
    stationCount?: NullableIntFieldUpdateOperationsInput | number | null
    stationSystemCount?: NullableIntFieldUpdateOperationsInput | number | null
    militiaCorporationID?: NullableIntFieldUpdateOperationsInput | number | null
    iconID?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type chrFactionsCreateManyInput = {
    factionID: number
    factionName?: string | null
    description?: string | null
    raceIDs?: number | null
    solarSystemID?: number | null
    corporationID?: number | null
    sizeFactor?: number | null
    stationCount?: number | null
    stationSystemCount?: number | null
    militiaCorporationID?: number | null
    iconID?: number | null
  }

  export type chrFactionsUpdateManyMutationInput = {
    factionID?: IntFieldUpdateOperationsInput | number
    factionName?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    raceIDs?: NullableIntFieldUpdateOperationsInput | number | null
    solarSystemID?: NullableIntFieldUpdateOperationsInput | number | null
    corporationID?: NullableIntFieldUpdateOperationsInput | number | null
    sizeFactor?: NullableFloatFieldUpdateOperationsInput | number | null
    stationCount?: NullableIntFieldUpdateOperationsInput | number | null
    stationSystemCount?: NullableIntFieldUpdateOperationsInput | number | null
    militiaCorporationID?: NullableIntFieldUpdateOperationsInput | number | null
    iconID?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type chrFactionsUncheckedUpdateManyInput = {
    factionID?: IntFieldUpdateOperationsInput | number
    factionName?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    raceIDs?: NullableIntFieldUpdateOperationsInput | number | null
    solarSystemID?: NullableIntFieldUpdateOperationsInput | number | null
    corporationID?: NullableIntFieldUpdateOperationsInput | number | null
    sizeFactor?: NullableFloatFieldUpdateOperationsInput | number | null
    stationCount?: NullableIntFieldUpdateOperationsInput | number | null
    stationSystemCount?: NullableIntFieldUpdateOperationsInput | number | null
    militiaCorporationID?: NullableIntFieldUpdateOperationsInput | number | null
    iconID?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type chrRacesCreateInput = {
    raceID: number
    raceName?: string | null
    description?: string | null
    iconID?: number | null
    shortDescription?: string | null
  }

  export type chrRacesUncheckedCreateInput = {
    raceID: number
    raceName?: string | null
    description?: string | null
    iconID?: number | null
    shortDescription?: string | null
  }

  export type chrRacesUpdateInput = {
    raceID?: IntFieldUpdateOperationsInput | number
    raceName?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    iconID?: NullableIntFieldUpdateOperationsInput | number | null
    shortDescription?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type chrRacesUncheckedUpdateInput = {
    raceID?: IntFieldUpdateOperationsInput | number
    raceName?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    iconID?: NullableIntFieldUpdateOperationsInput | number | null
    shortDescription?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type chrRacesCreateManyInput = {
    raceID: number
    raceName?: string | null
    description?: string | null
    iconID?: number | null
    shortDescription?: string | null
  }

  export type chrRacesUpdateManyMutationInput = {
    raceID?: IntFieldUpdateOperationsInput | number
    raceName?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    iconID?: NullableIntFieldUpdateOperationsInput | number | null
    shortDescription?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type chrRacesUncheckedUpdateManyInput = {
    raceID?: IntFieldUpdateOperationsInput | number
    raceName?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    iconID?: NullableIntFieldUpdateOperationsInput | number | null
    shortDescription?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type crpActivitiesCreateInput = {
    activityID: number
    activityName?: string | null
    description?: string | null
  }

  export type crpActivitiesUncheckedCreateInput = {
    activityID: number
    activityName?: string | null
    description?: string | null
  }

  export type crpActivitiesUpdateInput = {
    activityID?: IntFieldUpdateOperationsInput | number
    activityName?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type crpActivitiesUncheckedUpdateInput = {
    activityID?: IntFieldUpdateOperationsInput | number
    activityName?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type crpActivitiesCreateManyInput = {
    activityID: number
    activityName?: string | null
    description?: string | null
  }

  export type crpActivitiesUpdateManyMutationInput = {
    activityID?: IntFieldUpdateOperationsInput | number
    activityName?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type crpActivitiesUncheckedUpdateManyInput = {
    activityID?: IntFieldUpdateOperationsInput | number
    activityName?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type crpNPCCorporationDivisionsCreateInput = {
    corporationID: number
    divisionID: number
    size?: number | null
  }

  export type crpNPCCorporationDivisionsUncheckedCreateInput = {
    corporationID: number
    divisionID: number
    size?: number | null
  }

  export type crpNPCCorporationDivisionsUpdateInput = {
    corporationID?: IntFieldUpdateOperationsInput | number
    divisionID?: IntFieldUpdateOperationsInput | number
    size?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type crpNPCCorporationDivisionsUncheckedUpdateInput = {
    corporationID?: IntFieldUpdateOperationsInput | number
    divisionID?: IntFieldUpdateOperationsInput | number
    size?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type crpNPCCorporationDivisionsCreateManyInput = {
    corporationID: number
    divisionID: number
    size?: number | null
  }

  export type crpNPCCorporationDivisionsUpdateManyMutationInput = {
    corporationID?: IntFieldUpdateOperationsInput | number
    divisionID?: IntFieldUpdateOperationsInput | number
    size?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type crpNPCCorporationDivisionsUncheckedUpdateManyInput = {
    corporationID?: IntFieldUpdateOperationsInput | number
    divisionID?: IntFieldUpdateOperationsInput | number
    size?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type crpNPCCorporationResearchFieldsCreateInput = {
    skillID: number
    corporationID: number
  }

  export type crpNPCCorporationResearchFieldsUncheckedCreateInput = {
    skillID: number
    corporationID: number
  }

  export type crpNPCCorporationResearchFieldsUpdateInput = {
    skillID?: IntFieldUpdateOperationsInput | number
    corporationID?: IntFieldUpdateOperationsInput | number
  }

  export type crpNPCCorporationResearchFieldsUncheckedUpdateInput = {
    skillID?: IntFieldUpdateOperationsInput | number
    corporationID?: IntFieldUpdateOperationsInput | number
  }

  export type crpNPCCorporationResearchFieldsCreateManyInput = {
    skillID: number
    corporationID: number
  }

  export type crpNPCCorporationResearchFieldsUpdateManyMutationInput = {
    skillID?: IntFieldUpdateOperationsInput | number
    corporationID?: IntFieldUpdateOperationsInput | number
  }

  export type crpNPCCorporationResearchFieldsUncheckedUpdateManyInput = {
    skillID?: IntFieldUpdateOperationsInput | number
    corporationID?: IntFieldUpdateOperationsInput | number
  }

  export type crpNPCCorporationTradesCreateInput = {
    corporationID: number
    typeID: number
  }

  export type crpNPCCorporationTradesUncheckedCreateInput = {
    corporationID: number
    typeID: number
  }

  export type crpNPCCorporationTradesUpdateInput = {
    corporationID?: IntFieldUpdateOperationsInput | number
    typeID?: IntFieldUpdateOperationsInput | number
  }

  export type crpNPCCorporationTradesUncheckedUpdateInput = {
    corporationID?: IntFieldUpdateOperationsInput | number
    typeID?: IntFieldUpdateOperationsInput | number
  }

  export type crpNPCCorporationTradesCreateManyInput = {
    corporationID: number
    typeID: number
  }

  export type crpNPCCorporationTradesUpdateManyMutationInput = {
    corporationID?: IntFieldUpdateOperationsInput | number
    typeID?: IntFieldUpdateOperationsInput | number
  }

  export type crpNPCCorporationTradesUncheckedUpdateManyInput = {
    corporationID?: IntFieldUpdateOperationsInput | number
    typeID?: IntFieldUpdateOperationsInput | number
  }

  export type crpNPCCorporationsCreateInput = {
    corporationID: number
    size?: string | null
    extent?: string | null
    solarSystemID?: number | null
    investorID1?: number | null
    investorShares1?: number | null
    investorID2?: number | null
    investorShares2?: number | null
    investorID3?: number | null
    investorShares3?: number | null
    investorID4?: number | null
    investorShares4?: number | null
    friendID?: number | null
    enemyID?: number | null
    publicShares?: number | null
    initialPrice?: number | null
    minSecurity?: number | null
    scattered?: boolean | null
    fringe?: number | null
    corridor?: number | null
    hub?: number | null
    border?: number | null
    factionID?: number | null
    sizeFactor?: number | null
    stationCount?: number | null
    stationSystemCount?: number | null
    description?: string | null
    iconID?: number | null
  }

  export type crpNPCCorporationsUncheckedCreateInput = {
    corporationID: number
    size?: string | null
    extent?: string | null
    solarSystemID?: number | null
    investorID1?: number | null
    investorShares1?: number | null
    investorID2?: number | null
    investorShares2?: number | null
    investorID3?: number | null
    investorShares3?: number | null
    investorID4?: number | null
    investorShares4?: number | null
    friendID?: number | null
    enemyID?: number | null
    publicShares?: number | null
    initialPrice?: number | null
    minSecurity?: number | null
    scattered?: boolean | null
    fringe?: number | null
    corridor?: number | null
    hub?: number | null
    border?: number | null
    factionID?: number | null
    sizeFactor?: number | null
    stationCount?: number | null
    stationSystemCount?: number | null
    description?: string | null
    iconID?: number | null
  }

  export type crpNPCCorporationsUpdateInput = {
    corporationID?: IntFieldUpdateOperationsInput | number
    size?: NullableStringFieldUpdateOperationsInput | string | null
    extent?: NullableStringFieldUpdateOperationsInput | string | null
    solarSystemID?: NullableIntFieldUpdateOperationsInput | number | null
    investorID1?: NullableIntFieldUpdateOperationsInput | number | null
    investorShares1?: NullableIntFieldUpdateOperationsInput | number | null
    investorID2?: NullableIntFieldUpdateOperationsInput | number | null
    investorShares2?: NullableIntFieldUpdateOperationsInput | number | null
    investorID3?: NullableIntFieldUpdateOperationsInput | number | null
    investorShares3?: NullableIntFieldUpdateOperationsInput | number | null
    investorID4?: NullableIntFieldUpdateOperationsInput | number | null
    investorShares4?: NullableIntFieldUpdateOperationsInput | number | null
    friendID?: NullableIntFieldUpdateOperationsInput | number | null
    enemyID?: NullableIntFieldUpdateOperationsInput | number | null
    publicShares?: NullableIntFieldUpdateOperationsInput | number | null
    initialPrice?: NullableIntFieldUpdateOperationsInput | number | null
    minSecurity?: NullableFloatFieldUpdateOperationsInput | number | null
    scattered?: NullableBoolFieldUpdateOperationsInput | boolean | null
    fringe?: NullableIntFieldUpdateOperationsInput | number | null
    corridor?: NullableIntFieldUpdateOperationsInput | number | null
    hub?: NullableIntFieldUpdateOperationsInput | number | null
    border?: NullableIntFieldUpdateOperationsInput | number | null
    factionID?: NullableIntFieldUpdateOperationsInput | number | null
    sizeFactor?: NullableFloatFieldUpdateOperationsInput | number | null
    stationCount?: NullableIntFieldUpdateOperationsInput | number | null
    stationSystemCount?: NullableIntFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    iconID?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type crpNPCCorporationsUncheckedUpdateInput = {
    corporationID?: IntFieldUpdateOperationsInput | number
    size?: NullableStringFieldUpdateOperationsInput | string | null
    extent?: NullableStringFieldUpdateOperationsInput | string | null
    solarSystemID?: NullableIntFieldUpdateOperationsInput | number | null
    investorID1?: NullableIntFieldUpdateOperationsInput | number | null
    investorShares1?: NullableIntFieldUpdateOperationsInput | number | null
    investorID2?: NullableIntFieldUpdateOperationsInput | number | null
    investorShares2?: NullableIntFieldUpdateOperationsInput | number | null
    investorID3?: NullableIntFieldUpdateOperationsInput | number | null
    investorShares3?: NullableIntFieldUpdateOperationsInput | number | null
    investorID4?: NullableIntFieldUpdateOperationsInput | number | null
    investorShares4?: NullableIntFieldUpdateOperationsInput | number | null
    friendID?: NullableIntFieldUpdateOperationsInput | number | null
    enemyID?: NullableIntFieldUpdateOperationsInput | number | null
    publicShares?: NullableIntFieldUpdateOperationsInput | number | null
    initialPrice?: NullableIntFieldUpdateOperationsInput | number | null
    minSecurity?: NullableFloatFieldUpdateOperationsInput | number | null
    scattered?: NullableBoolFieldUpdateOperationsInput | boolean | null
    fringe?: NullableIntFieldUpdateOperationsInput | number | null
    corridor?: NullableIntFieldUpdateOperationsInput | number | null
    hub?: NullableIntFieldUpdateOperationsInput | number | null
    border?: NullableIntFieldUpdateOperationsInput | number | null
    factionID?: NullableIntFieldUpdateOperationsInput | number | null
    sizeFactor?: NullableFloatFieldUpdateOperationsInput | number | null
    stationCount?: NullableIntFieldUpdateOperationsInput | number | null
    stationSystemCount?: NullableIntFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    iconID?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type crpNPCCorporationsCreateManyInput = {
    corporationID: number
    size?: string | null
    extent?: string | null
    solarSystemID?: number | null
    investorID1?: number | null
    investorShares1?: number | null
    investorID2?: number | null
    investorShares2?: number | null
    investorID3?: number | null
    investorShares3?: number | null
    investorID4?: number | null
    investorShares4?: number | null
    friendID?: number | null
    enemyID?: number | null
    publicShares?: number | null
    initialPrice?: number | null
    minSecurity?: number | null
    scattered?: boolean | null
    fringe?: number | null
    corridor?: number | null
    hub?: number | null
    border?: number | null
    factionID?: number | null
    sizeFactor?: number | null
    stationCount?: number | null
    stationSystemCount?: number | null
    description?: string | null
    iconID?: number | null
  }

  export type crpNPCCorporationsUpdateManyMutationInput = {
    corporationID?: IntFieldUpdateOperationsInput | number
    size?: NullableStringFieldUpdateOperationsInput | string | null
    extent?: NullableStringFieldUpdateOperationsInput | string | null
    solarSystemID?: NullableIntFieldUpdateOperationsInput | number | null
    investorID1?: NullableIntFieldUpdateOperationsInput | number | null
    investorShares1?: NullableIntFieldUpdateOperationsInput | number | null
    investorID2?: NullableIntFieldUpdateOperationsInput | number | null
    investorShares2?: NullableIntFieldUpdateOperationsInput | number | null
    investorID3?: NullableIntFieldUpdateOperationsInput | number | null
    investorShares3?: NullableIntFieldUpdateOperationsInput | number | null
    investorID4?: NullableIntFieldUpdateOperationsInput | number | null
    investorShares4?: NullableIntFieldUpdateOperationsInput | number | null
    friendID?: NullableIntFieldUpdateOperationsInput | number | null
    enemyID?: NullableIntFieldUpdateOperationsInput | number | null
    publicShares?: NullableIntFieldUpdateOperationsInput | number | null
    initialPrice?: NullableIntFieldUpdateOperationsInput | number | null
    minSecurity?: NullableFloatFieldUpdateOperationsInput | number | null
    scattered?: NullableBoolFieldUpdateOperationsInput | boolean | null
    fringe?: NullableIntFieldUpdateOperationsInput | number | null
    corridor?: NullableIntFieldUpdateOperationsInput | number | null
    hub?: NullableIntFieldUpdateOperationsInput | number | null
    border?: NullableIntFieldUpdateOperationsInput | number | null
    factionID?: NullableIntFieldUpdateOperationsInput | number | null
    sizeFactor?: NullableFloatFieldUpdateOperationsInput | number | null
    stationCount?: NullableIntFieldUpdateOperationsInput | number | null
    stationSystemCount?: NullableIntFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    iconID?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type crpNPCCorporationsUncheckedUpdateManyInput = {
    corporationID?: IntFieldUpdateOperationsInput | number
    size?: NullableStringFieldUpdateOperationsInput | string | null
    extent?: NullableStringFieldUpdateOperationsInput | string | null
    solarSystemID?: NullableIntFieldUpdateOperationsInput | number | null
    investorID1?: NullableIntFieldUpdateOperationsInput | number | null
    investorShares1?: NullableIntFieldUpdateOperationsInput | number | null
    investorID2?: NullableIntFieldUpdateOperationsInput | number | null
    investorShares2?: NullableIntFieldUpdateOperationsInput | number | null
    investorID3?: NullableIntFieldUpdateOperationsInput | number | null
    investorShares3?: NullableIntFieldUpdateOperationsInput | number | null
    investorID4?: NullableIntFieldUpdateOperationsInput | number | null
    investorShares4?: NullableIntFieldUpdateOperationsInput | number | null
    friendID?: NullableIntFieldUpdateOperationsInput | number | null
    enemyID?: NullableIntFieldUpdateOperationsInput | number | null
    publicShares?: NullableIntFieldUpdateOperationsInput | number | null
    initialPrice?: NullableIntFieldUpdateOperationsInput | number | null
    minSecurity?: NullableFloatFieldUpdateOperationsInput | number | null
    scattered?: NullableBoolFieldUpdateOperationsInput | boolean | null
    fringe?: NullableIntFieldUpdateOperationsInput | number | null
    corridor?: NullableIntFieldUpdateOperationsInput | number | null
    hub?: NullableIntFieldUpdateOperationsInput | number | null
    border?: NullableIntFieldUpdateOperationsInput | number | null
    factionID?: NullableIntFieldUpdateOperationsInput | number | null
    sizeFactor?: NullableFloatFieldUpdateOperationsInput | number | null
    stationCount?: NullableIntFieldUpdateOperationsInput | number | null
    stationSystemCount?: NullableIntFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    iconID?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type crpNPCDivisionsCreateInput = {
    divisionID: number
    divisionName?: string | null
    description?: string | null
    leaderType?: string | null
  }

  export type crpNPCDivisionsUncheckedCreateInput = {
    divisionID: number
    divisionName?: string | null
    description?: string | null
    leaderType?: string | null
  }

  export type crpNPCDivisionsUpdateInput = {
    divisionID?: IntFieldUpdateOperationsInput | number
    divisionName?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    leaderType?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type crpNPCDivisionsUncheckedUpdateInput = {
    divisionID?: IntFieldUpdateOperationsInput | number
    divisionName?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    leaderType?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type crpNPCDivisionsCreateManyInput = {
    divisionID: number
    divisionName?: string | null
    description?: string | null
    leaderType?: string | null
  }

  export type crpNPCDivisionsUpdateManyMutationInput = {
    divisionID?: IntFieldUpdateOperationsInput | number
    divisionName?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    leaderType?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type crpNPCDivisionsUncheckedUpdateManyInput = {
    divisionID?: IntFieldUpdateOperationsInput | number
    divisionName?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    leaderType?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type dgmAttributeCategoriesCreateInput = {
    categoryID: number
    categoryName?: string | null
    categoryDescription?: string | null
  }

  export type dgmAttributeCategoriesUncheckedCreateInput = {
    categoryID: number
    categoryName?: string | null
    categoryDescription?: string | null
  }

  export type dgmAttributeCategoriesUpdateInput = {
    categoryID?: IntFieldUpdateOperationsInput | number
    categoryName?: NullableStringFieldUpdateOperationsInput | string | null
    categoryDescription?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type dgmAttributeCategoriesUncheckedUpdateInput = {
    categoryID?: IntFieldUpdateOperationsInput | number
    categoryName?: NullableStringFieldUpdateOperationsInput | string | null
    categoryDescription?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type dgmAttributeCategoriesCreateManyInput = {
    categoryID: number
    categoryName?: string | null
    categoryDescription?: string | null
  }

  export type dgmAttributeCategoriesUpdateManyMutationInput = {
    categoryID?: IntFieldUpdateOperationsInput | number
    categoryName?: NullableStringFieldUpdateOperationsInput | string | null
    categoryDescription?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type dgmAttributeCategoriesUncheckedUpdateManyInput = {
    categoryID?: IntFieldUpdateOperationsInput | number
    categoryName?: NullableStringFieldUpdateOperationsInput | string | null
    categoryDescription?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type dgmAttributeTypesCreateInput = {
    attributeID: number
    attributeName?: string | null
    description?: string | null
    iconID?: number | null
    defaultValue?: number | null
    published?: boolean | null
    displayName?: string | null
    unitID?: number | null
    stackable?: boolean | null
    highIsGood?: boolean | null
    categoryID?: number | null
  }

  export type dgmAttributeTypesUncheckedCreateInput = {
    attributeID: number
    attributeName?: string | null
    description?: string | null
    iconID?: number | null
    defaultValue?: number | null
    published?: boolean | null
    displayName?: string | null
    unitID?: number | null
    stackable?: boolean | null
    highIsGood?: boolean | null
    categoryID?: number | null
  }

  export type dgmAttributeTypesUpdateInput = {
    attributeID?: IntFieldUpdateOperationsInput | number
    attributeName?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    iconID?: NullableIntFieldUpdateOperationsInput | number | null
    defaultValue?: NullableFloatFieldUpdateOperationsInput | number | null
    published?: NullableBoolFieldUpdateOperationsInput | boolean | null
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    unitID?: NullableIntFieldUpdateOperationsInput | number | null
    stackable?: NullableBoolFieldUpdateOperationsInput | boolean | null
    highIsGood?: NullableBoolFieldUpdateOperationsInput | boolean | null
    categoryID?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type dgmAttributeTypesUncheckedUpdateInput = {
    attributeID?: IntFieldUpdateOperationsInput | number
    attributeName?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    iconID?: NullableIntFieldUpdateOperationsInput | number | null
    defaultValue?: NullableFloatFieldUpdateOperationsInput | number | null
    published?: NullableBoolFieldUpdateOperationsInput | boolean | null
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    unitID?: NullableIntFieldUpdateOperationsInput | number | null
    stackable?: NullableBoolFieldUpdateOperationsInput | boolean | null
    highIsGood?: NullableBoolFieldUpdateOperationsInput | boolean | null
    categoryID?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type dgmAttributeTypesCreateManyInput = {
    attributeID: number
    attributeName?: string | null
    description?: string | null
    iconID?: number | null
    defaultValue?: number | null
    published?: boolean | null
    displayName?: string | null
    unitID?: number | null
    stackable?: boolean | null
    highIsGood?: boolean | null
    categoryID?: number | null
  }

  export type dgmAttributeTypesUpdateManyMutationInput = {
    attributeID?: IntFieldUpdateOperationsInput | number
    attributeName?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    iconID?: NullableIntFieldUpdateOperationsInput | number | null
    defaultValue?: NullableFloatFieldUpdateOperationsInput | number | null
    published?: NullableBoolFieldUpdateOperationsInput | boolean | null
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    unitID?: NullableIntFieldUpdateOperationsInput | number | null
    stackable?: NullableBoolFieldUpdateOperationsInput | boolean | null
    highIsGood?: NullableBoolFieldUpdateOperationsInput | boolean | null
    categoryID?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type dgmAttributeTypesUncheckedUpdateManyInput = {
    attributeID?: IntFieldUpdateOperationsInput | number
    attributeName?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    iconID?: NullableIntFieldUpdateOperationsInput | number | null
    defaultValue?: NullableFloatFieldUpdateOperationsInput | number | null
    published?: NullableBoolFieldUpdateOperationsInput | boolean | null
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    unitID?: NullableIntFieldUpdateOperationsInput | number | null
    stackable?: NullableBoolFieldUpdateOperationsInput | boolean | null
    highIsGood?: NullableBoolFieldUpdateOperationsInput | boolean | null
    categoryID?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type dgmEffectsCreateInput = {
    effectID: number
    effectName?: string | null
    effectCategory?: number | null
    preExpression?: number | null
    postExpression?: number | null
    description?: string | null
    guid?: string | null
    iconID?: number | null
    isOffensive?: boolean | null
    isAssistance?: boolean | null
    durationAttributeID?: number | null
    trackingSpeedAttributeID?: number | null
    dischargeAttributeID?: number | null
    rangeAttributeID?: number | null
    falloffAttributeID?: number | null
    disallowAutoRepeat?: boolean | null
    published?: boolean | null
    displayName?: string | null
    isWarpSafe?: boolean | null
    rangeChance?: boolean | null
    electronicChance?: boolean | null
    propulsionChance?: boolean | null
    distribution?: number | null
    sfxName?: string | null
    npcUsageChanceAttributeID?: number | null
    npcActivationChanceAttributeID?: number | null
    fittingUsageChanceAttributeID?: number | null
    modifierInfo?: string | null
  }

  export type dgmEffectsUncheckedCreateInput = {
    effectID: number
    effectName?: string | null
    effectCategory?: number | null
    preExpression?: number | null
    postExpression?: number | null
    description?: string | null
    guid?: string | null
    iconID?: number | null
    isOffensive?: boolean | null
    isAssistance?: boolean | null
    durationAttributeID?: number | null
    trackingSpeedAttributeID?: number | null
    dischargeAttributeID?: number | null
    rangeAttributeID?: number | null
    falloffAttributeID?: number | null
    disallowAutoRepeat?: boolean | null
    published?: boolean | null
    displayName?: string | null
    isWarpSafe?: boolean | null
    rangeChance?: boolean | null
    electronicChance?: boolean | null
    propulsionChance?: boolean | null
    distribution?: number | null
    sfxName?: string | null
    npcUsageChanceAttributeID?: number | null
    npcActivationChanceAttributeID?: number | null
    fittingUsageChanceAttributeID?: number | null
    modifierInfo?: string | null
  }

  export type dgmEffectsUpdateInput = {
    effectID?: IntFieldUpdateOperationsInput | number
    effectName?: NullableStringFieldUpdateOperationsInput | string | null
    effectCategory?: NullableIntFieldUpdateOperationsInput | number | null
    preExpression?: NullableIntFieldUpdateOperationsInput | number | null
    postExpression?: NullableIntFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    guid?: NullableStringFieldUpdateOperationsInput | string | null
    iconID?: NullableIntFieldUpdateOperationsInput | number | null
    isOffensive?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isAssistance?: NullableBoolFieldUpdateOperationsInput | boolean | null
    durationAttributeID?: NullableIntFieldUpdateOperationsInput | number | null
    trackingSpeedAttributeID?: NullableIntFieldUpdateOperationsInput | number | null
    dischargeAttributeID?: NullableIntFieldUpdateOperationsInput | number | null
    rangeAttributeID?: NullableIntFieldUpdateOperationsInput | number | null
    falloffAttributeID?: NullableIntFieldUpdateOperationsInput | number | null
    disallowAutoRepeat?: NullableBoolFieldUpdateOperationsInput | boolean | null
    published?: NullableBoolFieldUpdateOperationsInput | boolean | null
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    isWarpSafe?: NullableBoolFieldUpdateOperationsInput | boolean | null
    rangeChance?: NullableBoolFieldUpdateOperationsInput | boolean | null
    electronicChance?: NullableBoolFieldUpdateOperationsInput | boolean | null
    propulsionChance?: NullableBoolFieldUpdateOperationsInput | boolean | null
    distribution?: NullableIntFieldUpdateOperationsInput | number | null
    sfxName?: NullableStringFieldUpdateOperationsInput | string | null
    npcUsageChanceAttributeID?: NullableIntFieldUpdateOperationsInput | number | null
    npcActivationChanceAttributeID?: NullableIntFieldUpdateOperationsInput | number | null
    fittingUsageChanceAttributeID?: NullableIntFieldUpdateOperationsInput | number | null
    modifierInfo?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type dgmEffectsUncheckedUpdateInput = {
    effectID?: IntFieldUpdateOperationsInput | number
    effectName?: NullableStringFieldUpdateOperationsInput | string | null
    effectCategory?: NullableIntFieldUpdateOperationsInput | number | null
    preExpression?: NullableIntFieldUpdateOperationsInput | number | null
    postExpression?: NullableIntFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    guid?: NullableStringFieldUpdateOperationsInput | string | null
    iconID?: NullableIntFieldUpdateOperationsInput | number | null
    isOffensive?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isAssistance?: NullableBoolFieldUpdateOperationsInput | boolean | null
    durationAttributeID?: NullableIntFieldUpdateOperationsInput | number | null
    trackingSpeedAttributeID?: NullableIntFieldUpdateOperationsInput | number | null
    dischargeAttributeID?: NullableIntFieldUpdateOperationsInput | number | null
    rangeAttributeID?: NullableIntFieldUpdateOperationsInput | number | null
    falloffAttributeID?: NullableIntFieldUpdateOperationsInput | number | null
    disallowAutoRepeat?: NullableBoolFieldUpdateOperationsInput | boolean | null
    published?: NullableBoolFieldUpdateOperationsInput | boolean | null
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    isWarpSafe?: NullableBoolFieldUpdateOperationsInput | boolean | null
    rangeChance?: NullableBoolFieldUpdateOperationsInput | boolean | null
    electronicChance?: NullableBoolFieldUpdateOperationsInput | boolean | null
    propulsionChance?: NullableBoolFieldUpdateOperationsInput | boolean | null
    distribution?: NullableIntFieldUpdateOperationsInput | number | null
    sfxName?: NullableStringFieldUpdateOperationsInput | string | null
    npcUsageChanceAttributeID?: NullableIntFieldUpdateOperationsInput | number | null
    npcActivationChanceAttributeID?: NullableIntFieldUpdateOperationsInput | number | null
    fittingUsageChanceAttributeID?: NullableIntFieldUpdateOperationsInput | number | null
    modifierInfo?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type dgmEffectsCreateManyInput = {
    effectID: number
    effectName?: string | null
    effectCategory?: number | null
    preExpression?: number | null
    postExpression?: number | null
    description?: string | null
    guid?: string | null
    iconID?: number | null
    isOffensive?: boolean | null
    isAssistance?: boolean | null
    durationAttributeID?: number | null
    trackingSpeedAttributeID?: number | null
    dischargeAttributeID?: number | null
    rangeAttributeID?: number | null
    falloffAttributeID?: number | null
    disallowAutoRepeat?: boolean | null
    published?: boolean | null
    displayName?: string | null
    isWarpSafe?: boolean | null
    rangeChance?: boolean | null
    electronicChance?: boolean | null
    propulsionChance?: boolean | null
    distribution?: number | null
    sfxName?: string | null
    npcUsageChanceAttributeID?: number | null
    npcActivationChanceAttributeID?: number | null
    fittingUsageChanceAttributeID?: number | null
    modifierInfo?: string | null
  }

  export type dgmEffectsUpdateManyMutationInput = {
    effectID?: IntFieldUpdateOperationsInput | number
    effectName?: NullableStringFieldUpdateOperationsInput | string | null
    effectCategory?: NullableIntFieldUpdateOperationsInput | number | null
    preExpression?: NullableIntFieldUpdateOperationsInput | number | null
    postExpression?: NullableIntFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    guid?: NullableStringFieldUpdateOperationsInput | string | null
    iconID?: NullableIntFieldUpdateOperationsInput | number | null
    isOffensive?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isAssistance?: NullableBoolFieldUpdateOperationsInput | boolean | null
    durationAttributeID?: NullableIntFieldUpdateOperationsInput | number | null
    trackingSpeedAttributeID?: NullableIntFieldUpdateOperationsInput | number | null
    dischargeAttributeID?: NullableIntFieldUpdateOperationsInput | number | null
    rangeAttributeID?: NullableIntFieldUpdateOperationsInput | number | null
    falloffAttributeID?: NullableIntFieldUpdateOperationsInput | number | null
    disallowAutoRepeat?: NullableBoolFieldUpdateOperationsInput | boolean | null
    published?: NullableBoolFieldUpdateOperationsInput | boolean | null
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    isWarpSafe?: NullableBoolFieldUpdateOperationsInput | boolean | null
    rangeChance?: NullableBoolFieldUpdateOperationsInput | boolean | null
    electronicChance?: NullableBoolFieldUpdateOperationsInput | boolean | null
    propulsionChance?: NullableBoolFieldUpdateOperationsInput | boolean | null
    distribution?: NullableIntFieldUpdateOperationsInput | number | null
    sfxName?: NullableStringFieldUpdateOperationsInput | string | null
    npcUsageChanceAttributeID?: NullableIntFieldUpdateOperationsInput | number | null
    npcActivationChanceAttributeID?: NullableIntFieldUpdateOperationsInput | number | null
    fittingUsageChanceAttributeID?: NullableIntFieldUpdateOperationsInput | number | null
    modifierInfo?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type dgmEffectsUncheckedUpdateManyInput = {
    effectID?: IntFieldUpdateOperationsInput | number
    effectName?: NullableStringFieldUpdateOperationsInput | string | null
    effectCategory?: NullableIntFieldUpdateOperationsInput | number | null
    preExpression?: NullableIntFieldUpdateOperationsInput | number | null
    postExpression?: NullableIntFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    guid?: NullableStringFieldUpdateOperationsInput | string | null
    iconID?: NullableIntFieldUpdateOperationsInput | number | null
    isOffensive?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isAssistance?: NullableBoolFieldUpdateOperationsInput | boolean | null
    durationAttributeID?: NullableIntFieldUpdateOperationsInput | number | null
    trackingSpeedAttributeID?: NullableIntFieldUpdateOperationsInput | number | null
    dischargeAttributeID?: NullableIntFieldUpdateOperationsInput | number | null
    rangeAttributeID?: NullableIntFieldUpdateOperationsInput | number | null
    falloffAttributeID?: NullableIntFieldUpdateOperationsInput | number | null
    disallowAutoRepeat?: NullableBoolFieldUpdateOperationsInput | boolean | null
    published?: NullableBoolFieldUpdateOperationsInput | boolean | null
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    isWarpSafe?: NullableBoolFieldUpdateOperationsInput | boolean | null
    rangeChance?: NullableBoolFieldUpdateOperationsInput | boolean | null
    electronicChance?: NullableBoolFieldUpdateOperationsInput | boolean | null
    propulsionChance?: NullableBoolFieldUpdateOperationsInput | boolean | null
    distribution?: NullableIntFieldUpdateOperationsInput | number | null
    sfxName?: NullableStringFieldUpdateOperationsInput | string | null
    npcUsageChanceAttributeID?: NullableIntFieldUpdateOperationsInput | number | null
    npcActivationChanceAttributeID?: NullableIntFieldUpdateOperationsInput | number | null
    fittingUsageChanceAttributeID?: NullableIntFieldUpdateOperationsInput | number | null
    modifierInfo?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type dgmExpressionsCreateInput = {
    expressionID: number
    operandID?: number | null
    arg1?: number | null
    arg2?: number | null
    expressionValue?: string | null
    description?: string | null
    expressionName?: string | null
    expressionTypeID?: number | null
    expressionGroupID?: number | null
    expressionAttributeID?: number | null
  }

  export type dgmExpressionsUncheckedCreateInput = {
    expressionID: number
    operandID?: number | null
    arg1?: number | null
    arg2?: number | null
    expressionValue?: string | null
    description?: string | null
    expressionName?: string | null
    expressionTypeID?: number | null
    expressionGroupID?: number | null
    expressionAttributeID?: number | null
  }

  export type dgmExpressionsUpdateInput = {
    expressionID?: IntFieldUpdateOperationsInput | number
    operandID?: NullableIntFieldUpdateOperationsInput | number | null
    arg1?: NullableIntFieldUpdateOperationsInput | number | null
    arg2?: NullableIntFieldUpdateOperationsInput | number | null
    expressionValue?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    expressionName?: NullableStringFieldUpdateOperationsInput | string | null
    expressionTypeID?: NullableIntFieldUpdateOperationsInput | number | null
    expressionGroupID?: NullableIntFieldUpdateOperationsInput | number | null
    expressionAttributeID?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type dgmExpressionsUncheckedUpdateInput = {
    expressionID?: IntFieldUpdateOperationsInput | number
    operandID?: NullableIntFieldUpdateOperationsInput | number | null
    arg1?: NullableIntFieldUpdateOperationsInput | number | null
    arg2?: NullableIntFieldUpdateOperationsInput | number | null
    expressionValue?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    expressionName?: NullableStringFieldUpdateOperationsInput | string | null
    expressionTypeID?: NullableIntFieldUpdateOperationsInput | number | null
    expressionGroupID?: NullableIntFieldUpdateOperationsInput | number | null
    expressionAttributeID?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type dgmExpressionsCreateManyInput = {
    expressionID: number
    operandID?: number | null
    arg1?: number | null
    arg2?: number | null
    expressionValue?: string | null
    description?: string | null
    expressionName?: string | null
    expressionTypeID?: number | null
    expressionGroupID?: number | null
    expressionAttributeID?: number | null
  }

  export type dgmExpressionsUpdateManyMutationInput = {
    expressionID?: IntFieldUpdateOperationsInput | number
    operandID?: NullableIntFieldUpdateOperationsInput | number | null
    arg1?: NullableIntFieldUpdateOperationsInput | number | null
    arg2?: NullableIntFieldUpdateOperationsInput | number | null
    expressionValue?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    expressionName?: NullableStringFieldUpdateOperationsInput | string | null
    expressionTypeID?: NullableIntFieldUpdateOperationsInput | number | null
    expressionGroupID?: NullableIntFieldUpdateOperationsInput | number | null
    expressionAttributeID?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type dgmExpressionsUncheckedUpdateManyInput = {
    expressionID?: IntFieldUpdateOperationsInput | number
    operandID?: NullableIntFieldUpdateOperationsInput | number | null
    arg1?: NullableIntFieldUpdateOperationsInput | number | null
    arg2?: NullableIntFieldUpdateOperationsInput | number | null
    expressionValue?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    expressionName?: NullableStringFieldUpdateOperationsInput | string | null
    expressionTypeID?: NullableIntFieldUpdateOperationsInput | number | null
    expressionGroupID?: NullableIntFieldUpdateOperationsInput | number | null
    expressionAttributeID?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type dgmTypeAttributesCreateInput = {
    typeID: number
    attributeID: number
    valueInt?: number | null
    valueFloat?: number | null
  }

  export type dgmTypeAttributesUncheckedCreateInput = {
    typeID: number
    attributeID: number
    valueInt?: number | null
    valueFloat?: number | null
  }

  export type dgmTypeAttributesUpdateInput = {
    typeID?: IntFieldUpdateOperationsInput | number
    attributeID?: IntFieldUpdateOperationsInput | number
    valueInt?: NullableIntFieldUpdateOperationsInput | number | null
    valueFloat?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type dgmTypeAttributesUncheckedUpdateInput = {
    typeID?: IntFieldUpdateOperationsInput | number
    attributeID?: IntFieldUpdateOperationsInput | number
    valueInt?: NullableIntFieldUpdateOperationsInput | number | null
    valueFloat?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type dgmTypeAttributesCreateManyInput = {
    typeID: number
    attributeID: number
    valueInt?: number | null
    valueFloat?: number | null
  }

  export type dgmTypeAttributesUpdateManyMutationInput = {
    typeID?: IntFieldUpdateOperationsInput | number
    attributeID?: IntFieldUpdateOperationsInput | number
    valueInt?: NullableIntFieldUpdateOperationsInput | number | null
    valueFloat?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type dgmTypeAttributesUncheckedUpdateManyInput = {
    typeID?: IntFieldUpdateOperationsInput | number
    attributeID?: IntFieldUpdateOperationsInput | number
    valueInt?: NullableIntFieldUpdateOperationsInput | number | null
    valueFloat?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type dgmTypeEffectsCreateInput = {
    typeID: number
    effectID: number
    isDefault?: boolean | null
  }

  export type dgmTypeEffectsUncheckedCreateInput = {
    typeID: number
    effectID: number
    isDefault?: boolean | null
  }

  export type dgmTypeEffectsUpdateInput = {
    typeID?: IntFieldUpdateOperationsInput | number
    effectID?: IntFieldUpdateOperationsInput | number
    isDefault?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type dgmTypeEffectsUncheckedUpdateInput = {
    typeID?: IntFieldUpdateOperationsInput | number
    effectID?: IntFieldUpdateOperationsInput | number
    isDefault?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type dgmTypeEffectsCreateManyInput = {
    typeID: number
    effectID: number
    isDefault?: boolean | null
  }

  export type dgmTypeEffectsUpdateManyMutationInput = {
    typeID?: IntFieldUpdateOperationsInput | number
    effectID?: IntFieldUpdateOperationsInput | number
    isDefault?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type dgmTypeEffectsUncheckedUpdateManyInput = {
    typeID?: IntFieldUpdateOperationsInput | number
    effectID?: IntFieldUpdateOperationsInput | number
    isDefault?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type eveGraphicsCreateInput = {
    graphicID: number
    sofFactionName?: string | null
    graphicFile?: string | null
    sofHullName?: string | null
    sofRaceName?: string | null
    description?: string | null
  }

  export type eveGraphicsUncheckedCreateInput = {
    graphicID: number
    sofFactionName?: string | null
    graphicFile?: string | null
    sofHullName?: string | null
    sofRaceName?: string | null
    description?: string | null
  }

  export type eveGraphicsUpdateInput = {
    graphicID?: IntFieldUpdateOperationsInput | number
    sofFactionName?: NullableStringFieldUpdateOperationsInput | string | null
    graphicFile?: NullableStringFieldUpdateOperationsInput | string | null
    sofHullName?: NullableStringFieldUpdateOperationsInput | string | null
    sofRaceName?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type eveGraphicsUncheckedUpdateInput = {
    graphicID?: IntFieldUpdateOperationsInput | number
    sofFactionName?: NullableStringFieldUpdateOperationsInput | string | null
    graphicFile?: NullableStringFieldUpdateOperationsInput | string | null
    sofHullName?: NullableStringFieldUpdateOperationsInput | string | null
    sofRaceName?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type eveGraphicsCreateManyInput = {
    graphicID: number
    sofFactionName?: string | null
    graphicFile?: string | null
    sofHullName?: string | null
    sofRaceName?: string | null
    description?: string | null
  }

  export type eveGraphicsUpdateManyMutationInput = {
    graphicID?: IntFieldUpdateOperationsInput | number
    sofFactionName?: NullableStringFieldUpdateOperationsInput | string | null
    graphicFile?: NullableStringFieldUpdateOperationsInput | string | null
    sofHullName?: NullableStringFieldUpdateOperationsInput | string | null
    sofRaceName?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type eveGraphicsUncheckedUpdateManyInput = {
    graphicID?: IntFieldUpdateOperationsInput | number
    sofFactionName?: NullableStringFieldUpdateOperationsInput | string | null
    graphicFile?: NullableStringFieldUpdateOperationsInput | string | null
    sofHullName?: NullableStringFieldUpdateOperationsInput | string | null
    sofRaceName?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type eveIconsCreateInput = {
    iconID: number
    iconFile?: string | null
    description?: string | null
  }

  export type eveIconsUncheckedCreateInput = {
    iconID: number
    iconFile?: string | null
    description?: string | null
  }

  export type eveIconsUpdateInput = {
    iconID?: IntFieldUpdateOperationsInput | number
    iconFile?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type eveIconsUncheckedUpdateInput = {
    iconID?: IntFieldUpdateOperationsInput | number
    iconFile?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type eveIconsCreateManyInput = {
    iconID: number
    iconFile?: string | null
    description?: string | null
  }

  export type eveIconsUpdateManyMutationInput = {
    iconID?: IntFieldUpdateOperationsInput | number
    iconFile?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type eveIconsUncheckedUpdateManyInput = {
    iconID?: IntFieldUpdateOperationsInput | number
    iconFile?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type eveUnitsCreateInput = {
    unitID: number
    unitName?: string | null
    displayName?: string | null
    description?: string | null
  }

  export type eveUnitsUncheckedCreateInput = {
    unitID: number
    unitName?: string | null
    displayName?: string | null
    description?: string | null
  }

  export type eveUnitsUpdateInput = {
    unitID?: IntFieldUpdateOperationsInput | number
    unitName?: NullableStringFieldUpdateOperationsInput | string | null
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type eveUnitsUncheckedUpdateInput = {
    unitID?: IntFieldUpdateOperationsInput | number
    unitName?: NullableStringFieldUpdateOperationsInput | string | null
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type eveUnitsCreateManyInput = {
    unitID: number
    unitName?: string | null
    displayName?: string | null
    description?: string | null
  }

  export type eveUnitsUpdateManyMutationInput = {
    unitID?: IntFieldUpdateOperationsInput | number
    unitName?: NullableStringFieldUpdateOperationsInput | string | null
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type eveUnitsUncheckedUpdateManyInput = {
    unitID?: IntFieldUpdateOperationsInput | number
    unitName?: NullableStringFieldUpdateOperationsInput | string | null
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type industryActivityCreateInput = {
    typeID: number
    activityID: number
    time?: number | null
  }

  export type industryActivityUncheckedCreateInput = {
    typeID: number
    activityID: number
    time?: number | null
  }

  export type industryActivityUpdateInput = {
    typeID?: IntFieldUpdateOperationsInput | number
    activityID?: IntFieldUpdateOperationsInput | number
    time?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type industryActivityUncheckedUpdateInput = {
    typeID?: IntFieldUpdateOperationsInput | number
    activityID?: IntFieldUpdateOperationsInput | number
    time?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type industryActivityCreateManyInput = {
    typeID: number
    activityID: number
    time?: number | null
  }

  export type industryActivityUpdateManyMutationInput = {
    typeID?: IntFieldUpdateOperationsInput | number
    activityID?: IntFieldUpdateOperationsInput | number
    time?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type industryActivityUncheckedUpdateManyInput = {
    typeID?: IntFieldUpdateOperationsInput | number
    activityID?: IntFieldUpdateOperationsInput | number
    time?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type industryBlueprintsCreateInput = {
    typeID: number
    maxProductionLimit?: number | null
  }

  export type industryBlueprintsUncheckedCreateInput = {
    typeID: number
    maxProductionLimit?: number | null
  }

  export type industryBlueprintsUpdateInput = {
    typeID?: IntFieldUpdateOperationsInput | number
    maxProductionLimit?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type industryBlueprintsUncheckedUpdateInput = {
    typeID?: IntFieldUpdateOperationsInput | number
    maxProductionLimit?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type industryBlueprintsCreateManyInput = {
    typeID: number
    maxProductionLimit?: number | null
  }

  export type industryBlueprintsUpdateManyMutationInput = {
    typeID?: IntFieldUpdateOperationsInput | number
    maxProductionLimit?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type industryBlueprintsUncheckedUpdateManyInput = {
    typeID?: IntFieldUpdateOperationsInput | number
    maxProductionLimit?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type invCategoriesCreateInput = {
    categoryID: number
    categoryName?: string | null
    iconID?: number | null
    published?: boolean | null
  }

  export type invCategoriesUncheckedCreateInput = {
    categoryID: number
    categoryName?: string | null
    iconID?: number | null
    published?: boolean | null
  }

  export type invCategoriesUpdateInput = {
    categoryID?: IntFieldUpdateOperationsInput | number
    categoryName?: NullableStringFieldUpdateOperationsInput | string | null
    iconID?: NullableIntFieldUpdateOperationsInput | number | null
    published?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type invCategoriesUncheckedUpdateInput = {
    categoryID?: IntFieldUpdateOperationsInput | number
    categoryName?: NullableStringFieldUpdateOperationsInput | string | null
    iconID?: NullableIntFieldUpdateOperationsInput | number | null
    published?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type invCategoriesCreateManyInput = {
    categoryID: number
    categoryName?: string | null
    iconID?: number | null
    published?: boolean | null
  }

  export type invCategoriesUpdateManyMutationInput = {
    categoryID?: IntFieldUpdateOperationsInput | number
    categoryName?: NullableStringFieldUpdateOperationsInput | string | null
    iconID?: NullableIntFieldUpdateOperationsInput | number | null
    published?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type invCategoriesUncheckedUpdateManyInput = {
    categoryID?: IntFieldUpdateOperationsInput | number
    categoryName?: NullableStringFieldUpdateOperationsInput | string | null
    iconID?: NullableIntFieldUpdateOperationsInput | number | null
    published?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type invContrabandTypesCreateInput = {
    factionID: number
    typeID: number
    standingLoss?: number | null
    confiscateMinSec?: number | null
    fineByValue?: number | null
    attackMinSec?: number | null
  }

  export type invContrabandTypesUncheckedCreateInput = {
    factionID: number
    typeID: number
    standingLoss?: number | null
    confiscateMinSec?: number | null
    fineByValue?: number | null
    attackMinSec?: number | null
  }

  export type invContrabandTypesUpdateInput = {
    factionID?: IntFieldUpdateOperationsInput | number
    typeID?: IntFieldUpdateOperationsInput | number
    standingLoss?: NullableFloatFieldUpdateOperationsInput | number | null
    confiscateMinSec?: NullableFloatFieldUpdateOperationsInput | number | null
    fineByValue?: NullableFloatFieldUpdateOperationsInput | number | null
    attackMinSec?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type invContrabandTypesUncheckedUpdateInput = {
    factionID?: IntFieldUpdateOperationsInput | number
    typeID?: IntFieldUpdateOperationsInput | number
    standingLoss?: NullableFloatFieldUpdateOperationsInput | number | null
    confiscateMinSec?: NullableFloatFieldUpdateOperationsInput | number | null
    fineByValue?: NullableFloatFieldUpdateOperationsInput | number | null
    attackMinSec?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type invContrabandTypesCreateManyInput = {
    factionID: number
    typeID: number
    standingLoss?: number | null
    confiscateMinSec?: number | null
    fineByValue?: number | null
    attackMinSec?: number | null
  }

  export type invContrabandTypesUpdateManyMutationInput = {
    factionID?: IntFieldUpdateOperationsInput | number
    typeID?: IntFieldUpdateOperationsInput | number
    standingLoss?: NullableFloatFieldUpdateOperationsInput | number | null
    confiscateMinSec?: NullableFloatFieldUpdateOperationsInput | number | null
    fineByValue?: NullableFloatFieldUpdateOperationsInput | number | null
    attackMinSec?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type invContrabandTypesUncheckedUpdateManyInput = {
    factionID?: IntFieldUpdateOperationsInput | number
    typeID?: IntFieldUpdateOperationsInput | number
    standingLoss?: NullableFloatFieldUpdateOperationsInput | number | null
    confiscateMinSec?: NullableFloatFieldUpdateOperationsInput | number | null
    fineByValue?: NullableFloatFieldUpdateOperationsInput | number | null
    attackMinSec?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type invControlTowerResourcePurposesCreateInput = {
    purpose: number
    purposeText?: string | null
  }

  export type invControlTowerResourcePurposesUncheckedCreateInput = {
    purpose: number
    purposeText?: string | null
  }

  export type invControlTowerResourcePurposesUpdateInput = {
    purpose?: IntFieldUpdateOperationsInput | number
    purposeText?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type invControlTowerResourcePurposesUncheckedUpdateInput = {
    purpose?: IntFieldUpdateOperationsInput | number
    purposeText?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type invControlTowerResourcePurposesCreateManyInput = {
    purpose: number
    purposeText?: string | null
  }

  export type invControlTowerResourcePurposesUpdateManyMutationInput = {
    purpose?: IntFieldUpdateOperationsInput | number
    purposeText?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type invControlTowerResourcePurposesUncheckedUpdateManyInput = {
    purpose?: IntFieldUpdateOperationsInput | number
    purposeText?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type invControlTowerResourcesCreateInput = {
    controlTowerTypeID: number
    resourceTypeID: number
    purpose?: number | null
    quantity?: number | null
    minSecurityLevel?: number | null
    factionID?: number | null
  }

  export type invControlTowerResourcesUncheckedCreateInput = {
    controlTowerTypeID: number
    resourceTypeID: number
    purpose?: number | null
    quantity?: number | null
    minSecurityLevel?: number | null
    factionID?: number | null
  }

  export type invControlTowerResourcesUpdateInput = {
    controlTowerTypeID?: IntFieldUpdateOperationsInput | number
    resourceTypeID?: IntFieldUpdateOperationsInput | number
    purpose?: NullableIntFieldUpdateOperationsInput | number | null
    quantity?: NullableIntFieldUpdateOperationsInput | number | null
    minSecurityLevel?: NullableFloatFieldUpdateOperationsInput | number | null
    factionID?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type invControlTowerResourcesUncheckedUpdateInput = {
    controlTowerTypeID?: IntFieldUpdateOperationsInput | number
    resourceTypeID?: IntFieldUpdateOperationsInput | number
    purpose?: NullableIntFieldUpdateOperationsInput | number | null
    quantity?: NullableIntFieldUpdateOperationsInput | number | null
    minSecurityLevel?: NullableFloatFieldUpdateOperationsInput | number | null
    factionID?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type invControlTowerResourcesCreateManyInput = {
    controlTowerTypeID: number
    resourceTypeID: number
    purpose?: number | null
    quantity?: number | null
    minSecurityLevel?: number | null
    factionID?: number | null
  }

  export type invControlTowerResourcesUpdateManyMutationInput = {
    controlTowerTypeID?: IntFieldUpdateOperationsInput | number
    resourceTypeID?: IntFieldUpdateOperationsInput | number
    purpose?: NullableIntFieldUpdateOperationsInput | number | null
    quantity?: NullableIntFieldUpdateOperationsInput | number | null
    minSecurityLevel?: NullableFloatFieldUpdateOperationsInput | number | null
    factionID?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type invControlTowerResourcesUncheckedUpdateManyInput = {
    controlTowerTypeID?: IntFieldUpdateOperationsInput | number
    resourceTypeID?: IntFieldUpdateOperationsInput | number
    purpose?: NullableIntFieldUpdateOperationsInput | number | null
    quantity?: NullableIntFieldUpdateOperationsInput | number | null
    minSecurityLevel?: NullableFloatFieldUpdateOperationsInput | number | null
    factionID?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type invFlagsCreateInput = {
    flagID: number
    flagName?: string | null
    flagText?: string | null
    orderID?: number | null
  }

  export type invFlagsUncheckedCreateInput = {
    flagID: number
    flagName?: string | null
    flagText?: string | null
    orderID?: number | null
  }

  export type invFlagsUpdateInput = {
    flagID?: IntFieldUpdateOperationsInput | number
    flagName?: NullableStringFieldUpdateOperationsInput | string | null
    flagText?: NullableStringFieldUpdateOperationsInput | string | null
    orderID?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type invFlagsUncheckedUpdateInput = {
    flagID?: IntFieldUpdateOperationsInput | number
    flagName?: NullableStringFieldUpdateOperationsInput | string | null
    flagText?: NullableStringFieldUpdateOperationsInput | string | null
    orderID?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type invFlagsCreateManyInput = {
    flagID: number
    flagName?: string | null
    flagText?: string | null
    orderID?: number | null
  }

  export type invFlagsUpdateManyMutationInput = {
    flagID?: IntFieldUpdateOperationsInput | number
    flagName?: NullableStringFieldUpdateOperationsInput | string | null
    flagText?: NullableStringFieldUpdateOperationsInput | string | null
    orderID?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type invFlagsUncheckedUpdateManyInput = {
    flagID?: IntFieldUpdateOperationsInput | number
    flagName?: NullableStringFieldUpdateOperationsInput | string | null
    flagText?: NullableStringFieldUpdateOperationsInput | string | null
    orderID?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type invGroupsCreateInput = {
    groupID: number
    categoryID?: number | null
    groupName?: string | null
    iconID?: number | null
    useBasePrice?: boolean | null
    anchored?: boolean | null
    anchorable?: boolean | null
    fittableNonSingleton?: boolean | null
    published?: boolean | null
  }

  export type invGroupsUncheckedCreateInput = {
    groupID: number
    categoryID?: number | null
    groupName?: string | null
    iconID?: number | null
    useBasePrice?: boolean | null
    anchored?: boolean | null
    anchorable?: boolean | null
    fittableNonSingleton?: boolean | null
    published?: boolean | null
  }

  export type invGroupsUpdateInput = {
    groupID?: IntFieldUpdateOperationsInput | number
    categoryID?: NullableIntFieldUpdateOperationsInput | number | null
    groupName?: NullableStringFieldUpdateOperationsInput | string | null
    iconID?: NullableIntFieldUpdateOperationsInput | number | null
    useBasePrice?: NullableBoolFieldUpdateOperationsInput | boolean | null
    anchored?: NullableBoolFieldUpdateOperationsInput | boolean | null
    anchorable?: NullableBoolFieldUpdateOperationsInput | boolean | null
    fittableNonSingleton?: NullableBoolFieldUpdateOperationsInput | boolean | null
    published?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type invGroupsUncheckedUpdateInput = {
    groupID?: IntFieldUpdateOperationsInput | number
    categoryID?: NullableIntFieldUpdateOperationsInput | number | null
    groupName?: NullableStringFieldUpdateOperationsInput | string | null
    iconID?: NullableIntFieldUpdateOperationsInput | number | null
    useBasePrice?: NullableBoolFieldUpdateOperationsInput | boolean | null
    anchored?: NullableBoolFieldUpdateOperationsInput | boolean | null
    anchorable?: NullableBoolFieldUpdateOperationsInput | boolean | null
    fittableNonSingleton?: NullableBoolFieldUpdateOperationsInput | boolean | null
    published?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type invGroupsCreateManyInput = {
    groupID: number
    categoryID?: number | null
    groupName?: string | null
    iconID?: number | null
    useBasePrice?: boolean | null
    anchored?: boolean | null
    anchorable?: boolean | null
    fittableNonSingleton?: boolean | null
    published?: boolean | null
  }

  export type invGroupsUpdateManyMutationInput = {
    groupID?: IntFieldUpdateOperationsInput | number
    categoryID?: NullableIntFieldUpdateOperationsInput | number | null
    groupName?: NullableStringFieldUpdateOperationsInput | string | null
    iconID?: NullableIntFieldUpdateOperationsInput | number | null
    useBasePrice?: NullableBoolFieldUpdateOperationsInput | boolean | null
    anchored?: NullableBoolFieldUpdateOperationsInput | boolean | null
    anchorable?: NullableBoolFieldUpdateOperationsInput | boolean | null
    fittableNonSingleton?: NullableBoolFieldUpdateOperationsInput | boolean | null
    published?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type invGroupsUncheckedUpdateManyInput = {
    groupID?: IntFieldUpdateOperationsInput | number
    categoryID?: NullableIntFieldUpdateOperationsInput | number | null
    groupName?: NullableStringFieldUpdateOperationsInput | string | null
    iconID?: NullableIntFieldUpdateOperationsInput | number | null
    useBasePrice?: NullableBoolFieldUpdateOperationsInput | boolean | null
    anchored?: NullableBoolFieldUpdateOperationsInput | boolean | null
    anchorable?: NullableBoolFieldUpdateOperationsInput | boolean | null
    fittableNonSingleton?: NullableBoolFieldUpdateOperationsInput | boolean | null
    published?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type invItemsCreateInput = {
    itemID: number
    typeID: number
    ownerID: number
    locationID: number
    flagID: number
    quantity: number
  }

  export type invItemsUncheckedCreateInput = {
    itemID: number
    typeID: number
    ownerID: number
    locationID: number
    flagID: number
    quantity: number
  }

  export type invItemsUpdateInput = {
    itemID?: IntFieldUpdateOperationsInput | number
    typeID?: IntFieldUpdateOperationsInput | number
    ownerID?: IntFieldUpdateOperationsInput | number
    locationID?: IntFieldUpdateOperationsInput | number
    flagID?: IntFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
  }

  export type invItemsUncheckedUpdateInput = {
    itemID?: IntFieldUpdateOperationsInput | number
    typeID?: IntFieldUpdateOperationsInput | number
    ownerID?: IntFieldUpdateOperationsInput | number
    locationID?: IntFieldUpdateOperationsInput | number
    flagID?: IntFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
  }

  export type invItemsCreateManyInput = {
    itemID: number
    typeID: number
    ownerID: number
    locationID: number
    flagID: number
    quantity: number
  }

  export type invItemsUpdateManyMutationInput = {
    itemID?: IntFieldUpdateOperationsInput | number
    typeID?: IntFieldUpdateOperationsInput | number
    ownerID?: IntFieldUpdateOperationsInput | number
    locationID?: IntFieldUpdateOperationsInput | number
    flagID?: IntFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
  }

  export type invItemsUncheckedUpdateManyInput = {
    itemID?: IntFieldUpdateOperationsInput | number
    typeID?: IntFieldUpdateOperationsInput | number
    ownerID?: IntFieldUpdateOperationsInput | number
    locationID?: IntFieldUpdateOperationsInput | number
    flagID?: IntFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
  }

  export type invMarketGroupsCreateInput = {
    marketGroupID: number
    parentGroupID?: number | null
    marketGroupName?: string | null
    description?: string | null
    iconID?: number | null
    hasTypes?: boolean | null
  }

  export type invMarketGroupsUncheckedCreateInput = {
    marketGroupID: number
    parentGroupID?: number | null
    marketGroupName?: string | null
    description?: string | null
    iconID?: number | null
    hasTypes?: boolean | null
  }

  export type invMarketGroupsUpdateInput = {
    marketGroupID?: IntFieldUpdateOperationsInput | number
    parentGroupID?: NullableIntFieldUpdateOperationsInput | number | null
    marketGroupName?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    iconID?: NullableIntFieldUpdateOperationsInput | number | null
    hasTypes?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type invMarketGroupsUncheckedUpdateInput = {
    marketGroupID?: IntFieldUpdateOperationsInput | number
    parentGroupID?: NullableIntFieldUpdateOperationsInput | number | null
    marketGroupName?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    iconID?: NullableIntFieldUpdateOperationsInput | number | null
    hasTypes?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type invMarketGroupsCreateManyInput = {
    marketGroupID: number
    parentGroupID?: number | null
    marketGroupName?: string | null
    description?: string | null
    iconID?: number | null
    hasTypes?: boolean | null
  }

  export type invMarketGroupsUpdateManyMutationInput = {
    marketGroupID?: IntFieldUpdateOperationsInput | number
    parentGroupID?: NullableIntFieldUpdateOperationsInput | number | null
    marketGroupName?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    iconID?: NullableIntFieldUpdateOperationsInput | number | null
    hasTypes?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type invMarketGroupsUncheckedUpdateManyInput = {
    marketGroupID?: IntFieldUpdateOperationsInput | number
    parentGroupID?: NullableIntFieldUpdateOperationsInput | number | null
    marketGroupName?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    iconID?: NullableIntFieldUpdateOperationsInput | number | null
    hasTypes?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type invMetaGroupsCreateInput = {
    metaGroupID: number
    metaGroupName?: string | null
    description?: string | null
    iconID?: number | null
  }

  export type invMetaGroupsUncheckedCreateInput = {
    metaGroupID: number
    metaGroupName?: string | null
    description?: string | null
    iconID?: number | null
  }

  export type invMetaGroupsUpdateInput = {
    metaGroupID?: IntFieldUpdateOperationsInput | number
    metaGroupName?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    iconID?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type invMetaGroupsUncheckedUpdateInput = {
    metaGroupID?: IntFieldUpdateOperationsInput | number
    metaGroupName?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    iconID?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type invMetaGroupsCreateManyInput = {
    metaGroupID: number
    metaGroupName?: string | null
    description?: string | null
    iconID?: number | null
  }

  export type invMetaGroupsUpdateManyMutationInput = {
    metaGroupID?: IntFieldUpdateOperationsInput | number
    metaGroupName?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    iconID?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type invMetaGroupsUncheckedUpdateManyInput = {
    metaGroupID?: IntFieldUpdateOperationsInput | number
    metaGroupName?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    iconID?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type invMetaTypesCreateInput = {
    typeID: number
    parentTypeID?: number | null
    metaGroupID?: number | null
  }

  export type invMetaTypesUncheckedCreateInput = {
    typeID: number
    parentTypeID?: number | null
    metaGroupID?: number | null
  }

  export type invMetaTypesUpdateInput = {
    typeID?: IntFieldUpdateOperationsInput | number
    parentTypeID?: NullableIntFieldUpdateOperationsInput | number | null
    metaGroupID?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type invMetaTypesUncheckedUpdateInput = {
    typeID?: IntFieldUpdateOperationsInput | number
    parentTypeID?: NullableIntFieldUpdateOperationsInput | number | null
    metaGroupID?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type invMetaTypesCreateManyInput = {
    typeID: number
    parentTypeID?: number | null
    metaGroupID?: number | null
  }

  export type invMetaTypesUpdateManyMutationInput = {
    typeID?: IntFieldUpdateOperationsInput | number
    parentTypeID?: NullableIntFieldUpdateOperationsInput | number | null
    metaGroupID?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type invMetaTypesUncheckedUpdateManyInput = {
    typeID?: IntFieldUpdateOperationsInput | number
    parentTypeID?: NullableIntFieldUpdateOperationsInput | number | null
    metaGroupID?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type invNamesCreateInput = {
    itemID: number
    itemName: string
  }

  export type invNamesUncheckedCreateInput = {
    itemID: number
    itemName: string
  }

  export type invNamesUpdateInput = {
    itemID?: IntFieldUpdateOperationsInput | number
    itemName?: StringFieldUpdateOperationsInput | string
  }

  export type invNamesUncheckedUpdateInput = {
    itemID?: IntFieldUpdateOperationsInput | number
    itemName?: StringFieldUpdateOperationsInput | string
  }

  export type invNamesCreateManyInput = {
    itemID: number
    itemName: string
  }

  export type invNamesUpdateManyMutationInput = {
    itemID?: IntFieldUpdateOperationsInput | number
    itemName?: StringFieldUpdateOperationsInput | string
  }

  export type invNamesUncheckedUpdateManyInput = {
    itemID?: IntFieldUpdateOperationsInput | number
    itemName?: StringFieldUpdateOperationsInput | string
  }

  export type invPositionsCreateInput = {
    itemID: number
    x: number
    y: number
    z: number
    yaw?: number | null
    pitch?: number | null
    roll?: number | null
  }

  export type invPositionsUncheckedCreateInput = {
    itemID: number
    x: number
    y: number
    z: number
    yaw?: number | null
    pitch?: number | null
    roll?: number | null
  }

  export type invPositionsUpdateInput = {
    itemID?: IntFieldUpdateOperationsInput | number
    x?: FloatFieldUpdateOperationsInput | number
    y?: FloatFieldUpdateOperationsInput | number
    z?: FloatFieldUpdateOperationsInput | number
    yaw?: NullableFloatFieldUpdateOperationsInput | number | null
    pitch?: NullableFloatFieldUpdateOperationsInput | number | null
    roll?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type invPositionsUncheckedUpdateInput = {
    itemID?: IntFieldUpdateOperationsInput | number
    x?: FloatFieldUpdateOperationsInput | number
    y?: FloatFieldUpdateOperationsInput | number
    z?: FloatFieldUpdateOperationsInput | number
    yaw?: NullableFloatFieldUpdateOperationsInput | number | null
    pitch?: NullableFloatFieldUpdateOperationsInput | number | null
    roll?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type invPositionsCreateManyInput = {
    itemID: number
    x: number
    y: number
    z: number
    yaw?: number | null
    pitch?: number | null
    roll?: number | null
  }

  export type invPositionsUpdateManyMutationInput = {
    itemID?: IntFieldUpdateOperationsInput | number
    x?: FloatFieldUpdateOperationsInput | number
    y?: FloatFieldUpdateOperationsInput | number
    z?: FloatFieldUpdateOperationsInput | number
    yaw?: NullableFloatFieldUpdateOperationsInput | number | null
    pitch?: NullableFloatFieldUpdateOperationsInput | number | null
    roll?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type invPositionsUncheckedUpdateManyInput = {
    itemID?: IntFieldUpdateOperationsInput | number
    x?: FloatFieldUpdateOperationsInput | number
    y?: FloatFieldUpdateOperationsInput | number
    z?: FloatFieldUpdateOperationsInput | number
    yaw?: NullableFloatFieldUpdateOperationsInput | number | null
    pitch?: NullableFloatFieldUpdateOperationsInput | number | null
    roll?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type invTraitsCreateInput = {
    typeID?: number | null
    skillID?: number | null
    bonus?: number | null
    bonusText?: string | null
    unitID?: number | null
  }

  export type invTraitsUncheckedCreateInput = {
    traitID?: number
    typeID?: number | null
    skillID?: number | null
    bonus?: number | null
    bonusText?: string | null
    unitID?: number | null
  }

  export type invTraitsUpdateInput = {
    typeID?: NullableIntFieldUpdateOperationsInput | number | null
    skillID?: NullableIntFieldUpdateOperationsInput | number | null
    bonus?: NullableFloatFieldUpdateOperationsInput | number | null
    bonusText?: NullableStringFieldUpdateOperationsInput | string | null
    unitID?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type invTraitsUncheckedUpdateInput = {
    traitID?: IntFieldUpdateOperationsInput | number
    typeID?: NullableIntFieldUpdateOperationsInput | number | null
    skillID?: NullableIntFieldUpdateOperationsInput | number | null
    bonus?: NullableFloatFieldUpdateOperationsInput | number | null
    bonusText?: NullableStringFieldUpdateOperationsInput | string | null
    unitID?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type invTraitsCreateManyInput = {
    traitID?: number
    typeID?: number | null
    skillID?: number | null
    bonus?: number | null
    bonusText?: string | null
    unitID?: number | null
  }

  export type invTraitsUpdateManyMutationInput = {
    typeID?: NullableIntFieldUpdateOperationsInput | number | null
    skillID?: NullableIntFieldUpdateOperationsInput | number | null
    bonus?: NullableFloatFieldUpdateOperationsInput | number | null
    bonusText?: NullableStringFieldUpdateOperationsInput | string | null
    unitID?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type invTraitsUncheckedUpdateManyInput = {
    traitID?: IntFieldUpdateOperationsInput | number
    typeID?: NullableIntFieldUpdateOperationsInput | number | null
    skillID?: NullableIntFieldUpdateOperationsInput | number | null
    bonus?: NullableFloatFieldUpdateOperationsInput | number | null
    bonusText?: NullableStringFieldUpdateOperationsInput | string | null
    unitID?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type invTypeMaterialsCreateInput = {
    typeID: number
    materialTypeID: number
    quantity: number
  }

  export type invTypeMaterialsUncheckedCreateInput = {
    typeID: number
    materialTypeID: number
    quantity: number
  }

  export type invTypeMaterialsUpdateInput = {
    typeID?: IntFieldUpdateOperationsInput | number
    materialTypeID?: IntFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
  }

  export type invTypeMaterialsUncheckedUpdateInput = {
    typeID?: IntFieldUpdateOperationsInput | number
    materialTypeID?: IntFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
  }

  export type invTypeMaterialsCreateManyInput = {
    typeID: number
    materialTypeID: number
    quantity: number
  }

  export type invTypeMaterialsUpdateManyMutationInput = {
    typeID?: IntFieldUpdateOperationsInput | number
    materialTypeID?: IntFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
  }

  export type invTypeMaterialsUncheckedUpdateManyInput = {
    typeID?: IntFieldUpdateOperationsInput | number
    materialTypeID?: IntFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
  }

  export type invTypeReactionsCreateInput = {
    reactionTypeID: number
    input: boolean
    typeID: number
    quantity?: number | null
  }

  export type invTypeReactionsUncheckedCreateInput = {
    reactionTypeID: number
    input: boolean
    typeID: number
    quantity?: number | null
  }

  export type invTypeReactionsUpdateInput = {
    reactionTypeID?: IntFieldUpdateOperationsInput | number
    input?: BoolFieldUpdateOperationsInput | boolean
    typeID?: IntFieldUpdateOperationsInput | number
    quantity?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type invTypeReactionsUncheckedUpdateInput = {
    reactionTypeID?: IntFieldUpdateOperationsInput | number
    input?: BoolFieldUpdateOperationsInput | boolean
    typeID?: IntFieldUpdateOperationsInput | number
    quantity?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type invTypeReactionsCreateManyInput = {
    reactionTypeID: number
    input: boolean
    typeID: number
    quantity?: number | null
  }

  export type invTypeReactionsUpdateManyMutationInput = {
    reactionTypeID?: IntFieldUpdateOperationsInput | number
    input?: BoolFieldUpdateOperationsInput | boolean
    typeID?: IntFieldUpdateOperationsInput | number
    quantity?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type invTypeReactionsUncheckedUpdateManyInput = {
    reactionTypeID?: IntFieldUpdateOperationsInput | number
    input?: BoolFieldUpdateOperationsInput | boolean
    typeID?: IntFieldUpdateOperationsInput | number
    quantity?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type invTypesCreateInput = {
    typeID: number
    groupID?: number | null
    typeName?: string | null
    description?: string | null
    mass?: number | null
    volume?: number | null
    capacity?: number | null
    portionSize?: number | null
    raceID?: number | null
    basePrice?: Decimal | DecimalJsLike | number | string | null
    published?: boolean | null
    marketGroupID?: number | null
    iconID?: number | null
    soundID?: number | null
    graphicID?: number | null
  }

  export type invTypesUncheckedCreateInput = {
    typeID: number
    groupID?: number | null
    typeName?: string | null
    description?: string | null
    mass?: number | null
    volume?: number | null
    capacity?: number | null
    portionSize?: number | null
    raceID?: number | null
    basePrice?: Decimal | DecimalJsLike | number | string | null
    published?: boolean | null
    marketGroupID?: number | null
    iconID?: number | null
    soundID?: number | null
    graphicID?: number | null
  }

  export type invTypesUpdateInput = {
    typeID?: IntFieldUpdateOperationsInput | number
    groupID?: NullableIntFieldUpdateOperationsInput | number | null
    typeName?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    mass?: NullableFloatFieldUpdateOperationsInput | number | null
    volume?: NullableFloatFieldUpdateOperationsInput | number | null
    capacity?: NullableFloatFieldUpdateOperationsInput | number | null
    portionSize?: NullableIntFieldUpdateOperationsInput | number | null
    raceID?: NullableIntFieldUpdateOperationsInput | number | null
    basePrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    published?: NullableBoolFieldUpdateOperationsInput | boolean | null
    marketGroupID?: NullableIntFieldUpdateOperationsInput | number | null
    iconID?: NullableIntFieldUpdateOperationsInput | number | null
    soundID?: NullableIntFieldUpdateOperationsInput | number | null
    graphicID?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type invTypesUncheckedUpdateInput = {
    typeID?: IntFieldUpdateOperationsInput | number
    groupID?: NullableIntFieldUpdateOperationsInput | number | null
    typeName?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    mass?: NullableFloatFieldUpdateOperationsInput | number | null
    volume?: NullableFloatFieldUpdateOperationsInput | number | null
    capacity?: NullableFloatFieldUpdateOperationsInput | number | null
    portionSize?: NullableIntFieldUpdateOperationsInput | number | null
    raceID?: NullableIntFieldUpdateOperationsInput | number | null
    basePrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    published?: NullableBoolFieldUpdateOperationsInput | boolean | null
    marketGroupID?: NullableIntFieldUpdateOperationsInput | number | null
    iconID?: NullableIntFieldUpdateOperationsInput | number | null
    soundID?: NullableIntFieldUpdateOperationsInput | number | null
    graphicID?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type invTypesCreateManyInput = {
    typeID: number
    groupID?: number | null
    typeName?: string | null
    description?: string | null
    mass?: number | null
    volume?: number | null
    capacity?: number | null
    portionSize?: number | null
    raceID?: number | null
    basePrice?: Decimal | DecimalJsLike | number | string | null
    published?: boolean | null
    marketGroupID?: number | null
    iconID?: number | null
    soundID?: number | null
    graphicID?: number | null
  }

  export type invTypesUpdateManyMutationInput = {
    typeID?: IntFieldUpdateOperationsInput | number
    groupID?: NullableIntFieldUpdateOperationsInput | number | null
    typeName?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    mass?: NullableFloatFieldUpdateOperationsInput | number | null
    volume?: NullableFloatFieldUpdateOperationsInput | number | null
    capacity?: NullableFloatFieldUpdateOperationsInput | number | null
    portionSize?: NullableIntFieldUpdateOperationsInput | number | null
    raceID?: NullableIntFieldUpdateOperationsInput | number | null
    basePrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    published?: NullableBoolFieldUpdateOperationsInput | boolean | null
    marketGroupID?: NullableIntFieldUpdateOperationsInput | number | null
    iconID?: NullableIntFieldUpdateOperationsInput | number | null
    soundID?: NullableIntFieldUpdateOperationsInput | number | null
    graphicID?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type invTypesUncheckedUpdateManyInput = {
    typeID?: IntFieldUpdateOperationsInput | number
    groupID?: NullableIntFieldUpdateOperationsInput | number | null
    typeName?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    mass?: NullableFloatFieldUpdateOperationsInput | number | null
    volume?: NullableFloatFieldUpdateOperationsInput | number | null
    capacity?: NullableFloatFieldUpdateOperationsInput | number | null
    portionSize?: NullableIntFieldUpdateOperationsInput | number | null
    raceID?: NullableIntFieldUpdateOperationsInput | number | null
    basePrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    published?: NullableBoolFieldUpdateOperationsInput | boolean | null
    marketGroupID?: NullableIntFieldUpdateOperationsInput | number | null
    iconID?: NullableIntFieldUpdateOperationsInput | number | null
    soundID?: NullableIntFieldUpdateOperationsInput | number | null
    graphicID?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type invUniqueNamesCreateInput = {
    itemID: number
    itemName: string
    groupID?: number | null
  }

  export type invUniqueNamesUncheckedCreateInput = {
    itemID: number
    itemName: string
    groupID?: number | null
  }

  export type invUniqueNamesUpdateInput = {
    itemID?: IntFieldUpdateOperationsInput | number
    itemName?: StringFieldUpdateOperationsInput | string
    groupID?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type invUniqueNamesUncheckedUpdateInput = {
    itemID?: IntFieldUpdateOperationsInput | number
    itemName?: StringFieldUpdateOperationsInput | string
    groupID?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type invUniqueNamesCreateManyInput = {
    itemID: number
    itemName: string
    groupID?: number | null
  }

  export type invUniqueNamesUpdateManyMutationInput = {
    itemID?: IntFieldUpdateOperationsInput | number
    itemName?: StringFieldUpdateOperationsInput | string
    groupID?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type invUniqueNamesUncheckedUpdateManyInput = {
    itemID?: IntFieldUpdateOperationsInput | number
    itemName?: StringFieldUpdateOperationsInput | string
    groupID?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type invVolumesCreateInput = {
    typeID: number
    volume?: number | null
  }

  export type invVolumesUncheckedCreateInput = {
    typeID: number
    volume?: number | null
  }

  export type invVolumesUpdateInput = {
    typeID?: IntFieldUpdateOperationsInput | number
    volume?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type invVolumesUncheckedUpdateInput = {
    typeID?: IntFieldUpdateOperationsInput | number
    volume?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type invVolumesCreateManyInput = {
    typeID: number
    volume?: number | null
  }

  export type invVolumesUpdateManyMutationInput = {
    typeID?: IntFieldUpdateOperationsInput | number
    volume?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type invVolumesUncheckedUpdateManyInput = {
    typeID?: IntFieldUpdateOperationsInput | number
    volume?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type mapCelestialGraphicsCreateInput = {
    celestialID: number
    heightMap1?: number | null
    heightMap2?: number | null
    shaderPreset?: number | null
    population?: boolean | null
  }

  export type mapCelestialGraphicsUncheckedCreateInput = {
    celestialID: number
    heightMap1?: number | null
    heightMap2?: number | null
    shaderPreset?: number | null
    population?: boolean | null
  }

  export type mapCelestialGraphicsUpdateInput = {
    celestialID?: IntFieldUpdateOperationsInput | number
    heightMap1?: NullableIntFieldUpdateOperationsInput | number | null
    heightMap2?: NullableIntFieldUpdateOperationsInput | number | null
    shaderPreset?: NullableIntFieldUpdateOperationsInput | number | null
    population?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type mapCelestialGraphicsUncheckedUpdateInput = {
    celestialID?: IntFieldUpdateOperationsInput | number
    heightMap1?: NullableIntFieldUpdateOperationsInput | number | null
    heightMap2?: NullableIntFieldUpdateOperationsInput | number | null
    shaderPreset?: NullableIntFieldUpdateOperationsInput | number | null
    population?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type mapCelestialGraphicsCreateManyInput = {
    celestialID: number
    heightMap1?: number | null
    heightMap2?: number | null
    shaderPreset?: number | null
    population?: boolean | null
  }

  export type mapCelestialGraphicsUpdateManyMutationInput = {
    celestialID?: IntFieldUpdateOperationsInput | number
    heightMap1?: NullableIntFieldUpdateOperationsInput | number | null
    heightMap2?: NullableIntFieldUpdateOperationsInput | number | null
    shaderPreset?: NullableIntFieldUpdateOperationsInput | number | null
    population?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type mapCelestialGraphicsUncheckedUpdateManyInput = {
    celestialID?: IntFieldUpdateOperationsInput | number
    heightMap1?: NullableIntFieldUpdateOperationsInput | number | null
    heightMap2?: NullableIntFieldUpdateOperationsInput | number | null
    shaderPreset?: NullableIntFieldUpdateOperationsInput | number | null
    population?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type mapCelestialStatisticsCreateInput = {
    celestialID: number
    temperature?: number | null
    spectralClass?: string | null
    luminosity?: number | null
    age?: number | null
    life?: number | null
    orbitRadius?: number | null
    eccentricity?: number | null
    massDust?: number | null
    massGas?: number | null
    fragmented?: boolean | null
    density?: number | null
    surfaceGravity?: number | null
    escapeVelocity?: number | null
    orbitPeriod?: number | null
    rotationRate?: number | null
    locked?: boolean | null
    pressure?: number | null
    radius?: number | null
    mass?: number | null
  }

  export type mapCelestialStatisticsUncheckedCreateInput = {
    celestialID: number
    temperature?: number | null
    spectralClass?: string | null
    luminosity?: number | null
    age?: number | null
    life?: number | null
    orbitRadius?: number | null
    eccentricity?: number | null
    massDust?: number | null
    massGas?: number | null
    fragmented?: boolean | null
    density?: number | null
    surfaceGravity?: number | null
    escapeVelocity?: number | null
    orbitPeriod?: number | null
    rotationRate?: number | null
    locked?: boolean | null
    pressure?: number | null
    radius?: number | null
    mass?: number | null
  }

  export type mapCelestialStatisticsUpdateInput = {
    celestialID?: IntFieldUpdateOperationsInput | number
    temperature?: NullableFloatFieldUpdateOperationsInput | number | null
    spectralClass?: NullableStringFieldUpdateOperationsInput | string | null
    luminosity?: NullableFloatFieldUpdateOperationsInput | number | null
    age?: NullableFloatFieldUpdateOperationsInput | number | null
    life?: NullableFloatFieldUpdateOperationsInput | number | null
    orbitRadius?: NullableFloatFieldUpdateOperationsInput | number | null
    eccentricity?: NullableFloatFieldUpdateOperationsInput | number | null
    massDust?: NullableFloatFieldUpdateOperationsInput | number | null
    massGas?: NullableFloatFieldUpdateOperationsInput | number | null
    fragmented?: NullableBoolFieldUpdateOperationsInput | boolean | null
    density?: NullableFloatFieldUpdateOperationsInput | number | null
    surfaceGravity?: NullableFloatFieldUpdateOperationsInput | number | null
    escapeVelocity?: NullableFloatFieldUpdateOperationsInput | number | null
    orbitPeriod?: NullableFloatFieldUpdateOperationsInput | number | null
    rotationRate?: NullableFloatFieldUpdateOperationsInput | number | null
    locked?: NullableBoolFieldUpdateOperationsInput | boolean | null
    pressure?: NullableFloatFieldUpdateOperationsInput | number | null
    radius?: NullableFloatFieldUpdateOperationsInput | number | null
    mass?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type mapCelestialStatisticsUncheckedUpdateInput = {
    celestialID?: IntFieldUpdateOperationsInput | number
    temperature?: NullableFloatFieldUpdateOperationsInput | number | null
    spectralClass?: NullableStringFieldUpdateOperationsInput | string | null
    luminosity?: NullableFloatFieldUpdateOperationsInput | number | null
    age?: NullableFloatFieldUpdateOperationsInput | number | null
    life?: NullableFloatFieldUpdateOperationsInput | number | null
    orbitRadius?: NullableFloatFieldUpdateOperationsInput | number | null
    eccentricity?: NullableFloatFieldUpdateOperationsInput | number | null
    massDust?: NullableFloatFieldUpdateOperationsInput | number | null
    massGas?: NullableFloatFieldUpdateOperationsInput | number | null
    fragmented?: NullableBoolFieldUpdateOperationsInput | boolean | null
    density?: NullableFloatFieldUpdateOperationsInput | number | null
    surfaceGravity?: NullableFloatFieldUpdateOperationsInput | number | null
    escapeVelocity?: NullableFloatFieldUpdateOperationsInput | number | null
    orbitPeriod?: NullableFloatFieldUpdateOperationsInput | number | null
    rotationRate?: NullableFloatFieldUpdateOperationsInput | number | null
    locked?: NullableBoolFieldUpdateOperationsInput | boolean | null
    pressure?: NullableFloatFieldUpdateOperationsInput | number | null
    radius?: NullableFloatFieldUpdateOperationsInput | number | null
    mass?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type mapCelestialStatisticsCreateManyInput = {
    celestialID: number
    temperature?: number | null
    spectralClass?: string | null
    luminosity?: number | null
    age?: number | null
    life?: number | null
    orbitRadius?: number | null
    eccentricity?: number | null
    massDust?: number | null
    massGas?: number | null
    fragmented?: boolean | null
    density?: number | null
    surfaceGravity?: number | null
    escapeVelocity?: number | null
    orbitPeriod?: number | null
    rotationRate?: number | null
    locked?: boolean | null
    pressure?: number | null
    radius?: number | null
    mass?: number | null
  }

  export type mapCelestialStatisticsUpdateManyMutationInput = {
    celestialID?: IntFieldUpdateOperationsInput | number
    temperature?: NullableFloatFieldUpdateOperationsInput | number | null
    spectralClass?: NullableStringFieldUpdateOperationsInput | string | null
    luminosity?: NullableFloatFieldUpdateOperationsInput | number | null
    age?: NullableFloatFieldUpdateOperationsInput | number | null
    life?: NullableFloatFieldUpdateOperationsInput | number | null
    orbitRadius?: NullableFloatFieldUpdateOperationsInput | number | null
    eccentricity?: NullableFloatFieldUpdateOperationsInput | number | null
    massDust?: NullableFloatFieldUpdateOperationsInput | number | null
    massGas?: NullableFloatFieldUpdateOperationsInput | number | null
    fragmented?: NullableBoolFieldUpdateOperationsInput | boolean | null
    density?: NullableFloatFieldUpdateOperationsInput | number | null
    surfaceGravity?: NullableFloatFieldUpdateOperationsInput | number | null
    escapeVelocity?: NullableFloatFieldUpdateOperationsInput | number | null
    orbitPeriod?: NullableFloatFieldUpdateOperationsInput | number | null
    rotationRate?: NullableFloatFieldUpdateOperationsInput | number | null
    locked?: NullableBoolFieldUpdateOperationsInput | boolean | null
    pressure?: NullableFloatFieldUpdateOperationsInput | number | null
    radius?: NullableFloatFieldUpdateOperationsInput | number | null
    mass?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type mapCelestialStatisticsUncheckedUpdateManyInput = {
    celestialID?: IntFieldUpdateOperationsInput | number
    temperature?: NullableFloatFieldUpdateOperationsInput | number | null
    spectralClass?: NullableStringFieldUpdateOperationsInput | string | null
    luminosity?: NullableFloatFieldUpdateOperationsInput | number | null
    age?: NullableFloatFieldUpdateOperationsInput | number | null
    life?: NullableFloatFieldUpdateOperationsInput | number | null
    orbitRadius?: NullableFloatFieldUpdateOperationsInput | number | null
    eccentricity?: NullableFloatFieldUpdateOperationsInput | number | null
    massDust?: NullableFloatFieldUpdateOperationsInput | number | null
    massGas?: NullableFloatFieldUpdateOperationsInput | number | null
    fragmented?: NullableBoolFieldUpdateOperationsInput | boolean | null
    density?: NullableFloatFieldUpdateOperationsInput | number | null
    surfaceGravity?: NullableFloatFieldUpdateOperationsInput | number | null
    escapeVelocity?: NullableFloatFieldUpdateOperationsInput | number | null
    orbitPeriod?: NullableFloatFieldUpdateOperationsInput | number | null
    rotationRate?: NullableFloatFieldUpdateOperationsInput | number | null
    locked?: NullableBoolFieldUpdateOperationsInput | boolean | null
    pressure?: NullableFloatFieldUpdateOperationsInput | number | null
    radius?: NullableFloatFieldUpdateOperationsInput | number | null
    mass?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type mapConstellationJumpsCreateInput = {
    fromRegionID?: number | null
    fromConstellationID: number
    toConstellationID: number
    toRegionID?: number | null
  }

  export type mapConstellationJumpsUncheckedCreateInput = {
    fromRegionID?: number | null
    fromConstellationID: number
    toConstellationID: number
    toRegionID?: number | null
  }

  export type mapConstellationJumpsUpdateInput = {
    fromRegionID?: NullableIntFieldUpdateOperationsInput | number | null
    fromConstellationID?: IntFieldUpdateOperationsInput | number
    toConstellationID?: IntFieldUpdateOperationsInput | number
    toRegionID?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type mapConstellationJumpsUncheckedUpdateInput = {
    fromRegionID?: NullableIntFieldUpdateOperationsInput | number | null
    fromConstellationID?: IntFieldUpdateOperationsInput | number
    toConstellationID?: IntFieldUpdateOperationsInput | number
    toRegionID?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type mapConstellationJumpsCreateManyInput = {
    fromRegionID?: number | null
    fromConstellationID: number
    toConstellationID: number
    toRegionID?: number | null
  }

  export type mapConstellationJumpsUpdateManyMutationInput = {
    fromRegionID?: NullableIntFieldUpdateOperationsInput | number | null
    fromConstellationID?: IntFieldUpdateOperationsInput | number
    toConstellationID?: IntFieldUpdateOperationsInput | number
    toRegionID?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type mapConstellationJumpsUncheckedUpdateManyInput = {
    fromRegionID?: NullableIntFieldUpdateOperationsInput | number | null
    fromConstellationID?: IntFieldUpdateOperationsInput | number
    toConstellationID?: IntFieldUpdateOperationsInput | number
    toRegionID?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type mapConstellationsCreateInput = {
    regionID?: number | null
    constellationID: number
    constellationName?: string | null
    x?: number | null
    y?: number | null
    z?: number | null
    xMin?: number | null
    xMax?: number | null
    yMin?: number | null
    yMax?: number | null
    zMin?: number | null
    zMax?: number | null
    factionID?: number | null
    radius?: number | null
  }

  export type mapConstellationsUncheckedCreateInput = {
    regionID?: number | null
    constellationID: number
    constellationName?: string | null
    x?: number | null
    y?: number | null
    z?: number | null
    xMin?: number | null
    xMax?: number | null
    yMin?: number | null
    yMax?: number | null
    zMin?: number | null
    zMax?: number | null
    factionID?: number | null
    radius?: number | null
  }

  export type mapConstellationsUpdateInput = {
    regionID?: NullableIntFieldUpdateOperationsInput | number | null
    constellationID?: IntFieldUpdateOperationsInput | number
    constellationName?: NullableStringFieldUpdateOperationsInput | string | null
    x?: NullableFloatFieldUpdateOperationsInput | number | null
    y?: NullableFloatFieldUpdateOperationsInput | number | null
    z?: NullableFloatFieldUpdateOperationsInput | number | null
    xMin?: NullableFloatFieldUpdateOperationsInput | number | null
    xMax?: NullableFloatFieldUpdateOperationsInput | number | null
    yMin?: NullableFloatFieldUpdateOperationsInput | number | null
    yMax?: NullableFloatFieldUpdateOperationsInput | number | null
    zMin?: NullableFloatFieldUpdateOperationsInput | number | null
    zMax?: NullableFloatFieldUpdateOperationsInput | number | null
    factionID?: NullableIntFieldUpdateOperationsInput | number | null
    radius?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type mapConstellationsUncheckedUpdateInput = {
    regionID?: NullableIntFieldUpdateOperationsInput | number | null
    constellationID?: IntFieldUpdateOperationsInput | number
    constellationName?: NullableStringFieldUpdateOperationsInput | string | null
    x?: NullableFloatFieldUpdateOperationsInput | number | null
    y?: NullableFloatFieldUpdateOperationsInput | number | null
    z?: NullableFloatFieldUpdateOperationsInput | number | null
    xMin?: NullableFloatFieldUpdateOperationsInput | number | null
    xMax?: NullableFloatFieldUpdateOperationsInput | number | null
    yMin?: NullableFloatFieldUpdateOperationsInput | number | null
    yMax?: NullableFloatFieldUpdateOperationsInput | number | null
    zMin?: NullableFloatFieldUpdateOperationsInput | number | null
    zMax?: NullableFloatFieldUpdateOperationsInput | number | null
    factionID?: NullableIntFieldUpdateOperationsInput | number | null
    radius?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type mapConstellationsCreateManyInput = {
    regionID?: number | null
    constellationID: number
    constellationName?: string | null
    x?: number | null
    y?: number | null
    z?: number | null
    xMin?: number | null
    xMax?: number | null
    yMin?: number | null
    yMax?: number | null
    zMin?: number | null
    zMax?: number | null
    factionID?: number | null
    radius?: number | null
  }

  export type mapConstellationsUpdateManyMutationInput = {
    regionID?: NullableIntFieldUpdateOperationsInput | number | null
    constellationID?: IntFieldUpdateOperationsInput | number
    constellationName?: NullableStringFieldUpdateOperationsInput | string | null
    x?: NullableFloatFieldUpdateOperationsInput | number | null
    y?: NullableFloatFieldUpdateOperationsInput | number | null
    z?: NullableFloatFieldUpdateOperationsInput | number | null
    xMin?: NullableFloatFieldUpdateOperationsInput | number | null
    xMax?: NullableFloatFieldUpdateOperationsInput | number | null
    yMin?: NullableFloatFieldUpdateOperationsInput | number | null
    yMax?: NullableFloatFieldUpdateOperationsInput | number | null
    zMin?: NullableFloatFieldUpdateOperationsInput | number | null
    zMax?: NullableFloatFieldUpdateOperationsInput | number | null
    factionID?: NullableIntFieldUpdateOperationsInput | number | null
    radius?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type mapConstellationsUncheckedUpdateManyInput = {
    regionID?: NullableIntFieldUpdateOperationsInput | number | null
    constellationID?: IntFieldUpdateOperationsInput | number
    constellationName?: NullableStringFieldUpdateOperationsInput | string | null
    x?: NullableFloatFieldUpdateOperationsInput | number | null
    y?: NullableFloatFieldUpdateOperationsInput | number | null
    z?: NullableFloatFieldUpdateOperationsInput | number | null
    xMin?: NullableFloatFieldUpdateOperationsInput | number | null
    xMax?: NullableFloatFieldUpdateOperationsInput | number | null
    yMin?: NullableFloatFieldUpdateOperationsInput | number | null
    yMax?: NullableFloatFieldUpdateOperationsInput | number | null
    zMin?: NullableFloatFieldUpdateOperationsInput | number | null
    zMax?: NullableFloatFieldUpdateOperationsInput | number | null
    factionID?: NullableIntFieldUpdateOperationsInput | number | null
    radius?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type mapDenormalizeCreateInput = {
    itemID: number
    typeID?: number | null
    groupID?: number | null
    solarSystemID?: number | null
    constellationID?: number | null
    regionID?: number | null
    orbitID?: number | null
    x?: number | null
    y?: number | null
    z?: number | null
    radius?: number | null
    itemName?: string | null
    security?: number | null
    celestialIndex?: number | null
    orbitIndex?: number | null
  }

  export type mapDenormalizeUncheckedCreateInput = {
    itemID: number
    typeID?: number | null
    groupID?: number | null
    solarSystemID?: number | null
    constellationID?: number | null
    regionID?: number | null
    orbitID?: number | null
    x?: number | null
    y?: number | null
    z?: number | null
    radius?: number | null
    itemName?: string | null
    security?: number | null
    celestialIndex?: number | null
    orbitIndex?: number | null
  }

  export type mapDenormalizeUpdateInput = {
    itemID?: IntFieldUpdateOperationsInput | number
    typeID?: NullableIntFieldUpdateOperationsInput | number | null
    groupID?: NullableIntFieldUpdateOperationsInput | number | null
    solarSystemID?: NullableIntFieldUpdateOperationsInput | number | null
    constellationID?: NullableIntFieldUpdateOperationsInput | number | null
    regionID?: NullableIntFieldUpdateOperationsInput | number | null
    orbitID?: NullableIntFieldUpdateOperationsInput | number | null
    x?: NullableFloatFieldUpdateOperationsInput | number | null
    y?: NullableFloatFieldUpdateOperationsInput | number | null
    z?: NullableFloatFieldUpdateOperationsInput | number | null
    radius?: NullableFloatFieldUpdateOperationsInput | number | null
    itemName?: NullableStringFieldUpdateOperationsInput | string | null
    security?: NullableFloatFieldUpdateOperationsInput | number | null
    celestialIndex?: NullableIntFieldUpdateOperationsInput | number | null
    orbitIndex?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type mapDenormalizeUncheckedUpdateInput = {
    itemID?: IntFieldUpdateOperationsInput | number
    typeID?: NullableIntFieldUpdateOperationsInput | number | null
    groupID?: NullableIntFieldUpdateOperationsInput | number | null
    solarSystemID?: NullableIntFieldUpdateOperationsInput | number | null
    constellationID?: NullableIntFieldUpdateOperationsInput | number | null
    regionID?: NullableIntFieldUpdateOperationsInput | number | null
    orbitID?: NullableIntFieldUpdateOperationsInput | number | null
    x?: NullableFloatFieldUpdateOperationsInput | number | null
    y?: NullableFloatFieldUpdateOperationsInput | number | null
    z?: NullableFloatFieldUpdateOperationsInput | number | null
    radius?: NullableFloatFieldUpdateOperationsInput | number | null
    itemName?: NullableStringFieldUpdateOperationsInput | string | null
    security?: NullableFloatFieldUpdateOperationsInput | number | null
    celestialIndex?: NullableIntFieldUpdateOperationsInput | number | null
    orbitIndex?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type mapDenormalizeCreateManyInput = {
    itemID: number
    typeID?: number | null
    groupID?: number | null
    solarSystemID?: number | null
    constellationID?: number | null
    regionID?: number | null
    orbitID?: number | null
    x?: number | null
    y?: number | null
    z?: number | null
    radius?: number | null
    itemName?: string | null
    security?: number | null
    celestialIndex?: number | null
    orbitIndex?: number | null
  }

  export type mapDenormalizeUpdateManyMutationInput = {
    itemID?: IntFieldUpdateOperationsInput | number
    typeID?: NullableIntFieldUpdateOperationsInput | number | null
    groupID?: NullableIntFieldUpdateOperationsInput | number | null
    solarSystemID?: NullableIntFieldUpdateOperationsInput | number | null
    constellationID?: NullableIntFieldUpdateOperationsInput | number | null
    regionID?: NullableIntFieldUpdateOperationsInput | number | null
    orbitID?: NullableIntFieldUpdateOperationsInput | number | null
    x?: NullableFloatFieldUpdateOperationsInput | number | null
    y?: NullableFloatFieldUpdateOperationsInput | number | null
    z?: NullableFloatFieldUpdateOperationsInput | number | null
    radius?: NullableFloatFieldUpdateOperationsInput | number | null
    itemName?: NullableStringFieldUpdateOperationsInput | string | null
    security?: NullableFloatFieldUpdateOperationsInput | number | null
    celestialIndex?: NullableIntFieldUpdateOperationsInput | number | null
    orbitIndex?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type mapDenormalizeUncheckedUpdateManyInput = {
    itemID?: IntFieldUpdateOperationsInput | number
    typeID?: NullableIntFieldUpdateOperationsInput | number | null
    groupID?: NullableIntFieldUpdateOperationsInput | number | null
    solarSystemID?: NullableIntFieldUpdateOperationsInput | number | null
    constellationID?: NullableIntFieldUpdateOperationsInput | number | null
    regionID?: NullableIntFieldUpdateOperationsInput | number | null
    orbitID?: NullableIntFieldUpdateOperationsInput | number | null
    x?: NullableFloatFieldUpdateOperationsInput | number | null
    y?: NullableFloatFieldUpdateOperationsInput | number | null
    z?: NullableFloatFieldUpdateOperationsInput | number | null
    radius?: NullableFloatFieldUpdateOperationsInput | number | null
    itemName?: NullableStringFieldUpdateOperationsInput | string | null
    security?: NullableFloatFieldUpdateOperationsInput | number | null
    celestialIndex?: NullableIntFieldUpdateOperationsInput | number | null
    orbitIndex?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type mapJumpsCreateInput = {
    stargateID: number
    destinationID?: number | null
  }

  export type mapJumpsUncheckedCreateInput = {
    stargateID: number
    destinationID?: number | null
  }

  export type mapJumpsUpdateInput = {
    stargateID?: IntFieldUpdateOperationsInput | number
    destinationID?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type mapJumpsUncheckedUpdateInput = {
    stargateID?: IntFieldUpdateOperationsInput | number
    destinationID?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type mapJumpsCreateManyInput = {
    stargateID: number
    destinationID?: number | null
  }

  export type mapJumpsUpdateManyMutationInput = {
    stargateID?: IntFieldUpdateOperationsInput | number
    destinationID?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type mapJumpsUncheckedUpdateManyInput = {
    stargateID?: IntFieldUpdateOperationsInput | number
    destinationID?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type mapLandmarksCreateInput = {
    landmarkID: number
    landmarkName?: string | null
    description?: string | null
    locationID?: number | null
    x?: number | null
    y?: number | null
    z?: number | null
    iconID?: number | null
  }

  export type mapLandmarksUncheckedCreateInput = {
    landmarkID: number
    landmarkName?: string | null
    description?: string | null
    locationID?: number | null
    x?: number | null
    y?: number | null
    z?: number | null
    iconID?: number | null
  }

  export type mapLandmarksUpdateInput = {
    landmarkID?: IntFieldUpdateOperationsInput | number
    landmarkName?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    locationID?: NullableIntFieldUpdateOperationsInput | number | null
    x?: NullableFloatFieldUpdateOperationsInput | number | null
    y?: NullableFloatFieldUpdateOperationsInput | number | null
    z?: NullableFloatFieldUpdateOperationsInput | number | null
    iconID?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type mapLandmarksUncheckedUpdateInput = {
    landmarkID?: IntFieldUpdateOperationsInput | number
    landmarkName?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    locationID?: NullableIntFieldUpdateOperationsInput | number | null
    x?: NullableFloatFieldUpdateOperationsInput | number | null
    y?: NullableFloatFieldUpdateOperationsInput | number | null
    z?: NullableFloatFieldUpdateOperationsInput | number | null
    iconID?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type mapLandmarksCreateManyInput = {
    landmarkID: number
    landmarkName?: string | null
    description?: string | null
    locationID?: number | null
    x?: number | null
    y?: number | null
    z?: number | null
    iconID?: number | null
  }

  export type mapLandmarksUpdateManyMutationInput = {
    landmarkID?: IntFieldUpdateOperationsInput | number
    landmarkName?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    locationID?: NullableIntFieldUpdateOperationsInput | number | null
    x?: NullableFloatFieldUpdateOperationsInput | number | null
    y?: NullableFloatFieldUpdateOperationsInput | number | null
    z?: NullableFloatFieldUpdateOperationsInput | number | null
    iconID?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type mapLandmarksUncheckedUpdateManyInput = {
    landmarkID?: IntFieldUpdateOperationsInput | number
    landmarkName?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    locationID?: NullableIntFieldUpdateOperationsInput | number | null
    x?: NullableFloatFieldUpdateOperationsInput | number | null
    y?: NullableFloatFieldUpdateOperationsInput | number | null
    z?: NullableFloatFieldUpdateOperationsInput | number | null
    iconID?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type mapLocationScenesCreateInput = {
    locationID: number
    graphicID?: number | null
  }

  export type mapLocationScenesUncheckedCreateInput = {
    locationID: number
    graphicID?: number | null
  }

  export type mapLocationScenesUpdateInput = {
    locationID?: IntFieldUpdateOperationsInput | number
    graphicID?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type mapLocationScenesUncheckedUpdateInput = {
    locationID?: IntFieldUpdateOperationsInput | number
    graphicID?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type mapLocationScenesCreateManyInput = {
    locationID: number
    graphicID?: number | null
  }

  export type mapLocationScenesUpdateManyMutationInput = {
    locationID?: IntFieldUpdateOperationsInput | number
    graphicID?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type mapLocationScenesUncheckedUpdateManyInput = {
    locationID?: IntFieldUpdateOperationsInput | number
    graphicID?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type mapLocationWormholeClassesCreateInput = {
    locationID: number
    wormholeClassID?: number | null
  }

  export type mapLocationWormholeClassesUncheckedCreateInput = {
    locationID: number
    wormholeClassID?: number | null
  }

  export type mapLocationWormholeClassesUpdateInput = {
    locationID?: IntFieldUpdateOperationsInput | number
    wormholeClassID?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type mapLocationWormholeClassesUncheckedUpdateInput = {
    locationID?: IntFieldUpdateOperationsInput | number
    wormholeClassID?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type mapLocationWormholeClassesCreateManyInput = {
    locationID: number
    wormholeClassID?: number | null
  }

  export type mapLocationWormholeClassesUpdateManyMutationInput = {
    locationID?: IntFieldUpdateOperationsInput | number
    wormholeClassID?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type mapLocationWormholeClassesUncheckedUpdateManyInput = {
    locationID?: IntFieldUpdateOperationsInput | number
    wormholeClassID?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type mapRegionJumpsCreateInput = {
    fromRegionID: number
    toRegionID: number
  }

  export type mapRegionJumpsUncheckedCreateInput = {
    fromRegionID: number
    toRegionID: number
  }

  export type mapRegionJumpsUpdateInput = {
    fromRegionID?: IntFieldUpdateOperationsInput | number
    toRegionID?: IntFieldUpdateOperationsInput | number
  }

  export type mapRegionJumpsUncheckedUpdateInput = {
    fromRegionID?: IntFieldUpdateOperationsInput | number
    toRegionID?: IntFieldUpdateOperationsInput | number
  }

  export type mapRegionJumpsCreateManyInput = {
    fromRegionID: number
    toRegionID: number
  }

  export type mapRegionJumpsUpdateManyMutationInput = {
    fromRegionID?: IntFieldUpdateOperationsInput | number
    toRegionID?: IntFieldUpdateOperationsInput | number
  }

  export type mapRegionJumpsUncheckedUpdateManyInput = {
    fromRegionID?: IntFieldUpdateOperationsInput | number
    toRegionID?: IntFieldUpdateOperationsInput | number
  }

  export type mapRegionsCreateInput = {
    regionID: number
    regionName?: string | null
    x?: number | null
    y?: number | null
    z?: number | null
    xMin?: number | null
    xMax?: number | null
    yMin?: number | null
    yMax?: number | null
    zMin?: number | null
    zMax?: number | null
    factionID?: number | null
    nebula?: number | null
    radius?: number | null
  }

  export type mapRegionsUncheckedCreateInput = {
    regionID: number
    regionName?: string | null
    x?: number | null
    y?: number | null
    z?: number | null
    xMin?: number | null
    xMax?: number | null
    yMin?: number | null
    yMax?: number | null
    zMin?: number | null
    zMax?: number | null
    factionID?: number | null
    nebula?: number | null
    radius?: number | null
  }

  export type mapRegionsUpdateInput = {
    regionID?: IntFieldUpdateOperationsInput | number
    regionName?: NullableStringFieldUpdateOperationsInput | string | null
    x?: NullableFloatFieldUpdateOperationsInput | number | null
    y?: NullableFloatFieldUpdateOperationsInput | number | null
    z?: NullableFloatFieldUpdateOperationsInput | number | null
    xMin?: NullableFloatFieldUpdateOperationsInput | number | null
    xMax?: NullableFloatFieldUpdateOperationsInput | number | null
    yMin?: NullableFloatFieldUpdateOperationsInput | number | null
    yMax?: NullableFloatFieldUpdateOperationsInput | number | null
    zMin?: NullableFloatFieldUpdateOperationsInput | number | null
    zMax?: NullableFloatFieldUpdateOperationsInput | number | null
    factionID?: NullableIntFieldUpdateOperationsInput | number | null
    nebula?: NullableIntFieldUpdateOperationsInput | number | null
    radius?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type mapRegionsUncheckedUpdateInput = {
    regionID?: IntFieldUpdateOperationsInput | number
    regionName?: NullableStringFieldUpdateOperationsInput | string | null
    x?: NullableFloatFieldUpdateOperationsInput | number | null
    y?: NullableFloatFieldUpdateOperationsInput | number | null
    z?: NullableFloatFieldUpdateOperationsInput | number | null
    xMin?: NullableFloatFieldUpdateOperationsInput | number | null
    xMax?: NullableFloatFieldUpdateOperationsInput | number | null
    yMin?: NullableFloatFieldUpdateOperationsInput | number | null
    yMax?: NullableFloatFieldUpdateOperationsInput | number | null
    zMin?: NullableFloatFieldUpdateOperationsInput | number | null
    zMax?: NullableFloatFieldUpdateOperationsInput | number | null
    factionID?: NullableIntFieldUpdateOperationsInput | number | null
    nebula?: NullableIntFieldUpdateOperationsInput | number | null
    radius?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type mapRegionsCreateManyInput = {
    regionID: number
    regionName?: string | null
    x?: number | null
    y?: number | null
    z?: number | null
    xMin?: number | null
    xMax?: number | null
    yMin?: number | null
    yMax?: number | null
    zMin?: number | null
    zMax?: number | null
    factionID?: number | null
    nebula?: number | null
    radius?: number | null
  }

  export type mapRegionsUpdateManyMutationInput = {
    regionID?: IntFieldUpdateOperationsInput | number
    regionName?: NullableStringFieldUpdateOperationsInput | string | null
    x?: NullableFloatFieldUpdateOperationsInput | number | null
    y?: NullableFloatFieldUpdateOperationsInput | number | null
    z?: NullableFloatFieldUpdateOperationsInput | number | null
    xMin?: NullableFloatFieldUpdateOperationsInput | number | null
    xMax?: NullableFloatFieldUpdateOperationsInput | number | null
    yMin?: NullableFloatFieldUpdateOperationsInput | number | null
    yMax?: NullableFloatFieldUpdateOperationsInput | number | null
    zMin?: NullableFloatFieldUpdateOperationsInput | number | null
    zMax?: NullableFloatFieldUpdateOperationsInput | number | null
    factionID?: NullableIntFieldUpdateOperationsInput | number | null
    nebula?: NullableIntFieldUpdateOperationsInput | number | null
    radius?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type mapRegionsUncheckedUpdateManyInput = {
    regionID?: IntFieldUpdateOperationsInput | number
    regionName?: NullableStringFieldUpdateOperationsInput | string | null
    x?: NullableFloatFieldUpdateOperationsInput | number | null
    y?: NullableFloatFieldUpdateOperationsInput | number | null
    z?: NullableFloatFieldUpdateOperationsInput | number | null
    xMin?: NullableFloatFieldUpdateOperationsInput | number | null
    xMax?: NullableFloatFieldUpdateOperationsInput | number | null
    yMin?: NullableFloatFieldUpdateOperationsInput | number | null
    yMax?: NullableFloatFieldUpdateOperationsInput | number | null
    zMin?: NullableFloatFieldUpdateOperationsInput | number | null
    zMax?: NullableFloatFieldUpdateOperationsInput | number | null
    factionID?: NullableIntFieldUpdateOperationsInput | number | null
    nebula?: NullableIntFieldUpdateOperationsInput | number | null
    radius?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type mapSolarSystemJumpsCreateInput = {
    fromRegionID?: number | null
    fromConstellationID?: number | null
    fromSolarSystemID: number
    toSolarSystemID: number
    toConstellationID?: number | null
    toRegionID?: number | null
  }

  export type mapSolarSystemJumpsUncheckedCreateInput = {
    fromRegionID?: number | null
    fromConstellationID?: number | null
    fromSolarSystemID: number
    toSolarSystemID: number
    toConstellationID?: number | null
    toRegionID?: number | null
  }

  export type mapSolarSystemJumpsUpdateInput = {
    fromRegionID?: NullableIntFieldUpdateOperationsInput | number | null
    fromConstellationID?: NullableIntFieldUpdateOperationsInput | number | null
    fromSolarSystemID?: IntFieldUpdateOperationsInput | number
    toSolarSystemID?: IntFieldUpdateOperationsInput | number
    toConstellationID?: NullableIntFieldUpdateOperationsInput | number | null
    toRegionID?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type mapSolarSystemJumpsUncheckedUpdateInput = {
    fromRegionID?: NullableIntFieldUpdateOperationsInput | number | null
    fromConstellationID?: NullableIntFieldUpdateOperationsInput | number | null
    fromSolarSystemID?: IntFieldUpdateOperationsInput | number
    toSolarSystemID?: IntFieldUpdateOperationsInput | number
    toConstellationID?: NullableIntFieldUpdateOperationsInput | number | null
    toRegionID?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type mapSolarSystemJumpsCreateManyInput = {
    fromRegionID?: number | null
    fromConstellationID?: number | null
    fromSolarSystemID: number
    toSolarSystemID: number
    toConstellationID?: number | null
    toRegionID?: number | null
  }

  export type mapSolarSystemJumpsUpdateManyMutationInput = {
    fromRegionID?: NullableIntFieldUpdateOperationsInput | number | null
    fromConstellationID?: NullableIntFieldUpdateOperationsInput | number | null
    fromSolarSystemID?: IntFieldUpdateOperationsInput | number
    toSolarSystemID?: IntFieldUpdateOperationsInput | number
    toConstellationID?: NullableIntFieldUpdateOperationsInput | number | null
    toRegionID?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type mapSolarSystemJumpsUncheckedUpdateManyInput = {
    fromRegionID?: NullableIntFieldUpdateOperationsInput | number | null
    fromConstellationID?: NullableIntFieldUpdateOperationsInput | number | null
    fromSolarSystemID?: IntFieldUpdateOperationsInput | number
    toSolarSystemID?: IntFieldUpdateOperationsInput | number
    toConstellationID?: NullableIntFieldUpdateOperationsInput | number | null
    toRegionID?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type mapSolarSystemsCreateInput = {
    regionID?: number | null
    constellationID?: number | null
    solarSystemID: number
    solarSystemName?: string | null
    x?: number | null
    y?: number | null
    z?: number | null
    xMin?: number | null
    xMax?: number | null
    yMin?: number | null
    yMax?: number | null
    zMin?: number | null
    zMax?: number | null
    luminosity?: number | null
    border?: boolean | null
    fringe?: boolean | null
    corridor?: boolean | null
    hub?: boolean | null
    international?: boolean | null
    regional?: boolean | null
    constellation?: boolean | null
    security?: number | null
    factionID?: number | null
    radius?: number | null
    sunTypeID?: number | null
    securityClass?: string | null
  }

  export type mapSolarSystemsUncheckedCreateInput = {
    regionID?: number | null
    constellationID?: number | null
    solarSystemID: number
    solarSystemName?: string | null
    x?: number | null
    y?: number | null
    z?: number | null
    xMin?: number | null
    xMax?: number | null
    yMin?: number | null
    yMax?: number | null
    zMin?: number | null
    zMax?: number | null
    luminosity?: number | null
    border?: boolean | null
    fringe?: boolean | null
    corridor?: boolean | null
    hub?: boolean | null
    international?: boolean | null
    regional?: boolean | null
    constellation?: boolean | null
    security?: number | null
    factionID?: number | null
    radius?: number | null
    sunTypeID?: number | null
    securityClass?: string | null
  }

  export type mapSolarSystemsUpdateInput = {
    regionID?: NullableIntFieldUpdateOperationsInput | number | null
    constellationID?: NullableIntFieldUpdateOperationsInput | number | null
    solarSystemID?: IntFieldUpdateOperationsInput | number
    solarSystemName?: NullableStringFieldUpdateOperationsInput | string | null
    x?: NullableFloatFieldUpdateOperationsInput | number | null
    y?: NullableFloatFieldUpdateOperationsInput | number | null
    z?: NullableFloatFieldUpdateOperationsInput | number | null
    xMin?: NullableFloatFieldUpdateOperationsInput | number | null
    xMax?: NullableFloatFieldUpdateOperationsInput | number | null
    yMin?: NullableFloatFieldUpdateOperationsInput | number | null
    yMax?: NullableFloatFieldUpdateOperationsInput | number | null
    zMin?: NullableFloatFieldUpdateOperationsInput | number | null
    zMax?: NullableFloatFieldUpdateOperationsInput | number | null
    luminosity?: NullableFloatFieldUpdateOperationsInput | number | null
    border?: NullableBoolFieldUpdateOperationsInput | boolean | null
    fringe?: NullableBoolFieldUpdateOperationsInput | boolean | null
    corridor?: NullableBoolFieldUpdateOperationsInput | boolean | null
    hub?: NullableBoolFieldUpdateOperationsInput | boolean | null
    international?: NullableBoolFieldUpdateOperationsInput | boolean | null
    regional?: NullableBoolFieldUpdateOperationsInput | boolean | null
    constellation?: NullableBoolFieldUpdateOperationsInput | boolean | null
    security?: NullableFloatFieldUpdateOperationsInput | number | null
    factionID?: NullableIntFieldUpdateOperationsInput | number | null
    radius?: NullableFloatFieldUpdateOperationsInput | number | null
    sunTypeID?: NullableIntFieldUpdateOperationsInput | number | null
    securityClass?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type mapSolarSystemsUncheckedUpdateInput = {
    regionID?: NullableIntFieldUpdateOperationsInput | number | null
    constellationID?: NullableIntFieldUpdateOperationsInput | number | null
    solarSystemID?: IntFieldUpdateOperationsInput | number
    solarSystemName?: NullableStringFieldUpdateOperationsInput | string | null
    x?: NullableFloatFieldUpdateOperationsInput | number | null
    y?: NullableFloatFieldUpdateOperationsInput | number | null
    z?: NullableFloatFieldUpdateOperationsInput | number | null
    xMin?: NullableFloatFieldUpdateOperationsInput | number | null
    xMax?: NullableFloatFieldUpdateOperationsInput | number | null
    yMin?: NullableFloatFieldUpdateOperationsInput | number | null
    yMax?: NullableFloatFieldUpdateOperationsInput | number | null
    zMin?: NullableFloatFieldUpdateOperationsInput | number | null
    zMax?: NullableFloatFieldUpdateOperationsInput | number | null
    luminosity?: NullableFloatFieldUpdateOperationsInput | number | null
    border?: NullableBoolFieldUpdateOperationsInput | boolean | null
    fringe?: NullableBoolFieldUpdateOperationsInput | boolean | null
    corridor?: NullableBoolFieldUpdateOperationsInput | boolean | null
    hub?: NullableBoolFieldUpdateOperationsInput | boolean | null
    international?: NullableBoolFieldUpdateOperationsInput | boolean | null
    regional?: NullableBoolFieldUpdateOperationsInput | boolean | null
    constellation?: NullableBoolFieldUpdateOperationsInput | boolean | null
    security?: NullableFloatFieldUpdateOperationsInput | number | null
    factionID?: NullableIntFieldUpdateOperationsInput | number | null
    radius?: NullableFloatFieldUpdateOperationsInput | number | null
    sunTypeID?: NullableIntFieldUpdateOperationsInput | number | null
    securityClass?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type mapSolarSystemsCreateManyInput = {
    regionID?: number | null
    constellationID?: number | null
    solarSystemID: number
    solarSystemName?: string | null
    x?: number | null
    y?: number | null
    z?: number | null
    xMin?: number | null
    xMax?: number | null
    yMin?: number | null
    yMax?: number | null
    zMin?: number | null
    zMax?: number | null
    luminosity?: number | null
    border?: boolean | null
    fringe?: boolean | null
    corridor?: boolean | null
    hub?: boolean | null
    international?: boolean | null
    regional?: boolean | null
    constellation?: boolean | null
    security?: number | null
    factionID?: number | null
    radius?: number | null
    sunTypeID?: number | null
    securityClass?: string | null
  }

  export type mapSolarSystemsUpdateManyMutationInput = {
    regionID?: NullableIntFieldUpdateOperationsInput | number | null
    constellationID?: NullableIntFieldUpdateOperationsInput | number | null
    solarSystemID?: IntFieldUpdateOperationsInput | number
    solarSystemName?: NullableStringFieldUpdateOperationsInput | string | null
    x?: NullableFloatFieldUpdateOperationsInput | number | null
    y?: NullableFloatFieldUpdateOperationsInput | number | null
    z?: NullableFloatFieldUpdateOperationsInput | number | null
    xMin?: NullableFloatFieldUpdateOperationsInput | number | null
    xMax?: NullableFloatFieldUpdateOperationsInput | number | null
    yMin?: NullableFloatFieldUpdateOperationsInput | number | null
    yMax?: NullableFloatFieldUpdateOperationsInput | number | null
    zMin?: NullableFloatFieldUpdateOperationsInput | number | null
    zMax?: NullableFloatFieldUpdateOperationsInput | number | null
    luminosity?: NullableFloatFieldUpdateOperationsInput | number | null
    border?: NullableBoolFieldUpdateOperationsInput | boolean | null
    fringe?: NullableBoolFieldUpdateOperationsInput | boolean | null
    corridor?: NullableBoolFieldUpdateOperationsInput | boolean | null
    hub?: NullableBoolFieldUpdateOperationsInput | boolean | null
    international?: NullableBoolFieldUpdateOperationsInput | boolean | null
    regional?: NullableBoolFieldUpdateOperationsInput | boolean | null
    constellation?: NullableBoolFieldUpdateOperationsInput | boolean | null
    security?: NullableFloatFieldUpdateOperationsInput | number | null
    factionID?: NullableIntFieldUpdateOperationsInput | number | null
    radius?: NullableFloatFieldUpdateOperationsInput | number | null
    sunTypeID?: NullableIntFieldUpdateOperationsInput | number | null
    securityClass?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type mapSolarSystemsUncheckedUpdateManyInput = {
    regionID?: NullableIntFieldUpdateOperationsInput | number | null
    constellationID?: NullableIntFieldUpdateOperationsInput | number | null
    solarSystemID?: IntFieldUpdateOperationsInput | number
    solarSystemName?: NullableStringFieldUpdateOperationsInput | string | null
    x?: NullableFloatFieldUpdateOperationsInput | number | null
    y?: NullableFloatFieldUpdateOperationsInput | number | null
    z?: NullableFloatFieldUpdateOperationsInput | number | null
    xMin?: NullableFloatFieldUpdateOperationsInput | number | null
    xMax?: NullableFloatFieldUpdateOperationsInput | number | null
    yMin?: NullableFloatFieldUpdateOperationsInput | number | null
    yMax?: NullableFloatFieldUpdateOperationsInput | number | null
    zMin?: NullableFloatFieldUpdateOperationsInput | number | null
    zMax?: NullableFloatFieldUpdateOperationsInput | number | null
    luminosity?: NullableFloatFieldUpdateOperationsInput | number | null
    border?: NullableBoolFieldUpdateOperationsInput | boolean | null
    fringe?: NullableBoolFieldUpdateOperationsInput | boolean | null
    corridor?: NullableBoolFieldUpdateOperationsInput | boolean | null
    hub?: NullableBoolFieldUpdateOperationsInput | boolean | null
    international?: NullableBoolFieldUpdateOperationsInput | boolean | null
    regional?: NullableBoolFieldUpdateOperationsInput | boolean | null
    constellation?: NullableBoolFieldUpdateOperationsInput | boolean | null
    security?: NullableFloatFieldUpdateOperationsInput | number | null
    factionID?: NullableIntFieldUpdateOperationsInput | number | null
    radius?: NullableFloatFieldUpdateOperationsInput | number | null
    sunTypeID?: NullableIntFieldUpdateOperationsInput | number | null
    securityClass?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type mapUniverseCreateInput = {
    universeID: number
    universeName?: string | null
    x?: number | null
    y?: number | null
    z?: number | null
    xMin?: number | null
    xMax?: number | null
    yMin?: number | null
    yMax?: number | null
    zMin?: number | null
    zMax?: number | null
    radius?: number | null
  }

  export type mapUniverseUncheckedCreateInput = {
    universeID: number
    universeName?: string | null
    x?: number | null
    y?: number | null
    z?: number | null
    xMin?: number | null
    xMax?: number | null
    yMin?: number | null
    yMax?: number | null
    zMin?: number | null
    zMax?: number | null
    radius?: number | null
  }

  export type mapUniverseUpdateInput = {
    universeID?: IntFieldUpdateOperationsInput | number
    universeName?: NullableStringFieldUpdateOperationsInput | string | null
    x?: NullableFloatFieldUpdateOperationsInput | number | null
    y?: NullableFloatFieldUpdateOperationsInput | number | null
    z?: NullableFloatFieldUpdateOperationsInput | number | null
    xMin?: NullableFloatFieldUpdateOperationsInput | number | null
    xMax?: NullableFloatFieldUpdateOperationsInput | number | null
    yMin?: NullableFloatFieldUpdateOperationsInput | number | null
    yMax?: NullableFloatFieldUpdateOperationsInput | number | null
    zMin?: NullableFloatFieldUpdateOperationsInput | number | null
    zMax?: NullableFloatFieldUpdateOperationsInput | number | null
    radius?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type mapUniverseUncheckedUpdateInput = {
    universeID?: IntFieldUpdateOperationsInput | number
    universeName?: NullableStringFieldUpdateOperationsInput | string | null
    x?: NullableFloatFieldUpdateOperationsInput | number | null
    y?: NullableFloatFieldUpdateOperationsInput | number | null
    z?: NullableFloatFieldUpdateOperationsInput | number | null
    xMin?: NullableFloatFieldUpdateOperationsInput | number | null
    xMax?: NullableFloatFieldUpdateOperationsInput | number | null
    yMin?: NullableFloatFieldUpdateOperationsInput | number | null
    yMax?: NullableFloatFieldUpdateOperationsInput | number | null
    zMin?: NullableFloatFieldUpdateOperationsInput | number | null
    zMax?: NullableFloatFieldUpdateOperationsInput | number | null
    radius?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type mapUniverseCreateManyInput = {
    universeID: number
    universeName?: string | null
    x?: number | null
    y?: number | null
    z?: number | null
    xMin?: number | null
    xMax?: number | null
    yMin?: number | null
    yMax?: number | null
    zMin?: number | null
    zMax?: number | null
    radius?: number | null
  }

  export type mapUniverseUpdateManyMutationInput = {
    universeID?: IntFieldUpdateOperationsInput | number
    universeName?: NullableStringFieldUpdateOperationsInput | string | null
    x?: NullableFloatFieldUpdateOperationsInput | number | null
    y?: NullableFloatFieldUpdateOperationsInput | number | null
    z?: NullableFloatFieldUpdateOperationsInput | number | null
    xMin?: NullableFloatFieldUpdateOperationsInput | number | null
    xMax?: NullableFloatFieldUpdateOperationsInput | number | null
    yMin?: NullableFloatFieldUpdateOperationsInput | number | null
    yMax?: NullableFloatFieldUpdateOperationsInput | number | null
    zMin?: NullableFloatFieldUpdateOperationsInput | number | null
    zMax?: NullableFloatFieldUpdateOperationsInput | number | null
    radius?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type mapUniverseUncheckedUpdateManyInput = {
    universeID?: IntFieldUpdateOperationsInput | number
    universeName?: NullableStringFieldUpdateOperationsInput | string | null
    x?: NullableFloatFieldUpdateOperationsInput | number | null
    y?: NullableFloatFieldUpdateOperationsInput | number | null
    z?: NullableFloatFieldUpdateOperationsInput | number | null
    xMin?: NullableFloatFieldUpdateOperationsInput | number | null
    xMax?: NullableFloatFieldUpdateOperationsInput | number | null
    yMin?: NullableFloatFieldUpdateOperationsInput | number | null
    yMax?: NullableFloatFieldUpdateOperationsInput | number | null
    zMin?: NullableFloatFieldUpdateOperationsInput | number | null
    zMax?: NullableFloatFieldUpdateOperationsInput | number | null
    radius?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type planetSchematicsCreateInput = {
    schematicID: number
    schematicName?: string | null
    cycleTime?: number | null
  }

  export type planetSchematicsUncheckedCreateInput = {
    schematicID: number
    schematicName?: string | null
    cycleTime?: number | null
  }

  export type planetSchematicsUpdateInput = {
    schematicID?: IntFieldUpdateOperationsInput | number
    schematicName?: NullableStringFieldUpdateOperationsInput | string | null
    cycleTime?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type planetSchematicsUncheckedUpdateInput = {
    schematicID?: IntFieldUpdateOperationsInput | number
    schematicName?: NullableStringFieldUpdateOperationsInput | string | null
    cycleTime?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type planetSchematicsCreateManyInput = {
    schematicID: number
    schematicName?: string | null
    cycleTime?: number | null
  }

  export type planetSchematicsUpdateManyMutationInput = {
    schematicID?: IntFieldUpdateOperationsInput | number
    schematicName?: NullableStringFieldUpdateOperationsInput | string | null
    cycleTime?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type planetSchematicsUncheckedUpdateManyInput = {
    schematicID?: IntFieldUpdateOperationsInput | number
    schematicName?: NullableStringFieldUpdateOperationsInput | string | null
    cycleTime?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type planetSchematicsPinMapCreateInput = {
    schematicID: number
    pinTypeID: number
  }

  export type planetSchematicsPinMapUncheckedCreateInput = {
    schematicID: number
    pinTypeID: number
  }

  export type planetSchematicsPinMapUpdateInput = {
    schematicID?: IntFieldUpdateOperationsInput | number
    pinTypeID?: IntFieldUpdateOperationsInput | number
  }

  export type planetSchematicsPinMapUncheckedUpdateInput = {
    schematicID?: IntFieldUpdateOperationsInput | number
    pinTypeID?: IntFieldUpdateOperationsInput | number
  }

  export type planetSchematicsPinMapCreateManyInput = {
    schematicID: number
    pinTypeID: number
  }

  export type planetSchematicsPinMapUpdateManyMutationInput = {
    schematicID?: IntFieldUpdateOperationsInput | number
    pinTypeID?: IntFieldUpdateOperationsInput | number
  }

  export type planetSchematicsPinMapUncheckedUpdateManyInput = {
    schematicID?: IntFieldUpdateOperationsInput | number
    pinTypeID?: IntFieldUpdateOperationsInput | number
  }

  export type planetSchematicsTypeMapCreateInput = {
    schematicID: number
    typeID: number
    quantity?: number | null
    isInput?: boolean | null
  }

  export type planetSchematicsTypeMapUncheckedCreateInput = {
    schematicID: number
    typeID: number
    quantity?: number | null
    isInput?: boolean | null
  }

  export type planetSchematicsTypeMapUpdateInput = {
    schematicID?: IntFieldUpdateOperationsInput | number
    typeID?: IntFieldUpdateOperationsInput | number
    quantity?: NullableIntFieldUpdateOperationsInput | number | null
    isInput?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type planetSchematicsTypeMapUncheckedUpdateInput = {
    schematicID?: IntFieldUpdateOperationsInput | number
    typeID?: IntFieldUpdateOperationsInput | number
    quantity?: NullableIntFieldUpdateOperationsInput | number | null
    isInput?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type planetSchematicsTypeMapCreateManyInput = {
    schematicID: number
    typeID: number
    quantity?: number | null
    isInput?: boolean | null
  }

  export type planetSchematicsTypeMapUpdateManyMutationInput = {
    schematicID?: IntFieldUpdateOperationsInput | number
    typeID?: IntFieldUpdateOperationsInput | number
    quantity?: NullableIntFieldUpdateOperationsInput | number | null
    isInput?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type planetSchematicsTypeMapUncheckedUpdateManyInput = {
    schematicID?: IntFieldUpdateOperationsInput | number
    typeID?: IntFieldUpdateOperationsInput | number
    quantity?: NullableIntFieldUpdateOperationsInput | number | null
    isInput?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type ramActivitiesCreateInput = {
    activityID: number
    activityName?: string | null
    iconNo?: string | null
    description?: string | null
    published?: boolean | null
  }

  export type ramActivitiesUncheckedCreateInput = {
    activityID: number
    activityName?: string | null
    iconNo?: string | null
    description?: string | null
    published?: boolean | null
  }

  export type ramActivitiesUpdateInput = {
    activityID?: IntFieldUpdateOperationsInput | number
    activityName?: NullableStringFieldUpdateOperationsInput | string | null
    iconNo?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    published?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type ramActivitiesUncheckedUpdateInput = {
    activityID?: IntFieldUpdateOperationsInput | number
    activityName?: NullableStringFieldUpdateOperationsInput | string | null
    iconNo?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    published?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type ramActivitiesCreateManyInput = {
    activityID: number
    activityName?: string | null
    iconNo?: string | null
    description?: string | null
    published?: boolean | null
  }

  export type ramActivitiesUpdateManyMutationInput = {
    activityID?: IntFieldUpdateOperationsInput | number
    activityName?: NullableStringFieldUpdateOperationsInput | string | null
    iconNo?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    published?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type ramActivitiesUncheckedUpdateManyInput = {
    activityID?: IntFieldUpdateOperationsInput | number
    activityName?: NullableStringFieldUpdateOperationsInput | string | null
    iconNo?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    published?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type ramAssemblyLineStationsCreateInput = {
    stationID: number
    assemblyLineTypeID: number
    quantity?: number | null
    stationTypeID?: number | null
    ownerID?: number | null
    solarSystemID?: number | null
    regionID?: number | null
  }

  export type ramAssemblyLineStationsUncheckedCreateInput = {
    stationID: number
    assemblyLineTypeID: number
    quantity?: number | null
    stationTypeID?: number | null
    ownerID?: number | null
    solarSystemID?: number | null
    regionID?: number | null
  }

  export type ramAssemblyLineStationsUpdateInput = {
    stationID?: IntFieldUpdateOperationsInput | number
    assemblyLineTypeID?: IntFieldUpdateOperationsInput | number
    quantity?: NullableIntFieldUpdateOperationsInput | number | null
    stationTypeID?: NullableIntFieldUpdateOperationsInput | number | null
    ownerID?: NullableIntFieldUpdateOperationsInput | number | null
    solarSystemID?: NullableIntFieldUpdateOperationsInput | number | null
    regionID?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type ramAssemblyLineStationsUncheckedUpdateInput = {
    stationID?: IntFieldUpdateOperationsInput | number
    assemblyLineTypeID?: IntFieldUpdateOperationsInput | number
    quantity?: NullableIntFieldUpdateOperationsInput | number | null
    stationTypeID?: NullableIntFieldUpdateOperationsInput | number | null
    ownerID?: NullableIntFieldUpdateOperationsInput | number | null
    solarSystemID?: NullableIntFieldUpdateOperationsInput | number | null
    regionID?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type ramAssemblyLineStationsCreateManyInput = {
    stationID: number
    assemblyLineTypeID: number
    quantity?: number | null
    stationTypeID?: number | null
    ownerID?: number | null
    solarSystemID?: number | null
    regionID?: number | null
  }

  export type ramAssemblyLineStationsUpdateManyMutationInput = {
    stationID?: IntFieldUpdateOperationsInput | number
    assemblyLineTypeID?: IntFieldUpdateOperationsInput | number
    quantity?: NullableIntFieldUpdateOperationsInput | number | null
    stationTypeID?: NullableIntFieldUpdateOperationsInput | number | null
    ownerID?: NullableIntFieldUpdateOperationsInput | number | null
    solarSystemID?: NullableIntFieldUpdateOperationsInput | number | null
    regionID?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type ramAssemblyLineStationsUncheckedUpdateManyInput = {
    stationID?: IntFieldUpdateOperationsInput | number
    assemblyLineTypeID?: IntFieldUpdateOperationsInput | number
    quantity?: NullableIntFieldUpdateOperationsInput | number | null
    stationTypeID?: NullableIntFieldUpdateOperationsInput | number | null
    ownerID?: NullableIntFieldUpdateOperationsInput | number | null
    solarSystemID?: NullableIntFieldUpdateOperationsInput | number | null
    regionID?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type ramAssemblyLineTypeDetailPerCategoryCreateInput = {
    assemblyLineTypeID: number
    categoryID: number
    timeMultiplier?: number | null
    materialMultiplier?: number | null
    costMultiplier?: number | null
  }

  export type ramAssemblyLineTypeDetailPerCategoryUncheckedCreateInput = {
    assemblyLineTypeID: number
    categoryID: number
    timeMultiplier?: number | null
    materialMultiplier?: number | null
    costMultiplier?: number | null
  }

  export type ramAssemblyLineTypeDetailPerCategoryUpdateInput = {
    assemblyLineTypeID?: IntFieldUpdateOperationsInput | number
    categoryID?: IntFieldUpdateOperationsInput | number
    timeMultiplier?: NullableFloatFieldUpdateOperationsInput | number | null
    materialMultiplier?: NullableFloatFieldUpdateOperationsInput | number | null
    costMultiplier?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type ramAssemblyLineTypeDetailPerCategoryUncheckedUpdateInput = {
    assemblyLineTypeID?: IntFieldUpdateOperationsInput | number
    categoryID?: IntFieldUpdateOperationsInput | number
    timeMultiplier?: NullableFloatFieldUpdateOperationsInput | number | null
    materialMultiplier?: NullableFloatFieldUpdateOperationsInput | number | null
    costMultiplier?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type ramAssemblyLineTypeDetailPerCategoryCreateManyInput = {
    assemblyLineTypeID: number
    categoryID: number
    timeMultiplier?: number | null
    materialMultiplier?: number | null
    costMultiplier?: number | null
  }

  export type ramAssemblyLineTypeDetailPerCategoryUpdateManyMutationInput = {
    assemblyLineTypeID?: IntFieldUpdateOperationsInput | number
    categoryID?: IntFieldUpdateOperationsInput | number
    timeMultiplier?: NullableFloatFieldUpdateOperationsInput | number | null
    materialMultiplier?: NullableFloatFieldUpdateOperationsInput | number | null
    costMultiplier?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type ramAssemblyLineTypeDetailPerCategoryUncheckedUpdateManyInput = {
    assemblyLineTypeID?: IntFieldUpdateOperationsInput | number
    categoryID?: IntFieldUpdateOperationsInput | number
    timeMultiplier?: NullableFloatFieldUpdateOperationsInput | number | null
    materialMultiplier?: NullableFloatFieldUpdateOperationsInput | number | null
    costMultiplier?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type ramAssemblyLineTypeDetailPerGroupCreateInput = {
    assemblyLineTypeID: number
    groupID: number
    timeMultiplier?: number | null
    materialMultiplier?: number | null
    costMultiplier?: number | null
  }

  export type ramAssemblyLineTypeDetailPerGroupUncheckedCreateInput = {
    assemblyLineTypeID: number
    groupID: number
    timeMultiplier?: number | null
    materialMultiplier?: number | null
    costMultiplier?: number | null
  }

  export type ramAssemblyLineTypeDetailPerGroupUpdateInput = {
    assemblyLineTypeID?: IntFieldUpdateOperationsInput | number
    groupID?: IntFieldUpdateOperationsInput | number
    timeMultiplier?: NullableFloatFieldUpdateOperationsInput | number | null
    materialMultiplier?: NullableFloatFieldUpdateOperationsInput | number | null
    costMultiplier?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type ramAssemblyLineTypeDetailPerGroupUncheckedUpdateInput = {
    assemblyLineTypeID?: IntFieldUpdateOperationsInput | number
    groupID?: IntFieldUpdateOperationsInput | number
    timeMultiplier?: NullableFloatFieldUpdateOperationsInput | number | null
    materialMultiplier?: NullableFloatFieldUpdateOperationsInput | number | null
    costMultiplier?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type ramAssemblyLineTypeDetailPerGroupCreateManyInput = {
    assemblyLineTypeID: number
    groupID: number
    timeMultiplier?: number | null
    materialMultiplier?: number | null
    costMultiplier?: number | null
  }

  export type ramAssemblyLineTypeDetailPerGroupUpdateManyMutationInput = {
    assemblyLineTypeID?: IntFieldUpdateOperationsInput | number
    groupID?: IntFieldUpdateOperationsInput | number
    timeMultiplier?: NullableFloatFieldUpdateOperationsInput | number | null
    materialMultiplier?: NullableFloatFieldUpdateOperationsInput | number | null
    costMultiplier?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type ramAssemblyLineTypeDetailPerGroupUncheckedUpdateManyInput = {
    assemblyLineTypeID?: IntFieldUpdateOperationsInput | number
    groupID?: IntFieldUpdateOperationsInput | number
    timeMultiplier?: NullableFloatFieldUpdateOperationsInput | number | null
    materialMultiplier?: NullableFloatFieldUpdateOperationsInput | number | null
    costMultiplier?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type ramAssemblyLineTypesCreateInput = {
    assemblyLineTypeID: number
    assemblyLineTypeName?: string | null
    description?: string | null
    baseTimeMultiplier?: number | null
    baseMaterialMultiplier?: number | null
    baseCostMultiplier?: number | null
    volume?: number | null
    activityID?: number | null
    minCostPerHour?: number | null
  }

  export type ramAssemblyLineTypesUncheckedCreateInput = {
    assemblyLineTypeID: number
    assemblyLineTypeName?: string | null
    description?: string | null
    baseTimeMultiplier?: number | null
    baseMaterialMultiplier?: number | null
    baseCostMultiplier?: number | null
    volume?: number | null
    activityID?: number | null
    minCostPerHour?: number | null
  }

  export type ramAssemblyLineTypesUpdateInput = {
    assemblyLineTypeID?: IntFieldUpdateOperationsInput | number
    assemblyLineTypeName?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    baseTimeMultiplier?: NullableFloatFieldUpdateOperationsInput | number | null
    baseMaterialMultiplier?: NullableFloatFieldUpdateOperationsInput | number | null
    baseCostMultiplier?: NullableFloatFieldUpdateOperationsInput | number | null
    volume?: NullableFloatFieldUpdateOperationsInput | number | null
    activityID?: NullableIntFieldUpdateOperationsInput | number | null
    minCostPerHour?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type ramAssemblyLineTypesUncheckedUpdateInput = {
    assemblyLineTypeID?: IntFieldUpdateOperationsInput | number
    assemblyLineTypeName?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    baseTimeMultiplier?: NullableFloatFieldUpdateOperationsInput | number | null
    baseMaterialMultiplier?: NullableFloatFieldUpdateOperationsInput | number | null
    baseCostMultiplier?: NullableFloatFieldUpdateOperationsInput | number | null
    volume?: NullableFloatFieldUpdateOperationsInput | number | null
    activityID?: NullableIntFieldUpdateOperationsInput | number | null
    minCostPerHour?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type ramAssemblyLineTypesCreateManyInput = {
    assemblyLineTypeID: number
    assemblyLineTypeName?: string | null
    description?: string | null
    baseTimeMultiplier?: number | null
    baseMaterialMultiplier?: number | null
    baseCostMultiplier?: number | null
    volume?: number | null
    activityID?: number | null
    minCostPerHour?: number | null
  }

  export type ramAssemblyLineTypesUpdateManyMutationInput = {
    assemblyLineTypeID?: IntFieldUpdateOperationsInput | number
    assemblyLineTypeName?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    baseTimeMultiplier?: NullableFloatFieldUpdateOperationsInput | number | null
    baseMaterialMultiplier?: NullableFloatFieldUpdateOperationsInput | number | null
    baseCostMultiplier?: NullableFloatFieldUpdateOperationsInput | number | null
    volume?: NullableFloatFieldUpdateOperationsInput | number | null
    activityID?: NullableIntFieldUpdateOperationsInput | number | null
    minCostPerHour?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type ramAssemblyLineTypesUncheckedUpdateManyInput = {
    assemblyLineTypeID?: IntFieldUpdateOperationsInput | number
    assemblyLineTypeName?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    baseTimeMultiplier?: NullableFloatFieldUpdateOperationsInput | number | null
    baseMaterialMultiplier?: NullableFloatFieldUpdateOperationsInput | number | null
    baseCostMultiplier?: NullableFloatFieldUpdateOperationsInput | number | null
    volume?: NullableFloatFieldUpdateOperationsInput | number | null
    activityID?: NullableIntFieldUpdateOperationsInput | number | null
    minCostPerHour?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type ramInstallationTypeContentsCreateInput = {
    installationTypeID: number
    assemblyLineTypeID: number
    quantity?: number | null
  }

  export type ramInstallationTypeContentsUncheckedCreateInput = {
    installationTypeID: number
    assemblyLineTypeID: number
    quantity?: number | null
  }

  export type ramInstallationTypeContentsUpdateInput = {
    installationTypeID?: IntFieldUpdateOperationsInput | number
    assemblyLineTypeID?: IntFieldUpdateOperationsInput | number
    quantity?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type ramInstallationTypeContentsUncheckedUpdateInput = {
    installationTypeID?: IntFieldUpdateOperationsInput | number
    assemblyLineTypeID?: IntFieldUpdateOperationsInput | number
    quantity?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type ramInstallationTypeContentsCreateManyInput = {
    installationTypeID: number
    assemblyLineTypeID: number
    quantity?: number | null
  }

  export type ramInstallationTypeContentsUpdateManyMutationInput = {
    installationTypeID?: IntFieldUpdateOperationsInput | number
    assemblyLineTypeID?: IntFieldUpdateOperationsInput | number
    quantity?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type ramInstallationTypeContentsUncheckedUpdateManyInput = {
    installationTypeID?: IntFieldUpdateOperationsInput | number
    assemblyLineTypeID?: IntFieldUpdateOperationsInput | number
    quantity?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type skinLicenseCreateInput = {
    licenseTypeID: number
    duration?: number | null
    skinID?: number | null
  }

  export type skinLicenseUncheckedCreateInput = {
    licenseTypeID: number
    duration?: number | null
    skinID?: number | null
  }

  export type skinLicenseUpdateInput = {
    licenseTypeID?: IntFieldUpdateOperationsInput | number
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    skinID?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type skinLicenseUncheckedUpdateInput = {
    licenseTypeID?: IntFieldUpdateOperationsInput | number
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    skinID?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type skinLicenseCreateManyInput = {
    licenseTypeID: number
    duration?: number | null
    skinID?: number | null
  }

  export type skinLicenseUpdateManyMutationInput = {
    licenseTypeID?: IntFieldUpdateOperationsInput | number
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    skinID?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type skinLicenseUncheckedUpdateManyInput = {
    licenseTypeID?: IntFieldUpdateOperationsInput | number
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    skinID?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type skinMaterialsCreateInput = {
    skinMaterialID: number
    displayNameID?: number | null
    materialSetID?: number | null
  }

  export type skinMaterialsUncheckedCreateInput = {
    skinMaterialID: number
    displayNameID?: number | null
    materialSetID?: number | null
  }

  export type skinMaterialsUpdateInput = {
    skinMaterialID?: IntFieldUpdateOperationsInput | number
    displayNameID?: NullableIntFieldUpdateOperationsInput | number | null
    materialSetID?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type skinMaterialsUncheckedUpdateInput = {
    skinMaterialID?: IntFieldUpdateOperationsInput | number
    displayNameID?: NullableIntFieldUpdateOperationsInput | number | null
    materialSetID?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type skinMaterialsCreateManyInput = {
    skinMaterialID: number
    displayNameID?: number | null
    materialSetID?: number | null
  }

  export type skinMaterialsUpdateManyMutationInput = {
    skinMaterialID?: IntFieldUpdateOperationsInput | number
    displayNameID?: NullableIntFieldUpdateOperationsInput | number | null
    materialSetID?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type skinMaterialsUncheckedUpdateManyInput = {
    skinMaterialID?: IntFieldUpdateOperationsInput | number
    displayNameID?: NullableIntFieldUpdateOperationsInput | number | null
    materialSetID?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type skinsCreateInput = {
    skinID: number
    internalName?: string | null
    skinMaterialID?: number | null
  }

  export type skinsUncheckedCreateInput = {
    skinID: number
    internalName?: string | null
    skinMaterialID?: number | null
  }

  export type skinsUpdateInput = {
    skinID?: IntFieldUpdateOperationsInput | number
    internalName?: NullableStringFieldUpdateOperationsInput | string | null
    skinMaterialID?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type skinsUncheckedUpdateInput = {
    skinID?: IntFieldUpdateOperationsInput | number
    internalName?: NullableStringFieldUpdateOperationsInput | string | null
    skinMaterialID?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type skinsCreateManyInput = {
    skinID: number
    internalName?: string | null
    skinMaterialID?: number | null
  }

  export type skinsUpdateManyMutationInput = {
    skinID?: IntFieldUpdateOperationsInput | number
    internalName?: NullableStringFieldUpdateOperationsInput | string | null
    skinMaterialID?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type skinsUncheckedUpdateManyInput = {
    skinID?: IntFieldUpdateOperationsInput | number
    internalName?: NullableStringFieldUpdateOperationsInput | string | null
    skinMaterialID?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type staOperationServicesCreateInput = {
    operationID: number
    serviceID: number
  }

  export type staOperationServicesUncheckedCreateInput = {
    operationID: number
    serviceID: number
  }

  export type staOperationServicesUpdateInput = {
    operationID?: IntFieldUpdateOperationsInput | number
    serviceID?: IntFieldUpdateOperationsInput | number
  }

  export type staOperationServicesUncheckedUpdateInput = {
    operationID?: IntFieldUpdateOperationsInput | number
    serviceID?: IntFieldUpdateOperationsInput | number
  }

  export type staOperationServicesCreateManyInput = {
    operationID: number
    serviceID: number
  }

  export type staOperationServicesUpdateManyMutationInput = {
    operationID?: IntFieldUpdateOperationsInput | number
    serviceID?: IntFieldUpdateOperationsInput | number
  }

  export type staOperationServicesUncheckedUpdateManyInput = {
    operationID?: IntFieldUpdateOperationsInput | number
    serviceID?: IntFieldUpdateOperationsInput | number
  }

  export type staOperationsCreateInput = {
    activityID?: number | null
    operationID: number
    operationName?: string | null
    description?: string | null
    fringe?: number | null
    corridor?: number | null
    hub?: number | null
    border?: number | null
    ratio?: number | null
    caldariStationTypeID?: number | null
    minmatarStationTypeID?: number | null
    amarrStationTypeID?: number | null
    gallenteStationTypeID?: number | null
    joveStationTypeID?: number | null
  }

  export type staOperationsUncheckedCreateInput = {
    activityID?: number | null
    operationID: number
    operationName?: string | null
    description?: string | null
    fringe?: number | null
    corridor?: number | null
    hub?: number | null
    border?: number | null
    ratio?: number | null
    caldariStationTypeID?: number | null
    minmatarStationTypeID?: number | null
    amarrStationTypeID?: number | null
    gallenteStationTypeID?: number | null
    joveStationTypeID?: number | null
  }

  export type staOperationsUpdateInput = {
    activityID?: NullableIntFieldUpdateOperationsInput | number | null
    operationID?: IntFieldUpdateOperationsInput | number
    operationName?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    fringe?: NullableIntFieldUpdateOperationsInput | number | null
    corridor?: NullableIntFieldUpdateOperationsInput | number | null
    hub?: NullableIntFieldUpdateOperationsInput | number | null
    border?: NullableIntFieldUpdateOperationsInput | number | null
    ratio?: NullableIntFieldUpdateOperationsInput | number | null
    caldariStationTypeID?: NullableIntFieldUpdateOperationsInput | number | null
    minmatarStationTypeID?: NullableIntFieldUpdateOperationsInput | number | null
    amarrStationTypeID?: NullableIntFieldUpdateOperationsInput | number | null
    gallenteStationTypeID?: NullableIntFieldUpdateOperationsInput | number | null
    joveStationTypeID?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type staOperationsUncheckedUpdateInput = {
    activityID?: NullableIntFieldUpdateOperationsInput | number | null
    operationID?: IntFieldUpdateOperationsInput | number
    operationName?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    fringe?: NullableIntFieldUpdateOperationsInput | number | null
    corridor?: NullableIntFieldUpdateOperationsInput | number | null
    hub?: NullableIntFieldUpdateOperationsInput | number | null
    border?: NullableIntFieldUpdateOperationsInput | number | null
    ratio?: NullableIntFieldUpdateOperationsInput | number | null
    caldariStationTypeID?: NullableIntFieldUpdateOperationsInput | number | null
    minmatarStationTypeID?: NullableIntFieldUpdateOperationsInput | number | null
    amarrStationTypeID?: NullableIntFieldUpdateOperationsInput | number | null
    gallenteStationTypeID?: NullableIntFieldUpdateOperationsInput | number | null
    joveStationTypeID?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type staOperationsCreateManyInput = {
    activityID?: number | null
    operationID: number
    operationName?: string | null
    description?: string | null
    fringe?: number | null
    corridor?: number | null
    hub?: number | null
    border?: number | null
    ratio?: number | null
    caldariStationTypeID?: number | null
    minmatarStationTypeID?: number | null
    amarrStationTypeID?: number | null
    gallenteStationTypeID?: number | null
    joveStationTypeID?: number | null
  }

  export type staOperationsUpdateManyMutationInput = {
    activityID?: NullableIntFieldUpdateOperationsInput | number | null
    operationID?: IntFieldUpdateOperationsInput | number
    operationName?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    fringe?: NullableIntFieldUpdateOperationsInput | number | null
    corridor?: NullableIntFieldUpdateOperationsInput | number | null
    hub?: NullableIntFieldUpdateOperationsInput | number | null
    border?: NullableIntFieldUpdateOperationsInput | number | null
    ratio?: NullableIntFieldUpdateOperationsInput | number | null
    caldariStationTypeID?: NullableIntFieldUpdateOperationsInput | number | null
    minmatarStationTypeID?: NullableIntFieldUpdateOperationsInput | number | null
    amarrStationTypeID?: NullableIntFieldUpdateOperationsInput | number | null
    gallenteStationTypeID?: NullableIntFieldUpdateOperationsInput | number | null
    joveStationTypeID?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type staOperationsUncheckedUpdateManyInput = {
    activityID?: NullableIntFieldUpdateOperationsInput | number | null
    operationID?: IntFieldUpdateOperationsInput | number
    operationName?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    fringe?: NullableIntFieldUpdateOperationsInput | number | null
    corridor?: NullableIntFieldUpdateOperationsInput | number | null
    hub?: NullableIntFieldUpdateOperationsInput | number | null
    border?: NullableIntFieldUpdateOperationsInput | number | null
    ratio?: NullableIntFieldUpdateOperationsInput | number | null
    caldariStationTypeID?: NullableIntFieldUpdateOperationsInput | number | null
    minmatarStationTypeID?: NullableIntFieldUpdateOperationsInput | number | null
    amarrStationTypeID?: NullableIntFieldUpdateOperationsInput | number | null
    gallenteStationTypeID?: NullableIntFieldUpdateOperationsInput | number | null
    joveStationTypeID?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type staServicesCreateInput = {
    serviceID: number
    serviceName?: string | null
    description?: string | null
  }

  export type staServicesUncheckedCreateInput = {
    serviceID: number
    serviceName?: string | null
    description?: string | null
  }

  export type staServicesUpdateInput = {
    serviceID?: IntFieldUpdateOperationsInput | number
    serviceName?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type staServicesUncheckedUpdateInput = {
    serviceID?: IntFieldUpdateOperationsInput | number
    serviceName?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type staServicesCreateManyInput = {
    serviceID: number
    serviceName?: string | null
    description?: string | null
  }

  export type staServicesUpdateManyMutationInput = {
    serviceID?: IntFieldUpdateOperationsInput | number
    serviceName?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type staServicesUncheckedUpdateManyInput = {
    serviceID?: IntFieldUpdateOperationsInput | number
    serviceName?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type staStationTypesCreateInput = {
    stationTypeID: number
    dockEntryX?: number | null
    dockEntryY?: number | null
    dockEntryZ?: number | null
    dockOrientationX?: number | null
    dockOrientationY?: number | null
    dockOrientationZ?: number | null
    operationID?: number | null
    officeSlots?: number | null
    reprocessingEfficiency?: number | null
    conquerable?: boolean | null
  }

  export type staStationTypesUncheckedCreateInput = {
    stationTypeID: number
    dockEntryX?: number | null
    dockEntryY?: number | null
    dockEntryZ?: number | null
    dockOrientationX?: number | null
    dockOrientationY?: number | null
    dockOrientationZ?: number | null
    operationID?: number | null
    officeSlots?: number | null
    reprocessingEfficiency?: number | null
    conquerable?: boolean | null
  }

  export type staStationTypesUpdateInput = {
    stationTypeID?: IntFieldUpdateOperationsInput | number
    dockEntryX?: NullableFloatFieldUpdateOperationsInput | number | null
    dockEntryY?: NullableFloatFieldUpdateOperationsInput | number | null
    dockEntryZ?: NullableFloatFieldUpdateOperationsInput | number | null
    dockOrientationX?: NullableFloatFieldUpdateOperationsInput | number | null
    dockOrientationY?: NullableFloatFieldUpdateOperationsInput | number | null
    dockOrientationZ?: NullableFloatFieldUpdateOperationsInput | number | null
    operationID?: NullableIntFieldUpdateOperationsInput | number | null
    officeSlots?: NullableIntFieldUpdateOperationsInput | number | null
    reprocessingEfficiency?: NullableFloatFieldUpdateOperationsInput | number | null
    conquerable?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type staStationTypesUncheckedUpdateInput = {
    stationTypeID?: IntFieldUpdateOperationsInput | number
    dockEntryX?: NullableFloatFieldUpdateOperationsInput | number | null
    dockEntryY?: NullableFloatFieldUpdateOperationsInput | number | null
    dockEntryZ?: NullableFloatFieldUpdateOperationsInput | number | null
    dockOrientationX?: NullableFloatFieldUpdateOperationsInput | number | null
    dockOrientationY?: NullableFloatFieldUpdateOperationsInput | number | null
    dockOrientationZ?: NullableFloatFieldUpdateOperationsInput | number | null
    operationID?: NullableIntFieldUpdateOperationsInput | number | null
    officeSlots?: NullableIntFieldUpdateOperationsInput | number | null
    reprocessingEfficiency?: NullableFloatFieldUpdateOperationsInput | number | null
    conquerable?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type staStationTypesCreateManyInput = {
    stationTypeID: number
    dockEntryX?: number | null
    dockEntryY?: number | null
    dockEntryZ?: number | null
    dockOrientationX?: number | null
    dockOrientationY?: number | null
    dockOrientationZ?: number | null
    operationID?: number | null
    officeSlots?: number | null
    reprocessingEfficiency?: number | null
    conquerable?: boolean | null
  }

  export type staStationTypesUpdateManyMutationInput = {
    stationTypeID?: IntFieldUpdateOperationsInput | number
    dockEntryX?: NullableFloatFieldUpdateOperationsInput | number | null
    dockEntryY?: NullableFloatFieldUpdateOperationsInput | number | null
    dockEntryZ?: NullableFloatFieldUpdateOperationsInput | number | null
    dockOrientationX?: NullableFloatFieldUpdateOperationsInput | number | null
    dockOrientationY?: NullableFloatFieldUpdateOperationsInput | number | null
    dockOrientationZ?: NullableFloatFieldUpdateOperationsInput | number | null
    operationID?: NullableIntFieldUpdateOperationsInput | number | null
    officeSlots?: NullableIntFieldUpdateOperationsInput | number | null
    reprocessingEfficiency?: NullableFloatFieldUpdateOperationsInput | number | null
    conquerable?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type staStationTypesUncheckedUpdateManyInput = {
    stationTypeID?: IntFieldUpdateOperationsInput | number
    dockEntryX?: NullableFloatFieldUpdateOperationsInput | number | null
    dockEntryY?: NullableFloatFieldUpdateOperationsInput | number | null
    dockEntryZ?: NullableFloatFieldUpdateOperationsInput | number | null
    dockOrientationX?: NullableFloatFieldUpdateOperationsInput | number | null
    dockOrientationY?: NullableFloatFieldUpdateOperationsInput | number | null
    dockOrientationZ?: NullableFloatFieldUpdateOperationsInput | number | null
    operationID?: NullableIntFieldUpdateOperationsInput | number | null
    officeSlots?: NullableIntFieldUpdateOperationsInput | number | null
    reprocessingEfficiency?: NullableFloatFieldUpdateOperationsInput | number | null
    conquerable?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type staStationsCreateInput = {
    stationID: bigint | number
    security?: number | null
    dockingCostPerVolume?: number | null
    maxShipVolumeDockable?: number | null
    officeRentalCost?: number | null
    operationID?: number | null
    stationTypeID?: number | null
    corporationID?: number | null
    solarSystemID?: number | null
    constellationID?: number | null
    regionID?: number | null
    stationName?: string | null
    x?: number | null
    y?: number | null
    z?: number | null
    reprocessingEfficiency?: number | null
    reprocessingStationsTake?: number | null
    reprocessingHangarFlag?: number | null
  }

  export type staStationsUncheckedCreateInput = {
    stationID: bigint | number
    security?: number | null
    dockingCostPerVolume?: number | null
    maxShipVolumeDockable?: number | null
    officeRentalCost?: number | null
    operationID?: number | null
    stationTypeID?: number | null
    corporationID?: number | null
    solarSystemID?: number | null
    constellationID?: number | null
    regionID?: number | null
    stationName?: string | null
    x?: number | null
    y?: number | null
    z?: number | null
    reprocessingEfficiency?: number | null
    reprocessingStationsTake?: number | null
    reprocessingHangarFlag?: number | null
  }

  export type staStationsUpdateInput = {
    stationID?: BigIntFieldUpdateOperationsInput | bigint | number
    security?: NullableFloatFieldUpdateOperationsInput | number | null
    dockingCostPerVolume?: NullableFloatFieldUpdateOperationsInput | number | null
    maxShipVolumeDockable?: NullableFloatFieldUpdateOperationsInput | number | null
    officeRentalCost?: NullableIntFieldUpdateOperationsInput | number | null
    operationID?: NullableIntFieldUpdateOperationsInput | number | null
    stationTypeID?: NullableIntFieldUpdateOperationsInput | number | null
    corporationID?: NullableIntFieldUpdateOperationsInput | number | null
    solarSystemID?: NullableIntFieldUpdateOperationsInput | number | null
    constellationID?: NullableIntFieldUpdateOperationsInput | number | null
    regionID?: NullableIntFieldUpdateOperationsInput | number | null
    stationName?: NullableStringFieldUpdateOperationsInput | string | null
    x?: NullableFloatFieldUpdateOperationsInput | number | null
    y?: NullableFloatFieldUpdateOperationsInput | number | null
    z?: NullableFloatFieldUpdateOperationsInput | number | null
    reprocessingEfficiency?: NullableFloatFieldUpdateOperationsInput | number | null
    reprocessingStationsTake?: NullableFloatFieldUpdateOperationsInput | number | null
    reprocessingHangarFlag?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type staStationsUncheckedUpdateInput = {
    stationID?: BigIntFieldUpdateOperationsInput | bigint | number
    security?: NullableFloatFieldUpdateOperationsInput | number | null
    dockingCostPerVolume?: NullableFloatFieldUpdateOperationsInput | number | null
    maxShipVolumeDockable?: NullableFloatFieldUpdateOperationsInput | number | null
    officeRentalCost?: NullableIntFieldUpdateOperationsInput | number | null
    operationID?: NullableIntFieldUpdateOperationsInput | number | null
    stationTypeID?: NullableIntFieldUpdateOperationsInput | number | null
    corporationID?: NullableIntFieldUpdateOperationsInput | number | null
    solarSystemID?: NullableIntFieldUpdateOperationsInput | number | null
    constellationID?: NullableIntFieldUpdateOperationsInput | number | null
    regionID?: NullableIntFieldUpdateOperationsInput | number | null
    stationName?: NullableStringFieldUpdateOperationsInput | string | null
    x?: NullableFloatFieldUpdateOperationsInput | number | null
    y?: NullableFloatFieldUpdateOperationsInput | number | null
    z?: NullableFloatFieldUpdateOperationsInput | number | null
    reprocessingEfficiency?: NullableFloatFieldUpdateOperationsInput | number | null
    reprocessingStationsTake?: NullableFloatFieldUpdateOperationsInput | number | null
    reprocessingHangarFlag?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type staStationsCreateManyInput = {
    stationID: bigint | number
    security?: number | null
    dockingCostPerVolume?: number | null
    maxShipVolumeDockable?: number | null
    officeRentalCost?: number | null
    operationID?: number | null
    stationTypeID?: number | null
    corporationID?: number | null
    solarSystemID?: number | null
    constellationID?: number | null
    regionID?: number | null
    stationName?: string | null
    x?: number | null
    y?: number | null
    z?: number | null
    reprocessingEfficiency?: number | null
    reprocessingStationsTake?: number | null
    reprocessingHangarFlag?: number | null
  }

  export type staStationsUpdateManyMutationInput = {
    stationID?: BigIntFieldUpdateOperationsInput | bigint | number
    security?: NullableFloatFieldUpdateOperationsInput | number | null
    dockingCostPerVolume?: NullableFloatFieldUpdateOperationsInput | number | null
    maxShipVolumeDockable?: NullableFloatFieldUpdateOperationsInput | number | null
    officeRentalCost?: NullableIntFieldUpdateOperationsInput | number | null
    operationID?: NullableIntFieldUpdateOperationsInput | number | null
    stationTypeID?: NullableIntFieldUpdateOperationsInput | number | null
    corporationID?: NullableIntFieldUpdateOperationsInput | number | null
    solarSystemID?: NullableIntFieldUpdateOperationsInput | number | null
    constellationID?: NullableIntFieldUpdateOperationsInput | number | null
    regionID?: NullableIntFieldUpdateOperationsInput | number | null
    stationName?: NullableStringFieldUpdateOperationsInput | string | null
    x?: NullableFloatFieldUpdateOperationsInput | number | null
    y?: NullableFloatFieldUpdateOperationsInput | number | null
    z?: NullableFloatFieldUpdateOperationsInput | number | null
    reprocessingEfficiency?: NullableFloatFieldUpdateOperationsInput | number | null
    reprocessingStationsTake?: NullableFloatFieldUpdateOperationsInput | number | null
    reprocessingHangarFlag?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type staStationsUncheckedUpdateManyInput = {
    stationID?: BigIntFieldUpdateOperationsInput | bigint | number
    security?: NullableFloatFieldUpdateOperationsInput | number | null
    dockingCostPerVolume?: NullableFloatFieldUpdateOperationsInput | number | null
    maxShipVolumeDockable?: NullableFloatFieldUpdateOperationsInput | number | null
    officeRentalCost?: NullableIntFieldUpdateOperationsInput | number | null
    operationID?: NullableIntFieldUpdateOperationsInput | number | null
    stationTypeID?: NullableIntFieldUpdateOperationsInput | number | null
    corporationID?: NullableIntFieldUpdateOperationsInput | number | null
    solarSystemID?: NullableIntFieldUpdateOperationsInput | number | null
    constellationID?: NullableIntFieldUpdateOperationsInput | number | null
    regionID?: NullableIntFieldUpdateOperationsInput | number | null
    stationName?: NullableStringFieldUpdateOperationsInput | string | null
    x?: NullableFloatFieldUpdateOperationsInput | number | null
    y?: NullableFloatFieldUpdateOperationsInput | number | null
    z?: NullableFloatFieldUpdateOperationsInput | number | null
    reprocessingEfficiency?: NullableFloatFieldUpdateOperationsInput | number | null
    reprocessingStationsTake?: NullableFloatFieldUpdateOperationsInput | number | null
    reprocessingHangarFlag?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type translationTablesCreateInput = {
    sourceTable: string
    destinationTable?: string | null
    translatedKey: string
    tcGroupID?: number | null
    tcID?: number | null
  }

  export type translationTablesUncheckedCreateInput = {
    sourceTable: string
    destinationTable?: string | null
    translatedKey: string
    tcGroupID?: number | null
    tcID?: number | null
  }

  export type translationTablesUpdateInput = {
    sourceTable?: StringFieldUpdateOperationsInput | string
    destinationTable?: NullableStringFieldUpdateOperationsInput | string | null
    translatedKey?: StringFieldUpdateOperationsInput | string
    tcGroupID?: NullableIntFieldUpdateOperationsInput | number | null
    tcID?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type translationTablesUncheckedUpdateInput = {
    sourceTable?: StringFieldUpdateOperationsInput | string
    destinationTable?: NullableStringFieldUpdateOperationsInput | string | null
    translatedKey?: StringFieldUpdateOperationsInput | string
    tcGroupID?: NullableIntFieldUpdateOperationsInput | number | null
    tcID?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type translationTablesCreateManyInput = {
    sourceTable: string
    destinationTable?: string | null
    translatedKey: string
    tcGroupID?: number | null
    tcID?: number | null
  }

  export type translationTablesUpdateManyMutationInput = {
    sourceTable?: StringFieldUpdateOperationsInput | string
    destinationTable?: NullableStringFieldUpdateOperationsInput | string | null
    translatedKey?: StringFieldUpdateOperationsInput | string
    tcGroupID?: NullableIntFieldUpdateOperationsInput | number | null
    tcID?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type translationTablesUncheckedUpdateManyInput = {
    sourceTable?: StringFieldUpdateOperationsInput | string
    destinationTable?: NullableStringFieldUpdateOperationsInput | string | null
    translatedKey?: StringFieldUpdateOperationsInput | string
    tcGroupID?: NullableIntFieldUpdateOperationsInput | number | null
    tcID?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type trnTranslationColumnsCreateInput = {
    tcGroupID?: number | null
    tcID: number
    tableName: string
    columnName: string
    masterID?: string | null
  }

  export type trnTranslationColumnsUncheckedCreateInput = {
    tcGroupID?: number | null
    tcID: number
    tableName: string
    columnName: string
    masterID?: string | null
  }

  export type trnTranslationColumnsUpdateInput = {
    tcGroupID?: NullableIntFieldUpdateOperationsInput | number | null
    tcID?: IntFieldUpdateOperationsInput | number
    tableName?: StringFieldUpdateOperationsInput | string
    columnName?: StringFieldUpdateOperationsInput | string
    masterID?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type trnTranslationColumnsUncheckedUpdateInput = {
    tcGroupID?: NullableIntFieldUpdateOperationsInput | number | null
    tcID?: IntFieldUpdateOperationsInput | number
    tableName?: StringFieldUpdateOperationsInput | string
    columnName?: StringFieldUpdateOperationsInput | string
    masterID?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type trnTranslationColumnsCreateManyInput = {
    tcGroupID?: number | null
    tcID: number
    tableName: string
    columnName: string
    masterID?: string | null
  }

  export type trnTranslationColumnsUpdateManyMutationInput = {
    tcGroupID?: NullableIntFieldUpdateOperationsInput | number | null
    tcID?: IntFieldUpdateOperationsInput | number
    tableName?: StringFieldUpdateOperationsInput | string
    columnName?: StringFieldUpdateOperationsInput | string
    masterID?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type trnTranslationColumnsUncheckedUpdateManyInput = {
    tcGroupID?: NullableIntFieldUpdateOperationsInput | number | null
    tcID?: IntFieldUpdateOperationsInput | number
    tableName?: StringFieldUpdateOperationsInput | string
    columnName?: StringFieldUpdateOperationsInput | string
    masterID?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type trnTranslationLanguagesCreateInput = {
    numericLanguageID: number
    languageID?: string | null
    languageName?: string | null
  }

  export type trnTranslationLanguagesUncheckedCreateInput = {
    numericLanguageID: number
    languageID?: string | null
    languageName?: string | null
  }

  export type trnTranslationLanguagesUpdateInput = {
    numericLanguageID?: IntFieldUpdateOperationsInput | number
    languageID?: NullableStringFieldUpdateOperationsInput | string | null
    languageName?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type trnTranslationLanguagesUncheckedUpdateInput = {
    numericLanguageID?: IntFieldUpdateOperationsInput | number
    languageID?: NullableStringFieldUpdateOperationsInput | string | null
    languageName?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type trnTranslationLanguagesCreateManyInput = {
    numericLanguageID: number
    languageID?: string | null
    languageName?: string | null
  }

  export type trnTranslationLanguagesUpdateManyMutationInput = {
    numericLanguageID?: IntFieldUpdateOperationsInput | number
    languageID?: NullableStringFieldUpdateOperationsInput | string | null
    languageName?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type trnTranslationLanguagesUncheckedUpdateManyInput = {
    numericLanguageID?: IntFieldUpdateOperationsInput | number
    languageID?: NullableStringFieldUpdateOperationsInput | string | null
    languageName?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type trnTranslationsCreateInput = {
    tcID: number
    keyID: number
    languageID: string
    text: string
  }

  export type trnTranslationsUncheckedCreateInput = {
    tcID: number
    keyID: number
    languageID: string
    text: string
  }

  export type trnTranslationsUpdateInput = {
    tcID?: IntFieldUpdateOperationsInput | number
    keyID?: IntFieldUpdateOperationsInput | number
    languageID?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
  }

  export type trnTranslationsUncheckedUpdateInput = {
    tcID?: IntFieldUpdateOperationsInput | number
    keyID?: IntFieldUpdateOperationsInput | number
    languageID?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
  }

  export type trnTranslationsCreateManyInput = {
    tcID: number
    keyID: number
    languageID: string
    text: string
  }

  export type trnTranslationsUpdateManyMutationInput = {
    tcID?: IntFieldUpdateOperationsInput | number
    keyID?: IntFieldUpdateOperationsInput | number
    languageID?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
  }

  export type trnTranslationsUncheckedUpdateManyInput = {
    tcID?: IntFieldUpdateOperationsInput | number
    keyID?: IntFieldUpdateOperationsInput | number
    languageID?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
  }

  export type warCombatZoneSystemsCreateInput = {
    solarSystemID: number
    combatZoneID?: number | null
  }

  export type warCombatZoneSystemsUncheckedCreateInput = {
    solarSystemID: number
    combatZoneID?: number | null
  }

  export type warCombatZoneSystemsUpdateInput = {
    solarSystemID?: IntFieldUpdateOperationsInput | number
    combatZoneID?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type warCombatZoneSystemsUncheckedUpdateInput = {
    solarSystemID?: IntFieldUpdateOperationsInput | number
    combatZoneID?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type warCombatZoneSystemsCreateManyInput = {
    solarSystemID: number
    combatZoneID?: number | null
  }

  export type warCombatZoneSystemsUpdateManyMutationInput = {
    solarSystemID?: IntFieldUpdateOperationsInput | number
    combatZoneID?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type warCombatZoneSystemsUncheckedUpdateManyInput = {
    solarSystemID?: IntFieldUpdateOperationsInput | number
    combatZoneID?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type warCombatZonesCreateInput = {
    combatZoneID: number
    combatZoneName?: string | null
    factionID?: number | null
    centerSystemID?: number | null
    description?: string | null
  }

  export type warCombatZonesUncheckedCreateInput = {
    combatZoneID: number
    combatZoneName?: string | null
    factionID?: number | null
    centerSystemID?: number | null
    description?: string | null
  }

  export type warCombatZonesUpdateInput = {
    combatZoneID?: IntFieldUpdateOperationsInput | number
    combatZoneName?: NullableStringFieldUpdateOperationsInput | string | null
    factionID?: NullableIntFieldUpdateOperationsInput | number | null
    centerSystemID?: NullableIntFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type warCombatZonesUncheckedUpdateInput = {
    combatZoneID?: IntFieldUpdateOperationsInput | number
    combatZoneName?: NullableStringFieldUpdateOperationsInput | string | null
    factionID?: NullableIntFieldUpdateOperationsInput | number | null
    centerSystemID?: NullableIntFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type warCombatZonesCreateManyInput = {
    combatZoneID: number
    combatZoneName?: string | null
    factionID?: number | null
    centerSystemID?: number | null
    description?: string | null
  }

  export type warCombatZonesUpdateManyMutationInput = {
    combatZoneID?: IntFieldUpdateOperationsInput | number
    combatZoneName?: NullableStringFieldUpdateOperationsInput | string | null
    factionID?: NullableIntFieldUpdateOperationsInput | number | null
    centerSystemID?: NullableIntFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type warCombatZonesUncheckedUpdateManyInput = {
    combatZoneID?: IntFieldUpdateOperationsInput | number
    combatZoneName?: NullableStringFieldUpdateOperationsInput | string | null
    factionID?: NullableIntFieldUpdateOperationsInput | number | null
    centerSystemID?: NullableIntFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type agtAgentTypesCountOrderByAggregateInput = {
    agentTypeID?: SortOrder
    agentType?: SortOrder
  }

  export type agtAgentTypesAvgOrderByAggregateInput = {
    agentTypeID?: SortOrder
  }

  export type agtAgentTypesMaxOrderByAggregateInput = {
    agentTypeID?: SortOrder
    agentType?: SortOrder
  }

  export type agtAgentTypesMinOrderByAggregateInput = {
    agentTypeID?: SortOrder
    agentType?: SortOrder
  }

  export type agtAgentTypesSumOrderByAggregateInput = {
    agentTypeID?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type BoolNullableFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableFilter<$PrismaModel> | boolean | null
  }

  export type agtAgentsCountOrderByAggregateInput = {
    agentID?: SortOrder
    divisionID?: SortOrder
    corporationID?: SortOrder
    locationID?: SortOrder
    level?: SortOrder
    quality?: SortOrder
    agentTypeID?: SortOrder
    isLocator?: SortOrder
  }

  export type agtAgentsAvgOrderByAggregateInput = {
    agentID?: SortOrder
    divisionID?: SortOrder
    corporationID?: SortOrder
    locationID?: SortOrder
    level?: SortOrder
    quality?: SortOrder
    agentTypeID?: SortOrder
  }

  export type agtAgentsMaxOrderByAggregateInput = {
    agentID?: SortOrder
    divisionID?: SortOrder
    corporationID?: SortOrder
    locationID?: SortOrder
    level?: SortOrder
    quality?: SortOrder
    agentTypeID?: SortOrder
    isLocator?: SortOrder
  }

  export type agtAgentsMinOrderByAggregateInput = {
    agentID?: SortOrder
    divisionID?: SortOrder
    corporationID?: SortOrder
    locationID?: SortOrder
    level?: SortOrder
    quality?: SortOrder
    agentTypeID?: SortOrder
    isLocator?: SortOrder
  }

  export type agtAgentsSumOrderByAggregateInput = {
    agentID?: SortOrder
    divisionID?: SortOrder
    corporationID?: SortOrder
    locationID?: SortOrder
    level?: SortOrder
    quality?: SortOrder
    agentTypeID?: SortOrder
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type BoolNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableWithAggregatesFilter<$PrismaModel> | boolean | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBoolNullableFilter<$PrismaModel>
    _max?: NestedBoolNullableFilter<$PrismaModel>
  }

  export type agtAgentsInSpaceCountOrderByAggregateInput = {
    agentID?: SortOrder
    dungeonID?: SortOrder
    solarSystemID?: SortOrder
    spawnPointID?: SortOrder
    typeID?: SortOrder
  }

  export type agtAgentsInSpaceAvgOrderByAggregateInput = {
    agentID?: SortOrder
    dungeonID?: SortOrder
    solarSystemID?: SortOrder
    spawnPointID?: SortOrder
    typeID?: SortOrder
  }

  export type agtAgentsInSpaceMaxOrderByAggregateInput = {
    agentID?: SortOrder
    dungeonID?: SortOrder
    solarSystemID?: SortOrder
    spawnPointID?: SortOrder
    typeID?: SortOrder
  }

  export type agtAgentsInSpaceMinOrderByAggregateInput = {
    agentID?: SortOrder
    dungeonID?: SortOrder
    solarSystemID?: SortOrder
    spawnPointID?: SortOrder
    typeID?: SortOrder
  }

  export type agtAgentsInSpaceSumOrderByAggregateInput = {
    agentID?: SortOrder
    dungeonID?: SortOrder
    solarSystemID?: SortOrder
    spawnPointID?: SortOrder
    typeID?: SortOrder
  }

  export type agtResearchAgentsAgentIDTypeIDCompoundUniqueInput = {
    agentID: number
    typeID: number
  }

  export type agtResearchAgentsCountOrderByAggregateInput = {
    agentID?: SortOrder
    typeID?: SortOrder
  }

  export type agtResearchAgentsAvgOrderByAggregateInput = {
    agentID?: SortOrder
    typeID?: SortOrder
  }

  export type agtResearchAgentsMaxOrderByAggregateInput = {
    agentID?: SortOrder
    typeID?: SortOrder
  }

  export type agtResearchAgentsMinOrderByAggregateInput = {
    agentID?: SortOrder
    typeID?: SortOrder
  }

  export type agtResearchAgentsSumOrderByAggregateInput = {
    agentID?: SortOrder
    typeID?: SortOrder
  }

  export type certCertsCountOrderByAggregateInput = {
    certID?: SortOrder
    description?: SortOrder
    groupID?: SortOrder
    name?: SortOrder
  }

  export type certCertsAvgOrderByAggregateInput = {
    certID?: SortOrder
    groupID?: SortOrder
  }

  export type certCertsMaxOrderByAggregateInput = {
    certID?: SortOrder
    description?: SortOrder
    groupID?: SortOrder
    name?: SortOrder
  }

  export type certCertsMinOrderByAggregateInput = {
    certID?: SortOrder
    description?: SortOrder
    groupID?: SortOrder
    name?: SortOrder
  }

  export type certCertsSumOrderByAggregateInput = {
    certID?: SortOrder
    groupID?: SortOrder
  }

  export type chrAncestriesCountOrderByAggregateInput = {
    ancestryID?: SortOrder
    ancestryName?: SortOrder
    bloodlineID?: SortOrder
    description?: SortOrder
    perception?: SortOrder
    willpower?: SortOrder
    charisma?: SortOrder
    memory?: SortOrder
    intelligence?: SortOrder
    iconID?: SortOrder
    shortDescription?: SortOrder
  }

  export type chrAncestriesAvgOrderByAggregateInput = {
    ancestryID?: SortOrder
    bloodlineID?: SortOrder
    perception?: SortOrder
    willpower?: SortOrder
    charisma?: SortOrder
    memory?: SortOrder
    intelligence?: SortOrder
    iconID?: SortOrder
  }

  export type chrAncestriesMaxOrderByAggregateInput = {
    ancestryID?: SortOrder
    ancestryName?: SortOrder
    bloodlineID?: SortOrder
    description?: SortOrder
    perception?: SortOrder
    willpower?: SortOrder
    charisma?: SortOrder
    memory?: SortOrder
    intelligence?: SortOrder
    iconID?: SortOrder
    shortDescription?: SortOrder
  }

  export type chrAncestriesMinOrderByAggregateInput = {
    ancestryID?: SortOrder
    ancestryName?: SortOrder
    bloodlineID?: SortOrder
    description?: SortOrder
    perception?: SortOrder
    willpower?: SortOrder
    charisma?: SortOrder
    memory?: SortOrder
    intelligence?: SortOrder
    iconID?: SortOrder
    shortDescription?: SortOrder
  }

  export type chrAncestriesSumOrderByAggregateInput = {
    ancestryID?: SortOrder
    bloodlineID?: SortOrder
    perception?: SortOrder
    willpower?: SortOrder
    charisma?: SortOrder
    memory?: SortOrder
    intelligence?: SortOrder
    iconID?: SortOrder
  }

  export type chrAttributesCountOrderByAggregateInput = {
    attributeID?: SortOrder
    attributeName?: SortOrder
    description?: SortOrder
    iconID?: SortOrder
    shortDescription?: SortOrder
    notes?: SortOrder
  }

  export type chrAttributesAvgOrderByAggregateInput = {
    attributeID?: SortOrder
    iconID?: SortOrder
  }

  export type chrAttributesMaxOrderByAggregateInput = {
    attributeID?: SortOrder
    attributeName?: SortOrder
    description?: SortOrder
    iconID?: SortOrder
    shortDescription?: SortOrder
    notes?: SortOrder
  }

  export type chrAttributesMinOrderByAggregateInput = {
    attributeID?: SortOrder
    attributeName?: SortOrder
    description?: SortOrder
    iconID?: SortOrder
    shortDescription?: SortOrder
    notes?: SortOrder
  }

  export type chrAttributesSumOrderByAggregateInput = {
    attributeID?: SortOrder
    iconID?: SortOrder
  }

  export type chrBloodlinesCountOrderByAggregateInput = {
    bloodlineID?: SortOrder
    bloodlineName?: SortOrder
    raceID?: SortOrder
    description?: SortOrder
    maleDescription?: SortOrder
    femaleDescription?: SortOrder
    shipTypeID?: SortOrder
    corporationID?: SortOrder
    perception?: SortOrder
    willpower?: SortOrder
    charisma?: SortOrder
    memory?: SortOrder
    intelligence?: SortOrder
    iconID?: SortOrder
    shortDescription?: SortOrder
    shortMaleDescription?: SortOrder
    shortFemaleDescription?: SortOrder
  }

  export type chrBloodlinesAvgOrderByAggregateInput = {
    bloodlineID?: SortOrder
    raceID?: SortOrder
    shipTypeID?: SortOrder
    corporationID?: SortOrder
    perception?: SortOrder
    willpower?: SortOrder
    charisma?: SortOrder
    memory?: SortOrder
    intelligence?: SortOrder
    iconID?: SortOrder
  }

  export type chrBloodlinesMaxOrderByAggregateInput = {
    bloodlineID?: SortOrder
    bloodlineName?: SortOrder
    raceID?: SortOrder
    description?: SortOrder
    maleDescription?: SortOrder
    femaleDescription?: SortOrder
    shipTypeID?: SortOrder
    corporationID?: SortOrder
    perception?: SortOrder
    willpower?: SortOrder
    charisma?: SortOrder
    memory?: SortOrder
    intelligence?: SortOrder
    iconID?: SortOrder
    shortDescription?: SortOrder
    shortMaleDescription?: SortOrder
    shortFemaleDescription?: SortOrder
  }

  export type chrBloodlinesMinOrderByAggregateInput = {
    bloodlineID?: SortOrder
    bloodlineName?: SortOrder
    raceID?: SortOrder
    description?: SortOrder
    maleDescription?: SortOrder
    femaleDescription?: SortOrder
    shipTypeID?: SortOrder
    corporationID?: SortOrder
    perception?: SortOrder
    willpower?: SortOrder
    charisma?: SortOrder
    memory?: SortOrder
    intelligence?: SortOrder
    iconID?: SortOrder
    shortDescription?: SortOrder
    shortMaleDescription?: SortOrder
    shortFemaleDescription?: SortOrder
  }

  export type chrBloodlinesSumOrderByAggregateInput = {
    bloodlineID?: SortOrder
    raceID?: SortOrder
    shipTypeID?: SortOrder
    corporationID?: SortOrder
    perception?: SortOrder
    willpower?: SortOrder
    charisma?: SortOrder
    memory?: SortOrder
    intelligence?: SortOrder
    iconID?: SortOrder
  }

  export type FloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type chrFactionsCountOrderByAggregateInput = {
    factionID?: SortOrder
    factionName?: SortOrder
    description?: SortOrder
    raceIDs?: SortOrder
    solarSystemID?: SortOrder
    corporationID?: SortOrder
    sizeFactor?: SortOrder
    stationCount?: SortOrder
    stationSystemCount?: SortOrder
    militiaCorporationID?: SortOrder
    iconID?: SortOrder
  }

  export type chrFactionsAvgOrderByAggregateInput = {
    factionID?: SortOrder
    raceIDs?: SortOrder
    solarSystemID?: SortOrder
    corporationID?: SortOrder
    sizeFactor?: SortOrder
    stationCount?: SortOrder
    stationSystemCount?: SortOrder
    militiaCorporationID?: SortOrder
    iconID?: SortOrder
  }

  export type chrFactionsMaxOrderByAggregateInput = {
    factionID?: SortOrder
    factionName?: SortOrder
    description?: SortOrder
    raceIDs?: SortOrder
    solarSystemID?: SortOrder
    corporationID?: SortOrder
    sizeFactor?: SortOrder
    stationCount?: SortOrder
    stationSystemCount?: SortOrder
    militiaCorporationID?: SortOrder
    iconID?: SortOrder
  }

  export type chrFactionsMinOrderByAggregateInput = {
    factionID?: SortOrder
    factionName?: SortOrder
    description?: SortOrder
    raceIDs?: SortOrder
    solarSystemID?: SortOrder
    corporationID?: SortOrder
    sizeFactor?: SortOrder
    stationCount?: SortOrder
    stationSystemCount?: SortOrder
    militiaCorporationID?: SortOrder
    iconID?: SortOrder
  }

  export type chrFactionsSumOrderByAggregateInput = {
    factionID?: SortOrder
    raceIDs?: SortOrder
    solarSystemID?: SortOrder
    corporationID?: SortOrder
    sizeFactor?: SortOrder
    stationCount?: SortOrder
    stationSystemCount?: SortOrder
    militiaCorporationID?: SortOrder
    iconID?: SortOrder
  }

  export type FloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type chrRacesCountOrderByAggregateInput = {
    raceID?: SortOrder
    raceName?: SortOrder
    description?: SortOrder
    iconID?: SortOrder
    shortDescription?: SortOrder
  }

  export type chrRacesAvgOrderByAggregateInput = {
    raceID?: SortOrder
    iconID?: SortOrder
  }

  export type chrRacesMaxOrderByAggregateInput = {
    raceID?: SortOrder
    raceName?: SortOrder
    description?: SortOrder
    iconID?: SortOrder
    shortDescription?: SortOrder
  }

  export type chrRacesMinOrderByAggregateInput = {
    raceID?: SortOrder
    raceName?: SortOrder
    description?: SortOrder
    iconID?: SortOrder
    shortDescription?: SortOrder
  }

  export type chrRacesSumOrderByAggregateInput = {
    raceID?: SortOrder
    iconID?: SortOrder
  }

  export type crpActivitiesCountOrderByAggregateInput = {
    activityID?: SortOrder
    activityName?: SortOrder
    description?: SortOrder
  }

  export type crpActivitiesAvgOrderByAggregateInput = {
    activityID?: SortOrder
  }

  export type crpActivitiesMaxOrderByAggregateInput = {
    activityID?: SortOrder
    activityName?: SortOrder
    description?: SortOrder
  }

  export type crpActivitiesMinOrderByAggregateInput = {
    activityID?: SortOrder
    activityName?: SortOrder
    description?: SortOrder
  }

  export type crpActivitiesSumOrderByAggregateInput = {
    activityID?: SortOrder
  }

  export type crpNPCCorporationDivisionsCorporationIDDivisionIDCompoundUniqueInput = {
    corporationID: number
    divisionID: number
  }

  export type crpNPCCorporationDivisionsCountOrderByAggregateInput = {
    corporationID?: SortOrder
    divisionID?: SortOrder
    size?: SortOrder
  }

  export type crpNPCCorporationDivisionsAvgOrderByAggregateInput = {
    corporationID?: SortOrder
    divisionID?: SortOrder
    size?: SortOrder
  }

  export type crpNPCCorporationDivisionsMaxOrderByAggregateInput = {
    corporationID?: SortOrder
    divisionID?: SortOrder
    size?: SortOrder
  }

  export type crpNPCCorporationDivisionsMinOrderByAggregateInput = {
    corporationID?: SortOrder
    divisionID?: SortOrder
    size?: SortOrder
  }

  export type crpNPCCorporationDivisionsSumOrderByAggregateInput = {
    corporationID?: SortOrder
    divisionID?: SortOrder
    size?: SortOrder
  }

  export type crpNPCCorporationResearchFieldsSkillIDCorporationIDCompoundUniqueInput = {
    skillID: number
    corporationID: number
  }

  export type crpNPCCorporationResearchFieldsCountOrderByAggregateInput = {
    skillID?: SortOrder
    corporationID?: SortOrder
  }

  export type crpNPCCorporationResearchFieldsAvgOrderByAggregateInput = {
    skillID?: SortOrder
    corporationID?: SortOrder
  }

  export type crpNPCCorporationResearchFieldsMaxOrderByAggregateInput = {
    skillID?: SortOrder
    corporationID?: SortOrder
  }

  export type crpNPCCorporationResearchFieldsMinOrderByAggregateInput = {
    skillID?: SortOrder
    corporationID?: SortOrder
  }

  export type crpNPCCorporationResearchFieldsSumOrderByAggregateInput = {
    skillID?: SortOrder
    corporationID?: SortOrder
  }

  export type crpNPCCorporationTradesCorporationIDTypeIDCompoundUniqueInput = {
    corporationID: number
    typeID: number
  }

  export type crpNPCCorporationTradesCountOrderByAggregateInput = {
    corporationID?: SortOrder
    typeID?: SortOrder
  }

  export type crpNPCCorporationTradesAvgOrderByAggregateInput = {
    corporationID?: SortOrder
    typeID?: SortOrder
  }

  export type crpNPCCorporationTradesMaxOrderByAggregateInput = {
    corporationID?: SortOrder
    typeID?: SortOrder
  }

  export type crpNPCCorporationTradesMinOrderByAggregateInput = {
    corporationID?: SortOrder
    typeID?: SortOrder
  }

  export type crpNPCCorporationTradesSumOrderByAggregateInput = {
    corporationID?: SortOrder
    typeID?: SortOrder
  }

  export type crpNPCCorporationsCountOrderByAggregateInput = {
    corporationID?: SortOrder
    size?: SortOrder
    extent?: SortOrder
    solarSystemID?: SortOrder
    investorID1?: SortOrder
    investorShares1?: SortOrder
    investorID2?: SortOrder
    investorShares2?: SortOrder
    investorID3?: SortOrder
    investorShares3?: SortOrder
    investorID4?: SortOrder
    investorShares4?: SortOrder
    friendID?: SortOrder
    enemyID?: SortOrder
    publicShares?: SortOrder
    initialPrice?: SortOrder
    minSecurity?: SortOrder
    scattered?: SortOrder
    fringe?: SortOrder
    corridor?: SortOrder
    hub?: SortOrder
    border?: SortOrder
    factionID?: SortOrder
    sizeFactor?: SortOrder
    stationCount?: SortOrder
    stationSystemCount?: SortOrder
    description?: SortOrder
    iconID?: SortOrder
  }

  export type crpNPCCorporationsAvgOrderByAggregateInput = {
    corporationID?: SortOrder
    solarSystemID?: SortOrder
    investorID1?: SortOrder
    investorShares1?: SortOrder
    investorID2?: SortOrder
    investorShares2?: SortOrder
    investorID3?: SortOrder
    investorShares3?: SortOrder
    investorID4?: SortOrder
    investorShares4?: SortOrder
    friendID?: SortOrder
    enemyID?: SortOrder
    publicShares?: SortOrder
    initialPrice?: SortOrder
    minSecurity?: SortOrder
    fringe?: SortOrder
    corridor?: SortOrder
    hub?: SortOrder
    border?: SortOrder
    factionID?: SortOrder
    sizeFactor?: SortOrder
    stationCount?: SortOrder
    stationSystemCount?: SortOrder
    iconID?: SortOrder
  }

  export type crpNPCCorporationsMaxOrderByAggregateInput = {
    corporationID?: SortOrder
    size?: SortOrder
    extent?: SortOrder
    solarSystemID?: SortOrder
    investorID1?: SortOrder
    investorShares1?: SortOrder
    investorID2?: SortOrder
    investorShares2?: SortOrder
    investorID3?: SortOrder
    investorShares3?: SortOrder
    investorID4?: SortOrder
    investorShares4?: SortOrder
    friendID?: SortOrder
    enemyID?: SortOrder
    publicShares?: SortOrder
    initialPrice?: SortOrder
    minSecurity?: SortOrder
    scattered?: SortOrder
    fringe?: SortOrder
    corridor?: SortOrder
    hub?: SortOrder
    border?: SortOrder
    factionID?: SortOrder
    sizeFactor?: SortOrder
    stationCount?: SortOrder
    stationSystemCount?: SortOrder
    description?: SortOrder
    iconID?: SortOrder
  }

  export type crpNPCCorporationsMinOrderByAggregateInput = {
    corporationID?: SortOrder
    size?: SortOrder
    extent?: SortOrder
    solarSystemID?: SortOrder
    investorID1?: SortOrder
    investorShares1?: SortOrder
    investorID2?: SortOrder
    investorShares2?: SortOrder
    investorID3?: SortOrder
    investorShares3?: SortOrder
    investorID4?: SortOrder
    investorShares4?: SortOrder
    friendID?: SortOrder
    enemyID?: SortOrder
    publicShares?: SortOrder
    initialPrice?: SortOrder
    minSecurity?: SortOrder
    scattered?: SortOrder
    fringe?: SortOrder
    corridor?: SortOrder
    hub?: SortOrder
    border?: SortOrder
    factionID?: SortOrder
    sizeFactor?: SortOrder
    stationCount?: SortOrder
    stationSystemCount?: SortOrder
    description?: SortOrder
    iconID?: SortOrder
  }

  export type crpNPCCorporationsSumOrderByAggregateInput = {
    corporationID?: SortOrder
    solarSystemID?: SortOrder
    investorID1?: SortOrder
    investorShares1?: SortOrder
    investorID2?: SortOrder
    investorShares2?: SortOrder
    investorID3?: SortOrder
    investorShares3?: SortOrder
    investorID4?: SortOrder
    investorShares4?: SortOrder
    friendID?: SortOrder
    enemyID?: SortOrder
    publicShares?: SortOrder
    initialPrice?: SortOrder
    minSecurity?: SortOrder
    fringe?: SortOrder
    corridor?: SortOrder
    hub?: SortOrder
    border?: SortOrder
    factionID?: SortOrder
    sizeFactor?: SortOrder
    stationCount?: SortOrder
    stationSystemCount?: SortOrder
    iconID?: SortOrder
  }

  export type crpNPCDivisionsCountOrderByAggregateInput = {
    divisionID?: SortOrder
    divisionName?: SortOrder
    description?: SortOrder
    leaderType?: SortOrder
  }

  export type crpNPCDivisionsAvgOrderByAggregateInput = {
    divisionID?: SortOrder
  }

  export type crpNPCDivisionsMaxOrderByAggregateInput = {
    divisionID?: SortOrder
    divisionName?: SortOrder
    description?: SortOrder
    leaderType?: SortOrder
  }

  export type crpNPCDivisionsMinOrderByAggregateInput = {
    divisionID?: SortOrder
    divisionName?: SortOrder
    description?: SortOrder
    leaderType?: SortOrder
  }

  export type crpNPCDivisionsSumOrderByAggregateInput = {
    divisionID?: SortOrder
  }

  export type dgmAttributeCategoriesCountOrderByAggregateInput = {
    categoryID?: SortOrder
    categoryName?: SortOrder
    categoryDescription?: SortOrder
  }

  export type dgmAttributeCategoriesAvgOrderByAggregateInput = {
    categoryID?: SortOrder
  }

  export type dgmAttributeCategoriesMaxOrderByAggregateInput = {
    categoryID?: SortOrder
    categoryName?: SortOrder
    categoryDescription?: SortOrder
  }

  export type dgmAttributeCategoriesMinOrderByAggregateInput = {
    categoryID?: SortOrder
    categoryName?: SortOrder
    categoryDescription?: SortOrder
  }

  export type dgmAttributeCategoriesSumOrderByAggregateInput = {
    categoryID?: SortOrder
  }

  export type dgmAttributeTypesCountOrderByAggregateInput = {
    attributeID?: SortOrder
    attributeName?: SortOrder
    description?: SortOrder
    iconID?: SortOrder
    defaultValue?: SortOrder
    published?: SortOrder
    displayName?: SortOrder
    unitID?: SortOrder
    stackable?: SortOrder
    highIsGood?: SortOrder
    categoryID?: SortOrder
  }

  export type dgmAttributeTypesAvgOrderByAggregateInput = {
    attributeID?: SortOrder
    iconID?: SortOrder
    defaultValue?: SortOrder
    unitID?: SortOrder
    categoryID?: SortOrder
  }

  export type dgmAttributeTypesMaxOrderByAggregateInput = {
    attributeID?: SortOrder
    attributeName?: SortOrder
    description?: SortOrder
    iconID?: SortOrder
    defaultValue?: SortOrder
    published?: SortOrder
    displayName?: SortOrder
    unitID?: SortOrder
    stackable?: SortOrder
    highIsGood?: SortOrder
    categoryID?: SortOrder
  }

  export type dgmAttributeTypesMinOrderByAggregateInput = {
    attributeID?: SortOrder
    attributeName?: SortOrder
    description?: SortOrder
    iconID?: SortOrder
    defaultValue?: SortOrder
    published?: SortOrder
    displayName?: SortOrder
    unitID?: SortOrder
    stackable?: SortOrder
    highIsGood?: SortOrder
    categoryID?: SortOrder
  }

  export type dgmAttributeTypesSumOrderByAggregateInput = {
    attributeID?: SortOrder
    iconID?: SortOrder
    defaultValue?: SortOrder
    unitID?: SortOrder
    categoryID?: SortOrder
  }

  export type dgmEffectsCountOrderByAggregateInput = {
    effectID?: SortOrder
    effectName?: SortOrder
    effectCategory?: SortOrder
    preExpression?: SortOrder
    postExpression?: SortOrder
    description?: SortOrder
    guid?: SortOrder
    iconID?: SortOrder
    isOffensive?: SortOrder
    isAssistance?: SortOrder
    durationAttributeID?: SortOrder
    trackingSpeedAttributeID?: SortOrder
    dischargeAttributeID?: SortOrder
    rangeAttributeID?: SortOrder
    falloffAttributeID?: SortOrder
    disallowAutoRepeat?: SortOrder
    published?: SortOrder
    displayName?: SortOrder
    isWarpSafe?: SortOrder
    rangeChance?: SortOrder
    electronicChance?: SortOrder
    propulsionChance?: SortOrder
    distribution?: SortOrder
    sfxName?: SortOrder
    npcUsageChanceAttributeID?: SortOrder
    npcActivationChanceAttributeID?: SortOrder
    fittingUsageChanceAttributeID?: SortOrder
    modifierInfo?: SortOrder
  }

  export type dgmEffectsAvgOrderByAggregateInput = {
    effectID?: SortOrder
    effectCategory?: SortOrder
    preExpression?: SortOrder
    postExpression?: SortOrder
    iconID?: SortOrder
    durationAttributeID?: SortOrder
    trackingSpeedAttributeID?: SortOrder
    dischargeAttributeID?: SortOrder
    rangeAttributeID?: SortOrder
    falloffAttributeID?: SortOrder
    distribution?: SortOrder
    npcUsageChanceAttributeID?: SortOrder
    npcActivationChanceAttributeID?: SortOrder
    fittingUsageChanceAttributeID?: SortOrder
  }

  export type dgmEffectsMaxOrderByAggregateInput = {
    effectID?: SortOrder
    effectName?: SortOrder
    effectCategory?: SortOrder
    preExpression?: SortOrder
    postExpression?: SortOrder
    description?: SortOrder
    guid?: SortOrder
    iconID?: SortOrder
    isOffensive?: SortOrder
    isAssistance?: SortOrder
    durationAttributeID?: SortOrder
    trackingSpeedAttributeID?: SortOrder
    dischargeAttributeID?: SortOrder
    rangeAttributeID?: SortOrder
    falloffAttributeID?: SortOrder
    disallowAutoRepeat?: SortOrder
    published?: SortOrder
    displayName?: SortOrder
    isWarpSafe?: SortOrder
    rangeChance?: SortOrder
    electronicChance?: SortOrder
    propulsionChance?: SortOrder
    distribution?: SortOrder
    sfxName?: SortOrder
    npcUsageChanceAttributeID?: SortOrder
    npcActivationChanceAttributeID?: SortOrder
    fittingUsageChanceAttributeID?: SortOrder
    modifierInfo?: SortOrder
  }

  export type dgmEffectsMinOrderByAggregateInput = {
    effectID?: SortOrder
    effectName?: SortOrder
    effectCategory?: SortOrder
    preExpression?: SortOrder
    postExpression?: SortOrder
    description?: SortOrder
    guid?: SortOrder
    iconID?: SortOrder
    isOffensive?: SortOrder
    isAssistance?: SortOrder
    durationAttributeID?: SortOrder
    trackingSpeedAttributeID?: SortOrder
    dischargeAttributeID?: SortOrder
    rangeAttributeID?: SortOrder
    falloffAttributeID?: SortOrder
    disallowAutoRepeat?: SortOrder
    published?: SortOrder
    displayName?: SortOrder
    isWarpSafe?: SortOrder
    rangeChance?: SortOrder
    electronicChance?: SortOrder
    propulsionChance?: SortOrder
    distribution?: SortOrder
    sfxName?: SortOrder
    npcUsageChanceAttributeID?: SortOrder
    npcActivationChanceAttributeID?: SortOrder
    fittingUsageChanceAttributeID?: SortOrder
    modifierInfo?: SortOrder
  }

  export type dgmEffectsSumOrderByAggregateInput = {
    effectID?: SortOrder
    effectCategory?: SortOrder
    preExpression?: SortOrder
    postExpression?: SortOrder
    iconID?: SortOrder
    durationAttributeID?: SortOrder
    trackingSpeedAttributeID?: SortOrder
    dischargeAttributeID?: SortOrder
    rangeAttributeID?: SortOrder
    falloffAttributeID?: SortOrder
    distribution?: SortOrder
    npcUsageChanceAttributeID?: SortOrder
    npcActivationChanceAttributeID?: SortOrder
    fittingUsageChanceAttributeID?: SortOrder
  }

  export type dgmExpressionsCountOrderByAggregateInput = {
    expressionID?: SortOrder
    operandID?: SortOrder
    arg1?: SortOrder
    arg2?: SortOrder
    expressionValue?: SortOrder
    description?: SortOrder
    expressionName?: SortOrder
    expressionTypeID?: SortOrder
    expressionGroupID?: SortOrder
    expressionAttributeID?: SortOrder
  }

  export type dgmExpressionsAvgOrderByAggregateInput = {
    expressionID?: SortOrder
    operandID?: SortOrder
    arg1?: SortOrder
    arg2?: SortOrder
    expressionTypeID?: SortOrder
    expressionGroupID?: SortOrder
    expressionAttributeID?: SortOrder
  }

  export type dgmExpressionsMaxOrderByAggregateInput = {
    expressionID?: SortOrder
    operandID?: SortOrder
    arg1?: SortOrder
    arg2?: SortOrder
    expressionValue?: SortOrder
    description?: SortOrder
    expressionName?: SortOrder
    expressionTypeID?: SortOrder
    expressionGroupID?: SortOrder
    expressionAttributeID?: SortOrder
  }

  export type dgmExpressionsMinOrderByAggregateInput = {
    expressionID?: SortOrder
    operandID?: SortOrder
    arg1?: SortOrder
    arg2?: SortOrder
    expressionValue?: SortOrder
    description?: SortOrder
    expressionName?: SortOrder
    expressionTypeID?: SortOrder
    expressionGroupID?: SortOrder
    expressionAttributeID?: SortOrder
  }

  export type dgmExpressionsSumOrderByAggregateInput = {
    expressionID?: SortOrder
    operandID?: SortOrder
    arg1?: SortOrder
    arg2?: SortOrder
    expressionTypeID?: SortOrder
    expressionGroupID?: SortOrder
    expressionAttributeID?: SortOrder
  }

  export type dgmTypeAttributesTypeIDAttributeIDCompoundUniqueInput = {
    typeID: number
    attributeID: number
  }

  export type dgmTypeAttributesCountOrderByAggregateInput = {
    typeID?: SortOrder
    attributeID?: SortOrder
    valueInt?: SortOrder
    valueFloat?: SortOrder
  }

  export type dgmTypeAttributesAvgOrderByAggregateInput = {
    typeID?: SortOrder
    attributeID?: SortOrder
    valueInt?: SortOrder
    valueFloat?: SortOrder
  }

  export type dgmTypeAttributesMaxOrderByAggregateInput = {
    typeID?: SortOrder
    attributeID?: SortOrder
    valueInt?: SortOrder
    valueFloat?: SortOrder
  }

  export type dgmTypeAttributesMinOrderByAggregateInput = {
    typeID?: SortOrder
    attributeID?: SortOrder
    valueInt?: SortOrder
    valueFloat?: SortOrder
  }

  export type dgmTypeAttributesSumOrderByAggregateInput = {
    typeID?: SortOrder
    attributeID?: SortOrder
    valueInt?: SortOrder
    valueFloat?: SortOrder
  }

  export type dgmTypeEffectsTypeIDEffectIDCompoundUniqueInput = {
    typeID: number
    effectID: number
  }

  export type dgmTypeEffectsCountOrderByAggregateInput = {
    typeID?: SortOrder
    effectID?: SortOrder
    isDefault?: SortOrder
  }

  export type dgmTypeEffectsAvgOrderByAggregateInput = {
    typeID?: SortOrder
    effectID?: SortOrder
  }

  export type dgmTypeEffectsMaxOrderByAggregateInput = {
    typeID?: SortOrder
    effectID?: SortOrder
    isDefault?: SortOrder
  }

  export type dgmTypeEffectsMinOrderByAggregateInput = {
    typeID?: SortOrder
    effectID?: SortOrder
    isDefault?: SortOrder
  }

  export type dgmTypeEffectsSumOrderByAggregateInput = {
    typeID?: SortOrder
    effectID?: SortOrder
  }

  export type eveGraphicsCountOrderByAggregateInput = {
    graphicID?: SortOrder
    sofFactionName?: SortOrder
    graphicFile?: SortOrder
    sofHullName?: SortOrder
    sofRaceName?: SortOrder
    description?: SortOrder
  }

  export type eveGraphicsAvgOrderByAggregateInput = {
    graphicID?: SortOrder
  }

  export type eveGraphicsMaxOrderByAggregateInput = {
    graphicID?: SortOrder
    sofFactionName?: SortOrder
    graphicFile?: SortOrder
    sofHullName?: SortOrder
    sofRaceName?: SortOrder
    description?: SortOrder
  }

  export type eveGraphicsMinOrderByAggregateInput = {
    graphicID?: SortOrder
    sofFactionName?: SortOrder
    graphicFile?: SortOrder
    sofHullName?: SortOrder
    sofRaceName?: SortOrder
    description?: SortOrder
  }

  export type eveGraphicsSumOrderByAggregateInput = {
    graphicID?: SortOrder
  }

  export type eveIconsCountOrderByAggregateInput = {
    iconID?: SortOrder
    iconFile?: SortOrder
    description?: SortOrder
  }

  export type eveIconsAvgOrderByAggregateInput = {
    iconID?: SortOrder
  }

  export type eveIconsMaxOrderByAggregateInput = {
    iconID?: SortOrder
    iconFile?: SortOrder
    description?: SortOrder
  }

  export type eveIconsMinOrderByAggregateInput = {
    iconID?: SortOrder
    iconFile?: SortOrder
    description?: SortOrder
  }

  export type eveIconsSumOrderByAggregateInput = {
    iconID?: SortOrder
  }

  export type eveUnitsCountOrderByAggregateInput = {
    unitID?: SortOrder
    unitName?: SortOrder
    displayName?: SortOrder
    description?: SortOrder
  }

  export type eveUnitsAvgOrderByAggregateInput = {
    unitID?: SortOrder
  }

  export type eveUnitsMaxOrderByAggregateInput = {
    unitID?: SortOrder
    unitName?: SortOrder
    displayName?: SortOrder
    description?: SortOrder
  }

  export type eveUnitsMinOrderByAggregateInput = {
    unitID?: SortOrder
    unitName?: SortOrder
    displayName?: SortOrder
    description?: SortOrder
  }

  export type eveUnitsSumOrderByAggregateInput = {
    unitID?: SortOrder
  }

  export type industryActivityTypeIDActivityIDCompoundUniqueInput = {
    typeID: number
    activityID: number
  }

  export type industryActivityCountOrderByAggregateInput = {
    typeID?: SortOrder
    activityID?: SortOrder
    time?: SortOrder
  }

  export type industryActivityAvgOrderByAggregateInput = {
    typeID?: SortOrder
    activityID?: SortOrder
    time?: SortOrder
  }

  export type industryActivityMaxOrderByAggregateInput = {
    typeID?: SortOrder
    activityID?: SortOrder
    time?: SortOrder
  }

  export type industryActivityMinOrderByAggregateInput = {
    typeID?: SortOrder
    activityID?: SortOrder
    time?: SortOrder
  }

  export type industryActivitySumOrderByAggregateInput = {
    typeID?: SortOrder
    activityID?: SortOrder
    time?: SortOrder
  }

  export type industryBlueprintsCountOrderByAggregateInput = {
    typeID?: SortOrder
    maxProductionLimit?: SortOrder
  }

  export type industryBlueprintsAvgOrderByAggregateInput = {
    typeID?: SortOrder
    maxProductionLimit?: SortOrder
  }

  export type industryBlueprintsMaxOrderByAggregateInput = {
    typeID?: SortOrder
    maxProductionLimit?: SortOrder
  }

  export type industryBlueprintsMinOrderByAggregateInput = {
    typeID?: SortOrder
    maxProductionLimit?: SortOrder
  }

  export type industryBlueprintsSumOrderByAggregateInput = {
    typeID?: SortOrder
    maxProductionLimit?: SortOrder
  }

  export type invCategoriesCountOrderByAggregateInput = {
    categoryID?: SortOrder
    categoryName?: SortOrder
    iconID?: SortOrder
    published?: SortOrder
  }

  export type invCategoriesAvgOrderByAggregateInput = {
    categoryID?: SortOrder
    iconID?: SortOrder
  }

  export type invCategoriesMaxOrderByAggregateInput = {
    categoryID?: SortOrder
    categoryName?: SortOrder
    iconID?: SortOrder
    published?: SortOrder
  }

  export type invCategoriesMinOrderByAggregateInput = {
    categoryID?: SortOrder
    categoryName?: SortOrder
    iconID?: SortOrder
    published?: SortOrder
  }

  export type invCategoriesSumOrderByAggregateInput = {
    categoryID?: SortOrder
    iconID?: SortOrder
  }

  export type invContrabandTypesFactionIDTypeIDCompoundUniqueInput = {
    factionID: number
    typeID: number
  }

  export type invContrabandTypesCountOrderByAggregateInput = {
    factionID?: SortOrder
    typeID?: SortOrder
    standingLoss?: SortOrder
    confiscateMinSec?: SortOrder
    fineByValue?: SortOrder
    attackMinSec?: SortOrder
  }

  export type invContrabandTypesAvgOrderByAggregateInput = {
    factionID?: SortOrder
    typeID?: SortOrder
    standingLoss?: SortOrder
    confiscateMinSec?: SortOrder
    fineByValue?: SortOrder
    attackMinSec?: SortOrder
  }

  export type invContrabandTypesMaxOrderByAggregateInput = {
    factionID?: SortOrder
    typeID?: SortOrder
    standingLoss?: SortOrder
    confiscateMinSec?: SortOrder
    fineByValue?: SortOrder
    attackMinSec?: SortOrder
  }

  export type invContrabandTypesMinOrderByAggregateInput = {
    factionID?: SortOrder
    typeID?: SortOrder
    standingLoss?: SortOrder
    confiscateMinSec?: SortOrder
    fineByValue?: SortOrder
    attackMinSec?: SortOrder
  }

  export type invContrabandTypesSumOrderByAggregateInput = {
    factionID?: SortOrder
    typeID?: SortOrder
    standingLoss?: SortOrder
    confiscateMinSec?: SortOrder
    fineByValue?: SortOrder
    attackMinSec?: SortOrder
  }

  export type invControlTowerResourcePurposesCountOrderByAggregateInput = {
    purpose?: SortOrder
    purposeText?: SortOrder
  }

  export type invControlTowerResourcePurposesAvgOrderByAggregateInput = {
    purpose?: SortOrder
  }

  export type invControlTowerResourcePurposesMaxOrderByAggregateInput = {
    purpose?: SortOrder
    purposeText?: SortOrder
  }

  export type invControlTowerResourcePurposesMinOrderByAggregateInput = {
    purpose?: SortOrder
    purposeText?: SortOrder
  }

  export type invControlTowerResourcePurposesSumOrderByAggregateInput = {
    purpose?: SortOrder
  }

  export type invControlTowerResourcesControlTowerTypeIDResourceTypeIDCompoundUniqueInput = {
    controlTowerTypeID: number
    resourceTypeID: number
  }

  export type invControlTowerResourcesCountOrderByAggregateInput = {
    controlTowerTypeID?: SortOrder
    resourceTypeID?: SortOrder
    purpose?: SortOrder
    quantity?: SortOrder
    minSecurityLevel?: SortOrder
    factionID?: SortOrder
  }

  export type invControlTowerResourcesAvgOrderByAggregateInput = {
    controlTowerTypeID?: SortOrder
    resourceTypeID?: SortOrder
    purpose?: SortOrder
    quantity?: SortOrder
    minSecurityLevel?: SortOrder
    factionID?: SortOrder
  }

  export type invControlTowerResourcesMaxOrderByAggregateInput = {
    controlTowerTypeID?: SortOrder
    resourceTypeID?: SortOrder
    purpose?: SortOrder
    quantity?: SortOrder
    minSecurityLevel?: SortOrder
    factionID?: SortOrder
  }

  export type invControlTowerResourcesMinOrderByAggregateInput = {
    controlTowerTypeID?: SortOrder
    resourceTypeID?: SortOrder
    purpose?: SortOrder
    quantity?: SortOrder
    minSecurityLevel?: SortOrder
    factionID?: SortOrder
  }

  export type invControlTowerResourcesSumOrderByAggregateInput = {
    controlTowerTypeID?: SortOrder
    resourceTypeID?: SortOrder
    purpose?: SortOrder
    quantity?: SortOrder
    minSecurityLevel?: SortOrder
    factionID?: SortOrder
  }

  export type invFlagsCountOrderByAggregateInput = {
    flagID?: SortOrder
    flagName?: SortOrder
    flagText?: SortOrder
    orderID?: SortOrder
  }

  export type invFlagsAvgOrderByAggregateInput = {
    flagID?: SortOrder
    orderID?: SortOrder
  }

  export type invFlagsMaxOrderByAggregateInput = {
    flagID?: SortOrder
    flagName?: SortOrder
    flagText?: SortOrder
    orderID?: SortOrder
  }

  export type invFlagsMinOrderByAggregateInput = {
    flagID?: SortOrder
    flagName?: SortOrder
    flagText?: SortOrder
    orderID?: SortOrder
  }

  export type invFlagsSumOrderByAggregateInput = {
    flagID?: SortOrder
    orderID?: SortOrder
  }

  export type invGroupsCountOrderByAggregateInput = {
    groupID?: SortOrder
    categoryID?: SortOrder
    groupName?: SortOrder
    iconID?: SortOrder
    useBasePrice?: SortOrder
    anchored?: SortOrder
    anchorable?: SortOrder
    fittableNonSingleton?: SortOrder
    published?: SortOrder
  }

  export type invGroupsAvgOrderByAggregateInput = {
    groupID?: SortOrder
    categoryID?: SortOrder
    iconID?: SortOrder
  }

  export type invGroupsMaxOrderByAggregateInput = {
    groupID?: SortOrder
    categoryID?: SortOrder
    groupName?: SortOrder
    iconID?: SortOrder
    useBasePrice?: SortOrder
    anchored?: SortOrder
    anchorable?: SortOrder
    fittableNonSingleton?: SortOrder
    published?: SortOrder
  }

  export type invGroupsMinOrderByAggregateInput = {
    groupID?: SortOrder
    categoryID?: SortOrder
    groupName?: SortOrder
    iconID?: SortOrder
    useBasePrice?: SortOrder
    anchored?: SortOrder
    anchorable?: SortOrder
    fittableNonSingleton?: SortOrder
    published?: SortOrder
  }

  export type invGroupsSumOrderByAggregateInput = {
    groupID?: SortOrder
    categoryID?: SortOrder
    iconID?: SortOrder
  }

  export type invItemsCountOrderByAggregateInput = {
    itemID?: SortOrder
    typeID?: SortOrder
    ownerID?: SortOrder
    locationID?: SortOrder
    flagID?: SortOrder
    quantity?: SortOrder
  }

  export type invItemsAvgOrderByAggregateInput = {
    itemID?: SortOrder
    typeID?: SortOrder
    ownerID?: SortOrder
    locationID?: SortOrder
    flagID?: SortOrder
    quantity?: SortOrder
  }

  export type invItemsMaxOrderByAggregateInput = {
    itemID?: SortOrder
    typeID?: SortOrder
    ownerID?: SortOrder
    locationID?: SortOrder
    flagID?: SortOrder
    quantity?: SortOrder
  }

  export type invItemsMinOrderByAggregateInput = {
    itemID?: SortOrder
    typeID?: SortOrder
    ownerID?: SortOrder
    locationID?: SortOrder
    flagID?: SortOrder
    quantity?: SortOrder
  }

  export type invItemsSumOrderByAggregateInput = {
    itemID?: SortOrder
    typeID?: SortOrder
    ownerID?: SortOrder
    locationID?: SortOrder
    flagID?: SortOrder
    quantity?: SortOrder
  }

  export type invMarketGroupsCountOrderByAggregateInput = {
    marketGroupID?: SortOrder
    parentGroupID?: SortOrder
    marketGroupName?: SortOrder
    description?: SortOrder
    iconID?: SortOrder
    hasTypes?: SortOrder
  }

  export type invMarketGroupsAvgOrderByAggregateInput = {
    marketGroupID?: SortOrder
    parentGroupID?: SortOrder
    iconID?: SortOrder
  }

  export type invMarketGroupsMaxOrderByAggregateInput = {
    marketGroupID?: SortOrder
    parentGroupID?: SortOrder
    marketGroupName?: SortOrder
    description?: SortOrder
    iconID?: SortOrder
    hasTypes?: SortOrder
  }

  export type invMarketGroupsMinOrderByAggregateInput = {
    marketGroupID?: SortOrder
    parentGroupID?: SortOrder
    marketGroupName?: SortOrder
    description?: SortOrder
    iconID?: SortOrder
    hasTypes?: SortOrder
  }

  export type invMarketGroupsSumOrderByAggregateInput = {
    marketGroupID?: SortOrder
    parentGroupID?: SortOrder
    iconID?: SortOrder
  }

  export type invMetaGroupsCountOrderByAggregateInput = {
    metaGroupID?: SortOrder
    metaGroupName?: SortOrder
    description?: SortOrder
    iconID?: SortOrder
  }

  export type invMetaGroupsAvgOrderByAggregateInput = {
    metaGroupID?: SortOrder
    iconID?: SortOrder
  }

  export type invMetaGroupsMaxOrderByAggregateInput = {
    metaGroupID?: SortOrder
    metaGroupName?: SortOrder
    description?: SortOrder
    iconID?: SortOrder
  }

  export type invMetaGroupsMinOrderByAggregateInput = {
    metaGroupID?: SortOrder
    metaGroupName?: SortOrder
    description?: SortOrder
    iconID?: SortOrder
  }

  export type invMetaGroupsSumOrderByAggregateInput = {
    metaGroupID?: SortOrder
    iconID?: SortOrder
  }

  export type invMetaTypesCountOrderByAggregateInput = {
    typeID?: SortOrder
    parentTypeID?: SortOrder
    metaGroupID?: SortOrder
  }

  export type invMetaTypesAvgOrderByAggregateInput = {
    typeID?: SortOrder
    parentTypeID?: SortOrder
    metaGroupID?: SortOrder
  }

  export type invMetaTypesMaxOrderByAggregateInput = {
    typeID?: SortOrder
    parentTypeID?: SortOrder
    metaGroupID?: SortOrder
  }

  export type invMetaTypesMinOrderByAggregateInput = {
    typeID?: SortOrder
    parentTypeID?: SortOrder
    metaGroupID?: SortOrder
  }

  export type invMetaTypesSumOrderByAggregateInput = {
    typeID?: SortOrder
    parentTypeID?: SortOrder
    metaGroupID?: SortOrder
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type invNamesCountOrderByAggregateInput = {
    itemID?: SortOrder
    itemName?: SortOrder
  }

  export type invNamesAvgOrderByAggregateInput = {
    itemID?: SortOrder
  }

  export type invNamesMaxOrderByAggregateInput = {
    itemID?: SortOrder
    itemName?: SortOrder
  }

  export type invNamesMinOrderByAggregateInput = {
    itemID?: SortOrder
    itemName?: SortOrder
  }

  export type invNamesSumOrderByAggregateInput = {
    itemID?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type invPositionsCountOrderByAggregateInput = {
    itemID?: SortOrder
    x?: SortOrder
    y?: SortOrder
    z?: SortOrder
    yaw?: SortOrder
    pitch?: SortOrder
    roll?: SortOrder
  }

  export type invPositionsAvgOrderByAggregateInput = {
    itemID?: SortOrder
    x?: SortOrder
    y?: SortOrder
    z?: SortOrder
    yaw?: SortOrder
    pitch?: SortOrder
    roll?: SortOrder
  }

  export type invPositionsMaxOrderByAggregateInput = {
    itemID?: SortOrder
    x?: SortOrder
    y?: SortOrder
    z?: SortOrder
    yaw?: SortOrder
    pitch?: SortOrder
    roll?: SortOrder
  }

  export type invPositionsMinOrderByAggregateInput = {
    itemID?: SortOrder
    x?: SortOrder
    y?: SortOrder
    z?: SortOrder
    yaw?: SortOrder
    pitch?: SortOrder
    roll?: SortOrder
  }

  export type invPositionsSumOrderByAggregateInput = {
    itemID?: SortOrder
    x?: SortOrder
    y?: SortOrder
    z?: SortOrder
    yaw?: SortOrder
    pitch?: SortOrder
    roll?: SortOrder
  }

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type invTraitsCountOrderByAggregateInput = {
    traitID?: SortOrder
    typeID?: SortOrder
    skillID?: SortOrder
    bonus?: SortOrder
    bonusText?: SortOrder
    unitID?: SortOrder
  }

  export type invTraitsAvgOrderByAggregateInput = {
    traitID?: SortOrder
    typeID?: SortOrder
    skillID?: SortOrder
    bonus?: SortOrder
    unitID?: SortOrder
  }

  export type invTraitsMaxOrderByAggregateInput = {
    traitID?: SortOrder
    typeID?: SortOrder
    skillID?: SortOrder
    bonus?: SortOrder
    bonusText?: SortOrder
    unitID?: SortOrder
  }

  export type invTraitsMinOrderByAggregateInput = {
    traitID?: SortOrder
    typeID?: SortOrder
    skillID?: SortOrder
    bonus?: SortOrder
    bonusText?: SortOrder
    unitID?: SortOrder
  }

  export type invTraitsSumOrderByAggregateInput = {
    traitID?: SortOrder
    typeID?: SortOrder
    skillID?: SortOrder
    bonus?: SortOrder
    unitID?: SortOrder
  }

  export type invTypeMaterialsTypeIDMaterialTypeIDCompoundUniqueInput = {
    typeID: number
    materialTypeID: number
  }

  export type invTypeMaterialsCountOrderByAggregateInput = {
    typeID?: SortOrder
    materialTypeID?: SortOrder
    quantity?: SortOrder
  }

  export type invTypeMaterialsAvgOrderByAggregateInput = {
    typeID?: SortOrder
    materialTypeID?: SortOrder
    quantity?: SortOrder
  }

  export type invTypeMaterialsMaxOrderByAggregateInput = {
    typeID?: SortOrder
    materialTypeID?: SortOrder
    quantity?: SortOrder
  }

  export type invTypeMaterialsMinOrderByAggregateInput = {
    typeID?: SortOrder
    materialTypeID?: SortOrder
    quantity?: SortOrder
  }

  export type invTypeMaterialsSumOrderByAggregateInput = {
    typeID?: SortOrder
    materialTypeID?: SortOrder
    quantity?: SortOrder
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type invTypeReactionsReactionTypeIDInputTypeIDCompoundUniqueInput = {
    reactionTypeID: number
    input: boolean
    typeID: number
  }

  export type invTypeReactionsCountOrderByAggregateInput = {
    reactionTypeID?: SortOrder
    input?: SortOrder
    typeID?: SortOrder
    quantity?: SortOrder
  }

  export type invTypeReactionsAvgOrderByAggregateInput = {
    reactionTypeID?: SortOrder
    typeID?: SortOrder
    quantity?: SortOrder
  }

  export type invTypeReactionsMaxOrderByAggregateInput = {
    reactionTypeID?: SortOrder
    input?: SortOrder
    typeID?: SortOrder
    quantity?: SortOrder
  }

  export type invTypeReactionsMinOrderByAggregateInput = {
    reactionTypeID?: SortOrder
    input?: SortOrder
    typeID?: SortOrder
    quantity?: SortOrder
  }

  export type invTypeReactionsSumOrderByAggregateInput = {
    reactionTypeID?: SortOrder
    typeID?: SortOrder
    quantity?: SortOrder
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type DecimalNullableFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
  }

  export type invTypesCountOrderByAggregateInput = {
    typeID?: SortOrder
    groupID?: SortOrder
    typeName?: SortOrder
    description?: SortOrder
    mass?: SortOrder
    volume?: SortOrder
    capacity?: SortOrder
    portionSize?: SortOrder
    raceID?: SortOrder
    basePrice?: SortOrder
    published?: SortOrder
    marketGroupID?: SortOrder
    iconID?: SortOrder
    soundID?: SortOrder
    graphicID?: SortOrder
  }

  export type invTypesAvgOrderByAggregateInput = {
    typeID?: SortOrder
    groupID?: SortOrder
    mass?: SortOrder
    volume?: SortOrder
    capacity?: SortOrder
    portionSize?: SortOrder
    raceID?: SortOrder
    basePrice?: SortOrder
    marketGroupID?: SortOrder
    iconID?: SortOrder
    soundID?: SortOrder
    graphicID?: SortOrder
  }

  export type invTypesMaxOrderByAggregateInput = {
    typeID?: SortOrder
    groupID?: SortOrder
    typeName?: SortOrder
    description?: SortOrder
    mass?: SortOrder
    volume?: SortOrder
    capacity?: SortOrder
    portionSize?: SortOrder
    raceID?: SortOrder
    basePrice?: SortOrder
    published?: SortOrder
    marketGroupID?: SortOrder
    iconID?: SortOrder
    soundID?: SortOrder
    graphicID?: SortOrder
  }

  export type invTypesMinOrderByAggregateInput = {
    typeID?: SortOrder
    groupID?: SortOrder
    typeName?: SortOrder
    description?: SortOrder
    mass?: SortOrder
    volume?: SortOrder
    capacity?: SortOrder
    portionSize?: SortOrder
    raceID?: SortOrder
    basePrice?: SortOrder
    published?: SortOrder
    marketGroupID?: SortOrder
    iconID?: SortOrder
    soundID?: SortOrder
    graphicID?: SortOrder
  }

  export type invTypesSumOrderByAggregateInput = {
    typeID?: SortOrder
    groupID?: SortOrder
    mass?: SortOrder
    volume?: SortOrder
    capacity?: SortOrder
    portionSize?: SortOrder
    raceID?: SortOrder
    basePrice?: SortOrder
    marketGroupID?: SortOrder
    iconID?: SortOrder
    soundID?: SortOrder
    graphicID?: SortOrder
  }

  export type DecimalNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedDecimalNullableFilter<$PrismaModel>
    _sum?: NestedDecimalNullableFilter<$PrismaModel>
    _min?: NestedDecimalNullableFilter<$PrismaModel>
    _max?: NestedDecimalNullableFilter<$PrismaModel>
  }

  export type invUniqueNamesCountOrderByAggregateInput = {
    itemID?: SortOrder
    itemName?: SortOrder
    groupID?: SortOrder
  }

  export type invUniqueNamesAvgOrderByAggregateInput = {
    itemID?: SortOrder
    groupID?: SortOrder
  }

  export type invUniqueNamesMaxOrderByAggregateInput = {
    itemID?: SortOrder
    itemName?: SortOrder
    groupID?: SortOrder
  }

  export type invUniqueNamesMinOrderByAggregateInput = {
    itemID?: SortOrder
    itemName?: SortOrder
    groupID?: SortOrder
  }

  export type invUniqueNamesSumOrderByAggregateInput = {
    itemID?: SortOrder
    groupID?: SortOrder
  }

  export type invVolumesCountOrderByAggregateInput = {
    typeID?: SortOrder
    volume?: SortOrder
  }

  export type invVolumesAvgOrderByAggregateInput = {
    typeID?: SortOrder
    volume?: SortOrder
  }

  export type invVolumesMaxOrderByAggregateInput = {
    typeID?: SortOrder
    volume?: SortOrder
  }

  export type invVolumesMinOrderByAggregateInput = {
    typeID?: SortOrder
    volume?: SortOrder
  }

  export type invVolumesSumOrderByAggregateInput = {
    typeID?: SortOrder
    volume?: SortOrder
  }

  export type mapCelestialGraphicsCountOrderByAggregateInput = {
    celestialID?: SortOrder
    heightMap1?: SortOrder
    heightMap2?: SortOrder
    shaderPreset?: SortOrder
    population?: SortOrder
  }

  export type mapCelestialGraphicsAvgOrderByAggregateInput = {
    celestialID?: SortOrder
    heightMap1?: SortOrder
    heightMap2?: SortOrder
    shaderPreset?: SortOrder
  }

  export type mapCelestialGraphicsMaxOrderByAggregateInput = {
    celestialID?: SortOrder
    heightMap1?: SortOrder
    heightMap2?: SortOrder
    shaderPreset?: SortOrder
    population?: SortOrder
  }

  export type mapCelestialGraphicsMinOrderByAggregateInput = {
    celestialID?: SortOrder
    heightMap1?: SortOrder
    heightMap2?: SortOrder
    shaderPreset?: SortOrder
    population?: SortOrder
  }

  export type mapCelestialGraphicsSumOrderByAggregateInput = {
    celestialID?: SortOrder
    heightMap1?: SortOrder
    heightMap2?: SortOrder
    shaderPreset?: SortOrder
  }

  export type mapCelestialStatisticsCountOrderByAggregateInput = {
    celestialID?: SortOrder
    temperature?: SortOrder
    spectralClass?: SortOrder
    luminosity?: SortOrder
    age?: SortOrder
    life?: SortOrder
    orbitRadius?: SortOrder
    eccentricity?: SortOrder
    massDust?: SortOrder
    massGas?: SortOrder
    fragmented?: SortOrder
    density?: SortOrder
    surfaceGravity?: SortOrder
    escapeVelocity?: SortOrder
    orbitPeriod?: SortOrder
    rotationRate?: SortOrder
    locked?: SortOrder
    pressure?: SortOrder
    radius?: SortOrder
    mass?: SortOrder
  }

  export type mapCelestialStatisticsAvgOrderByAggregateInput = {
    celestialID?: SortOrder
    temperature?: SortOrder
    luminosity?: SortOrder
    age?: SortOrder
    life?: SortOrder
    orbitRadius?: SortOrder
    eccentricity?: SortOrder
    massDust?: SortOrder
    massGas?: SortOrder
    density?: SortOrder
    surfaceGravity?: SortOrder
    escapeVelocity?: SortOrder
    orbitPeriod?: SortOrder
    rotationRate?: SortOrder
    pressure?: SortOrder
    radius?: SortOrder
    mass?: SortOrder
  }

  export type mapCelestialStatisticsMaxOrderByAggregateInput = {
    celestialID?: SortOrder
    temperature?: SortOrder
    spectralClass?: SortOrder
    luminosity?: SortOrder
    age?: SortOrder
    life?: SortOrder
    orbitRadius?: SortOrder
    eccentricity?: SortOrder
    massDust?: SortOrder
    massGas?: SortOrder
    fragmented?: SortOrder
    density?: SortOrder
    surfaceGravity?: SortOrder
    escapeVelocity?: SortOrder
    orbitPeriod?: SortOrder
    rotationRate?: SortOrder
    locked?: SortOrder
    pressure?: SortOrder
    radius?: SortOrder
    mass?: SortOrder
  }

  export type mapCelestialStatisticsMinOrderByAggregateInput = {
    celestialID?: SortOrder
    temperature?: SortOrder
    spectralClass?: SortOrder
    luminosity?: SortOrder
    age?: SortOrder
    life?: SortOrder
    orbitRadius?: SortOrder
    eccentricity?: SortOrder
    massDust?: SortOrder
    massGas?: SortOrder
    fragmented?: SortOrder
    density?: SortOrder
    surfaceGravity?: SortOrder
    escapeVelocity?: SortOrder
    orbitPeriod?: SortOrder
    rotationRate?: SortOrder
    locked?: SortOrder
    pressure?: SortOrder
    radius?: SortOrder
    mass?: SortOrder
  }

  export type mapCelestialStatisticsSumOrderByAggregateInput = {
    celestialID?: SortOrder
    temperature?: SortOrder
    luminosity?: SortOrder
    age?: SortOrder
    life?: SortOrder
    orbitRadius?: SortOrder
    eccentricity?: SortOrder
    massDust?: SortOrder
    massGas?: SortOrder
    density?: SortOrder
    surfaceGravity?: SortOrder
    escapeVelocity?: SortOrder
    orbitPeriod?: SortOrder
    rotationRate?: SortOrder
    pressure?: SortOrder
    radius?: SortOrder
    mass?: SortOrder
  }

  export type mapConstellationJumpsFromConstellationIDToConstellationIDCompoundUniqueInput = {
    fromConstellationID: number
    toConstellationID: number
  }

  export type mapConstellationJumpsCountOrderByAggregateInput = {
    fromRegionID?: SortOrder
    fromConstellationID?: SortOrder
    toConstellationID?: SortOrder
    toRegionID?: SortOrder
  }

  export type mapConstellationJumpsAvgOrderByAggregateInput = {
    fromRegionID?: SortOrder
    fromConstellationID?: SortOrder
    toConstellationID?: SortOrder
    toRegionID?: SortOrder
  }

  export type mapConstellationJumpsMaxOrderByAggregateInput = {
    fromRegionID?: SortOrder
    fromConstellationID?: SortOrder
    toConstellationID?: SortOrder
    toRegionID?: SortOrder
  }

  export type mapConstellationJumpsMinOrderByAggregateInput = {
    fromRegionID?: SortOrder
    fromConstellationID?: SortOrder
    toConstellationID?: SortOrder
    toRegionID?: SortOrder
  }

  export type mapConstellationJumpsSumOrderByAggregateInput = {
    fromRegionID?: SortOrder
    fromConstellationID?: SortOrder
    toConstellationID?: SortOrder
    toRegionID?: SortOrder
  }

  export type mapConstellationsCountOrderByAggregateInput = {
    regionID?: SortOrder
    constellationID?: SortOrder
    constellationName?: SortOrder
    x?: SortOrder
    y?: SortOrder
    z?: SortOrder
    xMin?: SortOrder
    xMax?: SortOrder
    yMin?: SortOrder
    yMax?: SortOrder
    zMin?: SortOrder
    zMax?: SortOrder
    factionID?: SortOrder
    radius?: SortOrder
  }

  export type mapConstellationsAvgOrderByAggregateInput = {
    regionID?: SortOrder
    constellationID?: SortOrder
    x?: SortOrder
    y?: SortOrder
    z?: SortOrder
    xMin?: SortOrder
    xMax?: SortOrder
    yMin?: SortOrder
    yMax?: SortOrder
    zMin?: SortOrder
    zMax?: SortOrder
    factionID?: SortOrder
    radius?: SortOrder
  }

  export type mapConstellationsMaxOrderByAggregateInput = {
    regionID?: SortOrder
    constellationID?: SortOrder
    constellationName?: SortOrder
    x?: SortOrder
    y?: SortOrder
    z?: SortOrder
    xMin?: SortOrder
    xMax?: SortOrder
    yMin?: SortOrder
    yMax?: SortOrder
    zMin?: SortOrder
    zMax?: SortOrder
    factionID?: SortOrder
    radius?: SortOrder
  }

  export type mapConstellationsMinOrderByAggregateInput = {
    regionID?: SortOrder
    constellationID?: SortOrder
    constellationName?: SortOrder
    x?: SortOrder
    y?: SortOrder
    z?: SortOrder
    xMin?: SortOrder
    xMax?: SortOrder
    yMin?: SortOrder
    yMax?: SortOrder
    zMin?: SortOrder
    zMax?: SortOrder
    factionID?: SortOrder
    radius?: SortOrder
  }

  export type mapConstellationsSumOrderByAggregateInput = {
    regionID?: SortOrder
    constellationID?: SortOrder
    x?: SortOrder
    y?: SortOrder
    z?: SortOrder
    xMin?: SortOrder
    xMax?: SortOrder
    yMin?: SortOrder
    yMax?: SortOrder
    zMin?: SortOrder
    zMax?: SortOrder
    factionID?: SortOrder
    radius?: SortOrder
  }

  export type mapDenormalizeCountOrderByAggregateInput = {
    itemID?: SortOrder
    typeID?: SortOrder
    groupID?: SortOrder
    solarSystemID?: SortOrder
    constellationID?: SortOrder
    regionID?: SortOrder
    orbitID?: SortOrder
    x?: SortOrder
    y?: SortOrder
    z?: SortOrder
    radius?: SortOrder
    itemName?: SortOrder
    security?: SortOrder
    celestialIndex?: SortOrder
    orbitIndex?: SortOrder
  }

  export type mapDenormalizeAvgOrderByAggregateInput = {
    itemID?: SortOrder
    typeID?: SortOrder
    groupID?: SortOrder
    solarSystemID?: SortOrder
    constellationID?: SortOrder
    regionID?: SortOrder
    orbitID?: SortOrder
    x?: SortOrder
    y?: SortOrder
    z?: SortOrder
    radius?: SortOrder
    security?: SortOrder
    celestialIndex?: SortOrder
    orbitIndex?: SortOrder
  }

  export type mapDenormalizeMaxOrderByAggregateInput = {
    itemID?: SortOrder
    typeID?: SortOrder
    groupID?: SortOrder
    solarSystemID?: SortOrder
    constellationID?: SortOrder
    regionID?: SortOrder
    orbitID?: SortOrder
    x?: SortOrder
    y?: SortOrder
    z?: SortOrder
    radius?: SortOrder
    itemName?: SortOrder
    security?: SortOrder
    celestialIndex?: SortOrder
    orbitIndex?: SortOrder
  }

  export type mapDenormalizeMinOrderByAggregateInput = {
    itemID?: SortOrder
    typeID?: SortOrder
    groupID?: SortOrder
    solarSystemID?: SortOrder
    constellationID?: SortOrder
    regionID?: SortOrder
    orbitID?: SortOrder
    x?: SortOrder
    y?: SortOrder
    z?: SortOrder
    radius?: SortOrder
    itemName?: SortOrder
    security?: SortOrder
    celestialIndex?: SortOrder
    orbitIndex?: SortOrder
  }

  export type mapDenormalizeSumOrderByAggregateInput = {
    itemID?: SortOrder
    typeID?: SortOrder
    groupID?: SortOrder
    solarSystemID?: SortOrder
    constellationID?: SortOrder
    regionID?: SortOrder
    orbitID?: SortOrder
    x?: SortOrder
    y?: SortOrder
    z?: SortOrder
    radius?: SortOrder
    security?: SortOrder
    celestialIndex?: SortOrder
    orbitIndex?: SortOrder
  }

  export type mapJumpsCountOrderByAggregateInput = {
    stargateID?: SortOrder
    destinationID?: SortOrder
  }

  export type mapJumpsAvgOrderByAggregateInput = {
    stargateID?: SortOrder
    destinationID?: SortOrder
  }

  export type mapJumpsMaxOrderByAggregateInput = {
    stargateID?: SortOrder
    destinationID?: SortOrder
  }

  export type mapJumpsMinOrderByAggregateInput = {
    stargateID?: SortOrder
    destinationID?: SortOrder
  }

  export type mapJumpsSumOrderByAggregateInput = {
    stargateID?: SortOrder
    destinationID?: SortOrder
  }

  export type mapLandmarksCountOrderByAggregateInput = {
    landmarkID?: SortOrder
    landmarkName?: SortOrder
    description?: SortOrder
    locationID?: SortOrder
    x?: SortOrder
    y?: SortOrder
    z?: SortOrder
    iconID?: SortOrder
  }

  export type mapLandmarksAvgOrderByAggregateInput = {
    landmarkID?: SortOrder
    locationID?: SortOrder
    x?: SortOrder
    y?: SortOrder
    z?: SortOrder
    iconID?: SortOrder
  }

  export type mapLandmarksMaxOrderByAggregateInput = {
    landmarkID?: SortOrder
    landmarkName?: SortOrder
    description?: SortOrder
    locationID?: SortOrder
    x?: SortOrder
    y?: SortOrder
    z?: SortOrder
    iconID?: SortOrder
  }

  export type mapLandmarksMinOrderByAggregateInput = {
    landmarkID?: SortOrder
    landmarkName?: SortOrder
    description?: SortOrder
    locationID?: SortOrder
    x?: SortOrder
    y?: SortOrder
    z?: SortOrder
    iconID?: SortOrder
  }

  export type mapLandmarksSumOrderByAggregateInput = {
    landmarkID?: SortOrder
    locationID?: SortOrder
    x?: SortOrder
    y?: SortOrder
    z?: SortOrder
    iconID?: SortOrder
  }

  export type mapLocationScenesCountOrderByAggregateInput = {
    locationID?: SortOrder
    graphicID?: SortOrder
  }

  export type mapLocationScenesAvgOrderByAggregateInput = {
    locationID?: SortOrder
    graphicID?: SortOrder
  }

  export type mapLocationScenesMaxOrderByAggregateInput = {
    locationID?: SortOrder
    graphicID?: SortOrder
  }

  export type mapLocationScenesMinOrderByAggregateInput = {
    locationID?: SortOrder
    graphicID?: SortOrder
  }

  export type mapLocationScenesSumOrderByAggregateInput = {
    locationID?: SortOrder
    graphicID?: SortOrder
  }

  export type mapLocationWormholeClassesCountOrderByAggregateInput = {
    locationID?: SortOrder
    wormholeClassID?: SortOrder
  }

  export type mapLocationWormholeClassesAvgOrderByAggregateInput = {
    locationID?: SortOrder
    wormholeClassID?: SortOrder
  }

  export type mapLocationWormholeClassesMaxOrderByAggregateInput = {
    locationID?: SortOrder
    wormholeClassID?: SortOrder
  }

  export type mapLocationWormholeClassesMinOrderByAggregateInput = {
    locationID?: SortOrder
    wormholeClassID?: SortOrder
  }

  export type mapLocationWormholeClassesSumOrderByAggregateInput = {
    locationID?: SortOrder
    wormholeClassID?: SortOrder
  }

  export type mapRegionJumpsFromRegionIDToRegionIDCompoundUniqueInput = {
    fromRegionID: number
    toRegionID: number
  }

  export type mapRegionJumpsCountOrderByAggregateInput = {
    fromRegionID?: SortOrder
    toRegionID?: SortOrder
  }

  export type mapRegionJumpsAvgOrderByAggregateInput = {
    fromRegionID?: SortOrder
    toRegionID?: SortOrder
  }

  export type mapRegionJumpsMaxOrderByAggregateInput = {
    fromRegionID?: SortOrder
    toRegionID?: SortOrder
  }

  export type mapRegionJumpsMinOrderByAggregateInput = {
    fromRegionID?: SortOrder
    toRegionID?: SortOrder
  }

  export type mapRegionJumpsSumOrderByAggregateInput = {
    fromRegionID?: SortOrder
    toRegionID?: SortOrder
  }

  export type mapRegionsCountOrderByAggregateInput = {
    regionID?: SortOrder
    regionName?: SortOrder
    x?: SortOrder
    y?: SortOrder
    z?: SortOrder
    xMin?: SortOrder
    xMax?: SortOrder
    yMin?: SortOrder
    yMax?: SortOrder
    zMin?: SortOrder
    zMax?: SortOrder
    factionID?: SortOrder
    nebula?: SortOrder
    radius?: SortOrder
  }

  export type mapRegionsAvgOrderByAggregateInput = {
    regionID?: SortOrder
    x?: SortOrder
    y?: SortOrder
    z?: SortOrder
    xMin?: SortOrder
    xMax?: SortOrder
    yMin?: SortOrder
    yMax?: SortOrder
    zMin?: SortOrder
    zMax?: SortOrder
    factionID?: SortOrder
    nebula?: SortOrder
    radius?: SortOrder
  }

  export type mapRegionsMaxOrderByAggregateInput = {
    regionID?: SortOrder
    regionName?: SortOrder
    x?: SortOrder
    y?: SortOrder
    z?: SortOrder
    xMin?: SortOrder
    xMax?: SortOrder
    yMin?: SortOrder
    yMax?: SortOrder
    zMin?: SortOrder
    zMax?: SortOrder
    factionID?: SortOrder
    nebula?: SortOrder
    radius?: SortOrder
  }

  export type mapRegionsMinOrderByAggregateInput = {
    regionID?: SortOrder
    regionName?: SortOrder
    x?: SortOrder
    y?: SortOrder
    z?: SortOrder
    xMin?: SortOrder
    xMax?: SortOrder
    yMin?: SortOrder
    yMax?: SortOrder
    zMin?: SortOrder
    zMax?: SortOrder
    factionID?: SortOrder
    nebula?: SortOrder
    radius?: SortOrder
  }

  export type mapRegionsSumOrderByAggregateInput = {
    regionID?: SortOrder
    x?: SortOrder
    y?: SortOrder
    z?: SortOrder
    xMin?: SortOrder
    xMax?: SortOrder
    yMin?: SortOrder
    yMax?: SortOrder
    zMin?: SortOrder
    zMax?: SortOrder
    factionID?: SortOrder
    nebula?: SortOrder
    radius?: SortOrder
  }

  export type mapSolarSystemJumpsFromSolarSystemIDToSolarSystemIDCompoundUniqueInput = {
    fromSolarSystemID: number
    toSolarSystemID: number
  }

  export type mapSolarSystemJumpsCountOrderByAggregateInput = {
    fromRegionID?: SortOrder
    fromConstellationID?: SortOrder
    fromSolarSystemID?: SortOrder
    toSolarSystemID?: SortOrder
    toConstellationID?: SortOrder
    toRegionID?: SortOrder
  }

  export type mapSolarSystemJumpsAvgOrderByAggregateInput = {
    fromRegionID?: SortOrder
    fromConstellationID?: SortOrder
    fromSolarSystemID?: SortOrder
    toSolarSystemID?: SortOrder
    toConstellationID?: SortOrder
    toRegionID?: SortOrder
  }

  export type mapSolarSystemJumpsMaxOrderByAggregateInput = {
    fromRegionID?: SortOrder
    fromConstellationID?: SortOrder
    fromSolarSystemID?: SortOrder
    toSolarSystemID?: SortOrder
    toConstellationID?: SortOrder
    toRegionID?: SortOrder
  }

  export type mapSolarSystemJumpsMinOrderByAggregateInput = {
    fromRegionID?: SortOrder
    fromConstellationID?: SortOrder
    fromSolarSystemID?: SortOrder
    toSolarSystemID?: SortOrder
    toConstellationID?: SortOrder
    toRegionID?: SortOrder
  }

  export type mapSolarSystemJumpsSumOrderByAggregateInput = {
    fromRegionID?: SortOrder
    fromConstellationID?: SortOrder
    fromSolarSystemID?: SortOrder
    toSolarSystemID?: SortOrder
    toConstellationID?: SortOrder
    toRegionID?: SortOrder
  }

  export type mapSolarSystemsCountOrderByAggregateInput = {
    regionID?: SortOrder
    constellationID?: SortOrder
    solarSystemID?: SortOrder
    solarSystemName?: SortOrder
    x?: SortOrder
    y?: SortOrder
    z?: SortOrder
    xMin?: SortOrder
    xMax?: SortOrder
    yMin?: SortOrder
    yMax?: SortOrder
    zMin?: SortOrder
    zMax?: SortOrder
    luminosity?: SortOrder
    border?: SortOrder
    fringe?: SortOrder
    corridor?: SortOrder
    hub?: SortOrder
    international?: SortOrder
    regional?: SortOrder
    constellation?: SortOrder
    security?: SortOrder
    factionID?: SortOrder
    radius?: SortOrder
    sunTypeID?: SortOrder
    securityClass?: SortOrder
  }

  export type mapSolarSystemsAvgOrderByAggregateInput = {
    regionID?: SortOrder
    constellationID?: SortOrder
    solarSystemID?: SortOrder
    x?: SortOrder
    y?: SortOrder
    z?: SortOrder
    xMin?: SortOrder
    xMax?: SortOrder
    yMin?: SortOrder
    yMax?: SortOrder
    zMin?: SortOrder
    zMax?: SortOrder
    luminosity?: SortOrder
    security?: SortOrder
    factionID?: SortOrder
    radius?: SortOrder
    sunTypeID?: SortOrder
  }

  export type mapSolarSystemsMaxOrderByAggregateInput = {
    regionID?: SortOrder
    constellationID?: SortOrder
    solarSystemID?: SortOrder
    solarSystemName?: SortOrder
    x?: SortOrder
    y?: SortOrder
    z?: SortOrder
    xMin?: SortOrder
    xMax?: SortOrder
    yMin?: SortOrder
    yMax?: SortOrder
    zMin?: SortOrder
    zMax?: SortOrder
    luminosity?: SortOrder
    border?: SortOrder
    fringe?: SortOrder
    corridor?: SortOrder
    hub?: SortOrder
    international?: SortOrder
    regional?: SortOrder
    constellation?: SortOrder
    security?: SortOrder
    factionID?: SortOrder
    radius?: SortOrder
    sunTypeID?: SortOrder
    securityClass?: SortOrder
  }

  export type mapSolarSystemsMinOrderByAggregateInput = {
    regionID?: SortOrder
    constellationID?: SortOrder
    solarSystemID?: SortOrder
    solarSystemName?: SortOrder
    x?: SortOrder
    y?: SortOrder
    z?: SortOrder
    xMin?: SortOrder
    xMax?: SortOrder
    yMin?: SortOrder
    yMax?: SortOrder
    zMin?: SortOrder
    zMax?: SortOrder
    luminosity?: SortOrder
    border?: SortOrder
    fringe?: SortOrder
    corridor?: SortOrder
    hub?: SortOrder
    international?: SortOrder
    regional?: SortOrder
    constellation?: SortOrder
    security?: SortOrder
    factionID?: SortOrder
    radius?: SortOrder
    sunTypeID?: SortOrder
    securityClass?: SortOrder
  }

  export type mapSolarSystemsSumOrderByAggregateInput = {
    regionID?: SortOrder
    constellationID?: SortOrder
    solarSystemID?: SortOrder
    x?: SortOrder
    y?: SortOrder
    z?: SortOrder
    xMin?: SortOrder
    xMax?: SortOrder
    yMin?: SortOrder
    yMax?: SortOrder
    zMin?: SortOrder
    zMax?: SortOrder
    luminosity?: SortOrder
    security?: SortOrder
    factionID?: SortOrder
    radius?: SortOrder
    sunTypeID?: SortOrder
  }

  export type mapUniverseCountOrderByAggregateInput = {
    universeID?: SortOrder
    universeName?: SortOrder
    x?: SortOrder
    y?: SortOrder
    z?: SortOrder
    xMin?: SortOrder
    xMax?: SortOrder
    yMin?: SortOrder
    yMax?: SortOrder
    zMin?: SortOrder
    zMax?: SortOrder
    radius?: SortOrder
  }

  export type mapUniverseAvgOrderByAggregateInput = {
    universeID?: SortOrder
    x?: SortOrder
    y?: SortOrder
    z?: SortOrder
    xMin?: SortOrder
    xMax?: SortOrder
    yMin?: SortOrder
    yMax?: SortOrder
    zMin?: SortOrder
    zMax?: SortOrder
    radius?: SortOrder
  }

  export type mapUniverseMaxOrderByAggregateInput = {
    universeID?: SortOrder
    universeName?: SortOrder
    x?: SortOrder
    y?: SortOrder
    z?: SortOrder
    xMin?: SortOrder
    xMax?: SortOrder
    yMin?: SortOrder
    yMax?: SortOrder
    zMin?: SortOrder
    zMax?: SortOrder
    radius?: SortOrder
  }

  export type mapUniverseMinOrderByAggregateInput = {
    universeID?: SortOrder
    universeName?: SortOrder
    x?: SortOrder
    y?: SortOrder
    z?: SortOrder
    xMin?: SortOrder
    xMax?: SortOrder
    yMin?: SortOrder
    yMax?: SortOrder
    zMin?: SortOrder
    zMax?: SortOrder
    radius?: SortOrder
  }

  export type mapUniverseSumOrderByAggregateInput = {
    universeID?: SortOrder
    x?: SortOrder
    y?: SortOrder
    z?: SortOrder
    xMin?: SortOrder
    xMax?: SortOrder
    yMin?: SortOrder
    yMax?: SortOrder
    zMin?: SortOrder
    zMax?: SortOrder
    radius?: SortOrder
  }

  export type planetSchematicsCountOrderByAggregateInput = {
    schematicID?: SortOrder
    schematicName?: SortOrder
    cycleTime?: SortOrder
  }

  export type planetSchematicsAvgOrderByAggregateInput = {
    schematicID?: SortOrder
    cycleTime?: SortOrder
  }

  export type planetSchematicsMaxOrderByAggregateInput = {
    schematicID?: SortOrder
    schematicName?: SortOrder
    cycleTime?: SortOrder
  }

  export type planetSchematicsMinOrderByAggregateInput = {
    schematicID?: SortOrder
    schematicName?: SortOrder
    cycleTime?: SortOrder
  }

  export type planetSchematicsSumOrderByAggregateInput = {
    schematicID?: SortOrder
    cycleTime?: SortOrder
  }

  export type planetSchematicsPinMapSchematicIDPinTypeIDCompoundUniqueInput = {
    schematicID: number
    pinTypeID: number
  }

  export type planetSchematicsPinMapCountOrderByAggregateInput = {
    schematicID?: SortOrder
    pinTypeID?: SortOrder
  }

  export type planetSchematicsPinMapAvgOrderByAggregateInput = {
    schematicID?: SortOrder
    pinTypeID?: SortOrder
  }

  export type planetSchematicsPinMapMaxOrderByAggregateInput = {
    schematicID?: SortOrder
    pinTypeID?: SortOrder
  }

  export type planetSchematicsPinMapMinOrderByAggregateInput = {
    schematicID?: SortOrder
    pinTypeID?: SortOrder
  }

  export type planetSchematicsPinMapSumOrderByAggregateInput = {
    schematicID?: SortOrder
    pinTypeID?: SortOrder
  }

  export type planetSchematicsTypeMapSchematicIDTypeIDCompoundUniqueInput = {
    schematicID: number
    typeID: number
  }

  export type planetSchematicsTypeMapCountOrderByAggregateInput = {
    schematicID?: SortOrder
    typeID?: SortOrder
    quantity?: SortOrder
    isInput?: SortOrder
  }

  export type planetSchematicsTypeMapAvgOrderByAggregateInput = {
    schematicID?: SortOrder
    typeID?: SortOrder
    quantity?: SortOrder
  }

  export type planetSchematicsTypeMapMaxOrderByAggregateInput = {
    schematicID?: SortOrder
    typeID?: SortOrder
    quantity?: SortOrder
    isInput?: SortOrder
  }

  export type planetSchematicsTypeMapMinOrderByAggregateInput = {
    schematicID?: SortOrder
    typeID?: SortOrder
    quantity?: SortOrder
    isInput?: SortOrder
  }

  export type planetSchematicsTypeMapSumOrderByAggregateInput = {
    schematicID?: SortOrder
    typeID?: SortOrder
    quantity?: SortOrder
  }

  export type ramActivitiesCountOrderByAggregateInput = {
    activityID?: SortOrder
    activityName?: SortOrder
    iconNo?: SortOrder
    description?: SortOrder
    published?: SortOrder
  }

  export type ramActivitiesAvgOrderByAggregateInput = {
    activityID?: SortOrder
  }

  export type ramActivitiesMaxOrderByAggregateInput = {
    activityID?: SortOrder
    activityName?: SortOrder
    iconNo?: SortOrder
    description?: SortOrder
    published?: SortOrder
  }

  export type ramActivitiesMinOrderByAggregateInput = {
    activityID?: SortOrder
    activityName?: SortOrder
    iconNo?: SortOrder
    description?: SortOrder
    published?: SortOrder
  }

  export type ramActivitiesSumOrderByAggregateInput = {
    activityID?: SortOrder
  }

  export type ramAssemblyLineStationsStationIDAssemblyLineTypeIDCompoundUniqueInput = {
    stationID: number
    assemblyLineTypeID: number
  }

  export type ramAssemblyLineStationsCountOrderByAggregateInput = {
    stationID?: SortOrder
    assemblyLineTypeID?: SortOrder
    quantity?: SortOrder
    stationTypeID?: SortOrder
    ownerID?: SortOrder
    solarSystemID?: SortOrder
    regionID?: SortOrder
  }

  export type ramAssemblyLineStationsAvgOrderByAggregateInput = {
    stationID?: SortOrder
    assemblyLineTypeID?: SortOrder
    quantity?: SortOrder
    stationTypeID?: SortOrder
    ownerID?: SortOrder
    solarSystemID?: SortOrder
    regionID?: SortOrder
  }

  export type ramAssemblyLineStationsMaxOrderByAggregateInput = {
    stationID?: SortOrder
    assemblyLineTypeID?: SortOrder
    quantity?: SortOrder
    stationTypeID?: SortOrder
    ownerID?: SortOrder
    solarSystemID?: SortOrder
    regionID?: SortOrder
  }

  export type ramAssemblyLineStationsMinOrderByAggregateInput = {
    stationID?: SortOrder
    assemblyLineTypeID?: SortOrder
    quantity?: SortOrder
    stationTypeID?: SortOrder
    ownerID?: SortOrder
    solarSystemID?: SortOrder
    regionID?: SortOrder
  }

  export type ramAssemblyLineStationsSumOrderByAggregateInput = {
    stationID?: SortOrder
    assemblyLineTypeID?: SortOrder
    quantity?: SortOrder
    stationTypeID?: SortOrder
    ownerID?: SortOrder
    solarSystemID?: SortOrder
    regionID?: SortOrder
  }

  export type ramAssemblyLineTypeDetailPerCategoryAssemblyLineTypeIDCategoryIDCompoundUniqueInput = {
    assemblyLineTypeID: number
    categoryID: number
  }

  export type ramAssemblyLineTypeDetailPerCategoryCountOrderByAggregateInput = {
    assemblyLineTypeID?: SortOrder
    categoryID?: SortOrder
    timeMultiplier?: SortOrder
    materialMultiplier?: SortOrder
    costMultiplier?: SortOrder
  }

  export type ramAssemblyLineTypeDetailPerCategoryAvgOrderByAggregateInput = {
    assemblyLineTypeID?: SortOrder
    categoryID?: SortOrder
    timeMultiplier?: SortOrder
    materialMultiplier?: SortOrder
    costMultiplier?: SortOrder
  }

  export type ramAssemblyLineTypeDetailPerCategoryMaxOrderByAggregateInput = {
    assemblyLineTypeID?: SortOrder
    categoryID?: SortOrder
    timeMultiplier?: SortOrder
    materialMultiplier?: SortOrder
    costMultiplier?: SortOrder
  }

  export type ramAssemblyLineTypeDetailPerCategoryMinOrderByAggregateInput = {
    assemblyLineTypeID?: SortOrder
    categoryID?: SortOrder
    timeMultiplier?: SortOrder
    materialMultiplier?: SortOrder
    costMultiplier?: SortOrder
  }

  export type ramAssemblyLineTypeDetailPerCategorySumOrderByAggregateInput = {
    assemblyLineTypeID?: SortOrder
    categoryID?: SortOrder
    timeMultiplier?: SortOrder
    materialMultiplier?: SortOrder
    costMultiplier?: SortOrder
  }

  export type ramAssemblyLineTypeDetailPerGroupAssemblyLineTypeIDGroupIDCompoundUniqueInput = {
    assemblyLineTypeID: number
    groupID: number
  }

  export type ramAssemblyLineTypeDetailPerGroupCountOrderByAggregateInput = {
    assemblyLineTypeID?: SortOrder
    groupID?: SortOrder
    timeMultiplier?: SortOrder
    materialMultiplier?: SortOrder
    costMultiplier?: SortOrder
  }

  export type ramAssemblyLineTypeDetailPerGroupAvgOrderByAggregateInput = {
    assemblyLineTypeID?: SortOrder
    groupID?: SortOrder
    timeMultiplier?: SortOrder
    materialMultiplier?: SortOrder
    costMultiplier?: SortOrder
  }

  export type ramAssemblyLineTypeDetailPerGroupMaxOrderByAggregateInput = {
    assemblyLineTypeID?: SortOrder
    groupID?: SortOrder
    timeMultiplier?: SortOrder
    materialMultiplier?: SortOrder
    costMultiplier?: SortOrder
  }

  export type ramAssemblyLineTypeDetailPerGroupMinOrderByAggregateInput = {
    assemblyLineTypeID?: SortOrder
    groupID?: SortOrder
    timeMultiplier?: SortOrder
    materialMultiplier?: SortOrder
    costMultiplier?: SortOrder
  }

  export type ramAssemblyLineTypeDetailPerGroupSumOrderByAggregateInput = {
    assemblyLineTypeID?: SortOrder
    groupID?: SortOrder
    timeMultiplier?: SortOrder
    materialMultiplier?: SortOrder
    costMultiplier?: SortOrder
  }

  export type ramAssemblyLineTypesCountOrderByAggregateInput = {
    assemblyLineTypeID?: SortOrder
    assemblyLineTypeName?: SortOrder
    description?: SortOrder
    baseTimeMultiplier?: SortOrder
    baseMaterialMultiplier?: SortOrder
    baseCostMultiplier?: SortOrder
    volume?: SortOrder
    activityID?: SortOrder
    minCostPerHour?: SortOrder
  }

  export type ramAssemblyLineTypesAvgOrderByAggregateInput = {
    assemblyLineTypeID?: SortOrder
    baseTimeMultiplier?: SortOrder
    baseMaterialMultiplier?: SortOrder
    baseCostMultiplier?: SortOrder
    volume?: SortOrder
    activityID?: SortOrder
    minCostPerHour?: SortOrder
  }

  export type ramAssemblyLineTypesMaxOrderByAggregateInput = {
    assemblyLineTypeID?: SortOrder
    assemblyLineTypeName?: SortOrder
    description?: SortOrder
    baseTimeMultiplier?: SortOrder
    baseMaterialMultiplier?: SortOrder
    baseCostMultiplier?: SortOrder
    volume?: SortOrder
    activityID?: SortOrder
    minCostPerHour?: SortOrder
  }

  export type ramAssemblyLineTypesMinOrderByAggregateInput = {
    assemblyLineTypeID?: SortOrder
    assemblyLineTypeName?: SortOrder
    description?: SortOrder
    baseTimeMultiplier?: SortOrder
    baseMaterialMultiplier?: SortOrder
    baseCostMultiplier?: SortOrder
    volume?: SortOrder
    activityID?: SortOrder
    minCostPerHour?: SortOrder
  }

  export type ramAssemblyLineTypesSumOrderByAggregateInput = {
    assemblyLineTypeID?: SortOrder
    baseTimeMultiplier?: SortOrder
    baseMaterialMultiplier?: SortOrder
    baseCostMultiplier?: SortOrder
    volume?: SortOrder
    activityID?: SortOrder
    minCostPerHour?: SortOrder
  }

  export type ramInstallationTypeContentsInstallationTypeIDAssemblyLineTypeIDCompoundUniqueInput = {
    installationTypeID: number
    assemblyLineTypeID: number
  }

  export type ramInstallationTypeContentsCountOrderByAggregateInput = {
    installationTypeID?: SortOrder
    assemblyLineTypeID?: SortOrder
    quantity?: SortOrder
  }

  export type ramInstallationTypeContentsAvgOrderByAggregateInput = {
    installationTypeID?: SortOrder
    assemblyLineTypeID?: SortOrder
    quantity?: SortOrder
  }

  export type ramInstallationTypeContentsMaxOrderByAggregateInput = {
    installationTypeID?: SortOrder
    assemblyLineTypeID?: SortOrder
    quantity?: SortOrder
  }

  export type ramInstallationTypeContentsMinOrderByAggregateInput = {
    installationTypeID?: SortOrder
    assemblyLineTypeID?: SortOrder
    quantity?: SortOrder
  }

  export type ramInstallationTypeContentsSumOrderByAggregateInput = {
    installationTypeID?: SortOrder
    assemblyLineTypeID?: SortOrder
    quantity?: SortOrder
  }

  export type skinLicenseCountOrderByAggregateInput = {
    licenseTypeID?: SortOrder
    duration?: SortOrder
    skinID?: SortOrder
  }

  export type skinLicenseAvgOrderByAggregateInput = {
    licenseTypeID?: SortOrder
    duration?: SortOrder
    skinID?: SortOrder
  }

  export type skinLicenseMaxOrderByAggregateInput = {
    licenseTypeID?: SortOrder
    duration?: SortOrder
    skinID?: SortOrder
  }

  export type skinLicenseMinOrderByAggregateInput = {
    licenseTypeID?: SortOrder
    duration?: SortOrder
    skinID?: SortOrder
  }

  export type skinLicenseSumOrderByAggregateInput = {
    licenseTypeID?: SortOrder
    duration?: SortOrder
    skinID?: SortOrder
  }

  export type skinMaterialsCountOrderByAggregateInput = {
    skinMaterialID?: SortOrder
    displayNameID?: SortOrder
    materialSetID?: SortOrder
  }

  export type skinMaterialsAvgOrderByAggregateInput = {
    skinMaterialID?: SortOrder
    displayNameID?: SortOrder
    materialSetID?: SortOrder
  }

  export type skinMaterialsMaxOrderByAggregateInput = {
    skinMaterialID?: SortOrder
    displayNameID?: SortOrder
    materialSetID?: SortOrder
  }

  export type skinMaterialsMinOrderByAggregateInput = {
    skinMaterialID?: SortOrder
    displayNameID?: SortOrder
    materialSetID?: SortOrder
  }

  export type skinMaterialsSumOrderByAggregateInput = {
    skinMaterialID?: SortOrder
    displayNameID?: SortOrder
    materialSetID?: SortOrder
  }

  export type skinsCountOrderByAggregateInput = {
    skinID?: SortOrder
    internalName?: SortOrder
    skinMaterialID?: SortOrder
  }

  export type skinsAvgOrderByAggregateInput = {
    skinID?: SortOrder
    skinMaterialID?: SortOrder
  }

  export type skinsMaxOrderByAggregateInput = {
    skinID?: SortOrder
    internalName?: SortOrder
    skinMaterialID?: SortOrder
  }

  export type skinsMinOrderByAggregateInput = {
    skinID?: SortOrder
    internalName?: SortOrder
    skinMaterialID?: SortOrder
  }

  export type skinsSumOrderByAggregateInput = {
    skinID?: SortOrder
    skinMaterialID?: SortOrder
  }

  export type staOperationServicesOperationIDServiceIDCompoundUniqueInput = {
    operationID: number
    serviceID: number
  }

  export type staOperationServicesCountOrderByAggregateInput = {
    operationID?: SortOrder
    serviceID?: SortOrder
  }

  export type staOperationServicesAvgOrderByAggregateInput = {
    operationID?: SortOrder
    serviceID?: SortOrder
  }

  export type staOperationServicesMaxOrderByAggregateInput = {
    operationID?: SortOrder
    serviceID?: SortOrder
  }

  export type staOperationServicesMinOrderByAggregateInput = {
    operationID?: SortOrder
    serviceID?: SortOrder
  }

  export type staOperationServicesSumOrderByAggregateInput = {
    operationID?: SortOrder
    serviceID?: SortOrder
  }

  export type staOperationsCountOrderByAggregateInput = {
    activityID?: SortOrder
    operationID?: SortOrder
    operationName?: SortOrder
    description?: SortOrder
    fringe?: SortOrder
    corridor?: SortOrder
    hub?: SortOrder
    border?: SortOrder
    ratio?: SortOrder
    caldariStationTypeID?: SortOrder
    minmatarStationTypeID?: SortOrder
    amarrStationTypeID?: SortOrder
    gallenteStationTypeID?: SortOrder
    joveStationTypeID?: SortOrder
  }

  export type staOperationsAvgOrderByAggregateInput = {
    activityID?: SortOrder
    operationID?: SortOrder
    fringe?: SortOrder
    corridor?: SortOrder
    hub?: SortOrder
    border?: SortOrder
    ratio?: SortOrder
    caldariStationTypeID?: SortOrder
    minmatarStationTypeID?: SortOrder
    amarrStationTypeID?: SortOrder
    gallenteStationTypeID?: SortOrder
    joveStationTypeID?: SortOrder
  }

  export type staOperationsMaxOrderByAggregateInput = {
    activityID?: SortOrder
    operationID?: SortOrder
    operationName?: SortOrder
    description?: SortOrder
    fringe?: SortOrder
    corridor?: SortOrder
    hub?: SortOrder
    border?: SortOrder
    ratio?: SortOrder
    caldariStationTypeID?: SortOrder
    minmatarStationTypeID?: SortOrder
    amarrStationTypeID?: SortOrder
    gallenteStationTypeID?: SortOrder
    joveStationTypeID?: SortOrder
  }

  export type staOperationsMinOrderByAggregateInput = {
    activityID?: SortOrder
    operationID?: SortOrder
    operationName?: SortOrder
    description?: SortOrder
    fringe?: SortOrder
    corridor?: SortOrder
    hub?: SortOrder
    border?: SortOrder
    ratio?: SortOrder
    caldariStationTypeID?: SortOrder
    minmatarStationTypeID?: SortOrder
    amarrStationTypeID?: SortOrder
    gallenteStationTypeID?: SortOrder
    joveStationTypeID?: SortOrder
  }

  export type staOperationsSumOrderByAggregateInput = {
    activityID?: SortOrder
    operationID?: SortOrder
    fringe?: SortOrder
    corridor?: SortOrder
    hub?: SortOrder
    border?: SortOrder
    ratio?: SortOrder
    caldariStationTypeID?: SortOrder
    minmatarStationTypeID?: SortOrder
    amarrStationTypeID?: SortOrder
    gallenteStationTypeID?: SortOrder
    joveStationTypeID?: SortOrder
  }

  export type staServicesCountOrderByAggregateInput = {
    serviceID?: SortOrder
    serviceName?: SortOrder
    description?: SortOrder
  }

  export type staServicesAvgOrderByAggregateInput = {
    serviceID?: SortOrder
  }

  export type staServicesMaxOrderByAggregateInput = {
    serviceID?: SortOrder
    serviceName?: SortOrder
    description?: SortOrder
  }

  export type staServicesMinOrderByAggregateInput = {
    serviceID?: SortOrder
    serviceName?: SortOrder
    description?: SortOrder
  }

  export type staServicesSumOrderByAggregateInput = {
    serviceID?: SortOrder
  }

  export type staStationTypesCountOrderByAggregateInput = {
    stationTypeID?: SortOrder
    dockEntryX?: SortOrder
    dockEntryY?: SortOrder
    dockEntryZ?: SortOrder
    dockOrientationX?: SortOrder
    dockOrientationY?: SortOrder
    dockOrientationZ?: SortOrder
    operationID?: SortOrder
    officeSlots?: SortOrder
    reprocessingEfficiency?: SortOrder
    conquerable?: SortOrder
  }

  export type staStationTypesAvgOrderByAggregateInput = {
    stationTypeID?: SortOrder
    dockEntryX?: SortOrder
    dockEntryY?: SortOrder
    dockEntryZ?: SortOrder
    dockOrientationX?: SortOrder
    dockOrientationY?: SortOrder
    dockOrientationZ?: SortOrder
    operationID?: SortOrder
    officeSlots?: SortOrder
    reprocessingEfficiency?: SortOrder
  }

  export type staStationTypesMaxOrderByAggregateInput = {
    stationTypeID?: SortOrder
    dockEntryX?: SortOrder
    dockEntryY?: SortOrder
    dockEntryZ?: SortOrder
    dockOrientationX?: SortOrder
    dockOrientationY?: SortOrder
    dockOrientationZ?: SortOrder
    operationID?: SortOrder
    officeSlots?: SortOrder
    reprocessingEfficiency?: SortOrder
    conquerable?: SortOrder
  }

  export type staStationTypesMinOrderByAggregateInput = {
    stationTypeID?: SortOrder
    dockEntryX?: SortOrder
    dockEntryY?: SortOrder
    dockEntryZ?: SortOrder
    dockOrientationX?: SortOrder
    dockOrientationY?: SortOrder
    dockOrientationZ?: SortOrder
    operationID?: SortOrder
    officeSlots?: SortOrder
    reprocessingEfficiency?: SortOrder
    conquerable?: SortOrder
  }

  export type staStationTypesSumOrderByAggregateInput = {
    stationTypeID?: SortOrder
    dockEntryX?: SortOrder
    dockEntryY?: SortOrder
    dockEntryZ?: SortOrder
    dockOrientationX?: SortOrder
    dockOrientationY?: SortOrder
    dockOrientationZ?: SortOrder
    operationID?: SortOrder
    officeSlots?: SortOrder
    reprocessingEfficiency?: SortOrder
  }

  export type BigIntFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    in?: bigint[] | number[]
    notIn?: bigint[] | number[]
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntFilter<$PrismaModel> | bigint | number
  }

  export type staStationsCountOrderByAggregateInput = {
    stationID?: SortOrder
    security?: SortOrder
    dockingCostPerVolume?: SortOrder
    maxShipVolumeDockable?: SortOrder
    officeRentalCost?: SortOrder
    operationID?: SortOrder
    stationTypeID?: SortOrder
    corporationID?: SortOrder
    solarSystemID?: SortOrder
    constellationID?: SortOrder
    regionID?: SortOrder
    stationName?: SortOrder
    x?: SortOrder
    y?: SortOrder
    z?: SortOrder
    reprocessingEfficiency?: SortOrder
    reprocessingStationsTake?: SortOrder
    reprocessingHangarFlag?: SortOrder
  }

  export type staStationsAvgOrderByAggregateInput = {
    stationID?: SortOrder
    security?: SortOrder
    dockingCostPerVolume?: SortOrder
    maxShipVolumeDockable?: SortOrder
    officeRentalCost?: SortOrder
    operationID?: SortOrder
    stationTypeID?: SortOrder
    corporationID?: SortOrder
    solarSystemID?: SortOrder
    constellationID?: SortOrder
    regionID?: SortOrder
    x?: SortOrder
    y?: SortOrder
    z?: SortOrder
    reprocessingEfficiency?: SortOrder
    reprocessingStationsTake?: SortOrder
    reprocessingHangarFlag?: SortOrder
  }

  export type staStationsMaxOrderByAggregateInput = {
    stationID?: SortOrder
    security?: SortOrder
    dockingCostPerVolume?: SortOrder
    maxShipVolumeDockable?: SortOrder
    officeRentalCost?: SortOrder
    operationID?: SortOrder
    stationTypeID?: SortOrder
    corporationID?: SortOrder
    solarSystemID?: SortOrder
    constellationID?: SortOrder
    regionID?: SortOrder
    stationName?: SortOrder
    x?: SortOrder
    y?: SortOrder
    z?: SortOrder
    reprocessingEfficiency?: SortOrder
    reprocessingStationsTake?: SortOrder
    reprocessingHangarFlag?: SortOrder
  }

  export type staStationsMinOrderByAggregateInput = {
    stationID?: SortOrder
    security?: SortOrder
    dockingCostPerVolume?: SortOrder
    maxShipVolumeDockable?: SortOrder
    officeRentalCost?: SortOrder
    operationID?: SortOrder
    stationTypeID?: SortOrder
    corporationID?: SortOrder
    solarSystemID?: SortOrder
    constellationID?: SortOrder
    regionID?: SortOrder
    stationName?: SortOrder
    x?: SortOrder
    y?: SortOrder
    z?: SortOrder
    reprocessingEfficiency?: SortOrder
    reprocessingStationsTake?: SortOrder
    reprocessingHangarFlag?: SortOrder
  }

  export type staStationsSumOrderByAggregateInput = {
    stationID?: SortOrder
    security?: SortOrder
    dockingCostPerVolume?: SortOrder
    maxShipVolumeDockable?: SortOrder
    officeRentalCost?: SortOrder
    operationID?: SortOrder
    stationTypeID?: SortOrder
    corporationID?: SortOrder
    solarSystemID?: SortOrder
    constellationID?: SortOrder
    regionID?: SortOrder
    x?: SortOrder
    y?: SortOrder
    z?: SortOrder
    reprocessingEfficiency?: SortOrder
    reprocessingStationsTake?: SortOrder
    reprocessingHangarFlag?: SortOrder
  }

  export type BigIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    in?: bigint[] | number[]
    notIn?: bigint[] | number[]
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntWithAggregatesFilter<$PrismaModel> | bigint | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedBigIntFilter<$PrismaModel>
    _min?: NestedBigIntFilter<$PrismaModel>
    _max?: NestedBigIntFilter<$PrismaModel>
  }

  export type translationTablesSourceTableTranslatedKeyCompoundUniqueInput = {
    sourceTable: string
    translatedKey: string
  }

  export type translationTablesCountOrderByAggregateInput = {
    sourceTable?: SortOrder
    destinationTable?: SortOrder
    translatedKey?: SortOrder
    tcGroupID?: SortOrder
    tcID?: SortOrder
  }

  export type translationTablesAvgOrderByAggregateInput = {
    tcGroupID?: SortOrder
    tcID?: SortOrder
  }

  export type translationTablesMaxOrderByAggregateInput = {
    sourceTable?: SortOrder
    destinationTable?: SortOrder
    translatedKey?: SortOrder
    tcGroupID?: SortOrder
    tcID?: SortOrder
  }

  export type translationTablesMinOrderByAggregateInput = {
    sourceTable?: SortOrder
    destinationTable?: SortOrder
    translatedKey?: SortOrder
    tcGroupID?: SortOrder
    tcID?: SortOrder
  }

  export type translationTablesSumOrderByAggregateInput = {
    tcGroupID?: SortOrder
    tcID?: SortOrder
  }

  export type trnTranslationColumnsCountOrderByAggregateInput = {
    tcGroupID?: SortOrder
    tcID?: SortOrder
    tableName?: SortOrder
    columnName?: SortOrder
    masterID?: SortOrder
  }

  export type trnTranslationColumnsAvgOrderByAggregateInput = {
    tcGroupID?: SortOrder
    tcID?: SortOrder
  }

  export type trnTranslationColumnsMaxOrderByAggregateInput = {
    tcGroupID?: SortOrder
    tcID?: SortOrder
    tableName?: SortOrder
    columnName?: SortOrder
    masterID?: SortOrder
  }

  export type trnTranslationColumnsMinOrderByAggregateInput = {
    tcGroupID?: SortOrder
    tcID?: SortOrder
    tableName?: SortOrder
    columnName?: SortOrder
    masterID?: SortOrder
  }

  export type trnTranslationColumnsSumOrderByAggregateInput = {
    tcGroupID?: SortOrder
    tcID?: SortOrder
  }

  export type trnTranslationLanguagesCountOrderByAggregateInput = {
    numericLanguageID?: SortOrder
    languageID?: SortOrder
    languageName?: SortOrder
  }

  export type trnTranslationLanguagesAvgOrderByAggregateInput = {
    numericLanguageID?: SortOrder
  }

  export type trnTranslationLanguagesMaxOrderByAggregateInput = {
    numericLanguageID?: SortOrder
    languageID?: SortOrder
    languageName?: SortOrder
  }

  export type trnTranslationLanguagesMinOrderByAggregateInput = {
    numericLanguageID?: SortOrder
    languageID?: SortOrder
    languageName?: SortOrder
  }

  export type trnTranslationLanguagesSumOrderByAggregateInput = {
    numericLanguageID?: SortOrder
  }

  export type trnTranslationsTcIDKeyIDLanguageIDCompoundUniqueInput = {
    tcID: number
    keyID: number
    languageID: string
  }

  export type trnTranslationsCountOrderByAggregateInput = {
    tcID?: SortOrder
    keyID?: SortOrder
    languageID?: SortOrder
    text?: SortOrder
  }

  export type trnTranslationsAvgOrderByAggregateInput = {
    tcID?: SortOrder
    keyID?: SortOrder
  }

  export type trnTranslationsMaxOrderByAggregateInput = {
    tcID?: SortOrder
    keyID?: SortOrder
    languageID?: SortOrder
    text?: SortOrder
  }

  export type trnTranslationsMinOrderByAggregateInput = {
    tcID?: SortOrder
    keyID?: SortOrder
    languageID?: SortOrder
    text?: SortOrder
  }

  export type trnTranslationsSumOrderByAggregateInput = {
    tcID?: SortOrder
    keyID?: SortOrder
  }

  export type warCombatZoneSystemsCountOrderByAggregateInput = {
    solarSystemID?: SortOrder
    combatZoneID?: SortOrder
  }

  export type warCombatZoneSystemsAvgOrderByAggregateInput = {
    solarSystemID?: SortOrder
    combatZoneID?: SortOrder
  }

  export type warCombatZoneSystemsMaxOrderByAggregateInput = {
    solarSystemID?: SortOrder
    combatZoneID?: SortOrder
  }

  export type warCombatZoneSystemsMinOrderByAggregateInput = {
    solarSystemID?: SortOrder
    combatZoneID?: SortOrder
  }

  export type warCombatZoneSystemsSumOrderByAggregateInput = {
    solarSystemID?: SortOrder
    combatZoneID?: SortOrder
  }

  export type warCombatZonesCountOrderByAggregateInput = {
    combatZoneID?: SortOrder
    combatZoneName?: SortOrder
    factionID?: SortOrder
    centerSystemID?: SortOrder
    description?: SortOrder
  }

  export type warCombatZonesAvgOrderByAggregateInput = {
    combatZoneID?: SortOrder
    factionID?: SortOrder
    centerSystemID?: SortOrder
  }

  export type warCombatZonesMaxOrderByAggregateInput = {
    combatZoneID?: SortOrder
    combatZoneName?: SortOrder
    factionID?: SortOrder
    centerSystemID?: SortOrder
    description?: SortOrder
  }

  export type warCombatZonesMinOrderByAggregateInput = {
    combatZoneID?: SortOrder
    combatZoneName?: SortOrder
    factionID?: SortOrder
    centerSystemID?: SortOrder
    description?: SortOrder
  }

  export type warCombatZonesSumOrderByAggregateInput = {
    combatZoneID?: SortOrder
    factionID?: SortOrder
    centerSystemID?: SortOrder
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type NullableBoolFieldUpdateOperationsInput = {
    set?: boolean | null
  }

  export type NullableFloatFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type NullableDecimalFieldUpdateOperationsInput = {
    set?: Decimal | DecimalJsLike | number | string | null
    increment?: Decimal | DecimalJsLike | number | string
    decrement?: Decimal | DecimalJsLike | number | string
    multiply?: Decimal | DecimalJsLike | number | string
    divide?: Decimal | DecimalJsLike | number | string
  }

  export type BigIntFieldUpdateOperationsInput = {
    set?: bigint | number
    increment?: bigint | number
    decrement?: bigint | number
    multiply?: bigint | number
    divide?: bigint | number
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedBoolNullableFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableFilter<$PrismaModel> | boolean | null
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedBoolNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableWithAggregatesFilter<$PrismaModel> | boolean | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBoolNullableFilter<$PrismaModel>
    _max?: NestedBoolNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedDecimalNullableFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
  }

  export type NestedDecimalNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedDecimalNullableFilter<$PrismaModel>
    _sum?: NestedDecimalNullableFilter<$PrismaModel>
    _min?: NestedDecimalNullableFilter<$PrismaModel>
    _max?: NestedDecimalNullableFilter<$PrismaModel>
  }

  export type NestedBigIntFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    in?: bigint[] | number[]
    notIn?: bigint[] | number[]
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntFilter<$PrismaModel> | bigint | number
  }

  export type NestedBigIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    in?: bigint[] | number[]
    notIn?: bigint[] | number[]
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntWithAggregatesFilter<$PrismaModel> | bigint | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedBigIntFilter<$PrismaModel>
    _min?: NestedBigIntFilter<$PrismaModel>
    _max?: NestedBigIntFilter<$PrismaModel>
  }



  /**
   * Aliases for legacy arg types
   */
    /**
     * @deprecated Use agtAgentTypesDefaultArgs instead
     */
    export type agtAgentTypesArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = agtAgentTypesDefaultArgs<ExtArgs>
    /**
     * @deprecated Use agtAgentsDefaultArgs instead
     */
    export type agtAgentsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = agtAgentsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use agtAgentsInSpaceDefaultArgs instead
     */
    export type agtAgentsInSpaceArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = agtAgentsInSpaceDefaultArgs<ExtArgs>
    /**
     * @deprecated Use agtResearchAgentsDefaultArgs instead
     */
    export type agtResearchAgentsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = agtResearchAgentsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use certCertsDefaultArgs instead
     */
    export type certCertsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = certCertsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use chrAncestriesDefaultArgs instead
     */
    export type chrAncestriesArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = chrAncestriesDefaultArgs<ExtArgs>
    /**
     * @deprecated Use chrAttributesDefaultArgs instead
     */
    export type chrAttributesArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = chrAttributesDefaultArgs<ExtArgs>
    /**
     * @deprecated Use chrBloodlinesDefaultArgs instead
     */
    export type chrBloodlinesArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = chrBloodlinesDefaultArgs<ExtArgs>
    /**
     * @deprecated Use chrFactionsDefaultArgs instead
     */
    export type chrFactionsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = chrFactionsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use chrRacesDefaultArgs instead
     */
    export type chrRacesArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = chrRacesDefaultArgs<ExtArgs>
    /**
     * @deprecated Use crpActivitiesDefaultArgs instead
     */
    export type crpActivitiesArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = crpActivitiesDefaultArgs<ExtArgs>
    /**
     * @deprecated Use crpNPCCorporationDivisionsDefaultArgs instead
     */
    export type crpNPCCorporationDivisionsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = crpNPCCorporationDivisionsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use crpNPCCorporationResearchFieldsDefaultArgs instead
     */
    export type crpNPCCorporationResearchFieldsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = crpNPCCorporationResearchFieldsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use crpNPCCorporationTradesDefaultArgs instead
     */
    export type crpNPCCorporationTradesArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = crpNPCCorporationTradesDefaultArgs<ExtArgs>
    /**
     * @deprecated Use crpNPCCorporationsDefaultArgs instead
     */
    export type crpNPCCorporationsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = crpNPCCorporationsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use crpNPCDivisionsDefaultArgs instead
     */
    export type crpNPCDivisionsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = crpNPCDivisionsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use dgmAttributeCategoriesDefaultArgs instead
     */
    export type dgmAttributeCategoriesArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = dgmAttributeCategoriesDefaultArgs<ExtArgs>
    /**
     * @deprecated Use dgmAttributeTypesDefaultArgs instead
     */
    export type dgmAttributeTypesArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = dgmAttributeTypesDefaultArgs<ExtArgs>
    /**
     * @deprecated Use dgmEffectsDefaultArgs instead
     */
    export type dgmEffectsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = dgmEffectsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use dgmExpressionsDefaultArgs instead
     */
    export type dgmExpressionsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = dgmExpressionsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use dgmTypeAttributesDefaultArgs instead
     */
    export type dgmTypeAttributesArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = dgmTypeAttributesDefaultArgs<ExtArgs>
    /**
     * @deprecated Use dgmTypeEffectsDefaultArgs instead
     */
    export type dgmTypeEffectsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = dgmTypeEffectsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use eveGraphicsDefaultArgs instead
     */
    export type eveGraphicsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = eveGraphicsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use eveIconsDefaultArgs instead
     */
    export type eveIconsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = eveIconsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use eveUnitsDefaultArgs instead
     */
    export type eveUnitsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = eveUnitsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use industryActivityDefaultArgs instead
     */
    export type industryActivityArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = industryActivityDefaultArgs<ExtArgs>
    /**
     * @deprecated Use industryBlueprintsDefaultArgs instead
     */
    export type industryBlueprintsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = industryBlueprintsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use invCategoriesDefaultArgs instead
     */
    export type invCategoriesArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = invCategoriesDefaultArgs<ExtArgs>
    /**
     * @deprecated Use invContrabandTypesDefaultArgs instead
     */
    export type invContrabandTypesArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = invContrabandTypesDefaultArgs<ExtArgs>
    /**
     * @deprecated Use invControlTowerResourcePurposesDefaultArgs instead
     */
    export type invControlTowerResourcePurposesArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = invControlTowerResourcePurposesDefaultArgs<ExtArgs>
    /**
     * @deprecated Use invControlTowerResourcesDefaultArgs instead
     */
    export type invControlTowerResourcesArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = invControlTowerResourcesDefaultArgs<ExtArgs>
    /**
     * @deprecated Use invFlagsDefaultArgs instead
     */
    export type invFlagsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = invFlagsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use invGroupsDefaultArgs instead
     */
    export type invGroupsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = invGroupsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use invItemsDefaultArgs instead
     */
    export type invItemsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = invItemsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use invMarketGroupsDefaultArgs instead
     */
    export type invMarketGroupsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = invMarketGroupsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use invMetaGroupsDefaultArgs instead
     */
    export type invMetaGroupsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = invMetaGroupsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use invMetaTypesDefaultArgs instead
     */
    export type invMetaTypesArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = invMetaTypesDefaultArgs<ExtArgs>
    /**
     * @deprecated Use invNamesDefaultArgs instead
     */
    export type invNamesArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = invNamesDefaultArgs<ExtArgs>
    /**
     * @deprecated Use invPositionsDefaultArgs instead
     */
    export type invPositionsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = invPositionsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use invTraitsDefaultArgs instead
     */
    export type invTraitsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = invTraitsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use invTypeMaterialsDefaultArgs instead
     */
    export type invTypeMaterialsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = invTypeMaterialsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use invTypeReactionsDefaultArgs instead
     */
    export type invTypeReactionsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = invTypeReactionsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use invTypesDefaultArgs instead
     */
    export type invTypesArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = invTypesDefaultArgs<ExtArgs>
    /**
     * @deprecated Use invUniqueNamesDefaultArgs instead
     */
    export type invUniqueNamesArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = invUniqueNamesDefaultArgs<ExtArgs>
    /**
     * @deprecated Use invVolumesDefaultArgs instead
     */
    export type invVolumesArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = invVolumesDefaultArgs<ExtArgs>
    /**
     * @deprecated Use mapCelestialGraphicsDefaultArgs instead
     */
    export type mapCelestialGraphicsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = mapCelestialGraphicsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use mapCelestialStatisticsDefaultArgs instead
     */
    export type mapCelestialStatisticsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = mapCelestialStatisticsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use mapConstellationJumpsDefaultArgs instead
     */
    export type mapConstellationJumpsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = mapConstellationJumpsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use mapConstellationsDefaultArgs instead
     */
    export type mapConstellationsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = mapConstellationsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use mapDenormalizeDefaultArgs instead
     */
    export type mapDenormalizeArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = mapDenormalizeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use mapJumpsDefaultArgs instead
     */
    export type mapJumpsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = mapJumpsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use mapLandmarksDefaultArgs instead
     */
    export type mapLandmarksArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = mapLandmarksDefaultArgs<ExtArgs>
    /**
     * @deprecated Use mapLocationScenesDefaultArgs instead
     */
    export type mapLocationScenesArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = mapLocationScenesDefaultArgs<ExtArgs>
    /**
     * @deprecated Use mapLocationWormholeClassesDefaultArgs instead
     */
    export type mapLocationWormholeClassesArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = mapLocationWormholeClassesDefaultArgs<ExtArgs>
    /**
     * @deprecated Use mapRegionJumpsDefaultArgs instead
     */
    export type mapRegionJumpsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = mapRegionJumpsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use mapRegionsDefaultArgs instead
     */
    export type mapRegionsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = mapRegionsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use mapSolarSystemJumpsDefaultArgs instead
     */
    export type mapSolarSystemJumpsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = mapSolarSystemJumpsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use mapSolarSystemsDefaultArgs instead
     */
    export type mapSolarSystemsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = mapSolarSystemsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use mapUniverseDefaultArgs instead
     */
    export type mapUniverseArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = mapUniverseDefaultArgs<ExtArgs>
    /**
     * @deprecated Use planetSchematicsDefaultArgs instead
     */
    export type planetSchematicsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = planetSchematicsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use planetSchematicsPinMapDefaultArgs instead
     */
    export type planetSchematicsPinMapArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = planetSchematicsPinMapDefaultArgs<ExtArgs>
    /**
     * @deprecated Use planetSchematicsTypeMapDefaultArgs instead
     */
    export type planetSchematicsTypeMapArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = planetSchematicsTypeMapDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ramActivitiesDefaultArgs instead
     */
    export type ramActivitiesArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = ramActivitiesDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ramAssemblyLineStationsDefaultArgs instead
     */
    export type ramAssemblyLineStationsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = ramAssemblyLineStationsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ramAssemblyLineTypeDetailPerCategoryDefaultArgs instead
     */
    export type ramAssemblyLineTypeDetailPerCategoryArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = ramAssemblyLineTypeDetailPerCategoryDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ramAssemblyLineTypeDetailPerGroupDefaultArgs instead
     */
    export type ramAssemblyLineTypeDetailPerGroupArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = ramAssemblyLineTypeDetailPerGroupDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ramAssemblyLineTypesDefaultArgs instead
     */
    export type ramAssemblyLineTypesArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = ramAssemblyLineTypesDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ramInstallationTypeContentsDefaultArgs instead
     */
    export type ramInstallationTypeContentsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = ramInstallationTypeContentsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use skinLicenseDefaultArgs instead
     */
    export type skinLicenseArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = skinLicenseDefaultArgs<ExtArgs>
    /**
     * @deprecated Use skinMaterialsDefaultArgs instead
     */
    export type skinMaterialsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = skinMaterialsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use skinsDefaultArgs instead
     */
    export type skinsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = skinsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use staOperationServicesDefaultArgs instead
     */
    export type staOperationServicesArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = staOperationServicesDefaultArgs<ExtArgs>
    /**
     * @deprecated Use staOperationsDefaultArgs instead
     */
    export type staOperationsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = staOperationsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use staServicesDefaultArgs instead
     */
    export type staServicesArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = staServicesDefaultArgs<ExtArgs>
    /**
     * @deprecated Use staStationTypesDefaultArgs instead
     */
    export type staStationTypesArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = staStationTypesDefaultArgs<ExtArgs>
    /**
     * @deprecated Use staStationsDefaultArgs instead
     */
    export type staStationsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = staStationsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use translationTablesDefaultArgs instead
     */
    export type translationTablesArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = translationTablesDefaultArgs<ExtArgs>
    /**
     * @deprecated Use trnTranslationColumnsDefaultArgs instead
     */
    export type trnTranslationColumnsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = trnTranslationColumnsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use trnTranslationLanguagesDefaultArgs instead
     */
    export type trnTranslationLanguagesArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = trnTranslationLanguagesDefaultArgs<ExtArgs>
    /**
     * @deprecated Use trnTranslationsDefaultArgs instead
     */
    export type trnTranslationsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = trnTranslationsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use warCombatZoneSystemsDefaultArgs instead
     */
    export type warCombatZoneSystemsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = warCombatZoneSystemsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use warCombatZonesDefaultArgs instead
     */
    export type warCombatZonesArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = warCombatZonesDefaultArgs<ExtArgs>

  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}